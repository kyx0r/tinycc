
/*
 *  TCC - Tiny C Compiler
 *
 *  Copyright (c) 2001-2004 Fabrice Bellard
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef _TCC_H
#define _TCC_H

#define _GNU_SOURCE

#ifndef CONFIG_TCCDIR
# define CONFIG_TCCDIR "./"
#endif
#define TCC_VERSION "0.9.27 Paro Edition"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <math.h>
#include <fcntl.h>
#include <setjmp.h>
#include <time.h>
#include <assert.h>

#ifndef _WIN32
# include <unistd.h>
# include <sys/time.h>
# ifndef CONFIG_TCC_STATIC
#  include <dlfcn.h>
# endif
/* XXX: need to define this to use them in non ISOC99 context */
extern float strtof (const char *__nptr, char **__endptr);
extern long double strtold (const char *__nptr, char **__endptr);
#endif

#ifdef _WIN32
# include <windows.h>
# include <io.h> /* open, close etc. */
# include <direct.h> /* getcwd */
# ifdef __GNUC__
#  include <stdint.h>
# endif
# define inline __inline
# define snprintf _snprintf
# define vsnprintf _vsnprintf
# ifndef __GNUC__
#  define strtold (long double)strtod
#  define strtof (float)strtod
#  define strtoll _strtoi64
#  define strtoull _strtoui64
# endif
# ifdef LIBTCC_AS_DLL
#  define LIBTCCAPI __declspec(dllexport)
#  define PUB_FUNC LIBTCCAPI
# endif
# define inp next_inp /* inp is an intrinsic on msvc/mingw */
# ifdef _MSC_VER
#  pragma warning (disable : 4244)  // conversion from 'uint64_t' to 'int', possible loss of data
#  pragma warning (disable : 4267)  // conversion from 'size_t' to 'int', possible loss of data
#  pragma warning (disable : 4996)  // The POSIX name for this item is deprecated. Instead, use the ISO C and C++ conformant name
#  pragma warning (disable : 4018)  // signed/unsigned mismatch
#  pragma warning (disable : 4146)  // unary minus operator applied to unsigned type, result still unsigned
#  define ssize_t intptr_t
#  ifdef _X86_
#   define __i386__ 1
#  endif
#  ifdef _AMD64_
#   define __x86_64__ 1
#  endif
# endif
# undef CONFIG_TCC_STATIC
#endif

#ifndef O_BINARY
# define O_BINARY 0
#endif

#ifndef offsetof
#define offsetof(type, field) ((size_t) &((type *)0)->field)
#endif

#ifndef countof
#define countof(tab) (sizeof(tab) / sizeof((tab)[0]))
#endif

#ifdef _MSC_VER
# define NORETURN __declspec(noreturn)
# define ALIGNED(x) __declspec(align(x))
#else
# define NORETURN __attribute__((noreturn))
# define ALIGNED(x) __attribute__((aligned(x)))
#endif

/* gnu headers use to #define __attribute__ to empty for non-gcc compilers */
#ifdef __TINYC__
# undef __attribute__
#endif

#ifdef _WIN32
# define IS_DIRSEP(c) (c == '/' || c == '\\')
# define IS_ABSPATH(p) (IS_DIRSEP(p[0]) || (p[0] && p[1] == ':' && IS_DIRSEP(p[2])))
# define PATHCMP stricmp
# define PATHSEP ";"
#else
# define IS_DIRSEP(c) (c == '/')
# define IS_ABSPATH(p) IS_DIRSEP(p[0])
# define PATHCMP strcmp
# define PATHSEP ":"
#endif

/* -------------------------------------------- */

/* parser debug */
/* #define PARSE_DEBUG */
/* preprocessor debug */
/* #define PP_DEBUG */
/* include file debug */
/* #define INC_DEBUG */
/* memory leak debug (only for single threaded usage) */
/* #define MEM_DEBUG */
/* assembler debug */
/* #define ASM_DEBUG */

/* target selection */
/* #define TCC_TARGET_I386   *//* i386 code generator */
/* #define TCC_TARGET_X86_64 *//* x86-64 code generator */
/* #define TCC_TARGET_ARM    *//* ARMv4 code generator */
/* #define TCC_TARGET_ARM64  *//* ARMv8 code generator */
/* #define TCC_TARGET_C67    *//* TMS320C67xx code generator */
/* #define TCC_TARGET_RISCV64 *//* risc-v code generator */

/* default target is I386 */
#if !defined(TCC_TARGET_I386) && !defined(TCC_TARGET_ARM) && \
    !defined(TCC_TARGET_ARM64) && !defined(TCC_TARGET_C67) && \
    !defined(TCC_TARGET_X86_64) && !defined(TCC_TARGET_RISCV64)
# if defined __x86_64__
#  define TCC_TARGET_X86_64
# elif defined __arm__
#  define TCC_TARGET_ARM
#  define TCC_ARM_EABI
#  define TCC_ARM_VFP
#  define TCC_ARM_HARDFLOAT
# elif defined __aarch64__
#  define TCC_TARGET_ARM64
# elif defined __riscv
#  define TCC_TARGET_RISCV64
# else
#  define TCC_TARGET_I386
# endif
# ifdef _WIN32
#  define TCC_TARGET_PE 1
# endif
#endif

/* only native compiler supports -run */
#if defined _WIN32 == defined TCC_TARGET_PE
# if defined __i386__ && defined TCC_TARGET_I386
#  define TCC_IS_NATIVE
# elif defined __x86_64__ && defined TCC_TARGET_X86_64
#  define TCC_IS_NATIVE
# elif defined __arm__ && defined TCC_TARGET_ARM
#  define TCC_IS_NATIVE
# elif defined __aarch64__ && defined TCC_TARGET_ARM64
#  define TCC_IS_NATIVE
# elif defined __riscv && defined __LP64__ && defined TCC_TARGET_RISCV64
#  define TCC_IS_NATIVE
# endif
#endif

#if defined TCC_IS_NATIVE && !defined CONFIG_TCCBOOT
# define CONFIG_TCC_BACKTRACE
# if (defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64) \
  && !defined TCC_UCLIBC && !defined TCC_MUSL
# define CONFIG_TCC_BCHECK /* enable bound checking code */
# endif
#endif

/* ------------ path configuration ------------ */

#ifndef CONFIG_SYSROOT
# define CONFIG_SYSROOT ""
#endif
#ifndef CONFIG_TCCDIR
# define CONFIG_TCCDIR "/usr/local/lib/tcc"
#endif
#ifndef CONFIG_LDDIR
# define CONFIG_LDDIR "lib"
#endif
#ifdef CONFIG_TRIPLET
# define USE_TRIPLET(s) s "/" CONFIG_TRIPLET
# define ALSO_TRIPLET(s) USE_TRIPLET(s) ":" s
#else
# define USE_TRIPLET(s) s
# define ALSO_TRIPLET(s) s
#endif

/* path to find crt1.o, crti.o and crtn.o */
#ifndef CONFIG_TCC_CRTPREFIX
# define CONFIG_TCC_CRTPREFIX USE_TRIPLET(CONFIG_SYSROOT "/usr/" CONFIG_LDDIR)
#endif

/* Below: {B} is substituted by CONFIG_TCCDIR (rsp. -B option) */

/* system include paths */
#ifndef CONFIG_TCC_SYSINCLUDEPATHS
# ifdef TCC_TARGET_PE
#  define CONFIG_TCC_SYSINCLUDEPATHS "{B}/include"PATHSEP"{B}/include/winapi"
# else
#  define CONFIG_TCC_SYSINCLUDEPATHS \
        "{B}/include" \
    ":" ALSO_TRIPLET(CONFIG_SYSROOT "/usr/local/include") \
    ":" ALSO_TRIPLET(CONFIG_SYSROOT "/usr/include")
# endif
#endif

/* library search paths */
#ifndef CONFIG_TCC_LIBPATHS
# ifdef TCC_TARGET_PE
#  define CONFIG_TCC_LIBPATHS "{B}/lib"
# else
#  define CONFIG_TCC_LIBPATHS \
        ALSO_TRIPLET(CONFIG_SYSROOT "/usr/" CONFIG_LDDIR) \
    ":" ALSO_TRIPLET(CONFIG_SYSROOT "/" CONFIG_LDDIR) \
    ":" ALSO_TRIPLET(CONFIG_SYSROOT "/usr/local/" CONFIG_LDDIR)
# endif
#endif

/* name of ELF interpreter */
#ifndef CONFIG_TCC_ELFINTERP
# if defined __FreeBSD__
#  define CONFIG_TCC_ELFINTERP "/libexec/ld-elf.so.1"
# elif defined __FreeBSD_kernel__
#  if defined(TCC_TARGET_X86_64)
#   define CONFIG_TCC_ELFINTERP "/lib/ld-kfreebsd-x86-64.so.1"
#  else
#   define CONFIG_TCC_ELFINTERP "/lib/ld.so.1"
#  endif
# elif defined __DragonFly__
#  define CONFIG_TCC_ELFINTERP "/usr/libexec/ld-elf.so.2"
# elif defined __NetBSD__
#  define CONFIG_TCC_ELFINTERP "/usr/libexec/ld.elf_so"
# elif defined __GNU__
#  define CONFIG_TCC_ELFINTERP "/lib/ld.so"
# elif defined(TCC_TARGET_PE)
#  define CONFIG_TCC_ELFINTERP "-"
# elif defined(TCC_UCLIBC)
#  define CONFIG_TCC_ELFINTERP "/lib/ld-uClibc.so.0" /* is there a uClibc for x86_64 ? */
# elif defined TCC_TARGET_ARM64
#  if defined(TCC_MUSL)
#   define CONFIG_TCC_ELFINTERP "/lib/ld-musl-aarch64.so.1"
#  else
#   define CONFIG_TCC_ELFINTERP "/lib/ld-linux-aarch64.so.1"
#  endif
# elif defined(TCC_TARGET_X86_64)
#  if defined(TCC_MUSL)
#   define CONFIG_TCC_ELFINTERP "/lib/ld-musl-x86_64.so.1"
#  else
#   define CONFIG_TCC_ELFINTERP "/lib64/ld-linux-x86-64.so.2"
#  endif
# elif defined(TCC_TARGET_RISCV64)
#  define CONFIG_TCC_ELFINTERP "/lib/ld-linux-riscv64-lp64d.so.1"
# elif !defined(TCC_ARM_EABI)
#  if defined(TCC_MUSL)
#   if defined(TCC_TARGET_I386)
#     define CONFIG_TCC_ELFINTERP "/lib/ld-musl-i386.so.1"
#    else
#     define CONFIG_TCC_ELFINTERP "/lib/ld-musl-arm.so.1"
#    endif
#  else
#   define CONFIG_TCC_ELFINTERP "/lib/ld-linux.so.2"
#  endif
# endif
#endif

/* var elf_interp dans *-gen.c */
#ifdef CONFIG_TCC_ELFINTERP
# define DEFAULT_ELFINTERP(s) CONFIG_TCC_ELFINTERP
#else
# define DEFAULT_ELFINTERP(s) default_elfinterp(s)
#endif

/* (target specific) libtcc1.a */
//#ifndef TCC_LIBTCC1
//# define TCC_LIBTCC1 "libtcc1.a" //no dyn link
//#endif

/* library to use with CONFIG_USE_LIBGCC instead of libtcc1.a */
#if defined CONFIG_USE_LIBGCC && !defined TCC_LIBGCC
#define TCC_LIBGCC USE_TRIPLET(CONFIG_SYSROOT "/" CONFIG_LDDIR) "/libgcc_s.so.1"
#endif

/* -------------------------------------------- */

/* va_list.c - tinycc support for va_list on X86_64 */

#if defined __x86_64__

/* This should be in sync with our include/stdarg.h */
enum __va_arg_type
{
	__va_gen_reg, __va_float_reg, __va_stack
};

#if defined __GNUC__ || defined __MINGW32__ || defined __MINGW64__
#include <stdarg.h>
#else

void __va_start(__va_list_struct *ap, void *fp)
{
	memset(ap, 0, sizeof(__va_list_struct));
	*ap = *(__va_list_struct *)((char *)fp - 16);
	ap->overflow_arg_area = (char *)fp + ap->overflow_offset;
	ap->reg_save_area = (char *)fp - 176 - 16;
}

void *__va_arg(__va_list_struct *ap,
               int arg_type,
               int size, int align)
{
	size = (size + 7) & ~7;
	align = (align + 7) & ~7;
	switch (arg_type)
	{
	case __va_gen_reg:
		if (ap->gp_offset + size <= 48)
		{
			ap->gp_offset += size;
			return ap->reg_save_area + ap->gp_offset - size;
		}
		goto use_overflow_area;

	case __va_float_reg:
		if (ap->fp_offset < 128 + 48)
		{
			ap->fp_offset += 16;
			return ap->reg_save_area + ap->fp_offset - 16;
		}
		size = 8;
		goto use_overflow_area;

	case __va_stack:
use_overflow_area:
		ap->overflow_arg_area += size;
		ap->overflow_arg_area = (char*)((long long)(ap->overflow_arg_area + align - 1) & -align);
		return ap->overflow_arg_area - size;

	default: /* should never happen */
		abort();
		return 0;
	}
}
#endif

#endif

//START libtcc1.c

#define W_TYPE_SIZE   32
#define BITS_PER_UNIT 8

typedef int Wtype;
typedef unsigned int UWtype;
typedef unsigned int USItype;
typedef long long DWtype;
typedef unsigned long long UDWtype;

struct DWstruct
{
	Wtype low, high;
};

typedef union
{
	struct DWstruct s;
	DWtype ll;
} DWunion;

typedef long double XFtype;
#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)

/* the following deal with IEEE single-precision numbers */
#define EXCESS		126
#define SIGNBIT		0x80000000
#define HIDDEN		(1 << 23)
#define SIGN(fp)	((fp) & SIGNBIT)
#define EXP(fp)		(((fp) >> 23) & 0xFF)
#define MANT(fp)	(((fp) & 0x7FFFFF) | HIDDEN)
#define PACK(s,e,m)	((s) | ((e) << 23) | (m))

/* the following deal with IEEE double-precision numbers */
#define EXCESSD		1022
#define HIDDEND		(1 << 20)
#define EXPD(fp)	(((fp.l.upper) >> 20) & 0x7FF)
#define SIGND(fp)	((fp.l.upper) & SIGNBIT)
#define MANTD(fp)	(((((fp.l.upper) & 0xFFFFF) | HIDDEND) << 10) | \
				(fp.l.lower >> 22))
#define HIDDEND_LL	((long long)1 << 52)
#define MANTD_LL(fp)	((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)
#define PACKD_LL(s,e,m)	(((long long)((s)+((e)<<20))<<32)|(m))

/* the following deal with x86 long double-precision numbers */
#define EXCESSLD	16382
#define EXPLD(fp)	(fp.l.upper & 0x7fff)
#define SIGNLD(fp)	((fp.l.upper) & 0x8000)

/* only for x86 */
union ldouble_long
{
	long double ld;
	struct
	{
		unsigned long long lower;
		unsigned short upper;
	} l;
};

union double_long
{
	double d;
#if 1
	struct
	{
		unsigned int lower;
		int upper;
	} l;
#else
	struct
	{
		int upper;
		unsigned int lower;
	} l;
#endif
	long long ll;
};

union float_long
{
	float f;
	unsigned int l;
};

/* XXX: we don't support several builtin supports for now */
#if !defined __x86_64__ && !defined __arm__

/* XXX: use gcc/tcc intrinsic ? */
#if defined __i386__
#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
  __asm__ ("subl %5,%1\n\tsbbl %3,%0"					\
	   : "=r" ((USItype) (sh)),					\
	     "=&r" ((USItype) (sl))					\
	   : "0" ((USItype) (ah)),					\
	     "g" ((USItype) (bh)),					\
	     "1" ((USItype) (al)),					\
	     "g" ((USItype) (bl)))
#define umul_ppmm(w1, w0, u, v) \
  __asm__ ("mull %3"							\
	   : "=a" ((USItype) (w0)),					\
	     "=d" ((USItype) (w1))					\
	   : "%0" ((USItype) (u)),					\
	     "rm" ((USItype) (v)))
#define udiv_qrnnd(q, r, n1, n0, dv) \
  __asm__ ("divl %4"							\
	   : "=a" ((USItype) (q)),					\
	     "=d" ((USItype) (r))					\
	   : "0" ((USItype) (n0)),					\
	     "1" ((USItype) (n1)),					\
	     "rm" ((USItype) (dv)))
#define count_leading_zeros(count, x) \
  do {									\
    USItype __cbtmp;							\
    __asm__ ("bsrl %1,%0"						\
	     : "=r" (__cbtmp) : "rm" ((USItype) (x)));			\
    (count) = __cbtmp ^ 31;						\
  } while (0)
#else
#error unsupported CPU type
#endif

/* most of this code is taken from libgcc2.c from gcc */

static UDWtype __udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
	DWunion ww;
	DWunion nn, dd;
	DWunion rr;
	UWtype d0, d1, n0, n1, n2;
	UWtype q0, q1;
	UWtype b, bm;

	nn.ll = n;
	dd.ll = d;

	d0 = dd.s.low;
	d1 = dd.s.high;
	n0 = nn.s.low;
	n1 = nn.s.high;

#if !defined(UDIV_NEEDS_NORMALIZATION)
	if (d1 == 0)
	{
		if (d0 > n1)
		{
			/* 0q = nn / 0D */

			udiv_qrnnd (q0, n0, n1, n0, d0);
			q1 = 0;

			/* Remainder in n0.  */
		}
		else
		{
			/* qq = NN / 0d */

			if (d0 == 0)
				d0 = 1 / d0;	/* Divide intentionally by zero.  */

			udiv_qrnnd (q1, n1, 0, n1, d0);
			udiv_qrnnd (q0, n0, n1, n0, d0);

			/* Remainder in n0.  */
		}

		if (rp != 0)
		{
			rr.s.low = n0;
			rr.s.high = 0;
			*rp = rr.ll;
		}
	}

#else /* UDIV_NEEDS_NORMALIZATION */

	if (d1 == 0)
	{
		if (d0 > n1)
		{
			/* 0q = nn / 0D */

			count_leading_zeros (bm, d0);

			if (bm != 0)
			{
				/* Normalize, i.e. make the most significant bit of the
				denominator set.  */

				d0 = d0 << bm;
				n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
				n0 = n0 << bm;
			}

			udiv_qrnnd (q0, n0, n1, n0, d0);
			q1 = 0;

			/* Remainder in n0 >> bm.  */
		}
		else
		{
			/* qq = NN / 0d */

			if (d0 == 0)
				d0 = 1 / d0;	/* Divide intentionally by zero.  */

			count_leading_zeros (bm, d0);

			if (bm == 0)
			{
				/* From (n1 >= d0) /\ (the most significant bit of d0 is set),
				conclude (the most significant bit of n1 is set) /\ (the
				 leading quotient digit q1 = 1).

				 This special case is necessary, not an optimization.
				 (Shifts counts of W_TYPE_SIZE are undefined.)  */

				n1 -= d0;
				q1 = 1;
			}
			else
			{
				/* Normalize.  */

				b = W_TYPE_SIZE - bm;

				d0 = d0 << bm;
				n2 = n1 >> b;
				n1 = (n1 << bm) | (n0 >> b);
				n0 = n0 << bm;

				udiv_qrnnd (q1, n1, n2, n1, d0);
			}

			/* n1 != d0...  */

			udiv_qrnnd (q0, n0, n1, n0, d0);

			/* Remainder in n0 >> bm.  */
		}

		if (rp != 0)
		{
			rr.s.low = n0 >> bm;
			rr.s.high = 0;
			*rp = rr.ll;
		}
	}
#endif /* UDIV_NEEDS_NORMALIZATION */

	else
	{
		if (d1 > n1)
		{
			/* 00 = nn / DD */

			q0 = 0;
			q1 = 0;

			/* Remainder in n1n0.  */
			if (rp != 0)
			{
				rr.s.low = n0;
				rr.s.high = n1;
				*rp = rr.ll;
			}
		}
		else
		{
			/* 0q = NN / dd */

			count_leading_zeros (bm, d1);
			if (bm == 0)
			{
				/* From (n1 >= d1) /\ (the most significant bit of d1 is set),
				conclude (the most significant bit of n1 is set) /\ (the
				 quotient digit q0 = 0 or 1).

				 This special case is necessary, not an optimization.  */

				/* The condition on the next line takes advantage of that
				n1 >= d1 (true due to program flow).  */
				if (n1 > d1 || n0 >= d0)
				{
					q0 = 1;
					sub_ddmmss (n1, n0, n1, n0, d1, d0);
				}
				else
					q0 = 0;

				q1 = 0;

				if (rp != 0)
				{
					rr.s.low = n0;
					rr.s.high = n1;
					*rp = rr.ll;
				}
			}
			else
			{
				UWtype m1, m0;
				/* Normalize.  */

				b = W_TYPE_SIZE - bm;

				d1 = (d1 << bm) | (d0 >> b);
				d0 = d0 << bm;
				n2 = n1 >> b;
				n1 = (n1 << bm) | (n0 >> b);
				n0 = n0 << bm;

				udiv_qrnnd (q0, n1, n2, n1, d1);
				umul_ppmm (m1, m0, q0, d0);

				if (m1 > n1 || (m1 == n1 && m0 > n0))
				{
					q0--;
					sub_ddmmss (m1, m0, m1, m0, d1, d0);
				}

				q1 = 0;

				/* Remainder in (n1n0 - m1m0) >> bm.  */
				if (rp != 0)
				{
					sub_ddmmss (n1, n0, n1, n0, m1, m0);
					rr.s.low = (n1 << b) | (n0 >> bm);
					rr.s.high = n1 >> bm;
					*rp = rr.ll;
				}
			}
		}
	}

	ww.s.low = q0;
	ww.s.high = q1;
	return ww.ll;
}

#define __negdi2(a) (-(a))

long long __divdi3(long long u, long long v)
{
	int c = 0;
	DWunion uu, vv;
	DWtype w;

	uu.ll = u;
	vv.ll = v;

	if (uu.s.high < 0)
	{
		c = ~c;
		uu.ll = __negdi2 (uu.ll);
	}
	if (vv.s.high < 0)
	{
		c = ~c;
		vv.ll = __negdi2 (vv.ll);
	}
	w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
	if (c)
		w = __negdi2 (w);
	return w;
}

long long __moddi3(long long u, long long v)
{
	int c = 0;
	DWunion uu, vv;
	DWtype w;

	uu.ll = u;
	vv.ll = v;

	if (uu.s.high < 0)
	{
		c = ~c;
		uu.ll = __negdi2 (uu.ll);
	}
	if (vv.s.high < 0)
		vv.ll = __negdi2 (vv.ll);

	__udivmoddi4 (uu.ll, vv.ll, (UDWtype *) &w);
	if (c)
		w = __negdi2 (w);
	return w;
}

unsigned long long __udivdi3(unsigned long long u, unsigned long long v)
{
	return __udivmoddi4 (u, v, (UDWtype *) 0);
}

unsigned long long __umoddi3(unsigned long long u, unsigned long long v)
{
	UDWtype w;

	__udivmoddi4 (u, v, &w);
	return w;
}

/* XXX: fix tcc's code generator to do this instead */
long long __ashrdi3(long long a, int b)
{
#ifdef __TINYC__
	DWunion u;
	u.ll = a;
	if (b >= 32)
	{
		u.s.low = u.s.high >> (b - 32);
		u.s.high = u.s.high >> 31;
	}
	else if (b != 0)
	{
		u.s.low = ((unsigned)u.s.low >> b) | (u.s.high << (32 - b));
		u.s.high = u.s.high >> b;
	}
	return u.ll;
#else
	return a >> b;
#endif
}

/* XXX: fix tcc's code generator to do this instead */
unsigned long long __lshrdi3(unsigned long long a, int b)
{
#ifdef __TINYC__
	DWunion u;
	u.ll = a;
	if (b >= 32)
	{
		u.s.low = (unsigned)u.s.high >> (b - 32);
		u.s.high = 0;
	}
	else if (b != 0)
	{
		u.s.low = ((unsigned)u.s.low >> b) | (u.s.high << (32 - b));
		u.s.high = (unsigned)u.s.high >> b;
	}
	return u.ll;
#else
	return a >> b;
#endif
}

/* XXX: fix tcc's code generator to do this instead */
long long __ashldi3(long long a, int b)
{
#ifdef __TINYC__
	DWunion u;
	u.ll = a;
	if (b >= 32)
	{
		u.s.high = (unsigned)u.s.low << (b - 32);
		u.s.low = 0;
	}
	else if (b != 0)
	{
		u.s.high = ((unsigned)u.s.high << b) | ((unsigned)u.s.low >> (32 - b));
		u.s.low = (unsigned)u.s.low << b;
	}
	return u.ll;
#else
	return a << b;
#endif
}

#endif /* !__x86_64__ */

/* XXX: fix tcc's code generator to do this instead */
float __floatundisf(unsigned long long a)
{
	DWunion uu;
	XFtype r;

	uu.ll = a;
	if (uu.s.high >= 0)
	{
		return (float)uu.ll;
	}
	else
	{
		r = (XFtype)uu.ll;
		r += 18446744073709551616.0;
		return (float)r;
	}
}

double __floatundidf(unsigned long long a)
{
	DWunion uu;
	XFtype r;

	uu.ll = a;
	if (uu.s.high >= 0)
	{
		return (double)uu.ll;
	}
	else
	{
		r = (XFtype)uu.ll;
		r += 18446744073709551616.0;
		return (double)r;
	}
}

long double __floatundixf(unsigned long long a)
{
	DWunion uu;
	XFtype r;

	uu.ll = a;
	if (uu.s.high >= 0)
	{
		return (long double)uu.ll;
	}
	else
	{
		r = (XFtype)uu.ll;
		r += 18446744073709551616.0;
		return (long double)r;
	}
}

unsigned long long __fixunssfdi (float a1)
{
	register union float_long fl1;
	register int exp;
	register unsigned long l;

	fl1.f = a1;

	if (fl1.l == 0)
		return (0);

	exp = EXP (fl1.l) - EXCESS - 24;

	l = MANT(fl1.l);
	if (exp >= 41)
		return (unsigned long long)-1;
	else if (exp >= 0)
		return (unsigned long long)l << exp;
	else if (exp >= -23)
		return l >> -exp;
	else
		return 0;
}

long long __fixsfdi (float a1)
{
	long long ret;
	int s;
	ret = __fixunssfdi((s = a1 >= 0) ? a1 : -a1);
	return s ? ret : -ret;
}

unsigned long long __fixunsdfdi (double a1)
{
	register union double_long dl1;
	register int exp;
	register unsigned long long l;

	dl1.d = a1;

	if (dl1.ll == 0)
		return (0);

	exp = EXPD (dl1) - EXCESSD - 53;

	l = MANTD_LL(dl1);

	if (exp >= 12)
		return (unsigned long long)-1;
	else if (exp >= 0)
		return l << exp;
	else if (exp >= -52)
		return l >> -exp;
	else
		return 0;
}

long long __fixdfdi (double a1)
{
	long long ret;
	int s;
	ret = __fixunsdfdi((s = a1 >= 0) ? a1 : -a1);
	return s ? ret : -ret;
}

#ifndef __arm__
unsigned long long __fixunsxfdi (long double a1)
{
	register union ldouble_long dl1;
	register int exp;
	register unsigned long long l;

	dl1.ld = a1;

	if (dl1.l.lower == 0 && dl1.l.upper == 0)
		return (0);

	exp = EXPLD (dl1) - EXCESSLD - 64;

	l = dl1.l.lower;

	if (exp > 0)
		return (unsigned long long)-1;
	else if (exp >= -63)
		return l >> -exp;
	else
		return 0;
}

long long __fixxfdi (long double a1)
{
	long long ret;
	int s;
	ret = __fixunsxfdi((s = a1 >= 0) ? a1 : -a1);
	return s ? ret : -ret;
}
#endif /* !ARM */
//END libtcc1.c

//START libtcc.h

#ifndef LIBTCCAPI
# define LIBTCCAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

struct TCCState;

typedef struct TCCState TCCState;

typedef void (*TCCErrorFunc)(void *opaque, const char *msg);

/* create a new TCC compilation context */
LIBTCCAPI TCCState *tcc_new(void);

/* free a TCC compilation context */
LIBTCCAPI void tcc_delete(TCCState *s);

/* set CONFIG_TCCDIR at runtime */
LIBTCCAPI void tcc_set_lib_path(TCCState *s, const char *path);

/* set error/warning display callback */
LIBTCCAPI void tcc_set_error_func(TCCState *s, void *error_opaque, TCCErrorFunc error_func);

/* return error/warning callback */
LIBTCCAPI TCCErrorFunc tcc_get_error_func(TCCState *s);

/* return error/warning callback opaque pointer */
LIBTCCAPI void *tcc_get_error_opaque(TCCState *s);

/* set options as from command line (multiple supported) */
LIBTCCAPI void tcc_set_options(TCCState *s, const char *str);

/*****************************/
/* preprocessor */

/* add include path */
LIBTCCAPI int tcc_add_include_path(TCCState *s, const char *pathname);

/* add in system include path */
LIBTCCAPI int tcc_add_sysinclude_path(TCCState *s, const char *pathname);

/* define preprocessor symbol 'sym'. Can put optional value */
LIBTCCAPI void tcc_define_symbol(TCCState *s, const char *sym, const char *value);

/* undefine preprocess symbol 'sym' */
LIBTCCAPI void tcc_undefine_symbol(TCCState *s, const char *sym);

/*****************************/
/* compiling */

/* add a file (C file, dll, object, library, ld script). Return -1 if error. */
LIBTCCAPI int tcc_add_file(TCCState *s, const char *filename);

/* compile a string containing a C source. Return -1 if error. */
LIBTCCAPI int tcc_compile_string(TCCState *s, const char *buf);

/*****************************/
/* linking commands */

/* set output type. MUST BE CALLED before any compilation */
LIBTCCAPI int tcc_set_output_type(TCCState *s, int output_type);
#define TCC_OUTPUT_MEMORY   1 /* output will be run in memory (default) */
#define TCC_OUTPUT_EXE      2 /* executable file */
#define TCC_OUTPUT_DLL      3 /* dynamic library */
#define TCC_OUTPUT_OBJ      4 /* object file */
#define TCC_OUTPUT_PREPROCESS 5 /* only preprocess (used internally) */

/* equivalent to -Lpath option */
LIBTCCAPI int tcc_add_library_path(TCCState *s, const char *pathname);

/* the library name is the same as the argument of the '-l' option */
LIBTCCAPI int tcc_add_library(TCCState *s, const char *libraryname);

/* add a symbol to the compiled program */
LIBTCCAPI int tcc_add_symbol(TCCState *s, const char *name, const void *val);

/* output an executable, library or object file. DO NOT call
   tcc_relocate() before. */
LIBTCCAPI int tcc_output_file(TCCState *s, const char *filename);

/* link and run main() function and return its value. DO NOT call
   tcc_relocate() before. */
LIBTCCAPI int tcc_run(TCCState *s, int argc, char **argv);

/* do all relocations (needed before using tcc_get_symbol()) */
LIBTCCAPI int tcc_relocate(TCCState *s1, void *ptr);
/* possible values for 'ptr':
   - TCC_RELOCATE_AUTO : Allocate and manage memory internally
   - NULL              : return required memory size for the step below
   - memory address    : copy code to memory passed by the caller
   returns -1 if error. */
#define TCC_RELOCATE_AUTO (void*)1

/* return symbol value or NULL if not found */
LIBTCCAPI void *tcc_get_symbol(TCCState *s, const char *name);

/* return symbol value or NULL if not found */
LIBTCCAPI void tcc_list_symbols(TCCState *s, void *ctx,
                                void (*symbol_cb)(void *ctx, const char *name, const void *val));

#ifdef __cplusplus
}
#endif

//END libtcc.h


//START elf.h


#ifndef _WIN32
#include <inttypes.h>
#else
#ifndef __int8_t_defined
#define __int8_t_defined
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;
typedef long long int int64_t;
typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
typedef unsigned int            uint32_t;
typedef unsigned long long int  uint64_t;
#endif
#endif

/* Standard ELF types.  */

/* Type for a 16-bit quantity.  */
typedef uint16_t Elf32_Half;
typedef uint16_t Elf64_Half;

/* Types for signed and unsigned 32-bit quantities.  */
typedef uint32_t Elf32_Word;
typedef	int32_t  Elf32_Sword;
typedef uint32_t Elf64_Word;
typedef	int32_t  Elf64_Sword;

/* Types for signed and unsigned 64-bit quantities.  */
typedef uint64_t Elf32_Xword;
typedef	int64_t  Elf32_Sxword;
typedef uint64_t Elf64_Xword;
typedef	int64_t  Elf64_Sxword;

/* Type of addresses.  */
typedef uint32_t Elf32_Addr;
typedef uint64_t Elf64_Addr;

/* Type of file offsets.  */
typedef uint32_t Elf32_Off;
typedef uint64_t Elf64_Off;

/* Type for section indices, which are 16-bit quantities.  */
typedef uint16_t Elf32_Section;
typedef uint16_t Elf64_Section;

/* Type for version symbol information.  */
typedef Elf32_Half Elf32_Versym;
typedef Elf64_Half Elf64_Versym;


/* The ELF file header.  This appears at the start of every ELF file.  */

#define EI_NIDENT (16)

typedef struct
{
	unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
	Elf32_Half	e_type;			/* Object file type */
	Elf32_Half	e_machine;		/* Architecture */
	Elf32_Word	e_version;		/* Object file version */
	Elf32_Addr	e_entry;		/* Entry point virtual address */
	Elf32_Off	e_phoff;		/* Program header table file offset */
	Elf32_Off	e_shoff;		/* Section header table file offset */
	Elf32_Word	e_flags;		/* Processor-specific flags */
	Elf32_Half	e_ehsize;		/* ELF header size in bytes */
	Elf32_Half	e_phentsize;		/* Program header table entry size */
	Elf32_Half	e_phnum;		/* Program header table entry count */
	Elf32_Half	e_shentsize;		/* Section header table entry size */
	Elf32_Half	e_shnum;		/* Section header table entry count */
	Elf32_Half	e_shstrndx;		/* Section header string table index */
} Elf32_Ehdr;

typedef struct
{
	unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
	Elf64_Half	e_type;			/* Object file type */
	Elf64_Half	e_machine;		/* Architecture */
	Elf64_Word	e_version;		/* Object file version */
	Elf64_Addr	e_entry;		/* Entry point virtual address */
	Elf64_Off	e_phoff;		/* Program header table file offset */
	Elf64_Off	e_shoff;		/* Section header table file offset */
	Elf64_Word	e_flags;		/* Processor-specific flags */
	Elf64_Half	e_ehsize;		/* ELF header size in bytes */
	Elf64_Half	e_phentsize;		/* Program header table entry size */
	Elf64_Half	e_phnum;		/* Program header table entry count */
	Elf64_Half	e_shentsize;		/* Section header table entry size */
	Elf64_Half	e_shnum;		/* Section header table entry count */
	Elf64_Half	e_shstrndx;		/* Section header string table index */
} Elf64_Ehdr;

/* Fields in the e_ident array.  The EI_* macros are indices into the
   array.  The macros under each EI_* macro are the values the byte
   may have.  */

#define EI_MAG0		0		/* File identification byte 0 index */
#define ELFMAG0		0x7f		/* Magic number byte 0 */

#define EI_MAG1		1		/* File identification byte 1 index */
#define ELFMAG1		'E'		/* Magic number byte 1 */

#define EI_MAG2		2		/* File identification byte 2 index */
#define ELFMAG2		'L'		/* Magic number byte 2 */

#define EI_MAG3		3		/* File identification byte 3 index */
#define ELFMAG3		'F'		/* Magic number byte 3 */

/* Conglomeration of the identification bytes, for easy testing as a word.  */
#define	ELFMAG		"\177ELF"
#define	SELFMAG		4

#define EI_CLASS	4		/* File class byte index */
#define ELFCLASSNONE	0		/* Invalid class */
#define ELFCLASS32	1		/* 32-bit objects */
#define ELFCLASS64	2		/* 64-bit objects */
#define ELFCLASSNUM	3

#define EI_DATA		5		/* Data encoding byte index */
#define ELFDATANONE	0		/* Invalid data encoding */
#define ELFDATA2LSB	1		/* 2's complement, little endian */
#define ELFDATA2MSB	2		/* 2's complement, big endian */
#define ELFDATANUM	3

#define EI_VERSION	6		/* File version byte index */
/* Value must be EV_CURRENT */

#define EI_OSABI	7		/* OS ABI identification */
#define ELFOSABI_NONE		0	/* UNIX System V ABI */
#define ELFOSABI_SYSV		0	/* Alias.  */
#define ELFOSABI_HPUX		1	/* HP-UX */
#define ELFOSABI_NETBSD		2	/* NetBSD.  */
#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
#define ELFOSABI_AIX		7	/* IBM AIX.  */
#define ELFOSABI_IRIX		8	/* SGI Irix.  */
#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
#define ELFOSABI_ARM		97	/* ARM */
#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */

#define EI_ABIVERSION	8		/* ABI version */

#define EI_PAD		9		/* Byte index of padding bytes */

/* Legal values for e_type (object file type).  */

#define ET_NONE		0		/* No file type */
#define ET_REL		1		/* Relocatable file */
#define ET_EXEC		2		/* Executable file */
#define ET_DYN		3		/* Shared object file */
#define ET_CORE		4		/* Core file */
#define	ET_NUM		5		/* Number of defined types */
#define ET_LOOS		0xfe00		/* OS-specific range start */
#define ET_HIOS		0xfeff		/* OS-specific range end */
#define ET_LOPROC	0xff00		/* Processor-specific range start */
#define ET_HIPROC	0xffff		/* Processor-specific range end */

/* Legal values for e_machine (architecture).  */

#define EM_NONE		 0		/* No machine */
#define EM_M32		 1		/* AT&T WE 32100 */
#define EM_SPARC	 2		/* SUN SPARC */
#define EM_386		 3		/* Intel 80386 */
#define EM_68K		 4		/* Motorola m68k family */
#define EM_88K		 5		/* Motorola m88k family */
#define EM_860		 7		/* Intel 80860 */
#define EM_MIPS		 8		/* MIPS R3000 big-endian */
#define EM_S370		 9		/* IBM System/370 */
#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */

#define EM_PARISC	15		/* HPPA */
#define EM_VPP500	17		/* Fujitsu VPP500 */
#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
#define EM_960		19		/* Intel 80960 */
#define EM_PPC		20		/* PowerPC */
#define EM_PPC64	21		/* PowerPC 64-bit */
#define EM_S390		22		/* IBM S390 */

#define EM_V800		36		/* NEC V800 series */
#define EM_FR20		37		/* Fujitsu FR20 */
#define EM_RH32		38		/* TRW RH-32 */
#define EM_RCE		39		/* Motorola RCE */
#define EM_ARM		40		/* ARM */
#define EM_FAKE_ALPHA	41		/* Digital Alpha */
#define EM_SH		42		/* Hitachi SH */
#define EM_SPARCV9	43		/* SPARC v9 64-bit */
#define EM_TRICORE	44		/* Siemens Tricore */
#define EM_ARC		45		/* Argonaut RISC Core */
#define EM_H8_300	46		/* Hitachi H8/300 */
#define EM_H8_300H	47		/* Hitachi H8/300H */
#define EM_H8S		48		/* Hitachi H8S */
#define EM_H8_500	49		/* Hitachi H8/500 */
#define EM_IA_64	50		/* Intel Merced */
#define EM_MIPS_X	51		/* Stanford MIPS-X */
#define EM_COLDFIRE	52		/* Motorola Coldfire */
#define EM_68HC12	53		/* Motorola M68HC12 */
#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
#define EM_PCP		55		/* Siemens PCP */
#define EM_NCPU		56		/* Sony nCPU embedded RISC */
#define EM_NDR1		57		/* Denso NDR1 microprocessor */
#define EM_STARCORE	58		/* Motorola Start*Core processor */
#define EM_ME16		59		/* Toyota ME16 processor */
#define EM_ST100	60		/* STMicroelectronic ST100 processor */
#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
#define EM_X86_64	62		/* AMD x86-64 architecture */
#define EM_PDSP		63		/* Sony DSP Processor */

#define EM_FX66		66		/* Siemens FX66 microcontroller */
#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
#define EM_ST7		68		/* STMicroelectronics ST7 8 bit mc */
#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
#define EM_SVX		73		/* Silicon Graphics SVx */
#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
#define EM_VAX		75		/* Digital VAX */
#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
#define EM_HUANY	81		/* Harvard University machine-independent object files */
#define EM_PRISM	82		/* SiTera Prism */
#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
#define EM_FR30		84		/* Fujitsu FR30 */
#define EM_D10V		85		/* Mitsubishi D10V */
#define EM_D30V		86		/* Mitsubishi D30V */
#define EM_V850		87		/* NEC v850 */
#define EM_M32R		88		/* Mitsubishi M32R */
#define EM_MN10300	89		/* Matsushita MN10300 */
#define EM_MN10200	90		/* Matsushita MN10200 */
#define EM_PJ		91		/* picoJava */
#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
#define EM_AARCH64	183		/* ARM AARCH64 */
#define EM_TILEPRO	188		/* Tilera TILEPro */
#define EM_TILEGX	191		/* Tilera TILE-Gx */
#define EM_RISCV	243	        /* RISC-V */
#define EM_NUM		253

/* If it is necessary to assign new unofficial EM_* values, please
   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
   chances of collision with official or non-GNU unofficial values.  */

#define EM_ALPHA	0x9026
#define EM_C60		0x9c60

/* Legal values for e_version (version).  */

#define EV_NONE		0		/* Invalid ELF version */
#define EV_CURRENT	1		/* Current version */
#define EV_NUM		2

/* Section header.  */

typedef struct
{
	Elf32_Word	sh_name;		/* Section name (string tbl index) */
	Elf32_Word	sh_type;		/* Section type */
	Elf32_Word	sh_flags;		/* Section flags */
	Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
	Elf32_Off	sh_offset;		/* Section file offset */
	Elf32_Word	sh_size;		/* Section size in bytes */
	Elf32_Word	sh_link;		/* Link to another section */
	Elf32_Word	sh_info;		/* Additional section information */
	Elf32_Word	sh_addralign;		/* Section alignment */
	Elf32_Word	sh_entsize;		/* Entry size if section holds table */
} Elf32_Shdr;

typedef struct
{
	Elf64_Word	sh_name;		/* Section name (string tbl index) */
	Elf64_Word	sh_type;		/* Section type */
	Elf64_Xword	sh_flags;		/* Section flags */
	Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
	Elf64_Off	sh_offset;		/* Section file offset */
	Elf64_Xword	sh_size;		/* Section size in bytes */
	Elf64_Word	sh_link;		/* Link to another section */
	Elf64_Word	sh_info;		/* Additional section information */
	Elf64_Xword	sh_addralign;		/* Section alignment */
	Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
} Elf64_Shdr;

/* Special section indices.  */

#define SHN_UNDEF	0		/* Undefined section */
#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
#define SHN_LOPROC	0xff00		/* Start of processor-specific */
#define SHN_BEFORE	0xff00		/* Order section before all others
					   (Solaris).  */
#define SHN_AFTER	0xff01		/* Order section after all others
					   (Solaris).  */
#define SHN_HIPROC	0xff1f		/* End of processor-specific */
#define SHN_LOOS	0xff20		/* Start of OS-specific */
#define SHN_HIOS	0xff3f		/* End of OS-specific */
#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
#define SHN_COMMON	0xfff2		/* Associated symbol is common */
#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
#define SHN_HIRESERVE	0xffff		/* End of reserved indices */

/* Legal values for sh_type (section type).  */

#define SHT_NULL	  0		/* Section header table entry unused */
#define SHT_PROGBITS	  1		/* Program data */
#define SHT_SYMTAB	  2		/* Symbol table */
#define SHT_STRTAB	  3		/* String table */
#define SHT_RELA	  4		/* Relocation entries with addends */
#define SHT_HASH	  5		/* Symbol hash table */
#define SHT_DYNAMIC	  6		/* Dynamic linking information */
#define SHT_NOTE	  7		/* Notes */
#define SHT_NOBITS	  8		/* Program space with no data (bss) */
#define SHT_REL		  9		/* Relocation entries, no addends */
#define SHT_SHLIB	  10		/* Reserved */
#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
#define SHT_INIT_ARRAY	  14		/* Array of constructors */
#define SHT_FINI_ARRAY	  15		/* Array of destructors */
#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
#define SHT_GROUP	  17		/* Section group */
#define SHT_SYMTAB_SHNDX  18		/* Extended section indices */
#define	SHT_NUM		  19		/* Number of defined types.  */
#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
#define SHT_SUNW_move	  0x6ffffffa
#define SHT_SUNW_COMDAT   0x6ffffffb
#define SHT_SUNW_syminfo  0x6ffffffc
#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */

/* Legal values for sh_flags (section flags).  */

#define SHF_WRITE	     (1 << 0)	/* Writable */
#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
#define SHF_MERGE	     (1 << 4)	/* Might be merged */
#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
					   required */
#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
#define SHF_COMPRESSED	     (1 << 11)	/* Section with compressed data. */
#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
					   (Solaris).  */
#define SHF_EXCLUDE	     (1U << 31)	/* Section is excluded unless
					   referenced or allocated (Solaris).*/

/* Section group handling.  */
#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */

/* Symbol table entry.  */

typedef struct
{
	Elf32_Word	st_name;		/* Symbol name (string tbl index) */
	Elf32_Addr	st_value;		/* Symbol value */
	Elf32_Word	st_size;		/* Symbol size */
	unsigned char	st_info;		/* Symbol type and binding */
	unsigned char	st_other;		/* Symbol visibility */
	Elf32_Section	st_shndx;		/* Section index */
} Elf32_Sym;

typedef struct
{
	Elf64_Word	st_name;		/* Symbol name (string tbl index) */
	unsigned char	st_info;		/* Symbol type and binding */
	unsigned char st_other;		/* Symbol visibility */
	Elf64_Section	st_shndx;		/* Section index */
	Elf64_Addr	st_value;		/* Symbol value */
	Elf64_Xword	st_size;		/* Symbol size */
} Elf64_Sym;

/* The syminfo section if available contains additional information about
   every dynamic symbol.  */

typedef struct
{
	Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
	Elf32_Half si_flags;			/* Per symbol flags */
} Elf32_Syminfo;

typedef struct
{
	Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
	Elf64_Half si_flags;			/* Per symbol flags */
} Elf64_Syminfo;

/* Possible values for si_boundto.  */
#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */

/* Possible bitmasks for si_flags.  */
#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
					   loaded */
/* Syminfo version values.  */
#define SYMINFO_NONE		0
#define SYMINFO_CURRENT		1
#define SYMINFO_NUM		2


/* How to extract and insert information held in the st_info field.  */

#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
#define ELF32_ST_TYPE(val)		((val) & 0xf)
#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))

/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))

/* Legal values for ST_BIND subfield of st_info (symbol binding).  */

#define STB_LOCAL	0		/* Local symbol */
#define STB_GLOBAL	1		/* Global symbol */
#define STB_WEAK	2		/* Weak symbol */
#define	STB_NUM		3		/* Number of defined types.  */
#define STB_LOOS	10		/* Start of OS-specific */
#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
#define STB_HIOS	12		/* End of OS-specific */
#define STB_LOPROC	13		/* Start of processor-specific */
#define STB_HIPROC	15		/* End of processor-specific */

/* Legal values for ST_TYPE subfield of st_info (symbol type).  */

#define STT_NOTYPE	0		/* Symbol type is unspecified */
#define STT_OBJECT	1		/* Symbol is a data object */
#define STT_FUNC	2		/* Symbol is a code object */
#define STT_SECTION	3		/* Symbol associated with a section */
#define STT_FILE	4		/* Symbol's name is file name */
#define STT_COMMON	5		/* Symbol is a common data object */
#define STT_TLS		6		/* Symbol is thread-local data object*/
#define	STT_NUM		7		/* Number of defined types.  */
#define STT_LOOS	10		/* Start of OS-specific */
#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
#define STT_HIOS	12		/* End of OS-specific */
#define STT_LOPROC	13		/* Start of processor-specific */
#define STT_HIPROC	15		/* End of processor-specific */


/* Symbol table indices are found in the hash buckets and chain table
   of a symbol hash table section.  This special index value indicates
   the end of a chain, meaning no further symbols are found in that bucket.  */

#define STN_UNDEF	0		/* End of a chain.  */


/* How to extract and insert information held in the st_other field.  */

#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)

/* For ELF64 the definitions are the same.  */
#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)

/* Symbol visibility specification encoded in the st_other field.  */
#define STV_DEFAULT	0		/* Default symbol visibility rules */
#define STV_INTERNAL	1		/* Processor specific hidden class */
#define STV_HIDDEN	2		/* Sym unavailable in other modules */
#define STV_PROTECTED	3		/* Not preemptible, not exported */


/* Relocation table entry without addend (in section of type SHT_REL).  */

typedef struct
{
	Elf32_Addr	r_offset;		/* Address */
	Elf32_Word	r_info;			/* Relocation type and symbol index */
} Elf32_Rel;

/* I have seen two different definitions of the Elf64_Rel and
   Elf64_Rela structures, so we'll leave them out until Novell (or
   whoever) gets their act together.  */
/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */

typedef struct
{
	Elf64_Addr	r_offset;		/* Address */
	Elf64_Xword	r_info;			/* Relocation type and symbol index */
} Elf64_Rel;

/* Relocation table entry with addend (in section of type SHT_RELA).  */

typedef struct
{
	Elf32_Addr	r_offset;		/* Address */
	Elf32_Word	r_info;			/* Relocation type and symbol index */
	Elf32_Sword	r_addend;		/* Addend */
} Elf32_Rela;

typedef struct
{
	Elf64_Addr	r_offset;		/* Address */
	Elf64_Xword	r_info;			/* Relocation type and symbol index */
	Elf64_Sxword	r_addend;		/* Addend */
} Elf64_Rela;

/* How to extract and insert information held in the r_info field.  */

#define ELF32_R_SYM(val)		((val) >> 8)
#define ELF32_R_TYPE(val)		((val) & 0xff)
#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))

#define ELF64_R_SYM(i)			((i) >> 32)
#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))

/* Program segment header.  */

typedef struct
{
	Elf32_Word	p_type;			/* Segment type */
	Elf32_Off	p_offset;		/* Segment file offset */
	Elf32_Addr	p_vaddr;		/* Segment virtual address */
	Elf32_Addr	p_paddr;		/* Segment physical address */
	Elf32_Word	p_filesz;		/* Segment size in file */
	Elf32_Word	p_memsz;		/* Segment size in memory */
	Elf32_Word	p_flags;		/* Segment flags */
	Elf32_Word	p_align;		/* Segment alignment */
} Elf32_Phdr;

typedef struct
{
	Elf64_Word	p_type;			/* Segment type */
	Elf64_Word	p_flags;		/* Segment flags */
	Elf64_Off	p_offset;		/* Segment file offset */
	Elf64_Addr	p_vaddr;		/* Segment virtual address */
	Elf64_Addr	p_paddr;		/* Segment physical address */
	Elf64_Xword	p_filesz;		/* Segment size in file */
	Elf64_Xword	p_memsz;		/* Segment size in memory */
	Elf64_Xword	p_align;		/* Segment alignment */
} Elf64_Phdr;

/* Special value for e_phnum.  This indicates that the real number of
   program headers is too large to fit into e_phnum.  Instead the real
   value is in the field sh_info of section 0.  */

#define PN_XNUM		0xffff

/* Legal values for p_type (segment type).  */

#define	PT_NULL		0		/* Program header table entry unused */
#define PT_LOAD		1		/* Loadable program segment */
#define PT_DYNAMIC	2		/* Dynamic linking information */
#define PT_INTERP	3		/* Program interpreter */
#define PT_NOTE		4		/* Auxiliary information */
#define PT_SHLIB	5		/* Reserved */
#define PT_PHDR		6		/* Entry for header table itself */
#define PT_TLS		7		/* Thread-local storage segment */
#define	PT_NUM		8		/* Number of defined types */
#define PT_LOOS		0x60000000	/* Start of OS-specific */
#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
#define PT_LOSUNW	0x6ffffffa
#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
#define PT_HISUNW	0x6fffffff
#define PT_HIOS		0x6fffffff	/* End of OS-specific */
#define PT_LOPROC	0x70000000	/* Start of processor-specific */
#define PT_HIPROC	0x7fffffff	/* End of processor-specific */

/* Legal values for p_flags (segment flags).  */

#define PF_X		(1 << 0)	/* Segment is executable */
#define PF_W		(1 << 1)	/* Segment is writable */
#define PF_R		(1 << 2)	/* Segment is readable */
#define PF_MASKOS	0x0ff00000	/* OS-specific */
#define PF_MASKPROC	0xf0000000	/* Processor-specific */

/* Legal values for note segment descriptor types for core files. */

#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
#define NT_PRXREG	4		/* Contains copy of prxregset struct */
#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
#define NT_AUXV		6		/* Contains copy of auxv array */
#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
#define NT_ASRS		8		/* Contains copy of asrset struct */
#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
#define NT_PSINFO	13		/* Contains copy of psinfo struct */
#define NT_PRCRED	14		/* Contains copy of prcred struct */
#define NT_UTSNAME	15		/* Contains copy of utsname struct */
#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
#define NT_S390_HIGH_GPRS	0x300	/* s390 upper register halves */
#define NT_S390_TIMER	0x301		/* s390 timer register */
#define NT_S390_TODCMP	0x302		/* s390 TOD clock comparator register */
#define NT_S390_TODPREG	0x303		/* s390 TOD programmable register */
#define NT_S390_CTRS	0x304		/* s390 control registers */
#define NT_S390_PREFIX	0x305		/* s390 prefix register */
#define NT_S390_LAST_BREAK	0x306	/* s390 breaking event address */
#define NT_S390_SYSTEM_CALL	0x307	/* s390 system call restart data */
#define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
#define NT_ARM_TLS	0x401		/* ARM TLS register */
#define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
#define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */

/* Legal values for the note segment descriptor types for object files.  */

#define NT_VERSION	1		/* Contains a version string.  */


/* Dynamic section entry.  */

typedef struct
{
	Elf32_Sword	d_tag;			/* Dynamic entry type */
	union
	{
		Elf32_Word d_val;			/* Integer value */
		Elf32_Addr d_ptr;			/* Address value */
	} d_un;
} Elf32_Dyn;

typedef struct
{
	Elf64_Sxword	d_tag;			/* Dynamic entry type */
	union
	{
		Elf64_Xword d_val;		/* Integer value */
		Elf64_Addr d_ptr;			/* Address value */
	} d_un;
} Elf64_Dyn;

/* Legal values for d_tag (dynamic entry type).  */

#define DT_NULL		0		/* Marks end of dynamic section */
#define DT_NEEDED	1		/* Name of needed library */
#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
#define DT_PLTGOT	3		/* Processor defined value */
#define DT_HASH		4		/* Address of symbol hash table */
#define DT_STRTAB	5		/* Address of string table */
#define DT_SYMTAB	6		/* Address of symbol table */
#define DT_RELA		7		/* Address of Rela relocs */
#define DT_RELASZ	8		/* Total size of Rela relocs */
#define DT_RELAENT	9		/* Size of one Rela reloc */
#define DT_STRSZ	10		/* Size of string table */
#define DT_SYMENT	11		/* Size of one symbol table entry */
#define DT_INIT		12		/* Address of init function */
#define DT_FINI		13		/* Address of termination function */
#define DT_SONAME	14		/* Name of shared object */
#define DT_RPATH	15		/* Library search path (deprecated) */
#define DT_SYMBOLIC	16		/* Start symbol search here */
#define DT_REL		17		/* Address of Rel relocs */
#define DT_RELSZ	18		/* Total size of Rel relocs */
#define DT_RELENT	19		/* Size of one Rel reloc */
#define DT_PLTREL	20		/* Type of reloc in PLT */
#define DT_DEBUG	21		/* For debugging; unspecified */
#define DT_TEXTREL	22		/* Reloc might modify .text */
#define DT_JMPREL	23		/* Address of PLT relocs */
#define	DT_BIND_NOW	24		/* Process relocations of object */
#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
#define DT_RUNPATH	29		/* Library search path */
#define DT_FLAGS	30		/* Flags for the object being loaded */
#define DT_ENCODING	32		/* Start of encoded range */
#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
#define	DT_NUM		34		/* Number used */
#define DT_LOOS		0x6000000d	/* Start of OS-specific */
#define DT_HIOS		0x6ffff000	/* End of OS-specific */
#define DT_LOPROC	0x70000000	/* Start of processor-specific */
#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */

/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
   approach.  */
#define DT_VALRNGLO	0x6ffffd00
#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
#define DT_CHECKSUM	0x6ffffdf8
#define DT_PLTPADSZ	0x6ffffdf9
#define DT_MOVEENT	0x6ffffdfa
#define DT_MOVESZ	0x6ffffdfb
#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
					   the following DT_* entry.  */
#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
#define DT_VALRNGHI	0x6ffffdff
#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
#define DT_VALNUM 12

/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.

   If any adjustment is made to the ELF object after it has been
   built these entries will need to be adjusted.  */
#define DT_ADDRRNGLO	0x6ffffe00
#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
#define DT_TLSDESC_PLT	0x6ffffef6
#define DT_TLSDESC_GOT	0x6ffffef7
#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
#define DT_ADDRRNGHI	0x6ffffeff
#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
#define DT_ADDRNUM 11

/* The versioning entry types.  The next are defined as part of the
   GNU extension.  */
#define DT_VERSYM	0x6ffffff0

#define DT_RELACOUNT	0x6ffffff9
#define DT_RELCOUNT	0x6ffffffa

/* These were chosen by Sun.  */
#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
					   table */
#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
					   versions */
#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
#define DT_VERSIONTAGNUM 16

/* Sun added these machine-independent extensions in the "processor-specific"
   range.  Be compatible.  */
#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
#define DT_EXTRANUM	3

/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */

/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
   entry in the dynamic section.  */
#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
#define DF_1_TRANS	0x00000200
#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
#define	DF_1_NODIRECT	0x00020000	/* Object has no-direct binding. */
#define	DF_1_IGNMULDEF	0x00040000
#define	DF_1_NOKSYMS	0x00080000
#define	DF_1_NOHDR	0x00100000
#define	DF_1_EDITED	0x00200000	/* Object is modified after built.  */
#define	DF_1_NORELOC	0x00400000
#define	DF_1_SYMINTPOSE	0x00800000	/* Object has individual interposers.  */
#define	DF_1_GLOBAUDIT	0x01000000	/* Global auditing required.  */
#define	DF_1_SINGLETON	0x02000000	/* Singleton symbols are used.  */

/* Flags for the feature selection in DT_FEATURE_1.  */
#define DTF_1_PARINIT	0x00000001
#define DTF_1_CONFEXP	0x00000002

/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
					   generally available.  */

/* Version definition sections.  */

typedef struct
{
	Elf32_Half	vd_version;		/* Version revision */
	Elf32_Half	vd_flags;		/* Version information */
	Elf32_Half	vd_ndx;			/* Version Index */
	Elf32_Half	vd_cnt;			/* Number of associated aux entries */
	Elf32_Word	vd_hash;		/* Version name hash value */
	Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
	Elf32_Word	vd_next;		/* Offset in bytes to next verdef
					   entry */
} Elf32_Verdef;

typedef struct
{
	Elf64_Half	vd_version;		/* Version revision */
	Elf64_Half	vd_flags;		/* Version information */
	Elf64_Half	vd_ndx;			/* Version Index */
	Elf64_Half	vd_cnt;			/* Number of associated aux entries */
	Elf64_Word	vd_hash;		/* Version name hash value */
	Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
	Elf64_Word	vd_next;		/* Offset in bytes to next verdef
					   entry */
} Elf64_Verdef;


/* Legal values for vd_version (version revision).  */
#define VER_DEF_NONE	0		/* No version */
#define VER_DEF_CURRENT	1		/* Current version */
#define VER_DEF_NUM	2		/* Given version number */

/* Legal values for vd_flags (version information flags).  */
#define VER_FLG_BASE	0x1		/* Version definition of file itself */
#define VER_FLG_WEAK	0x2		/* Weak version identifier */

/* Versym symbol index values.  */
#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */

/* Auxiliary version information.  */

typedef struct
{
	Elf32_Word	vda_name;		/* Version or dependency names */
	Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
					   entry */
} Elf32_Verdaux;

typedef struct
{
	Elf64_Word	vda_name;		/* Version or dependency names */
	Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
					   entry */
} Elf64_Verdaux;


/* Version dependency section.  */

typedef struct
{
	Elf32_Half	vn_version;		/* Version of structure */
	Elf32_Half	vn_cnt;			/* Number of associated aux entries */
	Elf32_Word	vn_file;		/* Offset of filename for this
					   dependency */
	Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
	Elf32_Word	vn_next;		/* Offset in bytes to next verneed
					   entry */
} Elf32_Verneed;

typedef struct
{
	Elf64_Half	vn_version;		/* Version of structure */
	Elf64_Half	vn_cnt;			/* Number of associated aux entries */
	Elf64_Word	vn_file;		/* Offset of filename for this
					   dependency */
	Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
	Elf64_Word	vn_next;		/* Offset in bytes to next verneed
					   entry */
} Elf64_Verneed;


/* Legal values for vn_version (version revision).  */
#define VER_NEED_NONE	 0		/* No version */
#define VER_NEED_CURRENT 1		/* Current version */
#define VER_NEED_NUM	 2		/* Given version number */

/* Auxiliary needed version information.  */

typedef struct
{
	Elf32_Word	vna_hash;		/* Hash value of dependency name */
	Elf32_Half	vna_flags;		/* Dependency specific information */
	Elf32_Half	vna_other;		/* Unused */
	Elf32_Word	vna_name;		/* Dependency name string offset */
	Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
					   entry */
} Elf32_Vernaux;

typedef struct
{
	Elf64_Word	vna_hash;		/* Hash value of dependency name */
	Elf64_Half	vna_flags;		/* Dependency specific information */
	Elf64_Half	vna_other;		/* Unused */
	Elf64_Word	vna_name;		/* Dependency name string offset */
	Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
					   entry */
} Elf64_Vernaux;


/* Legal values for vna_flags.  */
#define VER_FLG_WEAK	0x2		/* Weak version identifier */


/* Auxiliary vector.  */

/* This vector is normally only used by the program interpreter.  The
   usual definition in an ABI supplement uses the name auxv_t.  The
   vector is not usually defined in a standard <elf.h> file, but it
   can't hurt.  We rename it to avoid conflicts.  The sizes of these
   types are an arrangement between the exec server and the program
   interpreter, so we don't fully specify them here.  */

typedef struct
{
	uint32_t a_type;		/* Entry type */
	union
	{
		uint32_t a_val;		/* Integer value */
		/* We use to have pointer elements added here.  We cannot do that,
		though, since it does not work when using 32-bit definitions
		 on 64-bit platforms and vice versa.  */
	} a_un;
} Elf32_auxv_t;

typedef struct
{
	uint64_t a_type;		/* Entry type */
	union
	{
		uint64_t a_val;		/* Integer value */
		/* We use to have pointer elements added here.  We cannot do that,
		though, since it does not work when using 32-bit definitions
		 on 64-bit platforms and vice versa.  */
	} a_un;
} Elf64_auxv_t;

/* Legal values for a_type (entry type).  */

#define AT_NULL		0		/* End of vector */
#define AT_IGNORE	1		/* Entry should be ignored */
#define AT_EXECFD	2		/* File descriptor of program */
#define AT_PHDR		3		/* Program headers for program */
#define AT_PHENT	4		/* Size of program header entry */
#define AT_PHNUM	5		/* Number of program headers */
#define AT_PAGESZ	6		/* System page size */
#define AT_BASE		7		/* Base address of interpreter */
#define AT_FLAGS	8		/* Flags */
#define AT_ENTRY	9		/* Entry point of program */
#define AT_NOTELF	10		/* Program is not ELF */
#define AT_UID		11		/* Real uid */
#define AT_EUID		12		/* Effective uid */
#define AT_GID		13		/* Real gid */
#define AT_EGID		14		/* Effective gid */
#define AT_CLKTCK	17		/* Frequency of times() */

/* Some more special a_type values describing the hardware.  */
#define AT_PLATFORM	15		/* String identifying platform.  */
#define AT_HWCAP	16		/* Machine dependent hints about
					   processor capabilities.  */

/* This entry gives some information about the FPU initialization
   performed by the kernel.  */
#define AT_FPUCW	18		/* Used FPU control word.  */

/* Cache block sizes.  */
#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */

/* A special ignored value for PPC, used by the kernel to control the
   interpretation of the AUXV. Must be > 16.  */
#define AT_IGNOREPPC	22		/* Entry should be ignored.  */

#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */

#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/

#define AT_RANDOM	25		/* Address of 16 random bytes.  */

#define AT_EXECFN	31		/* Filename of executable.  */

/* Pointer to the global system page used for system calls and other
   nice things.  */
#define AT_SYSINFO	32
#define AT_SYSINFO_EHDR	33

/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
   log2 of line size; mask those to get cache size.  */
#define AT_L1I_CACHESHAPE	34
#define AT_L1D_CACHESHAPE	35
#define AT_L2_CACHESHAPE	36
#define AT_L3_CACHESHAPE	37

/* Note section contents.  Each entry in the note section begins with
   a header of a fixed form.  */

typedef struct
{
	Elf32_Word n_namesz;			/* Length of the note's name.  */
	Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
	Elf32_Word n_type;			/* Type of the note.  */
} Elf32_Nhdr;

typedef struct
{
	Elf64_Word n_namesz;			/* Length of the note's name.  */
	Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
	Elf64_Word n_type;			/* Type of the note.  */
} Elf64_Nhdr;

/* Known names of notes.  */

/* Solaris entries in the note section have this name.  */
#define ELF_NOTE_SOLARIS	"SUNW Solaris"

/* Note entries for GNU systems have this name.  */
#define ELF_NOTE_GNU		"GNU"


/* Defined types of notes for Solaris.  */

/* Value of descriptor (one word) is desired pagesize for the binary.  */
#define ELF_NOTE_PAGESIZE_HINT	1


/* Defined note types for GNU systems.  */

/* ABI information.  The descriptor consists of words:
   word 0: OS descriptor
   word 1: major version of the ABI
   word 2: minor version of the ABI
   word 3: subminor version of the ABI
*/
#define NT_GNU_ABI_TAG	1
#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */

/* Known OSes.  These values can appear in word 0 of an
   NT_GNU_ABI_TAG note section entry.  */
#define ELF_NOTE_OS_LINUX	0
#define ELF_NOTE_OS_GNU		1
#define ELF_NOTE_OS_SOLARIS2	2
#define ELF_NOTE_OS_FREEBSD	3

/* Synthetic hwcap information.  The descriptor begins with two words:
   word 0: number of entries
   word 1: bitmask of enabled entries
   Then follow variable-length entries, one byte followed by a
   '\0'-terminated hwcap name string.  The byte gives the bit
   number to test if enabled, (1U << bit) & bitmask.  */
#define NT_GNU_HWCAP	2

/* Build ID bits as generated by ld --build-id.
   The descriptor consists of any nonzero number of bytes.  */
#define NT_GNU_BUILD_ID	3

/* Version note generated by GNU gold containing a version string.  */
#define NT_GNU_GOLD_VERSION	4


/* Move records.  */
typedef struct
{
	Elf32_Xword m_value;		/* Symbol value.  */
	Elf32_Word m_info;		/* Size and index.  */
	Elf32_Word m_poffset;		/* Symbol offset.  */
	Elf32_Half m_repeat;		/* Repeat count.  */
	Elf32_Half m_stride;		/* Stride info.  */
} Elf32_Move;

typedef struct
{
	Elf64_Xword m_value;		/* Symbol value.  */
	Elf64_Xword m_info;		/* Size and index.  */
	Elf64_Xword m_poffset;	/* Symbol offset.  */
	Elf64_Half m_repeat;		/* Repeat count.  */
	Elf64_Half m_stride;		/* Stride info.  */
} Elf64_Move;

/* Macro to construct move records.  */
#define ELF32_M_SYM(info)	((info) >> 8)
#define ELF32_M_SIZE(info)	((unsigned char) (info))
#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))

#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)


/* Motorola 68k specific definitions.  */

/* Values for Elf32_Ehdr.e_flags.  */
#define EF_CPU32	0x00810000

/* m68k relocs.  */

#define R_68K_NONE	0		/* No reloc */
#define R_68K_32	1		/* Direct 32 bit  */
#define R_68K_16	2		/* Direct 16 bit  */
#define R_68K_8		3		/* Direct 8 bit  */
#define R_68K_PC32	4		/* PC relative 32 bit */
#define R_68K_PC16	5		/* PC relative 16 bit */
#define R_68K_PC8	6		/* PC relative 8 bit */
#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
#define R_68K_GOT32O	10		/* 32 bit GOT offset */
#define R_68K_GOT16O	11		/* 16 bit GOT offset */
#define R_68K_GOT8O	12		/* 8 bit GOT offset */
#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
#define R_68K_PLT32O	16		/* 32 bit PLT offset */
#define R_68K_PLT16O	17		/* 16 bit PLT offset */
#define R_68K_PLT8O	18		/* 8 bit PLT offset */
#define R_68K_COPY	19		/* Copy symbol at runtime */
#define R_68K_GLOB_DAT	20		/* Create GOT entry */
#define R_68K_JMP_SLOT	21		/* Create PLT entry */
#define R_68K_RELATIVE	22		/* Adjust by program base */
#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
					   static TLS block */
#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
					   static TLS block */
#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
					   static TLS block */
#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
/* Keep this the last entry.  */
#define R_68K_NUM	43

/* Intel 80386 specific definitions.  */

/* i386 relocs.  */

#define R_386_NONE	   0		/* No reloc */
#define R_386_32	   1		/* Direct 32 bit  */
#define R_386_PC32	   2		/* PC relative 32 bit */
#define R_386_GOT32	   3		/* 32 bit GOT entry */
#define R_386_PLT32	   4		/* 32 bit PLT address */
#define R_386_COPY	   5		/* Copy symbol at runtime */
#define R_386_GLOB_DAT	   6		/* Create GOT entry */
#define R_386_JMP_SLOT	   7		/* Create PLT entry */
#define R_386_RELATIVE	   8		/* Adjust by program base */
#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
#define R_386_32PLT	   11
#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
					   block offset */
#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
					   offset */
#define R_386_TLS_LE	   17		/* Offset relative to static TLS
					   block */
#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
					   general dynamic thread local data */
#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
					   local dynamic thread local data
					   in LE code */
#define R_386_16	   20
#define R_386_PC16	   21
#define R_386_8		   22
#define R_386_PC8	   23
#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
					   thread local data */
#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
#define R_386_TLS_GD_CALL  26		/* Relocation for call to
					   __tls_get_addr() */
#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
					   thread local data in LE code */
#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
					   __tls_get_addr() in LDM code */
#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
					   block offset */
#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
					   TLS block */
#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
/* 38? */
#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
					   descriptor for
					   relaxation.  */
#define R_386_TLS_DESC     41		/* TLS descriptor containing
					   pointer to code and to
					   argument, returning the TLS
					   offset for the symbol.  */
#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
#define R_386_GOT32X       43		/* 32 bit GOT entry, relaxable */
/* Keep this the last entry.  */
#define R_386_NUM	   44

/* SUN SPARC specific definitions.  */

/* Legal values for ST_TYPE subfield of st_info (symbol type).  */

#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */

/* Values for Elf64_Ehdr.e_flags.  */

#define EF_SPARCV9_MM		3
#define EF_SPARCV9_TSO		0
#define EF_SPARCV9_PSO		1
#define EF_SPARCV9_RMO		2
#define EF_SPARC_LEDATA		0x800000 /* little endian data */
#define EF_SPARC_EXT_MASK	0xFFFF00
#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */

/* SPARC relocs.  */

#define R_SPARC_NONE		0	/* No reloc */
#define R_SPARC_8		1	/* Direct 8 bit */
#define R_SPARC_16		2	/* Direct 16 bit */
#define R_SPARC_32		3	/* Direct 32 bit */
#define R_SPARC_DISP8		4	/* PC relative 8 bit */
#define R_SPARC_DISP16		5	/* PC relative 16 bit */
#define R_SPARC_DISP32		6	/* PC relative 32 bit */
#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
#define R_SPARC_HI22		9	/* High 22 bit */
#define R_SPARC_22		10	/* Direct 22 bit */
#define R_SPARC_13		11	/* Direct 13 bit */
#define R_SPARC_LO10		12	/* Truncated 10 bit */
#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
#define R_SPARC_COPY		19	/* Copy symbol at runtime */
#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
#define R_SPARC_RELATIVE	22	/* Adjust by program base */
#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */

/* Additional Sparc64 relocs.  */

#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
#define R_SPARC_10		30	/* Direct 10 bit */
#define R_SPARC_11		31	/* Direct 11 bit */
#define R_SPARC_64		32	/* Direct 64 bit */
#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
#define R_SPARC_PC_LM22		39	/* Low middle 22 bits of ... */
#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
#define R_SPARC_7		43	/* Direct 7 bit */
#define R_SPARC_5		44	/* Direct 5 bit */
#define R_SPARC_6		45	/* Direct 6 bit */
#define R_SPARC_DISP64		46	/* PC relative 64 bit */
#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
#define R_SPARC_HIX22		48	/* High 22 bit complemented */
#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
#define R_SPARC_REGISTER	53	/* Global register usage */
#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
#define R_SPARC_TLS_GD_HI22	56
#define R_SPARC_TLS_GD_LO10	57
#define R_SPARC_TLS_GD_ADD	58
#define R_SPARC_TLS_GD_CALL	59
#define R_SPARC_TLS_LDM_HI22	60
#define R_SPARC_TLS_LDM_LO10	61
#define R_SPARC_TLS_LDM_ADD	62
#define R_SPARC_TLS_LDM_CALL	63
#define R_SPARC_TLS_LDO_HIX22	64
#define R_SPARC_TLS_LDO_LOX10	65
#define R_SPARC_TLS_LDO_ADD	66
#define R_SPARC_TLS_IE_HI22	67
#define R_SPARC_TLS_IE_LO10	68
#define R_SPARC_TLS_IE_LD	69
#define R_SPARC_TLS_IE_LDX	70
#define R_SPARC_TLS_IE_ADD	71
#define R_SPARC_TLS_LE_HIX22	72
#define R_SPARC_TLS_LE_LOX10	73
#define R_SPARC_TLS_DTPMOD32	74
#define R_SPARC_TLS_DTPMOD64	75
#define R_SPARC_TLS_DTPOFF32	76
#define R_SPARC_TLS_DTPOFF64	77
#define R_SPARC_TLS_TPOFF32	78
#define R_SPARC_TLS_TPOFF64	79
#define R_SPARC_GOTDATA_HIX22	80
#define R_SPARC_GOTDATA_LOX10	81
#define R_SPARC_GOTDATA_OP_HIX22	82
#define R_SPARC_GOTDATA_OP_LOX10	83
#define R_SPARC_GOTDATA_OP	84
#define R_SPARC_H34		85
#define R_SPARC_SIZE32		86
#define R_SPARC_SIZE64		87
#define R_SPARC_WDISP10		88
#define R_SPARC_JMP_IREL	248
#define R_SPARC_IRELATIVE	249
#define R_SPARC_GNU_VTINHERIT	250
#define R_SPARC_GNU_VTENTRY	251
#define R_SPARC_REV32		252
/* Keep this the last entry.  */
#define R_SPARC_NUM		253

/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */

#define DT_SPARC_REGISTER 0x70000001
#define DT_SPARC_NUM	2

/* MIPS R3000 specific definitions.  */

/* Legal values for e_flags field of Elf32_Ehdr.  */

#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
#define EF_MIPS_PIC	    2		/* Contains PIC code */
#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
#define EF_MIPS_XGOT	    8
#define EF_MIPS_64BIT_WHIRL 16
#define EF_MIPS_ABI2	    32
#define EF_MIPS_ABI_ON32    64
#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */

/* Legal values for MIPS architecture level.  */

#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */

/* The following are non-official names and should not be used.  */

#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */

/* Special section indices.  */

#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */

/* Legal values for sh_type field of Elf32_Shdr.  */

#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
#define SHT_MIPS_MSYM	       0x70000001
#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
#define SHT_MIPS_PACKAGE       0x70000007
#define SHT_MIPS_PACKSYM       0x70000008
#define SHT_MIPS_RELD	       0x70000009
#define SHT_MIPS_IFACE         0x7000000b
#define SHT_MIPS_CONTENT       0x7000000c
#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
#define SHT_MIPS_SHDR	       0x70000010
#define SHT_MIPS_FDESC	       0x70000011
#define SHT_MIPS_EXTSYM	       0x70000012
#define SHT_MIPS_DENSE	       0x70000013
#define SHT_MIPS_PDESC	       0x70000014
#define SHT_MIPS_LOCSYM	       0x70000015
#define SHT_MIPS_AUXSYM	       0x70000016
#define SHT_MIPS_OPTSYM	       0x70000017
#define SHT_MIPS_LOCSTR	       0x70000018
#define SHT_MIPS_LINE	       0x70000019
#define SHT_MIPS_RFDESC	       0x7000001a
#define SHT_MIPS_DELTASYM      0x7000001b
#define SHT_MIPS_DELTAINST     0x7000001c
#define SHT_MIPS_DELTACLASS    0x7000001d
#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
#define SHT_MIPS_DELTADECL     0x7000001f
#define SHT_MIPS_SYMBOL_LIB    0x70000020
#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
#define SHT_MIPS_TRANSLATE     0x70000022
#define SHT_MIPS_PIXIE	       0x70000023
#define SHT_MIPS_XLATE	       0x70000024
#define SHT_MIPS_XLATE_DEBUG   0x70000025
#define SHT_MIPS_WHIRL	       0x70000026
#define SHT_MIPS_EH_REGION     0x70000027
#define SHT_MIPS_XLATE_OLD     0x70000028
#define SHT_MIPS_PDR_EXCEPTION 0x70000029

/* Legal values for sh_flags field of Elf32_Shdr.  */

#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
#define SHF_MIPS_MERGE	 0x20000000
#define SHF_MIPS_ADDR	 0x40000000
#define SHF_MIPS_STRINGS 0x80000000
#define SHF_MIPS_NOSTRIP 0x08000000
#define SHF_MIPS_LOCAL	 0x04000000
#define SHF_MIPS_NAMES	 0x02000000
#define SHF_MIPS_NODUPE	 0x01000000


/* Symbol tables.  */

/* MIPS specific values for `st_other'.  */
#define STO_MIPS_DEFAULT		0x0
#define STO_MIPS_INTERNAL		0x1
#define STO_MIPS_HIDDEN			0x2
#define STO_MIPS_PROTECTED		0x3
#define STO_MIPS_PLT			0x8
#define STO_MIPS_SC_ALIGN_UNUSED	0xff

/* MIPS specific values for `st_info'.  */
#define STB_MIPS_SPLIT_COMMON		13

/* Entries found in sections of type SHT_MIPS_GPTAB.  */

typedef union
{
	struct
	{
		Elf32_Word gt_current_g_value;	/* -G value used for compilation */
		Elf32_Word gt_unused;		/* Not used */
	} gt_header;			/* First entry in section */
	struct
	{
		Elf32_Word gt_g_value;		/* If this value were used for -G */
		Elf32_Word gt_bytes;		/* This many bytes would be used */
	} gt_entry;				/* Subsequent entries in section */
} Elf32_gptab;

/* Entry found in sections of type SHT_MIPS_REGINFO.  */

typedef struct
{
	Elf32_Word	ri_gprmask;		/* General registers used */
	Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
	Elf32_Sword	ri_gp_value;		/* $gp register value */
} Elf32_RegInfo;

/* Entries found in sections of type SHT_MIPS_OPTIONS.  */

typedef struct
{
	unsigned char kind;		/* Determines interpretation of the
				   variable part of descriptor.  */
	unsigned char size;		/* Size of descriptor, including header.  */
	Elf32_Section section;	/* Section header index of section affected,
				   0 for global options.  */
	Elf32_Word info;		/* Kind-specific information.  */
} Elf_Options;

/* Values for `kind' field in Elf_Options.  */

#define ODK_NULL	0	/* Undefined.  */
#define ODK_REGINFO	1	/* Register usage information.  */
#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
#define ODK_PAD		3	/* Section padding options.  */
#define ODK_HWPATCH	4	/* Hardware workarounds performed */
#define ODK_FILL	5	/* record the fill value used by the linker. */
#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */

/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */

#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
#define OEX_PRECISEFP	OEX_FPDBUG
#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */

#define OEX_FPU_INVAL	0x10
#define OEX_FPU_DIV0	0x08
#define OEX_FPU_OFLO	0x04
#define OEX_FPU_UFLO	0x02
#define OEX_FPU_INEX	0x01

/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */

#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */

#define OPAD_PREFIX	0x1
#define OPAD_POSTFIX	0x2
#define OPAD_SYMBOL	0x4

/* Entry found in `.options' section.  */

typedef struct
{
	Elf32_Word hwp_flags1;	/* Extra flags.  */
	Elf32_Word hwp_flags2;	/* Extra flags.  */
} Elf_Options_Hw;

/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */

#define OHWA0_R4KEOP_CHECKED	0x00000001
#define OHWA1_R4KEOP_CLEAN	0x00000002

/* MIPS relocs.  */

#define R_MIPS_NONE		0	/* No reloc */
#define R_MIPS_16		1	/* Direct 16 bit */
#define R_MIPS_32		2	/* Direct 32 bit */
#define R_MIPS_REL32		3	/* PC relative 32 bit */
#define R_MIPS_26		4	/* Direct 26 bit shifted */
#define R_MIPS_HI16		5	/* High 16 bit */
#define R_MIPS_LO16		6	/* Low 16 bit */
#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
#define R_MIPS_PC16		10	/* PC relative 16 bit */
#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
#define R_MIPS_GPREL32		12	/* GP relative 32 bit */

#define R_MIPS_SHIFT5		16
#define R_MIPS_SHIFT6		17
#define R_MIPS_64		18
#define R_MIPS_GOT_DISP		19
#define R_MIPS_GOT_PAGE		20
#define R_MIPS_GOT_OFST		21
#define R_MIPS_GOT_HI16		22
#define R_MIPS_GOT_LO16		23
#define R_MIPS_SUB		24
#define R_MIPS_INSERT_A		25
#define R_MIPS_INSERT_B		26
#define R_MIPS_DELETE		27
#define R_MIPS_HIGHER		28
#define R_MIPS_HIGHEST		29
#define R_MIPS_CALL_HI16	30
#define R_MIPS_CALL_LO16	31
#define R_MIPS_SCN_DISP		32
#define R_MIPS_REL16		33
#define R_MIPS_ADD_IMMEDIATE	34
#define R_MIPS_PJUMP		35
#define R_MIPS_RELGOT		36
#define R_MIPS_JALR		37
#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
#define R_MIPS_GLOB_DAT		51
#define R_MIPS_COPY		126
#define R_MIPS_JUMP_SLOT        127
/* Keep this the last entry.  */
#define R_MIPS_NUM		128

/* Legal values for p_type field of Elf32_Phdr.  */

#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
#define PT_MIPS_OPTIONS 0x70000002

/* Special program header types.  */

#define PF_MIPS_LOCAL	0x10000000

/* Legal values for d_tag field of Elf32_Dyn.  */

#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
#define DT_MIPS_MSYM	     0x70000007
#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
						DT_MIPS_DELTA_CLASS.  */
#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
						DT_MIPS_DELTA_INSTANCE.  */
#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
					     DT_MIPS_DELTA_RELOC.  */
#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
					   relocations refer to.  */
#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
					   DT_MIPS_DELTA_SYM.  */
#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
					     class declaration.  */
#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
						DT_MIPS_DELTA_CLASSSYM.  */
#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
#define DT_MIPS_PIXIE_INIT   0x70000023
#define DT_MIPS_SYMBOL_LIB   0x70000024
#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
#define DT_MIPS_LOCAL_GOTIDX 0x70000026
#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
						    function stored in GOT.  */
#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
					   by rld on dlopen() calls.  */
#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
/* The address of .got.plt in an executable using the new non-PIC ABI.  */
#define DT_MIPS_PLTGOT	     0x70000032
/* The base of the PLT in an executable using the new non-PIC ABI if that
   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
   value.  */
#define DT_MIPS_RWPLT        0x70000034
#define DT_MIPS_NUM	     0x35

/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */

#define RHF_NONE		   0		/* No flags */
#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
#define RHF_NO_MOVE		   (1 << 3)
#define RHF_SGI_ONLY		   (1 << 4)
#define RHF_GUARANTEE_INIT	   (1 << 5)
#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
#define RHF_GUARANTEE_START_INIT   (1 << 7)
#define RHF_PIXIE		   (1 << 8)
#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
#define RHF_REQUICKSTART	   (1 << 10)
#define RHF_REQUICKSTARTED	   (1 << 11)
#define RHF_CORD		   (1 << 12)
#define RHF_NO_UNRES_UNDEF	   (1 << 13)
#define RHF_RLD_ORDER_SAFE	   (1 << 14)

/* Entries found in sections of type SHT_MIPS_LIBLIST.  */

typedef struct
{
	Elf32_Word l_name;		/* Name (string table index) */
	Elf32_Word l_time_stamp;	/* Timestamp */
	Elf32_Word l_checksum;	/* Checksum */
	Elf32_Word l_version;		/* Interface version */
	Elf32_Word l_flags;		/* Flags */
} Elf32_Lib;

typedef struct
{
	Elf64_Word l_name;		/* Name (string table index) */
	Elf64_Word l_time_stamp;	/* Timestamp */
	Elf64_Word l_checksum;	/* Checksum */
	Elf64_Word l_version;		/* Interface version */
	Elf64_Word l_flags;		/* Flags */
} Elf64_Lib;


/* Legal values for l_flags.  */

#define LL_NONE		  0
#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
#define LL_REQUIRE_MINOR  (1 << 2)
#define LL_EXPORTS	  (1 << 3)
#define LL_DELAY_LOAD	  (1 << 4)
#define LL_DELTA	  (1 << 5)

/* Entries found in sections of type SHT_MIPS_CONFLICT.  */

typedef Elf32_Addr Elf32_Conflict;


/* HPPA specific definitions.  */

/* Legal values for e_flags field of Elf32_Ehdr.  */

#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
					      prediction.  */
#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */

/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */

#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */

/* Additional section indices.  */

#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tentatively declared
					      symbols in ANSI C.  */
#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */

/* Legal values for sh_type field of Elf32_Shdr.  */

#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */

/* Legal values for sh_flags field of Elf32_Shdr.  */

#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */

/* Legal values for ST_TYPE subfield of st_info (symbol type).  */

#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */

#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
#define STT_HP_STUB		(STT_LOOS + 0x2)

/* HPPA relocs.  */

#define R_PARISC_NONE		0	/* No reloc.  */
#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
#define R_PARISC_LORESERVE	128
#define R_PARISC_COPY		128	/* Copy relocation.  */
#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
#define R_PARISC_GNU_VTENTRY	232
#define R_PARISC_GNU_VTINHERIT	233
#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
#define R_PARISC_HIRESERVE	255

/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */

#define PT_HP_TLS		(PT_LOOS + 0x0)
#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
#define PT_HP_STACK		(PT_LOOS + 0x14)

#define PT_PARISC_ARCHEXT	0x70000000
#define PT_PARISC_UNWIND	0x70000001

/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */

#define PF_PARISC_SBP		0x08000000

#define PF_HP_PAGE_SIZE		0x00100000
#define PF_HP_FAR_SHARED	0x00200000
#define PF_HP_NEAR_SHARED	0x00400000
#define PF_HP_CODE		0x01000000
#define PF_HP_MODIFY		0x02000000
#define PF_HP_LAZYSWAP		0x04000000
#define PF_HP_SBP		0x08000000


/* Alpha specific definitions.  */

/* Legal values for e_flags field of Elf64_Ehdr.  */

#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */

/* Legal values for sh_type field of Elf64_Shdr.  */

/* These two are primarily concerned with ECOFF debugging info.  */
#define SHT_ALPHA_DEBUG		0x70000001
#define SHT_ALPHA_REGINFO	0x70000002

/* Legal values for sh_flags field of Elf64_Shdr.  */

#define SHF_ALPHA_GPREL		0x10000000

/* Legal values for st_other field of Elf64_Sym.  */
#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */

/* Alpha relocs.  */

#define R_ALPHA_NONE		0	/* No reloc */
#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
#define R_ALPHA_TLS_GD_HI	28
#define R_ALPHA_TLSGD		29
#define R_ALPHA_TLS_LDM		30
#define R_ALPHA_DTPMOD64	31
#define R_ALPHA_GOTDTPREL	32
#define R_ALPHA_DTPREL64	33
#define R_ALPHA_DTPRELHI	34
#define R_ALPHA_DTPRELLO	35
#define R_ALPHA_DTPREL16	36
#define R_ALPHA_GOTTPREL	37
#define R_ALPHA_TPREL64		38
#define R_ALPHA_TPRELHI		39
#define R_ALPHA_TPRELLO		40
#define R_ALPHA_TPREL16		41
/* Keep this the last entry.  */
#define R_ALPHA_NUM		46

/* Magic values of the LITUSE relocation addend.  */
#define LITUSE_ALPHA_ADDR	0
#define LITUSE_ALPHA_BASE	1
#define LITUSE_ALPHA_BYTOFF	2
#define LITUSE_ALPHA_JSR	3
#define LITUSE_ALPHA_TLS_GD	4
#define LITUSE_ALPHA_TLS_LDM	5

/* Legal values for d_tag of Elf64_Dyn.  */
#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
#define DT_ALPHA_NUM		1

/* PowerPC specific declarations */

/* Values for Elf32/64_Ehdr.e_flags.  */
#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */

/* Cygnus local bits below */
#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
						   flag */

/* PowerPC relocations defined by the ABIs */
#define R_PPC_NONE		0
#define R_PPC_ADDR32		1	/* 32bit absolute address */
#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
#define R_PPC_ADDR16		3	/* 16bit absolute address */
#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
#define R_PPC_ADDR14_BRTAKEN	8
#define R_PPC_ADDR14_BRNTAKEN	9
#define R_PPC_REL24		10	/* PC relative 26 bit */
#define R_PPC_REL14		11	/* PC relative 16 bit */
#define R_PPC_REL14_BRTAKEN	12
#define R_PPC_REL14_BRNTAKEN	13
#define R_PPC_GOT16		14
#define R_PPC_GOT16_LO		15
#define R_PPC_GOT16_HI		16
#define R_PPC_GOT16_HA		17
#define R_PPC_PLTREL24		18
#define R_PPC_COPY		19
#define R_PPC_GLOB_DAT		20
#define R_PPC_JMP_SLOT		21
#define R_PPC_RELATIVE		22
#define R_PPC_LOCAL24PC		23
#define R_PPC_UADDR32		24
#define R_PPC_UADDR16		25
#define R_PPC_REL32		26
#define R_PPC_PLT32		27
#define R_PPC_PLTREL32		28
#define R_PPC_PLT16_LO		29
#define R_PPC_PLT16_HI		30
#define R_PPC_PLT16_HA		31
#define R_PPC_SDAREL16		32
#define R_PPC_SECTOFF		33
#define R_PPC_SECTOFF_LO	34
#define R_PPC_SECTOFF_HI	35
#define R_PPC_SECTOFF_HA	36

/* PowerPC relocations defined for the TLS access ABI.  */
#define R_PPC_TLS		67 /* none	(sym+add)@tls */
#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */

/* The remaining relocs are from the Embedded ELF ABI, and are not
   in the SVR4 ELF ABI.  */
#define R_PPC_EMB_NADDR32	101
#define R_PPC_EMB_NADDR16	102
#define R_PPC_EMB_NADDR16_LO	103
#define R_PPC_EMB_NADDR16_HI	104
#define R_PPC_EMB_NADDR16_HA	105
#define R_PPC_EMB_SDAI16	106
#define R_PPC_EMB_SDA2I16	107
#define R_PPC_EMB_SDA2REL	108
#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
#define R_PPC_EMB_MRKREF	110
#define R_PPC_EMB_RELSEC16	111
#define R_PPC_EMB_RELST_LO	112
#define R_PPC_EMB_RELST_HI	113
#define R_PPC_EMB_RELST_HA	114
#define R_PPC_EMB_BIT_FLD	115
#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */

/* Diab tool relocations.  */
#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */

/* GNU extension to support local ifunc.  */
#define R_PPC_IRELATIVE		248

/* GNU relocs used in PIC code sequences.  */
#define R_PPC_REL16		249	/* half16   (sym+add-.) */
#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */

/* This is a phony reloc to handle any old fashioned TOC16 references
   that may still be in object files.  */
#define R_PPC_TOC16		255

/* PowerPC specific values for the Dyn d_tag field.  */
#define DT_PPC_GOT		(DT_LOPROC + 0)
#define DT_PPC_NUM		1

/* PowerPC64 relocations defined by the ABIs */
#define R_PPC64_NONE		R_PPC_NONE
#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
#define R_PPC64_GOT16		R_PPC_GOT16
#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA

#define R_PPC64_COPY		R_PPC_COPY
#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
#define R_PPC64_RELATIVE	R_PPC_RELATIVE

#define R_PPC64_UADDR32		R_PPC_UADDR32
#define R_PPC64_UADDR16		R_PPC_UADDR16
#define R_PPC64_REL32		R_PPC_REL32
#define R_PPC64_PLT32		R_PPC_PLT32
#define R_PPC64_PLTREL32	R_PPC_PLTREL32
#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA

#define R_PPC64_SECTOFF		R_PPC_SECTOFF
#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
#define R_PPC64_PLT64		45 /* doubleword64 L + A */
#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
#define R_PPC64_TOC		51 /* doubleword64 .TOC */
#define R_PPC64_PLTGOT16	52 /* half16* M + A */
#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */

#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */

/* PowerPC64 relocations defined for the TLS access ABI.  */
#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */

/* GNU extension to support local ifunc.  */
#define R_PPC64_JMP_IREL	247
#define R_PPC64_IRELATIVE	248
#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */

/* PowerPC64 specific values for the Dyn d_tag field.  */
#define DT_PPC64_GLINK  (DT_LOPROC + 0)
#define DT_PPC64_OPD	(DT_LOPROC + 1)
#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
#define DT_PPC64_NUM    3


/* ARM specific declarations */

/* Processor specific flags for the ELF header e_flags field.  */
#define EF_ARM_RELEXEC		0x01
#define EF_ARM_HASENTRY		0x02
#define EF_ARM_INTERWORK	0x04
#define EF_ARM_APCS_26		0x08
#define EF_ARM_APCS_FLOAT	0x10
#define EF_ARM_PIC		0x20
#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
#define EF_ARM_NEW_ABI		0x80
#define EF_ARM_OLD_ABI		0x100
#define EF_ARM_SOFT_FLOAT	0x200
#define EF_ARM_VFP_FLOAT	0x400
#define EF_ARM_MAVERICK_FLOAT	0x800

#define EF_ARM_ABI_FLOAT_SOFT	0x200   /* NB conflicts with EF_ARM_SOFT_FLOAT */
#define EF_ARM_ABI_FLOAT_HARD	0x400   /* NB conflicts with EF_ARM_VFP_FLOAT */


/* Other constants defined in the ARM ELF spec. version B-01.  */
/* NB. These conflict with values defined above.  */
#define EF_ARM_SYMSARESORTED	0x04
#define EF_ARM_DYNSYMSUSESEGIDX	0x08
#define EF_ARM_MAPSYMSFIRST	0x10
#define EF_ARM_EABIMASK		0XFF000000

/* Constants defined in AAELF.  */
#define EF_ARM_BE8	    0x00800000
#define EF_ARM_LE8	    0x00400000

#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
#define EF_ARM_EABI_UNKNOWN	0x00000000
#define EF_ARM_EABI_VER1	0x01000000
#define EF_ARM_EABI_VER2	0x02000000
#define EF_ARM_EABI_VER3	0x03000000
#define EF_ARM_EABI_VER4	0x04000000
#define EF_ARM_EABI_VER5	0x05000000

/* Additional symbol types for Thumb.  */
#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */

/* ARM-specific values for sh_flags */
#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
					      in the input to a link step.  */

/* ARM-specific program header flags */
#define PF_ARM_SB		0x10000000 /* Segment contains the location
					      addressed by the static base. */
#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */

/* Processor specific values for the Phdr p_type field.  */
#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */

/* Processor specific values for the Shdr sh_type field.  */
#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */


/* AArch64 relocs.  */

#define R_AARCH64_NONE            0	/* No relocation.  */
#define R_AARCH64_ABS64         257	/* Direct 64 bit. */
#define R_AARCH64_ABS32         258	/* Direct 32 bit.  */
#define R_AARCH64_ABS16         259	/* Direct 16-bit.  */
#define R_AARCH64_PREL64        260	/* PC-relative 64-bit.  */
#define R_AARCH64_PREL32        261	/* PC-relative 32-bit.  */
#define R_AARCH64_PREL16        262	/* PC-relative 16-bit.  */
#define R_AARCH64_MOVW_UABS_G0  263	/* Dir. MOVZ imm. from bits 15:0.  */
#define R_AARCH64_MOVW_UABS_G0_NC 264	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_UABS_G1  265	/* Dir. MOVZ imm. from bits 31:16.  */
#define R_AARCH64_MOVW_UABS_G1_NC 266	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_UABS_G2  267	/* Dir. MOVZ imm. from bits 47:32.  */
#define R_AARCH64_MOVW_UABS_G2_NC 268	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_UABS_G3  269	/* Dir. MOV{K,Z} imm. from 63:48.  */
#define R_AARCH64_MOVW_SABS_G0  270	/* Dir. MOV{N,Z} imm. from 15:0.  */
#define R_AARCH64_MOVW_SABS_G1  271	/* Dir. MOV{N,Z} imm. from 31:16.  */
#define R_AARCH64_MOVW_SABS_G2  272	/* Dir. MOV{N,Z} imm. from 47:32.  */
#define R_AARCH64_LD_PREL_LO19  273	/* PC-rel. LD imm. from bits 20:2.  */
#define R_AARCH64_ADR_PREL_LO21 274	/* PC-rel. ADR imm. from bits 20:0.  */
#define R_AARCH64_ADR_PREL_PG_HI21 275	/* Page-rel. ADRP imm. from 32:12.  */
#define R_AARCH64_ADR_PREL_PG_HI21_NC 276	/* Likewise; no overflow check.  */
#define R_AARCH64_ADD_ABS_LO12_NC 277	/* Dir. ADD imm. from bits 11:0.  */
#define R_AARCH64_LDST8_ABS_LO12_NC 278	/* Likewise for LD/ST; no check. */
#define R_AARCH64_TSTBR14       279	/* PC-rel. TBZ/TBNZ imm. from 15:2.  */
#define R_AARCH64_CONDBR19      280	/* PC-rel. cond. br. imm. from 20:2. */
#define R_AARCH64_JUMP26        282	/* PC-rel. B imm. from bits 27:2.  */
#define R_AARCH64_CALL26        283	/* Likewise for CALL.  */
#define R_AARCH64_LDST16_ABS_LO12_NC 284	/* Dir. ADD imm. from bits 11:1.  */
#define R_AARCH64_LDST32_ABS_LO12_NC 285	/* Likewise for bits 11:2.  */
#define R_AARCH64_LDST64_ABS_LO12_NC 286	/* Likewise for bits 11:3.  */
#define R_AARCH64_MOVW_PREL_G0  287	/* PC-rel. MOV{N,Z} imm. from 15:0.  */
#define R_AARCH64_MOVW_PREL_G0_NC 288	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_PREL_G1  289	/* PC-rel. MOV{N,Z} imm. from 31:16. */
#define R_AARCH64_MOVW_PREL_G1_NC 290	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_PREL_G2  291	/* PC-rel. MOV{N,Z} imm. from 47:32. */
#define R_AARCH64_MOVW_PREL_G2_NC 292	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_PREL_G3  293	/* PC-rel. MOV{N,Z} imm. from 63:48. */
#define R_AARCH64_LDST128_ABS_LO12_NC 299	/* Dir. ADD imm. from bits 11:4.  */
#define R_AARCH64_MOVW_GOTOFF_G0 300	/* GOT-rel. off. MOV{N,Z} imm. 15:0. */
#define R_AARCH64_MOVW_GOTOFF_G0_NC 301	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_GOTOFF_G1 302	/* GOT-rel. o. MOV{N,Z} imm. 31:16.  */
#define R_AARCH64_MOVW_GOTOFF_G1_NC 303	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_GOTOFF_G2 304	/* GOT-rel. o. MOV{N,Z} imm. 47:32.  */
#define R_AARCH64_MOVW_GOTOFF_G2_NC 305	/* Likewise for MOVK; no check.  */
#define R_AARCH64_MOVW_GOTOFF_G3 306	/* GOT-rel. o. MOV{N,Z} imm. 63:48.  */
#define R_AARCH64_GOTREL64      307	/* GOT-relative 64-bit.  */
#define R_AARCH64_GOTREL32      308	/* GOT-relative 32-bit.  */
#define R_AARCH64_GOT_LD_PREL19 309	/* PC-rel. GOT off. load imm. 20:2.  */
#define R_AARCH64_LD64_GOTOFF_LO15 310	/* GOT-rel. off. LD/ST imm. 14:3.  */
#define R_AARCH64_ADR_GOT_PAGE  311	/* P-page-rel. GOT off. ADRP 32:12.  */
#define R_AARCH64_LD64_GOT_LO12_NC 312	/* Dir. GOT off. LD/ST imm. 11:3.  */
#define R_AARCH64_LD64_GOTPAGE_LO15 313	/* GOT-page-rel. GOT off. LD/ST 14:3 */
#define R_AARCH64_TLSGD_ADR_PREL21 512	/* PC-relative ADR imm. 20:0.  */
#define R_AARCH64_TLSGD_ADR_PAGE21 513	/* page-rel. ADRP imm. 32:12.  */
#define R_AARCH64_TLSGD_ADD_LO12_NC 514	/* direct ADD imm. from 11:0.  */
#define R_AARCH64_TLSGD_MOVW_G1 515	/* GOT-rel. MOV{N,Z} 31:16.  */
#define R_AARCH64_TLSGD_MOVW_G0_NC 516	/* GOT-rel. MOVK imm. 15:0.  */
#define R_AARCH64_TLSLD_ADR_PREL21 517	/* Like 512; local dynamic model.  */
#define R_AARCH64_TLSLD_ADR_PAGE21 518	/* Like 513; local dynamic model.  */
#define R_AARCH64_TLSLD_ADD_LO12_NC 519	/* Like 514; local dynamic model.  */
#define R_AARCH64_TLSLD_MOVW_G1 520	/* Like 515; local dynamic model.  */
#define R_AARCH64_TLSLD_MOVW_G0_NC 521	/* Like 516; local dynamic model.  */
#define R_AARCH64_TLSLD_LD_PREL19 522	/* TLS PC-rel. load imm. 20:2.  */
#define R_AARCH64_TLSLD_MOVW_DTPREL_G2 523	/* TLS DTP-rel. MOV{N,Z} 47:32.  */
#define R_AARCH64_TLSLD_MOVW_DTPREL_G1 524	/* TLS DTP-rel. MOV{N,Z} 31:16.  */
#define R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC 525	/* Likewise; MOVK; no check.  */
#define R_AARCH64_TLSLD_MOVW_DTPREL_G0 526	/* TLS DTP-rel. MOV{N,Z} 15:0.  */
#define R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC 527	/* Likewise; MOVK; no check.  */
#define R_AARCH64_TLSLD_ADD_DTPREL_HI12 528	/* DTP-rel. ADD imm. from 23:12. */
#define R_AARCH64_TLSLD_ADD_DTPREL_LO12 529	/* DTP-rel. ADD imm. from 11:0.  */
#define R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC 530	/* Likewise; no ovfl. check.  */
#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12 531	/* DTP-rel. LD/ST imm. 11:0.  */
#define R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC 532	/* Likewise; no check.  */
#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12 533	/* DTP-rel. LD/ST imm. 11:1.  */
#define R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC 534	/* Likewise; no check.  */
#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12 535	/* DTP-rel. LD/ST imm. 11:2.  */
#define R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC 536	/* Likewise; no check.  */
#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12 537	/* DTP-rel. LD/ST imm. 11:3.  */
#define R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC 538	/* Likewise; no check.  */
#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 539	/* GOT-rel. MOV{N,Z} 31:16.  */
#define R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC 540	/* GOT-rel. MOVK 15:0.  */
#define R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 541	/* Page-rel. ADRP 32:12.  */
#define R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC 542	/* Direct LD off. 11:3.  */
#define R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 543	/* PC-rel. load imm. 20:2.  */
#define R_AARCH64_TLSLE_MOVW_TPREL_G2 544	/* TLS TP-rel. MOV{N,Z} 47:32.  */
#define R_AARCH64_TLSLE_MOVW_TPREL_G1 545	/* TLS TP-rel. MOV{N,Z} 31:16.  */
#define R_AARCH64_TLSLE_MOVW_TPREL_G1_NC 546	/* Likewise; MOVK; no check.  */
#define R_AARCH64_TLSLE_MOVW_TPREL_G0 547	/* TLS TP-rel. MOV{N,Z} 15:0.  */
#define R_AARCH64_TLSLE_MOVW_TPREL_G0_NC 548	/* Likewise; MOVK; no check.  */
#define R_AARCH64_TLSLE_ADD_TPREL_HI12 549	/* TP-rel. ADD imm. 23:12.  */
#define R_AARCH64_TLSLE_ADD_TPREL_LO12 550	/* TP-rel. ADD imm. 11:0.  */
#define R_AARCH64_TLSLE_ADD_TPREL_LO12_NC 551	/* Likewise; no ovfl. check.  */
#define R_AARCH64_TLSLE_LDST8_TPREL_LO12 552	/* TP-rel. LD/ST off. 11:0.  */
#define R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC 553	/* Likewise; no ovfl. check. */
#define R_AARCH64_TLSLE_LDST16_TPREL_LO12 554	/* TP-rel. LD/ST off. 11:1.  */
#define R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC 555	/* Likewise; no check.  */
#define R_AARCH64_TLSLE_LDST32_TPREL_LO12 556	/* TP-rel. LD/ST off. 11:2.  */
#define R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC 557	/* Likewise; no check.  */
#define R_AARCH64_TLSLE_LDST64_TPREL_LO12 558	/* TP-rel. LD/ST off. 11:3.  */
#define R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC 559	/* Likewise; no check.  */
#define R_AARCH64_TLSDESC_LD_PREL19 560	/* PC-rel. load immediate 20:2.  */
#define R_AARCH64_TLSDESC_ADR_PREL21 561	/* PC-rel. ADR immediate 20:0.  */
#define R_AARCH64_TLSDESC_ADR_PAGE21 562	/* Page-rel. ADRP imm. 32:12.  */
#define R_AARCH64_TLSDESC_LD64_LO12 563	/* Direct LD off. from 11:3.  */
#define R_AARCH64_TLSDESC_ADD_LO12 564	/* Direct ADD imm. from 11:0.  */
#define R_AARCH64_TLSDESC_OFF_G1 565	/* GOT-rel. MOV{N,Z} imm. 31:16.  */
#define R_AARCH64_TLSDESC_OFF_G0_NC 566	/* GOT-rel. MOVK imm. 15:0; no ck.  */
#define R_AARCH64_TLSDESC_LDR   567	/* Relax LDR.  */
#define R_AARCH64_TLSDESC_ADD   568	/* Relax ADD.  */
#define R_AARCH64_TLSDESC_CALL  569	/* Relax BLR.  */
#define R_AARCH64_TLSLE_LDST128_TPREL_LO12 570	/* TP-rel. LD/ST off. 11:4.  */
#define R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC 571	/* Likewise; no check.  */
#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12 572	/* DTP-rel. LD/ST imm. 11:4. */
#define R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC 573	/* Likewise; no check.  */
#define R_AARCH64_COPY         1024	/* Copy symbol at runtime.  */
#define R_AARCH64_GLOB_DAT     1025	/* Create GOT entry.  */
#define R_AARCH64_JUMP_SLOT    1026	/* Create PLT entry.  */
#define R_AARCH64_RELATIVE     1027	/* Adjust by program base.  */
#define R_AARCH64_TLS_DTPMOD64 1028	/* Module number, 64 bit.  */
#define R_AARCH64_TLS_DTPREL64 1029	/* Module-relative offset, 64 bit.  */
#define R_AARCH64_TLS_TPREL64  1030	/* TP-relative offset, 64 bit.  */
#define R_AARCH64_TLSDESC      1031	/* TLS Descriptor.  */
#define R_AARCH64_IRELATIVE    1032	/* STT_GNU_IFUNC relocation.  */
/* Keep this the last entry.  */
#define R_AARCH64_NUM          1033

/* ARM relocs.  */

#define R_ARM_NONE		0	/* No reloc */
#define R_ARM_PC24		1	/* PC relative 26 bit branch */
#define R_ARM_ABS32		2	/* Direct 32 bit  */
#define R_ARM_REL32		3	/* PC relative 32 bit */
#define R_ARM_PC13		4
#define R_ARM_ABS16		5	/* Direct 16 bit */
#define R_ARM_ABS12		6	/* Direct 12 bit */
#define R_ARM_THM_ABS5		7
#define R_ARM_ABS8		8	/* Direct 8 bit */
#define R_ARM_SBREL32		9
#define R_ARM_THM_PC22		10
#define R_ARM_THM_PC8		11
#define R_ARM_AMP_VCALL9	12
#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
#define R_ARM_THM_SWI8		14
#define R_ARM_XPC25		15
#define R_ARM_THM_XPC22		16
#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
#define R_ARM_COPY		20	/* Copy symbol at runtime */
#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
#define R_ARM_RELATIVE		23	/* Adjust by program base */
#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
#define R_ARM_GOT32		26	/* 32 bit GOT entry */
#define R_ARM_PLT32		27	/* 32 bit PLT address */
#define R_ARM_CALL		28
#define R_ARM_JUMP24		29
#define R_ARM_THM_JUMP24	30
#define R_ARM_ALU_PCREL_7_0	32
#define R_ARM_ALU_PCREL_15_8	33
#define R_ARM_ALU_PCREL_23_15	34
#define R_ARM_LDR_SBREL_11_0	35
#define R_ARM_ALU_SBREL_19_12	36
#define R_ARM_ALU_SBREL_27_20	37
#define R_ARM_V4BX		40
#define R_ARM_PREL31		42
#define R_ARM_MOVW_ABS_NC	43
#define R_ARM_MOVT_ABS		 44
#define R_ARM_THM_MOVW_ABS_NC	47
#define R_ARM_THM_MOVT_ABS	48
#define R_ARM_TLS_GOTDESC	90
#define R_ARM_TLS_CALL		91
#define R_ARM_TLS_DESCSEQ	92
#define R_ARM_THM_TLS_CALL	93
#define R_ARM_GNU_VTENTRY	100
#define R_ARM_GNU_VTINHERIT	101
#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
#define R_ARM_THM_PC9		103	/* thumb conditional branch */
#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
					   thread local data */
#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
					   thread local data */
#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
					   block */
#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
					   static TLS block offset */
#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
					   TLS block */
#define	R_ARM_THM_TLS_DESCSEQ	129
#define R_ARM_IRELATIVE		160
#define R_ARM_RXPC25		249
#define R_ARM_RSBREL32		250
#define R_ARM_THM_RPC22		251
#define R_ARM_RREL32		252
#define R_ARM_RABS22		253
#define R_ARM_RPC24		254
#define R_ARM_RBASE		255
/* Keep this the last entry.  */
#define R_ARM_NUM		256

/* TMS320C67xx specific declarations */

/* XXX: no ELF standard yet*/

/* TMS320C67xx relocs. */
#define R_C60_32       1
#define R_C60_GOT32     3               /* 32 bit GOT entry */
#define R_C60_PLT32     4               /* 32 bit PLT address */
#define R_C60_COPY      5               /* Copy symbol at runtime */
#define R_C60_GLOB_DAT  6               /* Create GOT entry */
#define R_C60_JMP_SLOT  7               /* Create PLT entry */
#define R_C60_RELATIVE  8               /* Adjust by program base */
#define R_C60_GOTOFF    9               /* 32 bit offset to GOT */
#define R_C60_GOTPC     10              /* 32 bit PC relative offset to GOT */

#define R_C60LO16      0x54       /* low 16 bit MVKL embedded */
#define R_C60HI16      0x55       /* high 16 bit MVKH embedded */
/* Keep this the last entry.  */
#define R_C60_NUM      0x56

/* IA-64 specific declarations.  */

/* Processor specific flags for the Ehdr e_flags field.  */
#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */

/* Processor specific values for the Phdr p_type field.  */
#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)

/* Processor specific flags for the Phdr p_flags field.  */
#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */

/* Processor specific values for the Shdr sh_type field.  */
#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */

/* Processor specific flags for the Shdr sh_flags field.  */
#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */

/* Processor specific values for the Dyn d_tag field.  */
#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
#define DT_IA_64_NUM		1

/* IA-64 relocations.  */
#define R_IA64_NONE		0x00	/* none */
#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
#define R_IA64_COPY		0x84	/* copy relocation */
#define R_IA64_SUB		0x85	/* Addend and symbol difference */
#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */

/* SH specific declarations */

/* Processor specific flags for the ELF header e_flags field.  */
#define EF_SH_MACH_MASK		0x1f
#define EF_SH_UNKNOWN		0x0
#define EF_SH1			0x1
#define EF_SH2			0x2
#define EF_SH3			0x3
#define EF_SH_DSP		0x4
#define EF_SH3_DSP		0x5
#define EF_SH4AL_DSP		0x6
#define EF_SH3E			0x8
#define EF_SH4			0x9
#define EF_SH2E			0xb
#define EF_SH4A			0xc
#define EF_SH2A			0xd
#define EF_SH4_NOFPU		0x10
#define EF_SH4A_NOFPU		0x11
#define EF_SH4_NOMMU_NOFPU	0x12
#define EF_SH2A_NOFPU		0x13
#define EF_SH3_NOMMU		0x14
#define EF_SH2A_SH4_NOFPU	0x15
#define EF_SH2A_SH3_NOFPU	0x16
#define EF_SH2A_SH4		0x17
#define EF_SH2A_SH3E		0x18

/* SH relocs.  */
#define	R_SH_NONE		0
#define	R_SH_DIR32		1
#define	R_SH_REL32		2
#define	R_SH_DIR8WPN		3
#define	R_SH_IND12W		4
#define	R_SH_DIR8WPL		5
#define	R_SH_DIR8WPZ		6
#define	R_SH_DIR8BP		7
#define	R_SH_DIR8W		8
#define	R_SH_DIR8L		9
#define	R_SH_SWITCH16		25
#define	R_SH_SWITCH32		26
#define	R_SH_USES		27
#define	R_SH_COUNT		28
#define	R_SH_ALIGN		29
#define	R_SH_CODE		30
#define	R_SH_DATA		31
#define	R_SH_LABEL		32
#define	R_SH_SWITCH8		33
#define	R_SH_GNU_VTINHERIT	34
#define	R_SH_GNU_VTENTRY	35
#define	R_SH_TLS_GD_32		144
#define	R_SH_TLS_LD_32		145
#define	R_SH_TLS_LDO_32		146
#define	R_SH_TLS_IE_32		147
#define	R_SH_TLS_LE_32		148
#define	R_SH_TLS_DTPMOD32	149
#define	R_SH_TLS_DTPOFF32	150
#define	R_SH_TLS_TPOFF32	151
#define	R_SH_GOT32		160
#define	R_SH_PLT32		161
#define	R_SH_COPY		162
#define	R_SH_GLOB_DAT		163
#define	R_SH_JMP_SLOT		164
#define	R_SH_RELATIVE		165
#define	R_SH_GOTOFF		166
#define	R_SH_GOTPC		167
/* Keep this the last entry.  */
#define	R_SH_NUM		256

/* S/390 specific definitions.  */

/* Valid values for the e_flags field.  */

#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */

/* Additional s390 relocs */

#define R_390_NONE		0	/* No reloc.  */
#define R_390_8			1	/* Direct 8 bit.  */
#define R_390_12		2	/* Direct 12 bit.  */
#define R_390_16		3	/* Direct 16 bit.  */
#define R_390_32		4	/* Direct 32 bit.  */
#define R_390_PC32		5	/* PC relative 32 bit.	*/
#define R_390_GOT12		6	/* 12 bit GOT offset.  */
#define R_390_GOT32		7	/* 32 bit GOT offset.  */
#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
#define R_390_COPY		9	/* Copy symbol at runtime.  */
#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
#define R_390_RELATIVE		12	/* Adjust by program base.  */
#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
#define R_390_GOT16		15	/* 16 bit GOT offset.  */
#define R_390_PC16		16	/* PC relative 16 bit.	*/
#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
#define R_390_64		22	/* Direct 64 bit.  */
#define R_390_PC64		23	/* PC relative 64 bit.	*/
#define R_390_GOT64		24	/* 64 bit GOT offset.  */
#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
#define R_390_TLS_GDCALL	38	/* Tag for function call in general
					   dynamic TLS code. */
#define R_390_TLS_LDCALL	39	/* Tag for function call in local
					   dynamic TLS code. */
#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
					   thread local data.  */
#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
					  thread local data.  */
#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
					   block offset.  */
#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
					   block offset.  */
#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
					   block offset. */
#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
					   thread local data in LE code.  */
#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
					   thread local data in LE code.  */
#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
					   negated static TLS block offset.  */
#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
					   negated static TLS block offset.  */
#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
					   negated static TLS block offset.  */
#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
					   static TLS block.  */
#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
					   static TLS block.  */
#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
					   block.  */
#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
					   block.  */
#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
					   block.  */
#define R_390_20		57	/* Direct 20 bit.  */
#define R_390_GOT20		58	/* 20 bit GOT offset.  */
#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
					   block offset.  */
#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
/* Keep this the last entry.  */
#define R_390_NUM		62


/* CRIS relocations.  */
#define R_CRIS_NONE		0
#define R_CRIS_8		1
#define R_CRIS_16		2
#define R_CRIS_32		3
#define R_CRIS_8_PCREL		4
#define R_CRIS_16_PCREL		5
#define R_CRIS_32_PCREL		6
#define R_CRIS_GNU_VTINHERIT	7
#define R_CRIS_GNU_VTENTRY	8
#define R_CRIS_COPY		9
#define R_CRIS_GLOB_DAT		10
#define R_CRIS_JUMP_SLOT	11
#define R_CRIS_RELATIVE		12
#define R_CRIS_16_GOT		13
#define R_CRIS_32_GOT		14
#define R_CRIS_16_GOTPLT	15
#define R_CRIS_32_GOTPLT	16
#define R_CRIS_32_GOTREL	17
#define R_CRIS_32_PLT_GOTREL	18
#define R_CRIS_32_PLT_PCREL	19

#define R_CRIS_NUM		20


/* AMD x86-64 relocations.  */
#define R_X86_64_NONE		0	/* No reloc */
#define R_X86_64_64		1	/* Direct 64 bit  */
#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
#define R_X86_64_PLT32		4	/* 32 bit PLT address */
#define R_X86_64_COPY		5	/* Copy symbol at runtime */
#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
#define R_X86_64_RELATIVE	8	/* Adjust by program base */
#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
					   offset to GOT */
#define R_X86_64_32		10	/* Direct 32 bit zero extended */
#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
#define R_X86_64_16		12	/* Direct 16 bit zero extended */
#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
					   to two GOT entries for GD symbol */
#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
					   to two GOT entries for LD symbol */
#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
					   to GOT entry for IE symbol */
#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
#define R_X86_64_PC64		24	/* PC relative 64 bit */
#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
					   offset to GOT */
#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
					   to GOT entry */
#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
					   to PLT entry */
#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
					   descriptor.  */
#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
#define R_X86_64_GOTPCRELX	41	/* like GOTPCREL, but optionally with
					   linker optimizations */
#define R_X86_64_REX_GOTPCRELX	42      /* like GOTPCRELX, but a REX prefix
					   is present */

#define R_X86_64_NUM		43


/* AM33 relocations.  */
#define R_MN10300_NONE		0	/* No reloc.  */
#define R_MN10300_32		1	/* Direct 32 bit.  */
#define R_MN10300_16		2	/* Direct 16 bit.  */
#define R_MN10300_8		3	/* Direct 8 bit.  */
#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
#define R_MN10300_24		9	/* Direct 24 bit.  */
#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
#define R_MN10300_TLS_GD	24	/* 32-bit offset for global dynamic.  */
#define R_MN10300_TLS_LD	25	/* 32-bit offset for local dynamic.  */
#define R_MN10300_TLS_LDO	26	/* Module-relative offset.  */
#define R_MN10300_TLS_GOTIE	27	/* GOT offset for static TLS block
					   offset.  */
#define R_MN10300_TLS_IE	28	/* GOT address for static TLS block
					   offset.  */
#define R_MN10300_TLS_LE	29	/* Offset relative to static TLS
					   block.  */
#define R_MN10300_TLS_DTPMOD	30	/* ID of module containing symbol.  */
#define R_MN10300_TLS_DTPOFF	31	/* Offset in module TLS block.  */
#define R_MN10300_TLS_TPOFF	32	/* Offset in static TLS block.  */
#define R_MN10300_SYM_DIFF	33	/* Adjustment for next reloc as needed
					   by linker relaxation.  */
#define R_MN10300_ALIGN		34	/* Alignment requirement for linker
					   relaxation.  */
#define R_MN10300_NUM		35


/* M32R relocs.  */
#define R_M32R_NONE		0	/* No reloc. */
#define R_M32R_16		1	/* Direct 16 bit. */
#define R_M32R_32		2	/* Direct 32 bit. */
#define R_M32R_24		3	/* Direct 24 bit. */
#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
#define R_M32R_LO16		9	/* Low 16 bit. */
#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
#define R_M32R_GNU_VTINHERIT	11
#define R_M32R_GNU_VTENTRY	12
/* M32R relocs use SHT_RELA.  */
#define R_M32R_16_RELA		33	/* Direct 16 bit. */
#define R_M32R_32_RELA		34	/* Direct 32 bit. */
#define R_M32R_24_RELA		35	/* Direct 24 bit. */
#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
#define R_M32R_LO16_RELA	41	/* Low 16 bit */
#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
#define R_M32R_RELA_GNU_VTINHERIT	43
#define R_M32R_RELA_GNU_VTENTRY	44
#define R_M32R_REL32		45	/* PC relative 32 bit.  */

#define R_M32R_GOT24		48	/* 24 bit GOT entry */
#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
#define R_M32R_COPY		50	/* Copy symbol at runtime */
#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
#define R_M32R_RELATIVE		53	/* Adjust by program base */
#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
					   low */
#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
					   low */
#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
					   GOT with unsigned low */
#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
					   GOT with signed low */
#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
					   GOT */
#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
					   with unsigned low */
#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
					   with signed low */
#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
#define R_M32R_NUM		256	/* Keep this the last entry. */


/* TILEPro relocations.  */
#define R_TILEPRO_NONE		0	/* No reloc */
#define R_TILEPRO_32		1	/* Direct 32 bit */
#define R_TILEPRO_16		2	/* Direct 16 bit */
#define R_TILEPRO_8		3	/* Direct 8 bit */
#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
#define R_TILEPRO_LO16		7	/* Low 16 bit */
#define R_TILEPRO_HI16		8	/* High 16 bit */
#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
#define R_TILEPRO_COPY		10	/* Copy relocation */
#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
/* Relocs 56-59 are currently not defined.  */
#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */

#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */

#define R_TILEPRO_NUM		130


/* TILE-Gx relocations.  */
#define R_TILEGX_NONE		0	/* No reloc */
#define R_TILEGX_64		1	/* Direct 64 bit */
#define R_TILEGX_32		2	/* Direct 32 bit */
#define R_TILEGX_16		3	/* Direct 16 bit */
#define R_TILEGX_8		4	/* Direct 8 bit */
#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
#define R_TILEGX_HW0		9	/* hword 0 16-bit */
#define R_TILEGX_HW1		10	/* hword 1 16-bit */
#define R_TILEGX_HW2		11	/* hword 2 16-bit */
#define R_TILEGX_HW3		12	/* hword 3 16-bit */
#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
#define R_TILEGX_COPY		16	/* Copy relocation */
#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
#define R_TILEGX_IMM16_X0_HW0_PLT_PCREL 66 /* X0 pipe PC-rel PLT hword 0 */
#define R_TILEGX_IMM16_X1_HW0_PLT_PCREL 67 /* X1 pipe PC-rel PLT hword 0 */
#define R_TILEGX_IMM16_X0_HW1_PLT_PCREL 68 /* X0 pipe PC-rel PLT hword 1 */
#define R_TILEGX_IMM16_X1_HW1_PLT_PCREL 69 /* X1 pipe PC-rel PLT hword 1 */
#define R_TILEGX_IMM16_X0_HW2_PLT_PCREL 70 /* X0 pipe PC-rel PLT hword 2 */
#define R_TILEGX_IMM16_X1_HW2_PLT_PCREL 71 /* X1 pipe PC-rel PLT hword 2 */
#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
#define R_TILEGX_IMM16_X0_HW3_PLT_PCREL 76 /* X0 pipe PC-rel PLT hword 3 */
#define R_TILEGX_IMM16_X1_HW3_PLT_PCREL 77 /* X1 pipe PC-rel PLT hword 3 */
#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
/* Relocs 90-91 are currently not defined.  */
#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
#define R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL 94 /* X0 pipe PC-rel PLT last hword 0 */
#define R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL 95 /* X1 pipe PC-rel PLT last hword 0 */
#define R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL 96 /* X0 pipe PC-rel PLT last hword 1 */
#define R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL 97 /* X1 pipe PC-rel PLT last hword 1 */
#define R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL 98 /* X0 pipe PC-rel PLT last hword 2 */
#define R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL 99 /* X1 pipe PC-rel PLT last hword 2 */
#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
/* Relocs 104-105 are currently not defined.  */
#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */

#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */

#define R_TILEGX_NUM		130

/* RISC-V ELF Flags */
#define EF_RISCV_RVC 			0x0001
#define EF_RISCV_FLOAT_ABI 		0x0006
#define EF_RISCV_FLOAT_ABI_SOFT 	0x0000
#define EF_RISCV_FLOAT_ABI_SINGLE 	0x0002
#define EF_RISCV_FLOAT_ABI_DOUBLE 	0x0004
#define EF_RISCV_FLOAT_ABI_QUAD 	0x0006

/* RISC-V relocations.  */
#define R_RISCV_NONE		 0
#define R_RISCV_32		 1
#define R_RISCV_64		 2
#define R_RISCV_RELATIVE	 3
#define R_RISCV_COPY		 4
#define R_RISCV_JUMP_SLOT	 5
#define R_RISCV_TLS_DTPMOD32	 6
#define R_RISCV_TLS_DTPMOD64	 7
#define R_RISCV_TLS_DTPREL32	 8
#define R_RISCV_TLS_DTPREL64	 9
#define R_RISCV_TLS_TPREL32	10
#define R_RISCV_TLS_TPREL64	11
#define R_RISCV_BRANCH		16
#define R_RISCV_JAL		17
#define R_RISCV_CALL		18
#define R_RISCV_CALL_PLT	19
#define R_RISCV_GOT_HI20	20
#define R_RISCV_TLS_GOT_HI20	21
#define R_RISCV_TLS_GD_HI20	22
#define R_RISCV_PCREL_HI20	23
#define R_RISCV_PCREL_LO12_I	24
#define R_RISCV_PCREL_LO12_S	25
#define R_RISCV_HI20		26
#define R_RISCV_LO12_I		27
#define R_RISCV_LO12_S		28
#define R_RISCV_TPREL_HI20	29
#define R_RISCV_TPREL_LO12_I	30
#define R_RISCV_TPREL_LO12_S	31
#define R_RISCV_TPREL_ADD	32
#define R_RISCV_ADD8		33
#define R_RISCV_ADD16		34
#define R_RISCV_ADD32		35
#define R_RISCV_ADD64		36
#define R_RISCV_SUB8		37
#define R_RISCV_SUB16		38
#define R_RISCV_SUB32		39
#define R_RISCV_SUB64		40
#define R_RISCV_GNU_VTINHERIT	41
#define R_RISCV_GNU_VTENTRY	42
#define R_RISCV_ALIGN		43
#define R_RISCV_RVC_BRANCH	44
#define R_RISCV_RVC_JUMP	45
#define R_RISCV_RVC_LUI		46
#define R_RISCV_GPREL_I		47
#define R_RISCV_GPREL_S		48
#define R_RISCV_TPREL_I		49
#define R_RISCV_TPREL_S		50
#define R_RISCV_RELAX		51
#define R_RISCV_SUB6		52
#define R_RISCV_SET6		53
#define R_RISCV_SET8		54
#define R_RISCV_SET16		55
#define R_RISCV_SET32		56
#define R_RISCV_32_PCREL	57

#define R_RISCV_NUM		58


//END elf.h

//START stub.h

#define __define_stab(NAME, CODE, STRING) NAME=CODE,

enum __stab_debug_code
{
	/* Table of DBX symbol codes for the GNU system.
	   Copyright (C) 1988, 1997 Free Software Foundation, Inc.
	   This file is part of the GNU C Library.

	   The GNU C Library is free software; you can redistribute it and/or
	   modify it under the terms of the GNU Library General Public License as
	   published by the Free Software Foundation; either version 2 of the
	   License, or (at your option) any later version.

	   The GNU C Library is distributed in the hope that it will be useful,
	   but WITHOUT ANY WARRANTY; without even the implied warranty of
	   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	   Library General Public License for more details.

	   You should have received a copy of the GNU Library General Public
	   License along with the GNU C Library; see the file COPYING.LIB.  If not,
	   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
	   Boston, MA 02111-1307, USA.  */

	/* This contains contribution from Cygnus Support.  */
	
	/* Global variable.  Only the name is significant.
	   To find the address, look in the corresponding external symbol.  */
	__define_stab (N_GSYM, 0x20, "GSYM")

	/* Function name for BSD Fortran.  Only the name is significant.
	   To find the address, look in the corresponding external symbol.  */
	__define_stab (N_FNAME, 0x22, "FNAME")

	/* Function name or text-segment variable for C.  Value is its address.
	   Desc is supposedly starting line number, but GCC doesn't set it
	   and DBX seems not to miss it.  */
	__define_stab (N_FUN, 0x24, "FUN")

	/* Data-segment variable with internal linkage.  Value is its address.
	   "Static Sym".  */
	__define_stab (N_STSYM, 0x26, "STSYM")

	/* BSS-segment variable with internal linkage.  Value is its address.  */
	__define_stab (N_LCSYM, 0x28, "LCSYM")

	/* Name of main routine.  Only the name is significant.
	   This is not used in C.  */
	__define_stab (N_MAIN, 0x2a, "MAIN")

	/* Global symbol in Pascal.
	   Supposedly the value is its line number; I'm skeptical.  */
	__define_stab (N_PC, 0x30, "PC")

	/* Number of symbols:  0, files,,funcs,lines according to Ultrix V4.0. */
	__define_stab (N_NSYMS, 0x32, "NSYMS")

	/* "No DST map for sym: name, ,0,type,ignored"  according to Ultrix V4.0. */
	__define_stab (N_NOMAP, 0x34, "NOMAP")

	/* New stab from Solaris.  I don't know what it means, but it
	   don't seem to contain useful information.  */
	__define_stab (N_OBJ, 0x38, "OBJ")

	/* New stab from Solaris.  I don't know what it means, but it
	   don't seem to contain useful information.  Possibly related to the
	   optimization flags used in this module.  */
	__define_stab (N_OPT, 0x3c, "OPT")

	/* Register variable.  Value is number of register.  */
	__define_stab (N_RSYM, 0x40, "RSYM")

	/* Modula-2 compilation unit.  Can someone say what info it contains?  */
	__define_stab (N_M2C, 0x42, "M2C")

	/* Line number in text segment.  Desc is the line number;
	   value is corresponding address.  */
	__define_stab (N_SLINE, 0x44, "SLINE")

	/* Similar, for data segment.  */
	__define_stab (N_DSLINE, 0x46, "DSLINE")

	/* Similar, for bss segment.  */
	__define_stab (N_BSLINE, 0x48, "BSLINE")

	/* Sun's source-code browser stabs.  ?? Don't know what the fields are.
	   Supposedly the field is "path to associated .cb file".  THIS VALUE
	   OVERLAPS WITH N_BSLINE!  */
	__define_stab (N_BROWS, 0x48, "BROWS")

	/* GNU Modula-2 definition module dependency.  Value is the modification time
	   of the definition file.  Other is non-zero if it is imported with the
	   GNU M2 keyword %INITIALIZE.  Perhaps N_M2C can be used if there
	   are enough empty fields? */
	__define_stab(N_DEFD, 0x4a, "DEFD")

	/* THE FOLLOWING TWO STAB VALUES CONFLICT.  Happily, one is for Modula-2
	   and one is for C++.   Still,... */
	/* GNU C++ exception variable.  Name is variable name.  */
	__define_stab (N_EHDECL, 0x50, "EHDECL")
	/* Modula2 info "for imc":  name,,0,0,0  according to Ultrix V4.0.  */
	__define_stab (N_MOD2, 0x50, "MOD2")

	/* GNU C++ `catch' clause.  Value is its address.  Desc is nonzero if
	   this entry is immediately followed by a CAUGHT stab saying what exception
	   was caught.  Multiple CAUGHT stabs means that multiple exceptions
	   can be caught here.  If Desc is 0, it means all exceptions are caught
	   here.  */
	__define_stab (N_CATCH, 0x54, "CATCH")

	/* Structure or union element.  Value is offset in the structure.  */
	__define_stab (N_SSYM, 0x60, "SSYM")

	/* Name of main source file.
	   Value is starting text address of the compilation.  */
	__define_stab (N_SO, 0x64, "SO")

	/* Automatic variable in the stack.  Value is offset from frame pointer.
	   Also used for type descriptions.  */
	__define_stab (N_LSYM, 0x80, "LSYM")

	/* Beginning of an include file.  Only Sun uses this.
	   In an object file, only the name is significant.
	   The Sun linker puts data into some of the other fields.  */
	__define_stab (N_BINCL, 0x82, "BINCL")

	/* Name of sub-source file (#include file).
	   Value is starting text address of the compilation.  */
	__define_stab (N_SOL, 0x84, "SOL")

	/* Parameter variable.  Value is offset from argument pointer.
	   (On most machines the argument pointer is the same as the frame pointer.  */
	__define_stab (N_PSYM, 0xa0, "PSYM")

	/* End of an include file.  No name.
	   This and N_BINCL act as brackets around the file's output.
	   In an object file, there is no significant data in this entry.
	   The Sun linker puts data into some of the fields.  */
	__define_stab (N_EINCL, 0xa2, "EINCL")

	/* Alternate entry point.  Value is its address.  */
	__define_stab (N_ENTRY, 0xa4, "ENTRY")

	/* Beginning of lexical block.
	   The desc is the nesting level in lexical blocks.
	   The value is the address of the start of the text for the block.
	   The variables declared inside the block *precede* the N_LBRAC symbol.  */
	__define_stab (N_LBRAC, 0xc0, "LBRAC")

	/* Place holder for deleted include file.  Replaces a N_BINCL and everything
	   up to the corresponding N_EINCL.  The Sun linker generates these when
	   it finds multiple identical copies of the symbols from an include file.
	   This appears only in output from the Sun linker.  */
	__define_stab (N_EXCL, 0xc2, "EXCL")

	/* Modula-2 scope information.  Can someone say what info it contains?  */
	__define_stab (N_SCOPE, 0xc4, "SCOPE")

	/* End of a lexical block.  Desc matches the N_LBRAC's desc.
	   The value is the address of the end of the text for the block.  */
	__define_stab (N_RBRAC, 0xe0, "RBRAC")

	/* Begin named common block.  Only the name is significant.  */
	__define_stab (N_BCOMM, 0xe2, "BCOMM")

	/* End named common block.  Only the name is significant
	   (and it should match the N_BCOMM).  */
	__define_stab (N_ECOMM, 0xe4, "ECOMM")

	/* End common (local name): value is address.
	   I'm not sure how this is used.  */
	__define_stab (N_ECOML, 0xe8, "ECOML")

	/* These STAB's are used on Gould systems for Non-Base register symbols
	   or something like that.  FIXME.  I have assigned the values at random
	   since I don't have a Gould here.  Fixups from Gould folk welcome... */
	__define_stab (N_NBTEXT, 0xF0, "NBTEXT")
	__define_stab (N_NBDATA, 0xF2, "NBDATA")
	__define_stab (N_NBBSS,  0xF4, "NBBSS")
	__define_stab (N_NBSTS,  0xF6, "NBSTS")
	__define_stab (N_NBLCS,  0xF8, "NBLCS")

	/* Second symbol entry containing a length-value for the preceding entry.
	   The value is the length.  */
	__define_stab (N_LENG, 0xfe, "LENG")
	
	/* The above information, in matrix format.

				STAB MATRIX
		_________________________________________________
		| 00 - 1F are not dbx stab symbols		|
		| In most cases, the low bit is the EXTernal bit|

		| 00 UNDEF  | 02 ABS	| 04 TEXT   | 06 DATA	|
		| 01  |EXT  | 03  |EXT	| 05  |EXT  | 07  |EXT	|

		| 08 BSS    | 0A INDR	| 0C FN_SEQ | 0E   	|
		| 09  |EXT  | 0B 	| 0D	    | 0F	|

		| 10 	    | 12 COMM	| 14 SETA   | 16 SETT	|
		| 11	    | 13	| 15 	    | 17	|

		| 18 SETD   | 1A SETB	| 1C SETV   | 1E WARNING|
		| 19	    | 1B	| 1D 	    | 1F FN	|

		|_______________________________________________|
		| Debug entries with bit 01 set are unused.	|
		| 20 GSYM   | 22 FNAME	| 24 FUN    | 26 STSYM	|
		| 28 LCSYM  | 2A MAIN	| 2C	    | 2E	|
		| 30 PC	    | 32 NSYMS	| 34 NOMAP  | 36	|
		| 38 OBJ    | 3A	| 3C OPT    | 3E	|
		| 40 RSYM   | 42 M2C	| 44 SLINE  | 46 DSLINE |
		| 48 BSLINE*| 4A DEFD	| 4C        | 4E	|
		| 50 EHDECL*| 52	| 54 CATCH  | 56        |
		| 58        | 5A        | 5C        | 5E	|
		| 60 SSYM   | 62	| 64 SO	    | 66 	|
		| 68 	    | 6A	| 6C	    | 6E	|
		| 70	    | 72	| 74	    | 76	|
		| 78	    | 7A	| 7C	    | 7E	|
		| 80 LSYM   | 82 BINCL	| 84 SOL    | 86	|
		| 88	    | 8A	| 8C	    | 8E	|
		| 90	    | 92	| 94	    | 96	|
		| 98	    | 9A	| 9C	    | 9E	|
		| A0 PSYM   | A2 EINCL	| A4 ENTRY  | A6	|
		| A8	    | AA	| AC	    | AE	|
		| B0	    | B2	| B4	    | B6	|
		| B8	    | BA	| BC	    | BE	|
		| C0 LBRAC  | C2 EXCL	| C4 SCOPE  | C6	|
		| C8	    | CA	| CC	    | CE	|
		| D0	    | D2	| D4	    | D6	|
		| D8	    | DA	| DC	    | DE	|
		| E0 RBRAC  | E2 BCOMM	| E4 ECOMM  | E6	|
		| E8 ECOML  | EA	| EC	    | EE	|
		| F0	    | F2	| F4	    | F6	|
		| F8	    | FA	| FC	    | FE LENG	|
		+-----------------------------------------------+
	 * 50 EHDECL is also MOD2.
	 * 48 BSLINE is also BROWS.
	 */
	LAST_UNUSED_STAB_CODE
};

#undef __define_stab

//END stub.h

/* -------------------------------------------- */

#ifndef PUB_FUNC /* functions used by tcc.c but not in libtcc.h */
# define PUB_FUNC
#endif

#ifndef ONE_SOURCE
# define ONE_SOURCE 1
#endif

/* support using libtcc from threads */
#define CONFIG_TCC_SEMLOCK

#if ONE_SOURCE
#define ST_INLN static inline
#define ST_FUNC static
#define ST_DATA static
#else
#define ST_INLN
#define ST_FUNC
#define ST_DATA extern
#endif

#ifdef TCC_PROFILE /* profile all functions */
# define static
#endif

/* -------------------------------------------- */
/* DEFINES: include the target specific definitions */

#ifdef TCC_TARGET_I386

/* number of available registers */
#define NB_REGS         5
#define NB_ASM_REGS     8
#define CONFIG_TCC_ASM

/* a register can belong to several classes. The classes must be
   sorted from more general to more precise (see gv2() code which does
   assumptions on it). */
#define RC_INT     0x0001 /* generic integer register */
#define RC_FLOAT   0x0002 /* generic float register */
#define RC_EAX     0x0004
#define RC_ST0     0x0008
#define RC_ECX     0x0010
#define RC_EDX     0x0020
#define RC_EBX     0x0040

#define RC_IRET    RC_EAX /* function return: integer register */
#define RC_IRE2    RC_EDX /* function return: second integer register */
#define RC_FRET    RC_ST0 /* function return: float register */

/* pretty names for the registers */
enum
{
	TREG_EAX = 0,
	TREG_ECX,
	TREG_EDX,
	TREG_EBX,
	TREG_ST0,
	TREG_ESP = 4
};

/* return registers for function */
#define REG_IRET TREG_EAX /* single word int return register */
#define REG_IRE2 TREG_EDX /* second word return register (for long long) */
#define REG_FRET TREG_ST0 /* float return register */

/* defined if function parameters must be evaluated in reverse order */
#define INVERT_FUNC_PARAMS

/* defined if structures are passed as pointers. Otherwise structures
   are directly pushed on stack. */
/* #define FUNC_STRUCT_PARAM_AS_PTR */

/* pointer size, in bytes */
#define PTR_SIZE 4

/* long double size and alignment, in bytes */
#define LDOUBLE_SIZE  12
#define LDOUBLE_ALIGN 4
/* maximum alignment (for aligned attribute support) */
#define MAX_ALIGN     8

/* define if return values need to be extended explicitely
   at caller side (for interfacing with non-TCC compilers) */

#define EM_TCC_TARGET EM_386

/* relocation type for 32 bit data relocation */
#define R_DATA_32   R_386_32
#define R_DATA_PTR  R_386_32
#define R_JMP_SLOT  R_386_JMP_SLOT
#define R_GLOB_DAT  R_386_GLOB_DAT
#define R_COPY      R_386_COPY
#define R_RELATIVE  R_386_RELATIVE

#define R_NUM       R_386_NUM

#define ELF_START_ADDR 0x08048000
#define ELF_PAGE_SIZE  0x1000

#define PCRELATIVE_DLLPLT 0
#define RELOCATE_DLLPLT 0

#elif defined TCC_TARGET_X86_64

/* number of available registers */
#define NB_REGS         25
#define NB_ASM_REGS     16
#define CONFIG_TCC_ASM

/* a register can belong to several classes. The classes must be
   sorted from more general to more precise (see gv2() code which does
   assumptions on it). */
#define RC_INT     0x0001 /* generic integer register */
#define RC_FLOAT   0x0002 /* generic float register */
#define RC_RAX     0x0004
#define RC_RCX     0x0008
#define RC_RDX     0x0010
#define RC_ST0     0x0080 /* only for long double */
#define RC_R8      0x0100
#define RC_R9      0x0200
#define RC_R10     0x0400
#define RC_R11     0x0800
#define RC_XMM0    0x1000
#define RC_XMM1    0x2000
#define RC_XMM2    0x4000
#define RC_XMM3    0x8000
#define RC_XMM4    0x10000
#define RC_XMM5    0x20000
#define RC_XMM6    0x40000
#define RC_XMM7    0x80000
#define RC_IRET    RC_RAX /* function return: integer register */
#define RC_IRE2    RC_RDX /* function return: second integer register */
#define RC_FRET    RC_XMM0 /* function return: float register */
#define RC_FRE2    RC_XMM1 /* function return: second float register */

/* pretty names for the registers */
enum
{
	TREG_RAX = 0,
	TREG_RCX = 1,
	TREG_RDX = 2,
	TREG_RSP = 4,
	TREG_RSI = 6,
	TREG_RDI = 7,

	TREG_R8  = 8,
	TREG_R9  = 9,
	TREG_R10 = 10,
	TREG_R11 = 11,

	TREG_XMM0 = 16,
	TREG_XMM1 = 17,
	TREG_XMM2 = 18,
	TREG_XMM3 = 19,
	TREG_XMM4 = 20,
	TREG_XMM5 = 21,
	TREG_XMM6 = 22,
	TREG_XMM7 = 23,

	TREG_ST0 = 24,

	TREG_MEM = 0x20
};

#define REX_BASE(reg) (((reg) >> 3) & 1)
#define REG_VALUE(reg) ((reg) & 7)

/* return registers for function */
#define REG_IRET TREG_RAX /* single word int return register */
#define REG_IRE2 TREG_RDX /* second word return register (for long long) */
#define REG_FRET TREG_XMM0 /* float return register */
#define REG_FRE2 TREG_XMM1 /* second float return register */

/* defined if function parameters must be evaluated in reverse order */
#define INVERT_FUNC_PARAMS

/* pointer size, in bytes */
#define PTR_SIZE 8

/* long double size and alignment, in bytes */
#define LDOUBLE_SIZE  16
#define LDOUBLE_ALIGN 16
/* maximum alignment (for aligned attribute support) */
#define MAX_ALIGN     16

/* define if return values need to be extended explicitely
   at caller side (for interfacing with non-TCC compilers) */

#define PROMOTE_RET

#define EM_TCC_TARGET EM_X86_64

/* relocation type for 32 bit data relocation */
#define R_DATA_32   R_X86_64_32S
#define R_DATA_PTR  R_X86_64_64
#define R_JMP_SLOT  R_X86_64_JUMP_SLOT
#define R_GLOB_DAT  R_X86_64_GLOB_DAT
#define R_COPY      R_X86_64_COPY
#define R_RELATIVE  R_X86_64_RELATIVE

#define R_NUM       R_X86_64_NUM

#define ELF_START_ADDR 0x400000
#define ELF_PAGE_SIZE  0x200000

#define PCRELATIVE_DLLPLT 1
#define RELOCATE_DLLPLT 1


#elif defined TCC_TARGET_ARM

#if defined(TCC_ARM_EABI) && !defined(TCC_ARM_VFP)
#error "Currently TinyCC only supports float computation with VFP instructions"
#endif

/* number of available registers */
#ifdef TCC_ARM_VFP
#define NB_REGS            13
#else
#define NB_REGS             9
#endif

#ifndef TCC_CPU_VERSION
# define TCC_CPU_VERSION 5
#endif

/* a register can belong to several classes. The classes must be
   sorted from more general to more precise (see gv2() code which does
   assumptions on it). */
#define RC_INT     0x0001 /* generic integer register */
#define RC_FLOAT   0x0002 /* generic float register */
#define RC_R0      0x0004
#define RC_R1      0x0008
#define RC_R2      0x0010
#define RC_R3      0x0020
#define RC_R12     0x0040
#define RC_F0      0x0080
#define RC_F1      0x0100
#define RC_F2      0x0200
#define RC_F3      0x0400
#ifdef TCC_ARM_VFP
#define RC_F4      0x0800
#define RC_F5      0x1000
#define RC_F6      0x2000
#define RC_F7      0x4000
#endif
#define RC_IRET    RC_R0  /* function return: integer register */
#define RC_IRE2    RC_R1  /* function return: second integer register */
#define RC_FRET    RC_F0  /* function return: float register */

/* pretty names for the registers */
enum
{
	TREG_R0 = 0,
	TREG_R1,
	TREG_R2,
	TREG_R3,
	TREG_R12,
	TREG_F0,
	TREG_F1,
	TREG_F2,
	TREG_F3,
#ifdef TCC_ARM_VFP
	TREG_F4,
	TREG_F5,
	TREG_F6,
	TREG_F7,
#endif
	TREG_SP = 13,
	TREG_LR,
};

#ifdef TCC_ARM_VFP
#define T2CPR(t) (((t) & VT_BTYPE) != VT_FLOAT ? 0x100 : 0)
#endif

/* return registers for function */
#define REG_IRET TREG_R0 /* single word int return register */
#define REG_IRE2 TREG_R1 /* second word return register (for long long) */
#define REG_FRET TREG_F0 /* float return register */

#ifdef TCC_ARM_EABI
#define TOK___divdi3 TOK___aeabi_ldivmod
#define TOK___moddi3 TOK___aeabi_ldivmod
#define TOK___udivdi3 TOK___aeabi_uldivmod
#define TOK___umoddi3 TOK___aeabi_uldivmod
#endif

/* defined if function parameters must be evaluated in reverse order */
#define INVERT_FUNC_PARAMS

/* defined if structures are passed as pointers. Otherwise structures
   are directly pushed on stack. */
/* #define FUNC_STRUCT_PARAM_AS_PTR */

/* pointer size, in bytes */
#define PTR_SIZE 4

/* long double size and alignment, in bytes */
#ifdef TCC_ARM_VFP
#define LDOUBLE_SIZE  8
#endif

#ifndef LDOUBLE_SIZE
#define LDOUBLE_SIZE  8
#endif

#ifdef TCC_ARM_EABI
#define LDOUBLE_ALIGN 8
#else
#define LDOUBLE_ALIGN 4
#endif

/* maximum alignment (for aligned attribute support) */
#define MAX_ALIGN     8

#define CHAR_IS_UNSIGNED


#define EM_TCC_TARGET EM_ARM

/* relocation type for 32 bit data relocation */
#define R_DATA_32   R_ARM_ABS32
#define R_DATA_PTR  R_ARM_ABS32
#define R_JMP_SLOT  R_ARM_JUMP_SLOT
#define R_GLOB_DAT  R_ARM_GLOB_DAT
#define R_COPY      R_ARM_COPY
#define R_RELATIVE  R_ARM_RELATIVE

#define R_NUM       R_ARM_NUM

#define ELF_START_ADDR 0x00008000
#define ELF_PAGE_SIZE  0x1000

#define PCRELATIVE_DLLPLT 1
#define RELOCATE_DLLPLT 0

enum float_abi
{
	ARM_SOFTFP_FLOAT,
	ARM_HARD_FLOAT,
};

#define CONFIG_TCC_ASM
#define NB_ASM_REGS 16

ST_FUNC void g(int c);
ST_FUNC void gen_le16(int c);
ST_FUNC void gen_le32(int c);

#elif defined TCC_TARGET_ARM64

// Number of registers available to allocator:
#define NB_REGS 28 // x0-x18, x30, v0-v7

#define TREG_R(x) (x) // x = 0..18
#define TREG_R30  19
#define TREG_F(x) (x + 20) // x = 0..7

// Register classes sorted from more general to more precise:
#define RC_INT (1 << 0)
#define RC_FLOAT (1 << 1)
#define RC_R(x) (1 << (2 + (x))) // x = 0..18
#define RC_R30  (1 << 21)
#define RC_F(x) (1 << (22 + (x))) // x = 0..7

#define RC_IRET (RC_R(0)) // int return register class
#define RC_FRET (RC_F(0)) // float return register class

#define REG_IRET (TREG_R(0)) // int return register number
#define REG_FRET (TREG_F(0)) // float return register number

#define PTR_SIZE 8

#define LDOUBLE_SIZE 16
#define LDOUBLE_ALIGN 16

#define MAX_ALIGN 16

#define CHAR_IS_UNSIGNED

/* define if return values need to be extended explicitely
   at caller side (for interfacing with non-TCC compilers) */
#define PROMOTE_RET


#define EM_TCC_TARGET EM_AARCH64

#define R_DATA_32  R_AARCH64_ABS32
#define R_DATA_PTR R_AARCH64_ABS64
#define R_JMP_SLOT R_AARCH64_JUMP_SLOT
#define R_GLOB_DAT R_AARCH64_GLOB_DAT
#define R_COPY     R_AARCH64_COPY
#define R_RELATIVE R_AARCH64_RELATIVE

#define R_NUM      R_AARCH64_NUM

#define ELF_START_ADDR 0x00400000
#define ELF_PAGE_SIZE 0x10000

#define PCRELATIVE_DLLPLT 1
#define RELOCATE_DLLPLT 1

#elif defined TCC_TARGET_C67
# define TCC_TARGET_COFF

/**************************************************************************/
/*  COFF.H                                                                */
/*     COFF data structures and related definitions used by the linker    */
/**************************************************************************/

/*------------------------------------------------------------------------*/
/*  COFF FILE HEADER                                                      */
/*------------------------------------------------------------------------*/
struct filehdr
{
	unsigned short  f_magic;        /* magic number */
	unsigned short  f_nscns;        /* number of sections */
	long            f_timdat;       /* time & date stamp */
	long            f_symptr;       /* file pointer to symtab */
	long            f_nsyms;        /* number of symtab entries */
	unsigned short  f_opthdr;       /* sizeof(optional hdr) */
	unsigned short  f_flags;        /* flags */
	unsigned short  f_TargetID;     /* for C6x = 0x0099 */
};

/*------------------------------------------------------------------------*/
/*  File header flags                                                     */
/*------------------------------------------------------------------------*/
#define  F_RELFLG   0x01       /* relocation info stripped from file       */
#define  F_EXEC     0x02       /* file is executable (no unresolved refs)  */
#define  F_LNNO     0x04       /* line numbers stripped from file          */
#define  F_LSYMS    0x08       /* local symbols stripped from file         */
#define  F_GSP10    0x10       /* 34010 version                            */
#define  F_GSP20    0x20       /* 34020 version                            */
#define  F_SWABD    0x40       /* bytes swabbed (in names)                 */
#define  F_AR16WR   0x80       /* byte ordering of an AR16WR (PDP-11)      */
#define  F_LITTLE   0x100      /* byte ordering of an AR32WR (vax)         */
#define  F_BIG      0x200      /* byte ordering of an AR32W (3B, maxi)     */
#define  F_PATCH    0x400      /* contains "patch" list in optional header */
#define  F_NODF     0x400

#define F_VERSION    (F_GSP10  | F_GSP20)
#define F_BYTE_ORDER (F_LITTLE | F_BIG)
#define FILHDR  struct filehdr

/* #define FILHSZ  sizeof(FILHDR)  */
#define FILHSZ  22                /* above rounds to align on 4 bytes which causes problems */

#define COFF_C67_MAGIC 0x00c2

/*------------------------------------------------------------------------*/
/*  Macros to recognize magic numbers                                     */
/*------------------------------------------------------------------------*/
#define ISMAGIC(x)      (((unsigned short)(x))==(unsigned short)magic)
#define ISARCHIVE(x)    ((((unsigned short)(x))==(unsigned short)ARTYPE))
#define BADMAGIC(x)     (((unsigned short)(x) & 0x8080) && !ISMAGIC(x))


/*------------------------------------------------------------------------*/
/*  OPTIONAL FILE HEADER                                                  */
/*------------------------------------------------------------------------*/
typedef struct aouthdr
{
	short   magic;          /* see magic.h                          */
	short   vstamp;         /* version stamp                        */
	long    tsize;          /* text size in bytes, padded to FW bdry*/
	long    dsize;          /* initialized data "  "                */
	long    bsize;          /* uninitialized data "   "             */
	long    entrypt;        /* entry pt.                            */
	long    text_start;     /* base of text used for this file      */
	long    data_start;     /* base of data used for this file      */
} AOUTHDR;

#define AOUTSZ  sizeof(AOUTHDR)

/*----------------------------------------------------------------------*/
/*      When a UNIX aout header is to be built in the optional header,  */
/*      the following magic numbers can appear in that header:          */
/*                                                                      */
/*              AOUT1MAGIC : default : readonly sharable text segment   */
/*              AOUT2MAGIC:          : writable text segment            */
/*              PAGEMAGIC  :         : configured for paging            */
/*----------------------------------------------------------------------*/
#define AOUT1MAGIC 0410
#define AOUT2MAGIC 0407
#define PAGEMAGIC  0413


/*------------------------------------------------------------------------*/
/*  COMMON ARCHIVE FILE STRUCTURES                                        */
/*                                                                        */
/*       ARCHIVE File Organization:                                       */
/*       _______________________________________________                  */
/*       |__________ARCHIVE_MAGIC_STRING_______________|                  */
/*       |__________ARCHIVE_FILE_MEMBER_1______________|                  */
/*       |                                             |                  */
/*       |       Archive File Header "ar_hdr"          |                  */
/*       |.............................................|                  */
/*       |       Member Contents                       |                  */
/*       |               1. External symbol directory  |                  */
/*       |               2. Text file                  |                  */
/*       |_____________________________________________|                  */
/*       |________ARCHIVE_FILE_MEMBER_2________________|                  */
/*       |               "ar_hdr"                      |                  */
/*       |.............................................|                  */
/*       |       Member Contents (.o or text file)     |                  */
/*       |_____________________________________________|                  */
/*       |       .               .               .     |                  */
/*       |       .               .               .     |                  */
/*       |       .               .               .     |                  */
/*       |_____________________________________________|                  */
/*       |________ARCHIVE_FILE_MEMBER_n________________|                  */
/*       |               "ar_hdr"                      |                  */
/*       |.............................................|                  */
/*       |               Member Contents               |                  */
/*       |_____________________________________________|                  */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define COFF_ARMAG   "!<arch>\n"
#define SARMAG  8
#define ARFMAG  "`\n"

struct ar_hdr           /* archive file member header - printable ascii */
{
	char    ar_name[16];    /* file member name - `/' terminated */
	char    ar_date[12];    /* file member date - decimal */
	char    ar_uid[6];      /* file member user id - decimal */
	char    ar_gid[6];      /* file member group id - decimal */
	char    ar_mode[8];     /* file member mode - octal */
	char    ar_size[10];    /* file member size - decimal */
	char    ar_fmag[2];     /* ARFMAG - string to end header */
};


/*------------------------------------------------------------------------*/
/*  SECTION HEADER                                                        */
/*------------------------------------------------------------------------*/
struct scnhdr
{
	char            s_name[8];      /* section name */
	long            s_paddr;        /* physical address */
	long            s_vaddr;        /* virtual address */
	long            s_size;         /* section size */
	long            s_scnptr;       /* file ptr to raw data for section */
	long            s_relptr;       /* file ptr to relocation */
	long            s_lnnoptr;      /* file ptr to line numbers */
	unsigned int	s_nreloc;       /* number of relocation entries */
	unsigned int	s_nlnno;        /* number of line number entries */
	unsigned int	s_flags;        /* flags */
	unsigned short	s_reserved;     /* reserved byte */
	unsigned short  s_page;         /* memory page id */
};

#define SCNHDR  struct scnhdr
#define SCNHSZ  sizeof(SCNHDR)

/*------------------------------------------------------------------------*/
/* Define constants for names of "special" sections                       */
/*------------------------------------------------------------------------*/
/* #define _TEXT    ".text" */
#define _DATA    ".data"
#define _BSS     ".bss"
#define _CINIT   ".cinit"
#define _TV      ".tv"

/*------------------------------------------------------------------------*/
/* The low 4 bits of s_flags is used as a section "type"                  */
/*------------------------------------------------------------------------*/
#define STYP_REG    0x00  /* "regular" : allocated, relocated, loaded */
#define STYP_DSECT  0x01  /* "dummy"   : not allocated, relocated, not loaded */
#define STYP_NOLOAD 0x02  /* "noload"  : allocated, relocated, not loaded */
#define STYP_GROUP  0x04  /* "grouped" : formed of input sections */
#define STYP_PAD    0x08  /* "padding" : not allocated, not relocated, loaded */
#define STYP_COPY   0x10  /* "copy"    : used for C init tables - 
                                                not allocated, relocated,
                                                loaded;  reloc & lineno
                                                entries processed normally */
#define STYP_TEXT   0x20   /* section contains text only */
#define STYP_DATA   0x40   /* section contains data only */
#define STYP_BSS    0x80   /* section contains bss only */

#define STYP_ALIGN  0x100  /* align flag passed by old version assemblers */
#define ALIGN_MASK  0x0F00 /* part of s_flags that is used for align vals */
#define ALIGNSIZE(x) (1 << ((x & ALIGN_MASK) >> 8))


/*------------------------------------------------------------------------*/
/*  RELOCATION ENTRIES                                                    */
/*------------------------------------------------------------------------*/
struct reloc
{
	long            r_vaddr;        /* (virtual) address of reference */
	short           r_symndx;       /* index into symbol table */
	unsigned short  r_disp;         /* additional bits for address calculation */
	unsigned short  r_type;         /* relocation type */
};

#define RELOC   struct reloc
#define RELSZ   10                 /* sizeof(RELOC) */

/*--------------------------------------------------------------------------*/
/*   define all relocation types                                            */
/*--------------------------------------------------------------------------*/

#define R_ABS           0         /* absolute address - no relocation       */
#define R_DIR16         01        /* UNUSED                                 */
#define R_REL16         02        /* UNUSED                                 */
#define R_DIR24         04        /* UNUSED                                 */
#define R_REL24         05        /* 24 bits, direct                        */
#define R_DIR32         06        /* UNUSED                                 */
#define R_RELBYTE      017        /* 8 bits, direct                         */
#define R_RELWORD      020        /* 16 bits, direct                        */
#define R_RELLONG      021        /* 32 bits, direct                        */
#define R_PCRBYTE      022        /* 8 bits, PC-relative                    */
#define R_PCRWORD      023        /* 16 bits, PC-relative                   */
#define R_PCRLONG      024        /* 32 bits, PC-relative                   */
#define R_OCRLONG      030        /* GSP: 32 bits, one's complement direct  */
#define R_GSPPCR16     031        /* GSP: 16 bits, PC relative (in words)   */
#define R_GSPOPR32     032        /* GSP: 32 bits, direct big-endian        */
#define R_PARTLS16     040        /* Brahma: 16 bit offset of 24 bit address*/
#define R_PARTMS8      041        /* Brahma: 8 bit page of 24 bit address   */
#define R_PARTLS7      050        /* DSP: 7 bit offset of 16 bit address    */
#define R_PARTMS9      051        /* DSP: 9 bit page of 16 bit address      */
#define R_REL13        052        /* DSP: 13 bits, direct                   */


/*------------------------------------------------------------------------*/
/*  LINE NUMBER ENTRIES                                                   */
/*------------------------------------------------------------------------*/
struct lineno
{
	union
	{
		long    l_symndx ;      /* sym. table index of function name
                                                iff l_lnno == 0      */
		long    l_paddr ;       /* (physical) address of line number */
	}               l_addr ;
	unsigned short  l_lnno ;        /* line number */
};

#define LINENO  struct lineno
#define LINESZ  6       /* sizeof(LINENO) */


/*------------------------------------------------------------------------*/
/*   STORAGE CLASSES                                                      */
/*------------------------------------------------------------------------*/
#define  C_EFCN          -1    /* physical end of function */
#define  C_NULL          0
#define  C_AUTO          1     /* automatic variable */
#define  C_EXT           2     /* external symbol */
#define  C_STAT          3     /* static */
#define  C_REG           4     /* register variable */
#define  C_EXTDEF        5     /* external definition */
#define  C_LABEL         6     /* label */
#define  C_ULABEL        7     /* undefined label */
#define  C_MOS           8     /* member of structure */
#define  C_ARG           9     /* function argument */
#define  C_STRTAG        10    /* structure tag */
#define  C_MOU           11    /* member of union */
#define  C_UNTAG         12    /* union tag */
#define  C_TPDEF         13    /* type definition */
#define C_USTATIC        14    /* undefined static */
#define  C_ENTAG         15    /* enumeration tag */
#define  C_MOE           16    /* member of enumeration */
#define  C_REGPARM       17    /* register parameter */
#define  C_FIELD         18    /* bit field */

#define  C_BLOCK         100   /* ".bb" or ".eb" */
#define  C_FCN           101   /* ".bf" or ".ef" */
#define  C_EOS           102   /* end of structure */
#define  C_FILE          103   /* file name */
#define  C_LINE          104   /* dummy sclass for line number entry */
#define  C_ALIAS         105   /* duplicate tag */
#define  C_HIDDEN        106   /* special storage class for external */
/* symbols in dmert public libraries  */

/*------------------------------------------------------------------------*/
/*  SYMBOL TABLE ENTRIES                                                  */
/*------------------------------------------------------------------------*/

#define  SYMNMLEN   8      /*  Number of characters in a symbol name */
#define  FILNMLEN   14     /*  Number of characters in a file name */
#define  DIMNUM     4      /*  Number of array dimensions in auxiliary entry */


struct syment
{
	union
	{
		char            _n_name[SYMNMLEN];      /* old COFF version */
		struct
		{
			long    _n_zeroes;      /* new == 0 */
			long    _n_offset;      /* offset into string table */
		} _n_n;
		char            *_n_nptr[2];    /* allows for overlaying */
	} _n;
	long                    n_value;        /* value of symbol */
	short                   n_scnum;        /* section number */
	unsigned short          n_type;         /* type and derived type */
	char                    n_sclass;       /* storage class */
	char                    n_numaux;       /* number of aux. entries */
};

#define n_name          _n._n_name
#define n_nptr          _n._n_nptr[1]
#define n_zeroes        _n._n_n._n_zeroes
#define n_offset        _n._n_n._n_offset

/*------------------------------------------------------------------------*/
/* Relocatable symbols have a section number of the                       */
/* section in which they are defined.  Otherwise, section                 */
/* numbers have the following meanings:                                   */
/*------------------------------------------------------------------------*/
#define  N_UNDEF  0                     /* undefined symbol */
#define  N_ABS    -1                    /* value of symbol is absolute */
#define  N_DEBUG  -2                    /* special debugging symbol  */
#define  N_TV     (unsigned short)-3    /* needs transfer vector (preload) */
#define  P_TV     (unsigned short)-4    /* needs transfer vector (postload) */


/*------------------------------------------------------------------------*/
/* The fundamental type of a symbol packed into the low                   */
/* 4 bits of the word.                                                    */
/*------------------------------------------------------------------------*/
#define  _EF    ".ef"

#define  T_NULL     0          /* no type info */
#define  T_ARG      1          /* function argument (only used by compiler) */
#define  T_CHAR     2          /* character */
#define  T_SHORT    3          /* short integer */
#define  T_INT      4          /* integer */
#define  T_LONG     5          /* long integer */
#define  T_FLOAT    6          /* floating point */
#define  T_DOUBLE   7          /* double word */
#define  T_STRUCT   8          /* structure  */
#define  T_UNION    9          /* union  */
#define  T_ENUM     10         /* enumeration  */
#define  T_MOE      11         /* member of enumeration */
#define  T_UCHAR    12         /* unsigned character */
#define  T_USHORT   13         /* unsigned short */
#define  T_UINT     14         /* unsigned integer */
#define  T_ULONG    15         /* unsigned long */

/*------------------------------------------------------------------------*/
/* derived types are:                                                     */
/*------------------------------------------------------------------------*/
#define  DT_NON      0          /* no derived type */
#define  DT_PTR      1          /* pointer */
#define  DT_FCN      2          /* function */
#define  DT_ARY      3          /* array */

#define MKTYPE(basic, d1,d2,d3,d4,d5,d6) \
       ((basic) | ((d1) <<  4) | ((d2) <<  6) | ((d3) <<  8) |\
                  ((d4) << 10) | ((d5) << 12) | ((d6) << 14))

/*------------------------------------------------------------------------*/
/* type packing constants and macros                                      */
/*------------------------------------------------------------------------*/
#define  N_BTMASK_COFF     017
#define  N_TMASK_COFF      060
#define  N_TMASK1_COFF     0300
#define  N_TMASK2_COFF     0360
#define  N_BTSHFT_COFF     4
#define  N_TSHIFT_COFF     2

#define  BTYPE_COFF(x)  ((x) & N_BTMASK_COFF)
#define  ISINT(x)  (((x) >= T_CHAR && (x) <= T_LONG) ||   \
		    ((x) >= T_UCHAR && (x) <= T_ULONG) || (x) == T_ENUM)
#define  ISFLT_COFF(x)  ((x) == T_DOUBLE || (x) == T_FLOAT)
#define  ISPTR_COFF(x)  (((x) & N_TMASK_COFF) == (DT_PTR << N_BTSHFT_COFF))
#define  ISFCN_COFF(x)  (((x) & N_TMASK_COFF) == (DT_FCN << N_BTSHFT_COFF))
#define  ISARY_COFF(x)  (((x) & N_TMASK_COFF) == (DT_ARY << N_BTSHFT_COFF))
#define  ISTAG_COFF(x)  ((x)==C_STRTAG || (x)==C_UNTAG || (x)==C_ENTAG)

#define  INCREF_COFF(x) ((((x)&~N_BTMASK_COFF)<<N_TSHIFT_COFF)|(DT_PTR<<N_BTSHFT_COFF)|(x&N_BTMASK_COFF))
#define  DECREF_COFF(x) ((((x)>>N_TSHIFT_COFF)&~N_BTMASK_COFF)|((x)&N_BTMASK_COFF))


/*------------------------------------------------------------------------*/
/*  AUXILIARY SYMBOL ENTRY                                                */
/*------------------------------------------------------------------------*/
union auxent
{
	struct
	{
		long            x_tagndx;       /* str, un, or enum tag indx */
		union
		{
			struct
			{
				unsigned short  x_lnno; /* declaration line number */
				unsigned short  x_size; /* str, union, array size */
			} x_lnsz;
			long    x_fsize;        /* size of function */
		} x_misc;
		union
		{
			struct                  /* if ISFCN, tag, or .bb */
			{
				long    x_lnnoptr;      /* ptr to fcn line # */
				long    x_endndx;       /* entry ndx past block end */
			}       x_fcn;
			struct                  /* if ISARY, up to 4 dimen. */
			{
				unsigned short  x_dimen[DIMNUM];
			}       x_ary;
		}               x_fcnary;
		unsigned short  x_regcount;   /* number of registers used by func */
	}       x_sym;
	struct
	{
		char    x_fname[FILNMLEN];
	}       x_file;
	struct
	{
		long    x_scnlen;          /* section length */
		unsigned short  x_nreloc;  /* number of relocation entries */
		unsigned short  x_nlinno;  /* number of line numbers */
	}       x_scn;
};

#define SYMENT  struct syment
#define SYMESZ  18      /* sizeof(SYMENT) */

#define AUXENT  union auxent
#define AUXESZ  18      /* sizeof(AUXENT) */

/*------------------------------------------------------------------------*/
/*  NAMES OF "SPECIAL" SYMBOLS                                            */
/*------------------------------------------------------------------------*/
#define _STEXT          ".text"
#define _ETEXT          "etext"
#define _SDATA          ".data"
#define _EDATA          "edata"
#define _SBSS           ".bss"
#define _END            "end"
#define _CINITPTR       "cinit"

/*--------------------------------------------------------------------------*/
/*  ENTRY POINT SYMBOLS                                                     */
/*--------------------------------------------------------------------------*/
#define _START          "_start"
#define _MAIN           "_main"
/*  _CSTART         "_c_int00"          (defined in params.h)  */


#define _TVORIG         "_tvorig"
#define _TORIGIN        "_torigin"
#define _DORIGIN        "_dorigin"

#define _SORIGIN        "_sorigin"

/* #define ASSEMBLY_LISTING_C67 */

/* number of available registers */
#define NB_REGS            24

/* a register can belong to several classes. The classes must be
   sorted from more general to more precise (see gv2() code which does
   assumptions on it). */
#define RC_INT     0x0001	/* generic integer register */
#define RC_FLOAT   0x0002	/* generic float register */
#define RC_EAX     0x0004
#define RC_ST0     0x0008
#define RC_ECX     0x0010
#define RC_EDX     0x0020
#define RC_INT_BSIDE  0x00000040	/* generic integer register  on b side */
#define RC_C67_A4     0x00000100
#define RC_C67_A5     0x00000200
#define RC_C67_B4     0x00000400
#define RC_C67_B5     0x00000800
#define RC_C67_A6     0x00001000
#define RC_C67_A7     0x00002000
#define RC_C67_B6     0x00004000
#define RC_C67_B7     0x00008000
#define RC_C67_A8     0x00010000
#define RC_C67_A9     0x00020000
#define RC_C67_B8     0x00040000
#define RC_C67_B9     0x00080000
#define RC_C67_A10    0x00100000
#define RC_C67_A11    0x00200000
#define RC_C67_B10    0x00400000
#define RC_C67_B11    0x00800000
#define RC_C67_A12    0x01000000
#define RC_C67_A13    0x02000000
#define RC_C67_B12    0x04000000
#define RC_C67_B13    0x08000000
#define RC_IRET    RC_C67_A4	/* function return: integer register */
#define RC_IRE2    RC_C67_A5	/* function return: second integer register */
#define RC_FRET    RC_C67_A4	/* function return: float register */

/* pretty names for the registers */
enum
{
	TREG_EAX = 0,		// really A2
	TREG_ECX,			// really A3
	TREG_EDX,			// really B0
	TREG_ST0,			// really B1
	TREG_C67_A4,
	TREG_C67_A5,
	TREG_C67_B4,
	TREG_C67_B5,
	TREG_C67_A6,
	TREG_C67_A7,
	TREG_C67_B6,
	TREG_C67_B7,
	TREG_C67_A8,
	TREG_C67_A9,
	TREG_C67_B8,
	TREG_C67_B9,
	TREG_C67_A10,
	TREG_C67_A11,
	TREG_C67_B10,
	TREG_C67_B11,
	TREG_C67_A12,
	TREG_C67_A13,
	TREG_C67_B12,
	TREG_C67_B13,
};

/* return registers for function */
#define REG_IRET TREG_C67_A4	/* single word int return register */
#define REG_IRE2 TREG_C67_A5    /* second word return register (for long long) */
#define REG_FRET TREG_C67_A4	/* float return register */

/* defined if function parameters must be evaluated in reverse order */
/* #define INVERT_FUNC_PARAMS */

/* defined if structures are passed as pointers. Otherwise structures
   are directly pushed on stack. */
/* #define FUNC_STRUCT_PARAM_AS_PTR */

/* pointer size, in bytes */
#define PTR_SIZE 4

/* long double size and alignment, in bytes */
#define LDOUBLE_SIZE  12
#define LDOUBLE_ALIGN 4
/* maximum alignment (for aligned attribute support) */
#define MAX_ALIGN     8


#define EM_TCC_TARGET EM_C60

/* relocation type for 32 bit data relocation */
#define R_DATA_32   R_C60_32
#define R_DATA_PTR  R_C60_32
#define R_JMP_SLOT  R_C60_JMP_SLOT
#define R_GLOB_DAT  R_C60_GLOB_DAT
#define R_COPY      R_C60_COPY
#define R_RELATIVE  R_C60_RELATIVE

#define R_NUM       R_C60_NUM

#define ELF_START_ADDR 0x00000400
#define ELF_PAGE_SIZE  0x1000

#define PCRELATIVE_DLLPLT 0
#define RELOCATE_DLLPLT 0

#elif defined(TCC_TARGET_RISCV64)

// Number of registers available to allocator:
#define NB_REGS 19 // x10-x17 aka a0-a7, f10-f17 aka fa0-fa7, xxx, ra, sp

#define TREG_R(x) (x) // x = 0..7
#define TREG_F(x) (x + 8) // x = 0..7

// Register classes sorted from more general to more precise:
#define RC_INT (1 << 0)
#define RC_FLOAT (1 << 1)
#define RC_R(x) (1 << (2 + (x))) // x = 0..7
#define RC_F(x) (1 << (10 + (x))) // x = 0..7

#define RC_IRET (RC_R(0)) // int return register class
#define RC_IRE2 (RC_R(1)) // int 2nd return register class
#define RC_FRET (RC_F(0)) // float return register class

#define REG_IRET (TREG_R(0)) // int return register number
#define REG_IRE2 (TREG_R(1)) // int 2nd return register number
#define REG_FRET (TREG_F(0)) // float return register number

#define PTR_SIZE 8

#define LDOUBLE_SIZE 16
#define LDOUBLE_ALIGN 16

#define MAX_ALIGN 16

#define CHAR_IS_UNSIGNED

#define EM_TCC_TARGET EM_RISCV

#define R_DATA_32  R_RISCV_32
#define R_DATA_PTR R_RISCV_64
#define R_JMP_SLOT R_RISCV_JUMP_SLOT
#define R_GLOB_DAT R_RISCV_64
#define R_COPY     R_RISCV_COPY
#define R_RELATIVE R_RISCV_RELATIVE

#define R_NUM      R_RISCV_NUM

#define ELF_START_ADDR 0x00010000
#define ELF_PAGE_SIZE 0x1000

#define PCRELATIVE_DLLPLT 1
#define RELOCATE_DLLPLT 1

#else
#error unknown target
#endif

//END DEFINES 


/* -------------------------------------------- */


#if PTR_SIZE == 8
# define ELFCLASSW ELFCLASS64
# define ElfW(type) Elf##64##_##type
# define ELFW(type) ELF##64##_##type
# define ElfW_Rel ElfW(Rela)
# define SHT_RELX SHT_RELA
# define REL_SECTION_FMT ".rela%s"
#else
# define ELFCLASSW ELFCLASS32
# define ElfW(type) Elf##32##_##type
# define ELFW(type) ELF##32##_##type
# define ElfW_Rel ElfW(Rel)
# define SHT_RELX SHT_REL
# define REL_SECTION_FMT ".rel%s"
#endif
/* target address type */
#define addr_t ElfW(Addr)
#define ElfSym ElfW(Sym)

#if PTR_SIZE == 8 && !defined TCC_TARGET_PE
# define LONG_SIZE 8
#else
# define LONG_SIZE 4
#endif

/* -------------------------------------------- */

#define INCLUDE_STACK_SIZE  32
#define IFDEF_STACK_SIZE    64
#define VSTACK_SIZE         256
#define STRING_MAX_SIZE     1024
#define TOKSTR_MAX_SIZE     256
#define PACK_STACK_SIZE     8

#define TOK_HASH_SIZE       16384 /* must be a power of two */
#define TOK_ALLOC_INCR      512  /* must be a power of two */
#define TOK_MAX_SIZE        4 /* token max size in int unit when stored in string */

/* token symbol management */
typedef struct TokenSym
{
	struct TokenSym *hash_next;
	struct Sym *sym_define; /* direct pointer to define */
	struct Sym *sym_label; /* direct pointer to label */
	struct Sym *sym_struct; /* direct pointer to structure */
	struct Sym *sym_identifier; /* direct pointer to identifier */
	int tok; /* token number */
	int len;
	char str[1];
} TokenSym;

#ifdef TCC_TARGET_PE
typedef unsigned short nwchar_t;
#else
typedef int nwchar_t;
#endif

typedef struct CString
{
	int size; /* size in bytes */
	void *data; /* either 'char *' or 'nwchar_t *' */
	int size_allocated;
} CString;

/* type definition */
typedef struct CType
{
	int t;
	struct Sym *ref;
} CType;

/* constant value */
typedef union CValue
{
	long double ld;
	double d;
	float f;
	uint64_t i;
	struct
	{
		int size;
		const void *data;
	} str;
	int tab[LDOUBLE_SIZE/4];
} CValue;

/* value on stack */
typedef struct SValue
{
	CType type;      /* type */
	unsigned short r;      /* register + flags */
	unsigned short r2;     /* second register, used for 'long long'
                              type. If not used, set to VT_CONST */
	union
	{
		struct
		{
			int jtrue, jfalse;
		}; /* forward jmps */
		CValue c;         /* constant, if VT_CONST */
	};
	union
	{
		struct
		{
			unsigned short cmp_op, cmp_r;
		}; /* VT_CMP operation */
		struct Sym *sym;  /* symbol, if (VT_SYM | VT_CONST), or if */
	};                  /* result of unary() for an identifier. */

} SValue;

/* symbol attributes */
struct SymAttr
{
	unsigned short
	aligned     : 5, /* alignment as log2+1 (0 == unspecified) */
	            packed      : 1,
	            weak        : 1,
	            visibility  : 2,
	            dllexport   : 1,
	            nodecorate  : 1,
	            dllimport   : 1,
	            addrtaken   : 1,
	            xxxx        : 3; /* not used */
};

/* function attributes or temporary attributes for parsing */
struct FuncAttr
{
	unsigned
	func_call   : 3, /* calling convention (0..5), see below */
	            func_type   : 2, /* FUNC_OLD/NEW/ELLIPSIS */
	            func_noreturn : 1, /* attribute((noreturn)) */
	            func_ctor   : 1, /* attribute((constructor)) */
	            func_dtor   : 1, /* attribute((destructor)) */
	            func_args   : 8; /* PE __stdcall args */
};

/* symbol management */
typedef struct Sym
{
	int v; /* symbol token */
	unsigned short r; /* associated register or VT_CONST/VT_LOCAL and LVAL type */
	struct SymAttr a; /* symbol attributes */
	union
	{
		struct
		{
			int c; /* associated number or Elf symbol index */
			union
			{
				int sym_scope; /* scope level for locals */
				int jnext; /* next jump label */
				struct FuncAttr f; /* function attributes */
				int auxtype; /* bitfield access type */
			};
		};
		long long enum_val; /* enum constant if IS_ENUM_VAL */
		int *d; /* define token stream */
		struct Sym *ncl; /* next cleanup */
	};
	CType type; /* associated type */
	union
	{
		struct Sym *next; /* next related symbol (for fields and anoms) */
		struct Sym *cleanupstate; /* in defined labels */
		int asm_label; /* associated asm label */
	};
	struct Sym *prev; /* prev symbol in stack */
	struct Sym *prev_tok; /* previous symbol for this token */
} Sym;

/* section definition */
typedef struct Section
{
	unsigned long data_offset; /* current data offset */
	unsigned char *data;       /* section data */
	unsigned long data_allocated; /* used for realloc() handling */
	TCCState *s1;
	int sh_name;             /* elf section name (only used during output) */
	int sh_num;              /* elf section number */
	int sh_type;             /* elf section type */
	int sh_flags;            /* elf section flags */
	int sh_info;             /* elf section info */
	int sh_addralign;        /* elf section alignment */
	int sh_entsize;          /* elf entry size */
	unsigned long sh_size;   /* section size (only used during output) */
	addr_t sh_addr;          /* address at which the section is relocated */
	unsigned long sh_offset; /* file offset */
	int nb_hashed_syms;      /* used to resize the hash table */
	struct Section *link;    /* link to another section */
	struct Section *reloc;   /* corresponding section for relocation, if any */
	struct Section *hash;    /* hash table for symbols */
	struct Section *prev;    /* previous section on section stack */
	char name[1];           /* section name */
} Section;

typedef struct DLLReference
{
	int level;
	void *handle;
	char name[1];
} DLLReference;

/* -------------------------------------------------- */

#define SYM_STRUCT     0x40000000 /* struct/union/enum symbol space */
#define SYM_FIELD      0x20000000 /* struct/union field symbol space */
#define SYM_FIRST_ANOM 0x10000000 /* first anonymous sym */

/* stored in 'Sym->f.func_type' field */
#define FUNC_NEW       1 /* ansi function prototype */
#define FUNC_OLD       2 /* old function prototype */
#define FUNC_ELLIPSIS  3 /* ansi function prototype with ... */

/* stored in 'Sym->f.func_call' field */
#define FUNC_CDECL     0 /* standard c call */
#define FUNC_STDCALL   1 /* pascal c call */
#define FUNC_FASTCALL1 2 /* first param in %eax */
#define FUNC_FASTCALL2 3 /* first parameters in %eax, %edx */
#define FUNC_FASTCALL3 4 /* first parameter in %eax, %edx, %ecx */
#define FUNC_FASTCALLW 5 /* first parameter in %ecx, %edx */

/* field 'Sym.t' for macros */
#define MACRO_OBJ      0 /* object like macro */
#define MACRO_FUNC     1 /* function like macro */

/* field 'Sym.r' for C labels */
#define LABEL_DEFINED  0 /* label is defined */
#define LABEL_FORWARD  1 /* label is forward defined */
#define LABEL_DECLARED 2 /* label is declared but never used */

/* type_decl() types */
#define TYPE_ABSTRACT  1 /* type without variable */
#define TYPE_DIRECT    2 /* type with variable */

#define IO_BUF_SIZE 8192

typedef struct BufferedFile
{
	uint8_t *buf_ptr;
	uint8_t *buf_end;
	int fd;
	struct BufferedFile *prev;
	int line_num;    /* current line number - here to simplify code */
	int line_ref;    /* tcc -E: last printed line */
	int ifndef_macro;  /* #ifndef macro / #endif search */
	int ifndef_macro_saved; /* saved ifndef_macro */
	int *ifdef_stack_ptr; /* ifdef_stack value at the start of the file */
	int include_next_index; /* next search path */
	char filename[1024];    /* filename */
	char *true_filename; /* filename not modified by # line directive */
	unsigned char unget[4];
	unsigned char buffer[1]; /* extra size for CH_EOB char */
} BufferedFile;

#define CH_EOB   '\\'       /* end of buffer or '\0' char in file */
#define CH_EOF   (-1)   /* end of file */

/* used to record tokens */
typedef struct TokenString
{
	int *str;
	int len;
	int lastlen;
	int allocated_len;
	int last_line_num;
	int save_line_num;
	/* used to chain token-strings with begin/end_macro() */
	struct TokenString *prev;
	const int *prev_ptr;
	char alloc;
} TokenString;

/* GNUC attribute definition */
typedef struct AttributeDef
{
	struct SymAttr a;
	struct FuncAttr f;
	struct Section *section;
	Sym *cleanup_func;
	int alias_target; /* token */
	int asm_label; /* associated asm label */
	char attr_mode; /* __attribute__((__mode__(...))) */
} AttributeDef;

/* inline functions */
typedef struct InlineFunc
{
	TokenString *func_str;
	Sym *sym;
	char filename[1];
} InlineFunc;

/* include file cache, used to find files faster and also to eliminate
   inclusion if the include file is protected by #ifndef ... #endif */
typedef struct CachedInclude
{
	int ifndef_macro;
	int once;
	int hash_next; /* -1 if none */
	char filename[1]; /* path specified in #include */
} CachedInclude;

#define CACHED_INCLUDES_HASH_SIZE 32

#ifdef CONFIG_TCC_ASM
typedef struct ExprValue
{
	uint64_t v;
	Sym *sym;
	int pcrel;
} ExprValue;

#define MAX_ASM_OPERANDS 30
typedef struct ASMOperand
{
	int id; /* GCC 3 optional identifier (0 if number only supported */
	char *constraint;
	char asm_str[16]; /* computed asm string for operand */
	SValue *vt; /* C value of the expression */
	int ref_index; /* if >= 0, gives reference to a output constraint */
	int input_index; /* if >= 0, gives reference to an input constraint */
	int priority; /* priority, used to assign registers */
	int reg; /* if >= 0, register number used for this operand */
	int is_llong; /* true if double register value */
	int is_memory; /* true if memory operand */
	int is_rw;     /* for '+' modifier */
} ASMOperand;
#endif

/* extra symbol attributes (not in symbol table) */
struct sym_attr
{
	unsigned got_offset;
	unsigned plt_offset;
	int plt_sym;
	int dyn_index;
#ifdef TCC_TARGET_ARM
	unsigned char plt_thumb_stub:1;
#endif
};

struct TCCState
{
	unsigned char verbose; /* if true, display some information during compilation */
	unsigned char nostdinc; /* if true, no standard headers are added */
	unsigned char nostdlib; /* if true, no standard libraries are added */
	unsigned char nocommon; /* if true, do not use common symbols for .bss data */
	unsigned char static_link; /* if true, static linking is performed */
	unsigned char rdynamic; /* if true, all symbols are exported */
	unsigned char symbolic; /* if true, resolve symbols in the current module first */
	unsigned char filetype; /* file type for compilation (NONE,C,ASM) */
	unsigned int  cversion; /* supported C ISO version, 199901 (the default), 201112, ... */

	char *tcc_lib_path; /* CONFIG_TCCDIR or -B option */
	char *soname; /* as specified on the command line (-soname) */
	char *rpath; /* as specified on the command line (-Wl,-rpath=) */
	unsigned char enable_new_dtags; /* ditto, (-Wl,--enable-new-dtags) */

	/* output type, see TCC_OUTPUT_XXX */
	int output_type;
	/* output format, see TCC_OUTPUT_FORMAT_xxx */
	int output_format;

	/* C language options */
	unsigned char char_is_unsigned;
	unsigned char leading_underscore;
	unsigned char ms_extensions; /* allow nested named struct w/o identifier behave like unnamed */
	unsigned char dollars_in_identifiers;  /* allows '$' char in identifiers */
	unsigned char ms_bitfields; /* if true, emulate MS algorithm for aligning bitfields */
	/*Inline asm */
	unsigned char intelasm;

	/* warning switches */
	unsigned char warn_write_strings;
	unsigned char warn_unsupported;
	unsigned char warn_error;
	unsigned char warn_none;
	unsigned char warn_implicit_function_declaration;
	unsigned char warn_gcc_compat;

	/* compile with debug symbol (and use them if error during execution) */
	unsigned char do_debug;
	unsigned char do_backtrace;
#ifdef CONFIG_TCC_BCHECK
	/* compile with built-in memory and bounds checker */
	unsigned char do_bounds_check;
#endif
#ifdef TCC_TARGET_ARM
	enum float_abi float_abi; /* float ABI of the generated code*/
#endif
	int run_test; /* nth test to run with -dt -run */

	addr_t text_addr; /* address of text section */
	unsigned char has_text_addr;

	unsigned section_align; /* section alignment */

	/* use GNU C extensions */
	unsigned char gnu_ext;
	/* use TinyCC extensions */
	unsigned char tcc_ext;

	char *init_symbol; /* symbols to call at load-time (not used currently) */
	char *fini_symbol; /* symbols to call at unload-time (not used currently) */

#ifdef TCC_TARGET_I386
	int seg_size; /* 32. Can be 16 with i386 assembler (.code16) */
#endif
#ifdef TCC_TARGET_X86_64
	unsigned char nosse; /* For -mno-sse support. */
#endif

	/* array of all loaded dlls (including those referenced by loaded dlls) */
	DLLReference **loaded_dlls;
	int nb_loaded_dlls;

	/* include paths */
	char **include_paths;
	int nb_include_paths;

	char **sysinclude_paths;
	int nb_sysinclude_paths;

	/* library paths */
	char **library_paths;
	int nb_library_paths;

	/* crt?.o object path */
	char **crt_paths;
	int nb_crt_paths;

	/* -D / -U options */
	CString cmdline_defs;
	/* -include options */
	CString cmdline_incl;

	/* error handling */
	void *error_opaque;
	void (*error_func)(void *opaque, const char *msg);
	int error_set_jmp_enabled;
	jmp_buf error_jmp_buf;
	int nb_errors;

	/* output file for preprocessing (-E) */
	FILE *ppfp;
	enum
	{
		LINE_MACRO_OUTPUT_FORMAT_GCC,
		LINE_MACRO_OUTPUT_FORMAT_NONE,
		LINE_MACRO_OUTPUT_FORMAT_STD,
		LINE_MACRO_OUTPUT_FORMAT_P10 = 11
	} Pflag; /* -P switch */
	char dflag; /* -dX value */

	/* for -MD/-MF: collected dependencies for this compilation */
	char **target_deps;
	int nb_target_deps;

	/* compilation */
	BufferedFile *include_stack[INCLUDE_STACK_SIZE];
	BufferedFile **include_stack_ptr;

	int ifdef_stack[IFDEF_STACK_SIZE];
	int *ifdef_stack_ptr;

	/* included files enclosed with #ifndef MACRO */
	int cached_includes_hash[CACHED_INCLUDES_HASH_SIZE];
	CachedInclude **cached_includes;
	int nb_cached_includes;

	/* #pragma pack stack */
	int pack_stack[PACK_STACK_SIZE];
	int *pack_stack_ptr;
	char **pragma_libs;
	int nb_pragma_libs;

	/* inline functions are stored as token lists and compiled last
	   only if referenced */
	struct InlineFunc **inline_fns;
	int nb_inline_fns;

	/* sections */
	Section **sections;
	int nb_sections; /* number of sections, including first dummy section */

	Section **priv_sections;
	int nb_priv_sections; /* number of private sections */

	/* got & plt handling */
	Section *got;
	Section *plt;

	/* predefined sections */
	Section *text_section, *data_section, *bss_section;
	Section *common_section;
	Section *cur_text_section; /* current section where function code is generated */
#ifdef CONFIG_TCC_BCHECK
	/* bound check related sections */
	Section *bounds_section; /* contains global data bound description */
	Section *lbounds_section; /* contains local data bound description */
#endif
	/* symbol sections */
	Section *symtab_section;
	/* debug sections */
	Section *stab_section;
	/* Is there a new undefined sym since last new_undef_sym() */
	int new_undef_sym;

	/* temporary dynamic symbol sections (for dll loading) */
	Section *dynsymtab_section;
	/* exported dynamic symbol section */
	Section *dynsym;
	/* copy of the global symtab_section variable */
	Section *symtab;
	/* extra attributes (eg. GOT/PLT value) for symtab symbols */
	struct sym_attr *sym_attrs;
	int nb_sym_attrs;
	/* ptr to next reloc entry reused */
	ElfW_Rel *qrel;
#   define qrel s1->qrel

#ifdef TCC_TARGET_PE
	/* PE info */
	int pe_subsystem;
	unsigned pe_characteristics;
	unsigned pe_file_align;
	unsigned pe_stack_size;
	addr_t pe_imagebase;
# ifdef TCC_TARGET_X86_64
	Section *uw_pdata;
	int uw_sym;
	unsigned uw_offs;
# endif
# define ELF_OBJ_ONLY
#endif

#ifndef ELF_OBJ_ONLY
	int nb_sym_versions;
	struct sym_version *sym_versions;
	int nb_sym_to_version;
	int *sym_to_version;
	int dt_verneednum;
	Section *versym_section;
	Section *verneed_section;
#endif

#ifdef TCC_IS_NATIVE
	const char *runtime_main;
	void **runtime_mem;
	int nb_runtime_mem;
#endif

#ifdef CONFIG_TCC_BACKTRACE
	int rt_num_callers;
#endif

	int fd, cc; /* used by tcc_load_ldscript */

	/* benchmark info */
	int total_idents;
	int total_lines;
	int total_bytes;

	/* option -dnum (for general development purposes) */
	int g_debug;

	/* used by main and tcc_parse_args only */
	struct filespec **files; /* files seen on command line */
	int nb_files; /* number thereof */
	int nb_libraries; /* number of libs thereof */
	char *outfile; /* output filename */
	unsigned char option_r; /* option -r */
	unsigned char do_bench; /* option -bench */
	int gen_deps; /* option -MD  */
	char *deps_outfile; /* option -MF */
	unsigned char option_pthread; /* -pthread option */
	int argc;
	char **argv;
};

struct filespec
{
	char type;
	char name[1];
};

/* The current value can be: */
#define VT_VALMASK   0x003f  /* mask for value location, register or: */
#define VT_CONST     0x0030  /* constant in vc (must be first non register value) */
#define VT_LLOCAL    0x0031  /* lvalue, offset on stack */
#define VT_LOCAL     0x0032  /* offset on stack */
#define VT_CMP       0x0033  /* the value is stored in processor flags (in vc) */
#define VT_JMP       0x0034  /* value is the consequence of jmp true (even) */
#define VT_JMPI      0x0035  /* value is the consequence of jmp false (odd) */
#define VT_LVAL      0x0100  /* var is an lvalue */
#define VT_SYM       0x0200  /* a symbol value is added */
#define VT_MUSTCAST  0x0C00  /* value must be casted to be correct (used for
                                char/short stored in integer registers) */
#define VT_MUSTBOUND 0x4000  /* bound checking must be done before
                                dereferencing value */
#define VT_BOUNDED   0x8000  /* value is bounded. The address of the
                                bounding function call point is in vc */
/* types */
#define VT_BTYPE       0x000f  /* mask for basic type */
#define VT_VOID             0  /* void type */
#define VT_BYTE             1  /* signed byte type */
#define VT_SHORT            2  /* short type */
#define VT_INT              3  /* integer type */
#define VT_LLONG            4  /* 64 bit integer */
#define VT_PTR              5  /* pointer */
#define VT_FUNC             6  /* function type */
#define VT_STRUCT           7  /* struct/union definition */
#define VT_FLOAT            8  /* IEEE float */
#define VT_DOUBLE           9  /* IEEE double */
#define VT_LDOUBLE         10  /* IEEE long double */
#define VT_BOOL            11  /* ISOC99 boolean type */
#define VT_QLONG           13  /* 128-bit integer. Only used for x86-64 ABI */
#define VT_QFLOAT          14  /* 128-bit float. Only used for x86-64 ABI */

#define VT_UNSIGNED    0x0010  /* unsigned type */
#define VT_DEFSIGN     0x0020  /* explicitly signed or unsigned */
#define VT_ARRAY       0x0040  /* array type (also has VT_PTR) */
#define VT_BITFIELD    0x0080  /* bitfield modifier */
#define VT_CONSTANT    0x0100  /* const modifier */
#define VT_VOLATILE    0x0200  /* volatile modifier */
#define VT_VLA         0x0400  /* VLA type (also has VT_PTR and VT_ARRAY) */
#define VT_LONG        0x0800  /* long type (also has VT_INT rsp. VT_LLONG) */

/* storage */
#define VT_EXTERN  0x00001000  /* extern definition */
#define VT_STATIC  0x00002000  /* static variable */
#define VT_TYPEDEF 0x00004000  /* typedef definition */
#define VT_INLINE  0x00008000  /* inline definition */
/* currently unused: 0x000[1248]0000  */

#define VT_STRUCT_SHIFT 20     /* shift for bitfield shift values (32 - 2*6) */
#define VT_STRUCT_MASK (((1U << (6+6)) - 1) << VT_STRUCT_SHIFT | VT_BITFIELD)
#define BIT_POS(t) (((t) >> VT_STRUCT_SHIFT) & 0x3f)
#define BIT_SIZE(t) (((t) >> (VT_STRUCT_SHIFT + 6)) & 0x3f)

#define VT_UNION    (1 << VT_STRUCT_SHIFT | VT_STRUCT)
#define VT_ENUM     (2 << VT_STRUCT_SHIFT) /* integral type is an enum really */
#define VT_ENUM_VAL (3 << VT_STRUCT_SHIFT) /* integral type is an enum constant really */

#define IS_ENUM(t) ((t & VT_STRUCT_MASK) == VT_ENUM)
#define IS_ENUM_VAL(t) ((t & VT_STRUCT_MASK) == VT_ENUM_VAL)
#define IS_UNION(t) ((t & (VT_STRUCT_MASK|VT_BTYPE)) == VT_UNION)

/* type mask (except storage) */
#define VT_STORAGE (VT_EXTERN | VT_STATIC | VT_TYPEDEF | VT_INLINE)
#define VT_TYPE (~(VT_STORAGE|VT_STRUCT_MASK))

/* symbol was created by tccasm.c first */
#define VT_ASM (VT_VOID | VT_UNSIGNED)
#define IS_ASM_SYM(sym) (((sym)->type.t & (VT_BTYPE | VT_ASM)) == VT_ASM)

/* general: set/get the pseudo-bitfield value for bit-mask M */
#define BFVAL(M,N) ((unsigned)((M) & ~((M) << 1)) * (N))
#define BFGET(X,M) (((X) & (M)) / BFVAL(M,1))
#define BFSET(X,M,N) ((X) = ((X) & ~(M)) | BFVAL(M,N))

/* token values */

/* warning: the following compare tokens depend on i386 asm code */
#define TOK_ULT 0x92
#define TOK_UGE 0x93
#define TOK_EQ  0x94
#define TOK_NE  0x95
#define TOK_ULE 0x96
#define TOK_UGT 0x97
#define TOK_Nset 0x98
#define TOK_Nclear 0x99
#define TOK_LT  0x9c
#define TOK_GE  0x9d
#define TOK_LE  0x9e
#define TOK_GT  0x9f

#define TOK_LAND  0xa0
#define TOK_LOR   0xa1
#define TOK_DEC   0xa2
#define TOK_MID   0xa3 /* inc/dec, to void constant */
#define TOK_INC   0xa4
#define TOK_UDIV  0xb0 /* unsigned division */
#define TOK_UMOD  0xb1 /* unsigned modulo */
#define TOK_PDIV  0xb2 /* fast division with undefined rounding for pointers */

/* tokens that carry values (in additional token string space / tokc) --> */
#define TOK_CCHAR   0xb3 /* char constant in tokc */
#define TOK_LCHAR   0xb4
#define TOK_CINT    0xb5 /* number in tokc */
#define TOK_CUINT   0xb6 /* unsigned int constant */
#define TOK_CLLONG  0xb7 /* long long constant */
#define TOK_CULLONG 0xb8 /* unsigned long long constant */
#define TOK_STR     0xb9 /* pointer to string in tokc */
#define TOK_LSTR    0xba
#define TOK_CFLOAT  0xbb /* float constant */
#define TOK_CDOUBLE 0xbc /* double constant */
#define TOK_CLDOUBLE 0xbd /* long double constant */
#define TOK_PPNUM   0xbe /* preprocessor number */
#define TOK_PPSTR   0xbf /* preprocessor string */
#define TOK_LINENUM 0xc0 /* line number info */
#define TOK_TWODOTS 0xa8 /* C++ token ? */
/* <-- */

#define TOK_UMULL    0xc2 /* unsigned 32x32 -> 64 mul */
#define TOK_ADDC1    0xc3 /* add with carry generation */
#define TOK_ADDC2    0xc4 /* add with carry use */
#define TOK_SUBC1    0xc5 /* add with carry generation */
#define TOK_SUBC2    0xc6 /* add with carry use */
#define TOK_ARROW    0xc7
#define TOK_DOTS     0xc8 /* three dots */
#define TOK_SHR      0xc9 /* unsigned shift right */
#define TOK_TWOSHARPS 0xca /* ## preprocessing token */
#define TOK_PLCHLDR  0xcb /* placeholder token as defined in C99 */
#define TOK_NOSUBST  0xcc /* means following token has already been pp'd */
#define TOK_PPJOIN   0xcd /* A '##' in the right position to mean pasting */
#define TOK_CLONG    0xce /* long constant */
#define TOK_CULONG   0xcf /* unsigned long constant */

#define TOK_SHL   0x01 /* shift left */
#define TOK_SAR   0x02 /* signed shift right */

/* assignment operators : normal operator or 0x80 */
#define TOK_A_MOD 0xa5
#define TOK_A_AND 0xa6
#define TOK_A_MUL 0xaa
#define TOK_A_ADD 0xab
#define TOK_A_SUB 0xad
#define TOK_A_DIV 0xaf
#define TOK_A_XOR 0xde
#define TOK_A_OR  0xfc
#define TOK_A_SHL 0x81
#define TOK_A_SAR 0x82

#define TOK_EOF       (-1)  /* end of file */
#define TOK_LINEFEED  10    /* line feed */

/* all identifiers and strings have token above that */
#define TOK_IDENT 256

#define DEF_ASM(x) DEF(TOK_ASM_ ## x, #x)
#define TOK_ASM_int TOK_INT
#define DEF_ASMDIR(x) DEF(TOK_ASMDIR_ ## x, "." #x)
#define TOK_ASMDIR_FIRST TOK_ASMDIR_byte
#define TOK_ASMDIR_LAST TOK_ASMDIR_section

#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
/* only used for i386 asm opcodes definitions */
#define DEF_BWL(x) \
 DEF(TOK_ASM_ ## x ## b, #x "b") \
 DEF(TOK_ASM_ ## x ## w, #x "w") \
 DEF(TOK_ASM_ ## x ## l, #x "l") \
 DEF(TOK_ASM_ ## x, #x)
#define DEF_WL(x) \
 DEF(TOK_ASM_ ## x ## w, #x "w") \
 DEF(TOK_ASM_ ## x ## l, #x "l") \
 DEF(TOK_ASM_ ## x, #x)
#ifdef TCC_TARGET_X86_64
# define DEF_BWLQ(x) \
 DEF(TOK_ASM_ ## x ## b, #x "b") \
 DEF(TOK_ASM_ ## x ## w, #x "w") \
 DEF(TOK_ASM_ ## x ## l, #x "l") \
 DEF(TOK_ASM_ ## x ## q, #x "q") \
 DEF(TOK_ASM_ ## x, #x)
# define DEF_WLQ(x) \
 DEF(TOK_ASM_ ## x ## w, #x "w") \
 DEF(TOK_ASM_ ## x ## l, #x "l") \
 DEF(TOK_ASM_ ## x ## q, #x "q") \
 DEF(TOK_ASM_ ## x, #x)
# define DEF_BWLX DEF_BWLQ
# define DEF_WLX DEF_WLQ
/* number of sizes + 1 */
# define NBWLX 5
#else
# define DEF_BWLX DEF_BWL
# define DEF_WLX DEF_WL
/* number of sizes + 1 */
# define NBWLX 4
#endif

#define DEF_FP1(x) \
 DEF(TOK_ASM_ ## f ## x ## s, "f" #x "s") \
 DEF(TOK_ASM_ ## fi ## x ## l, "fi" #x "l") \
 DEF(TOK_ASM_ ## f ## x ## l, "f" #x "l") \
 DEF(TOK_ASM_ ## fi ## x ## s, "fi" #x "s")

#define DEF_FP(x) \
 DEF(TOK_ASM_ ## f ## x, "f" #x ) \
 DEF(TOK_ASM_ ## f ## x ## p, "f" #x "p") \
 DEF_FP1(x)

#define DEF_ASMTEST(x,suffix) \
 DEF_ASM(x ## o ## suffix) \
 DEF_ASM(x ## no ## suffix) \
 DEF_ASM(x ## b ## suffix) \
 DEF_ASM(x ## c ## suffix) \
 DEF_ASM(x ## nae ## suffix) \
 DEF_ASM(x ## nb ## suffix) \
 DEF_ASM(x ## nc ## suffix) \
 DEF_ASM(x ## ae ## suffix) \
 DEF_ASM(x ## e ## suffix) \
 DEF_ASM(x ## z ## suffix) \
 DEF_ASM(x ## ne ## suffix) \
 DEF_ASM(x ## nz ## suffix) \
 DEF_ASM(x ## be ## suffix) \
 DEF_ASM(x ## na ## suffix) \
 DEF_ASM(x ## nbe ## suffix) \
 DEF_ASM(x ## a ## suffix) \
 DEF_ASM(x ## s ## suffix) \
 DEF_ASM(x ## ns ## suffix) \
 DEF_ASM(x ## p ## suffix) \
 DEF_ASM(x ## pe ## suffix) \
 DEF_ASM(x ## np ## suffix) \
 DEF_ASM(x ## po ## suffix) \
 DEF_ASM(x ## l ## suffix) \
 DEF_ASM(x ## nge ## suffix) \
 DEF_ASM(x ## nl ## suffix) \
 DEF_ASM(x ## ge ## suffix) \
 DEF_ASM(x ## le ## suffix) \
 DEF_ASM(x ## ng ## suffix) \
 DEF_ASM(x ## nle ## suffix) \
 DEF_ASM(x ## g ## suffix)

#endif /* defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 */

enum tcc_token
{
	TOK_LAST = TOK_IDENT - 1
#define DEF(id, str) ,id

//START tcctok.h

	           /* keywords */
	           DEF(TOK_INT, "int")
	           DEF(TOK_VOID, "void")
	           DEF(TOK_CHAR, "char")
	           DEF(TOK_IF, "if")
	           DEF(TOK_ELSE, "else")
	           DEF(TOK_WHILE, "while")
	           DEF(TOK_BREAK, "break")
	           DEF(TOK_RETURN, "return")
	           DEF(TOK_FOR, "for")
	           DEF(TOK_EXTERN, "extern")
	           DEF(TOK_STATIC, "static")
	           DEF(TOK_UNSIGNED, "unsigned")
	           DEF(TOK_GOTO, "goto")
	           DEF(TOK_DO, "do")
	           DEF(TOK_CONTINUE, "continue")
	           DEF(TOK_SWITCH, "switch")
	           DEF(TOK_CASE, "case")

	           DEF(TOK_CONST1, "const")
	           DEF(TOK_CONST2, "__const") /* gcc keyword */
	           DEF(TOK_CONST3, "__const__") /* gcc keyword */
	           DEF(TOK_VOLATILE1, "volatile")
	           DEF(TOK_VOLATILE2, "__volatile") /* gcc keyword */
	           DEF(TOK_VOLATILE3, "__volatile__") /* gcc keyword */
	           DEF(TOK_LONG, "long")
	           DEF(TOK_REGISTER, "register")
	           DEF(TOK_SIGNED1, "signed")
	           DEF(TOK_SIGNED2, "__signed") /* gcc keyword */
	           DEF(TOK_SIGNED3, "__signed__") /* gcc keyword */
	           DEF(TOK_AUTO, "auto")
	           DEF(TOK_INLINE1, "inline")
	           DEF(TOK_INLINE2, "__inline") /* gcc keyword */
	           DEF(TOK_INLINE3, "__inline__") /* gcc keyword */
	           DEF(TOK_RESTRICT1, "restrict")
	           DEF(TOK_RESTRICT2, "__restrict")
	           DEF(TOK_RESTRICT3, "__restrict__")
	           DEF(TOK_EXTENSION, "__extension__") /* gcc keyword */

	           DEF(TOK_GENERIC, "_Generic")
	           DEF(TOK_STATIC_ASSERT, "_Static_assert")

	           DEF(TOK_FLOAT, "float")
	           DEF(TOK_DOUBLE, "double")
	           DEF(TOK_BOOL, "_Bool")
	           DEF(TOK_SHORT, "short")
	           DEF(TOK_STRUCT, "struct")
	           DEF(TOK_UNION, "union")
	           DEF(TOK_TYPEDEF, "typedef")
	           DEF(TOK_DEFAULT, "default")
	           DEF(TOK_ENUM, "enum")
	           DEF(TOK_SIZEOF, "sizeof")
	           DEF(TOK_ATTRIBUTE1, "__attribute")
	           DEF(TOK_ATTRIBUTE2, "__attribute__")
	           DEF(TOK_ALIGNOF1, "__alignof")
	           DEF(TOK_ALIGNOF2, "__alignof__")
	           DEF(TOK_ALIGNOF3, "_Alignof")
	           DEF(TOK_ALIGNAS, "_Alignas")
	           DEF(TOK_TYPEOF1, "typeof")
	           DEF(TOK_TYPEOF2, "__typeof")
	           DEF(TOK_TYPEOF3, "__typeof__")
	           DEF(TOK_LABEL, "__label__")
	           DEF(TOK_ASM1, "asm")
	           DEF(TOK_ASM2, "__asm")
	           DEF(TOK_ASM3, "__asm__")

#ifdef TCC_TARGET_ARM64
	           DEF(TOK_UINT128, "__uint128_t")
#endif

	           /*********************************************************************/
	           /* the following are not keywords. They are included to ease parsing */
	           /* preprocessor only */
	           DEF(TOK_DEFINE, "define")
	           DEF(TOK_INCLUDE, "include")
	           DEF(TOK_INCLUDE_NEXT, "include_next")
	           DEF(TOK_IFDEF, "ifdef")
	           DEF(TOK_IFNDEF, "ifndef")
	           DEF(TOK_ELIF, "elif")
	           DEF(TOK_ENDIF, "endif")
	           DEF(TOK_DEFINED, "defined")
	           DEF(TOK_UNDEF, "undef")
	           DEF(TOK_ERROR, "error")
	           DEF(TOK_WARNING, "warning")
	           DEF(TOK_LINE, "line")
	           DEF(TOK_PRAGMA, "pragma")
	           DEF(TOK___LINE__, "__LINE__")
	           DEF(TOK___FILE__, "__FILE__")
	           DEF(TOK___DATE__, "__DATE__")
	           DEF(TOK___TIME__, "__TIME__")
	           DEF(TOK___FUNCTION__, "__FUNCTION__")
	           DEF(TOK___VA_ARGS__, "__VA_ARGS__")
	           DEF(TOK___COUNTER__, "__COUNTER__")

	           /* special identifiers */
	           DEF(TOK___FUNC__, "__func__")

	           /* special floating point values */
	           DEF(TOK___NAN__, "__nan__")
	           DEF(TOK___SNAN__, "__snan__")
	           DEF(TOK___INF__, "__inf__")

	           /* attribute identifiers */
	           /* XXX: handle all tokens generically since speed is not critical */
	           DEF(TOK_SECTION1, "section")
	           DEF(TOK_SECTION2, "__section__")
	           DEF(TOK_ALIGNED1, "aligned")
	           DEF(TOK_ALIGNED2, "__aligned__")
	           DEF(TOK_PACKED1, "packed")
	           DEF(TOK_PACKED2, "__packed__")
	           DEF(TOK_WEAK1, "weak")
	           DEF(TOK_WEAK2, "__weak__")
	           DEF(TOK_ALIAS1, "alias")
	           DEF(TOK_ALIAS2, "__alias__")
	           DEF(TOK_UNUSED1, "unused")
	           DEF(TOK_UNUSED2, "__unused__")
	           DEF(TOK_CDECL1, "cdecl")
	           DEF(TOK_CDECL2, "__cdecl")
	           DEF(TOK_CDECL3, "__cdecl__")
	           DEF(TOK_STDCALL1, "stdcall")
	           DEF(TOK_STDCALL2, "__stdcall")
	           DEF(TOK_STDCALL3, "__stdcall__")
	           DEF(TOK_FASTCALL1, "fastcall")
	           DEF(TOK_FASTCALL2, "__fastcall")
	           DEF(TOK_FASTCALL3, "__fastcall__")
	           DEF(TOK_REGPARM1, "regparm")
	           DEF(TOK_REGPARM2, "__regparm__")
	           DEF(TOK_CLEANUP1, "cleanup")
	           DEF(TOK_CLEANUP2, "__cleanup__")
	           DEF(TOK_CONSTRUCTOR1, "constructor")
	           DEF(TOK_CONSTRUCTOR2, "__constructor__")
	           DEF(TOK_DESTRUCTOR1, "destructor")
	           DEF(TOK_DESTRUCTOR2, "__destructor__")

	           DEF(TOK_MODE, "__mode__")
	           DEF(TOK_MODE_QI, "__QI__")
	           DEF(TOK_MODE_DI, "__DI__")
	           DEF(TOK_MODE_HI, "__HI__")
	           DEF(TOK_MODE_SI, "__SI__")
	           DEF(TOK_MODE_word, "__word__")

	           DEF(TOK_DLLEXPORT, "dllexport")
	           DEF(TOK_DLLIMPORT, "dllimport")
	           DEF(TOK_NODECORATE, "nodecorate")
	           DEF(TOK_NORETURN1, "noreturn")
	           DEF(TOK_NORETURN2, "__noreturn__")
	           DEF(TOK_NORETURN3, "_Noreturn")
	           DEF(TOK_VISIBILITY1, "visibility")
	           DEF(TOK_VISIBILITY2, "__visibility__")

	           DEF(TOK_builtin_types_compatible_p, "__builtin_types_compatible_p")
	           DEF(TOK_builtin_choose_expr, "__builtin_choose_expr")
	           DEF(TOK_builtin_constant_p, "__builtin_constant_p")
	           DEF(TOK_builtin_frame_address, "__builtin_frame_address")
	           DEF(TOK_builtin_return_address, "__builtin_return_address")
	           DEF(TOK_builtin_expect, "__builtin_expect")
	           /*DEF(TOK_builtin_va_list, "__builtin_va_list")*/
#if defined TCC_TARGET_PE && defined TCC_TARGET_X86_64
	           DEF(TOK_builtin_va_start, "__builtin_va_start")
#elif defined TCC_TARGET_X86_64
	           DEF(TOK_builtin_va_arg_types, "__builtin_va_arg_types")
#elif defined TCC_TARGET_ARM64
	           DEF(TOK___va_start, "__va_start")
	           DEF(TOK___va_arg, "__va_arg")
#elif defined TCC_TARGET_RISCV64
	           DEF(TOK_builtin_va_start, "__builtin_va_start")
#endif

	           /* pragma */
	           DEF(TOK_pack, "pack")
#if !defined(TCC_TARGET_I386) && !defined(TCC_TARGET_X86_64)
	           /* already defined for assembler */
	           DEF(TOK_ASM_push, "push")
	           DEF(TOK_ASM_pop, "pop")
#endif
	           DEF(TOK_comment, "comment")
	           DEF(TOK_lib, "lib")
	           DEF(TOK_push_macro, "push_macro")
	           DEF(TOK_pop_macro, "pop_macro")
	           DEF(TOK_once, "once")
	           DEF(TOK_option, "option")

	           /* builtin functions or variables */
#ifndef TCC_ARM_EABI
	           DEF(TOK_memcpy, "memcpy")
	           DEF(TOK_memmove, "memmove")
	           DEF(TOK_memset, "memset")
	           DEF(TOK___divdi3, "__divdi3")
	           DEF(TOK___moddi3, "__moddi3")
	           DEF(TOK___udivdi3, "__udivdi3")
	           DEF(TOK___umoddi3, "__umoddi3")
	           DEF(TOK___ashrdi3, "__ashrdi3")
	           DEF(TOK___lshrdi3, "__lshrdi3")
	           DEF(TOK___ashldi3, "__ashldi3")
	           DEF(TOK___floatundisf, "__floatundisf")
	           DEF(TOK___floatundidf, "__floatundidf")
# ifndef TCC_ARM_VFP
	           DEF(TOK___floatundixf, "__floatundixf")
	           DEF(TOK___fixunsxfdi, "__fixunsxfdi")
# endif
	           DEF(TOK___fixunssfdi, "__fixunssfdi")
	           DEF(TOK___fixunsdfdi, "__fixunsdfdi")
#endif

#if defined TCC_TARGET_ARM
# ifdef TCC_ARM_EABI
	           DEF(TOK_memcpy, "__aeabi_memcpy")
	           DEF(TOK_memcpy4, "__aeabi_memcpy4")
	           DEF(TOK_memcpy8, "__aeabi_memcpy8")
	           DEF(TOK_memmove, "__aeabi_memmove")
	           DEF(TOK_memset, "__aeabi_memset")
	           DEF(TOK___aeabi_ldivmod, "__aeabi_ldivmod")
	           DEF(TOK___aeabi_uldivmod, "__aeabi_uldivmod")
	           DEF(TOK___aeabi_idivmod, "__aeabi_idivmod")
	           DEF(TOK___aeabi_uidivmod, "__aeabi_uidivmod")
	           DEF(TOK___divsi3, "__aeabi_idiv")
	           DEF(TOK___udivsi3, "__aeabi_uidiv")
	           DEF(TOK___floatdisf, "__aeabi_l2f")
	           DEF(TOK___floatdidf, "__aeabi_l2d")
	           DEF(TOK___fixsfdi, "__aeabi_f2lz")
	           DEF(TOK___fixdfdi, "__aeabi_d2lz")
	           DEF(TOK___ashrdi3, "__aeabi_lasr")
	           DEF(TOK___lshrdi3, "__aeabi_llsr")
	           DEF(TOK___ashldi3, "__aeabi_llsl")
	           DEF(TOK___floatundisf, "__aeabi_ul2f")
	           DEF(TOK___floatundidf, "__aeabi_ul2d")
	           DEF(TOK___fixunssfdi, "__aeabi_f2ulz")
	           DEF(TOK___fixunsdfdi, "__aeabi_d2ulz")
# else
	           DEF(TOK___modsi3, "__modsi3")
	           DEF(TOK___umodsi3, "__umodsi3")
	           DEF(TOK___divsi3, "__divsi3")
	           DEF(TOK___udivsi3, "__udivsi3")
	           DEF(TOK___floatdisf, "__floatdisf")
	           DEF(TOK___floatdidf, "__floatdidf")
#  ifndef TCC_ARM_VFP
	           DEF(TOK___floatdixf, "__floatdixf")
	           DEF(TOK___fixunssfsi, "__fixunssfsi")
	           DEF(TOK___fixunsdfsi, "__fixunsdfsi")
	           DEF(TOK___fixunsxfsi, "__fixunsxfsi")
	           DEF(TOK___fixxfdi, "__fixxfdi")
#  endif
	           DEF(TOK___fixsfdi, "__fixsfdi")
	           DEF(TOK___fixdfdi, "__fixdfdi")
# endif
#endif

#if defined TCC_TARGET_C67
	           DEF(TOK__divi, "_divi")
	           DEF(TOK__divu, "_divu")
	           DEF(TOK__divf, "_divf")
	           DEF(TOK__divd, "_divd")
	           DEF(TOK__remi, "_remi")
	           DEF(TOK__remu, "_remu")
#endif

#if defined TCC_TARGET_I386
	           DEF(TOK___fixsfdi, "__fixsfdi")
	           DEF(TOK___fixdfdi, "__fixdfdi")
	           DEF(TOK___fixxfdi, "__fixxfdi")
#endif

#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
	           DEF(TOK_alloca, "alloca")
#endif

#if defined TCC_TARGET_PE
	           DEF(TOK___chkstk, "__chkstk")
#endif
#if defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64
	           DEF(TOK___arm64_clear_cache, "__arm64_clear_cache")
	           DEF(TOK___addtf3, "__addtf3")
	           DEF(TOK___subtf3, "__subtf3")
	           DEF(TOK___multf3, "__multf3")
	           DEF(TOK___divtf3, "__divtf3")
	           DEF(TOK___extendsftf2, "__extendsftf2")
	           DEF(TOK___extenddftf2, "__extenddftf2")
	           DEF(TOK___trunctfsf2, "__trunctfsf2")
	           DEF(TOK___trunctfdf2, "__trunctfdf2")
	           DEF(TOK___fixtfsi, "__fixtfsi")
	           DEF(TOK___fixtfdi, "__fixtfdi")
	           DEF(TOK___fixunstfsi, "__fixunstfsi")
	           DEF(TOK___fixunstfdi, "__fixunstfdi")
	           DEF(TOK___floatsitf, "__floatsitf")
	           DEF(TOK___floatditf, "__floatditf")
	           DEF(TOK___floatunsitf, "__floatunsitf")
	           DEF(TOK___floatunditf, "__floatunditf")
	           DEF(TOK___eqtf2, "__eqtf2")
	           DEF(TOK___netf2, "__netf2")
	           DEF(TOK___lttf2, "__lttf2")
	           DEF(TOK___letf2, "__letf2")
	           DEF(TOK___gttf2, "__gttf2")
	           DEF(TOK___getf2, "__getf2")
#endif

	           /* bound checking symbols */
#ifdef CONFIG_TCC_BCHECK
	           DEF(TOK___bound_ptr_add, "__bound_ptr_add")
	           DEF(TOK___bound_ptr_indir1, "__bound_ptr_indir1")
	           DEF(TOK___bound_ptr_indir2, "__bound_ptr_indir2")
	           DEF(TOK___bound_ptr_indir4, "__bound_ptr_indir4")
	           DEF(TOK___bound_ptr_indir8, "__bound_ptr_indir8")
	           DEF(TOK___bound_ptr_indir12, "__bound_ptr_indir12")
	           DEF(TOK___bound_ptr_indir16, "__bound_ptr_indir16")
	           DEF(TOK___bound_main_arg, "__bound_main_arg")
	           DEF(TOK___bound_local_new, "__bound_local_new")
	           DEF(TOK___bound_local_delete, "__bound_local_delete")
# ifdef TCC_TARGET_PE
#  ifdef TCC_TARGET_X86_64
	           DEF(TOK___bound_alloca_nr, "__bound_alloca_nr")
#  endif
	           DEF(TOK_malloc, "malloc")
	           DEF(TOK_free, "free")
	           DEF(TOK_realloc, "realloc")
	           DEF(TOK_memalign, "memalign")
	           DEF(TOK_calloc, "calloc")
# endif
	           DEF(TOK_mmap, "mmap")
	           DEF(TOK_munmap, "munmap")
	           DEF(TOK_memcmp, "memcmp")
	           DEF(TOK_strlen, "strlen")
	           DEF(TOK_strcpy, "strcpy")
	           DEF(TOK_strncpy, "strncpy")
	           DEF(TOK_strcmp, "strcmp")
	           DEF(TOK_strncmp, "strncmp")
	           DEF(TOK_strcat, "strcat")
	           DEF(TOK_strchr, "strchr")
	           DEF(TOK_strdup, "strdup")
#endif

	           /* Tiny Assembler */
	           DEF_ASMDIR(byte)              /* must be first directive */
	           DEF_ASMDIR(word)
	           DEF_ASMDIR(align)
	           DEF_ASMDIR(balign)
	           DEF_ASMDIR(p2align)
	           DEF_ASMDIR(set)
	           DEF_ASMDIR(skip)
	           DEF_ASMDIR(space)
	           DEF_ASMDIR(string)
	           DEF_ASMDIR(asciz)
	           DEF_ASMDIR(ascii)
	           DEF_ASMDIR(file)
	           DEF_ASMDIR(globl)
	           DEF_ASMDIR(global)
	           DEF_ASMDIR(weak)
	           DEF_ASMDIR(hidden)
	           DEF_ASMDIR(ident)
	           DEF_ASMDIR(size)
	           DEF_ASMDIR(type)
	           DEF_ASMDIR(text)
	           DEF_ASMDIR(data)
	           DEF_ASMDIR(bss)
	           DEF_ASMDIR(previous)
	           DEF_ASMDIR(pushsection)
	           DEF_ASMDIR(popsection)
	           DEF_ASMDIR(fill)
	           DEF_ASMDIR(rept)
	           DEF_ASMDIR(endr)
	           DEF_ASMDIR(org)
	           DEF_ASMDIR(quad)
#if defined(TCC_TARGET_I386)
	           DEF_ASMDIR(code16)
	           DEF_ASMDIR(code32)
#elif defined(TCC_TARGET_X86_64)
	           DEF_ASMDIR(code64)
#endif
	           DEF_ASMDIR(short)
	           DEF_ASMDIR(long)
	           DEF_ASMDIR(int)
	           DEF_ASMDIR(section)            /* must be last directive */

#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64

//START i386-tok.h

	           /* ------------------------------------------------------------------ */
	           /* WARNING: relative order of tokens is important. */

	           /* register */
	           DEF_ASM(al)
	           DEF_ASM(cl)
	           DEF_ASM(dl)
	           DEF_ASM(bl)
	           DEF_ASM(ah)
	           DEF_ASM(ch)
	           DEF_ASM(dh)
	           DEF_ASM(bh)
	           DEF_ASM(ax)
	           DEF_ASM(cx)
	           DEF_ASM(dx)
	           DEF_ASM(bx)
	           DEF_ASM(sp)
	           DEF_ASM(bp)
	           DEF_ASM(si)
	           DEF_ASM(di)
	           DEF_ASM(eax)
	           DEF_ASM(ecx)
	           DEF_ASM(edx)
	           DEF_ASM(ebx)
	           DEF_ASM(esp)
	           DEF_ASM(ebp)
	           DEF_ASM(esi)
	           DEF_ASM(edi)
#ifdef TCC_TARGET_X86_64
	           DEF_ASM(rax)
	           DEF_ASM(rcx)
	           DEF_ASM(rdx)
	           DEF_ASM(rbx)
	           DEF_ASM(rsp)
	           DEF_ASM(rbp)
	           DEF_ASM(rsi)
	           DEF_ASM(rdi)
#endif
	           DEF_ASM(mm0)
	           DEF_ASM(mm1)
	           DEF_ASM(mm2)
	           DEF_ASM(mm3)
	           DEF_ASM(mm4)
	           DEF_ASM(mm5)
	           DEF_ASM(mm6)
	           DEF_ASM(mm7)
	           DEF_ASM(xmm0)
	           DEF_ASM(xmm1)
	           DEF_ASM(xmm2)
	           DEF_ASM(xmm3)
	           DEF_ASM(xmm4)
	           DEF_ASM(xmm5)
	           DEF_ASM(xmm6)
	           DEF_ASM(xmm7)
	           DEF_ASM(cr0)
	           DEF_ASM(cr1)
	           DEF_ASM(cr2)
	           DEF_ASM(cr3)
	           DEF_ASM(cr4)
	           DEF_ASM(cr5)
	           DEF_ASM(cr6)
	           DEF_ASM(cr7)
	           DEF_ASM(tr0)
	           DEF_ASM(tr1)
	           DEF_ASM(tr2)
	           DEF_ASM(tr3)
	           DEF_ASM(tr4)
	           DEF_ASM(tr5)
	           DEF_ASM(tr6)
	           DEF_ASM(tr7)
	           DEF_ASM(db0)
	           DEF_ASM(db1)
	           DEF_ASM(db2)
	           DEF_ASM(db3)
	           DEF_ASM(db4)
	           DEF_ASM(db5)
	           DEF_ASM(db6)
	           DEF_ASM(db7)
	           DEF_ASM(dr0)
	           DEF_ASM(dr1)
	           DEF_ASM(dr2)
	           DEF_ASM(dr3)
	           DEF_ASM(dr4)
	           DEF_ASM(dr5)
	           DEF_ASM(dr6)
	           DEF_ASM(dr7)
	           DEF_ASM(es)
	           DEF_ASM(cs)
	           DEF_ASM(ss)
	           DEF_ASM(ds)
	           DEF_ASM(fs)
	           DEF_ASM(gs)
	           DEF_ASM(st)
	           DEF_ASM(rip)

#ifdef TCC_TARGET_X86_64
	           /* The four low parts of sp/bp/si/di that exist only on
	              x86-64 (encoding aliased to ah,ch,dh,dh when not using REX). */
	           DEF_ASM(spl)
	           DEF_ASM(bpl)
	           DEF_ASM(sil)
	           DEF_ASM(dil)
#endif
	           /* generic two operands */
	           DEF_BWLX(mov)

	           DEF_BWLX(add)
	           DEF_BWLX(or)
	           DEF_BWLX(adc)
	           DEF_BWLX(sbb)
	           DEF_BWLX(and)
	           DEF_BWLX(sub)
	           DEF_BWLX(xor)
	           DEF_BWLX(cmp)

	           /* unary ops */
	           DEF_BWLX(inc)
	           DEF_BWLX(dec)
	           DEF_BWLX(not)
	           DEF_BWLX(neg)
	           DEF_BWLX(mul)
	           DEF_BWLX(imul)
	           DEF_BWLX(div)
	           DEF_BWLX(idiv)

	           DEF_BWLX(xchg)
	           DEF_BWLX(test)

	           /* shifts */
	           DEF_BWLX(rol)
	           DEF_BWLX(ror)
	           DEF_BWLX(rcl)
	           DEF_BWLX(rcr)
	           DEF_BWLX(shl)
	           DEF_BWLX(shr)
	           DEF_BWLX(sar)

	           DEF_WLX(shld)
	           DEF_WLX(shrd)

	           DEF_ASM(pushw)
	           DEF_ASM(pushl)
#ifdef TCC_TARGET_X86_64
	           DEF_ASM(pushq)
#endif
	           DEF_ASM(push)

	           DEF_ASM(popw)
	           DEF_ASM(popl)
#ifdef TCC_TARGET_X86_64
	           DEF_ASM(popq)
#endif
	           DEF_ASM(pop)

	           DEF_BWL(in)
	           DEF_BWL(out)

	           DEF_WLX(movzb)
	           DEF_ASM(movzwl)
	           DEF_ASM(movsbw)
	           DEF_ASM(movsbl)
	           DEF_ASM(movswl)
#ifdef TCC_TARGET_X86_64
	           DEF_ASM(movsbq)
	           DEF_ASM(movswq)
	           DEF_ASM(movzwq)
	           DEF_ASM(movslq)
#endif

	           DEF_WLX(lea)

	           DEF_ASM(les)
	           DEF_ASM(lds)
	           DEF_ASM(lss)
	           DEF_ASM(lfs)
	           DEF_ASM(lgs)

	           DEF_ASM(call)
	           DEF_ASM(jmp)
	           DEF_ASM(lcall)
	           DEF_ASM(ljmp)

	           DEF_ASMTEST(j,)

	           DEF_ASMTEST(set,)
	           DEF_ASMTEST(set,b)
	           DEF_ASMTEST(cmov,)

	           DEF_WLX(bsf)
	           DEF_WLX(bsr)
	           DEF_WLX(bt)
	           DEF_WLX(bts)
	           DEF_WLX(btr)
	           DEF_WLX(btc)

	           DEF_WLX(lar)
	           DEF_WLX(lsl)

	           /* generic FP ops */
	           DEF_FP(add)
	           DEF_FP(mul)

	           DEF_ASM(fcom)
	           DEF_ASM(fcom_1) /* non existent op, just to have a regular table */
	           DEF_FP1(com)

	           DEF_FP(comp)
	           DEF_FP(sub)
	           DEF_FP(subr)
	           DEF_FP(div)
	           DEF_FP(divr)

	           DEF_BWLX(xadd)
	           DEF_BWLX(cmpxchg)

	           /* string ops */
	           DEF_BWLX(cmps)
	           DEF_BWLX(scmp)
	           DEF_BWL(ins)
	           DEF_BWL(outs)
	           DEF_BWLX(lods)
	           DEF_BWLX(slod)
	           DEF_BWLX(movs)
	           DEF_BWLX(smov)
	           DEF_BWLX(scas)
	           DEF_BWLX(ssca)
	           DEF_BWLX(stos)
	           DEF_BWLX(ssto)

	           /* generic asm ops */
#define ALT(x)
#define DEF_ASM_OP0(name, opcode) DEF_ASM(name)
#define DEF_ASM_OP0L(name, opcode, group, instr_type)
#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)
#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)
#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)
#ifdef TCC_TARGET_X86_64
//START x86_64-asm.h

#define X86ASMOPCODE
#include "tinycc.h"

//END x86_64-asm.h
#else

#define i386ASMOPCODE
#include "tinycc.h"
//# include "i386-asm.h"
#endif

#define ALT(x)
#define DEF_ASM_OP0(name, opcode)
#define DEF_ASM_OP0L(name, opcode, group, instr_type) DEF_ASM(name)
#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) DEF_ASM(name)
#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) DEF_ASM(name)
#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) DEF_ASM(name)
#ifdef TCC_TARGET_X86_64

//START x86_64-asm.h

#define X86ASMOPCODE
#include "tinycc.h"

//END x86_64-asm.h

#else
#define i386ASMOPCODE
#include "tinycc.h"

//# include "i386-asm.h"
#endif
//END i386-tok.h


#endif

//END tcctok.h




#undef DEF
};

/* keywords: tok >= TOK_IDENT && tok < TOK_UIDENT */
#define TOK_UIDENT TOK_DEFINE

/* ------------ libtcc.c ------------ */

ST_DATA struct TCCState *tcc_state;

/* public functions currently used by the tcc main function */
ST_FUNC char *pstrcpy(char *buf, size_t buf_size, const char *s);
ST_FUNC char *pstrcat(char *buf, size_t buf_size, const char *s);
ST_FUNC char *pstrncpy(char *out, const char *in, size_t num);
PUB_FUNC char *tcc_basename(const char *name);
PUB_FUNC char *tcc_fileextension (const char *name);

#ifndef MEM_DEBUG
PUB_FUNC void tcc_free(void *ptr);
PUB_FUNC void *tcc_malloc(unsigned long size);
PUB_FUNC void *tcc_mallocz(unsigned long size);
PUB_FUNC void *tcc_realloc(void *ptr, unsigned long size);
PUB_FUNC char *tcc_strdup(const char *str);
#else
#define tcc_free(ptr)           tcc_free_debug(ptr)
#define tcc_malloc(size)        tcc_malloc_debug(size, __FILE__, __LINE__)
#define tcc_mallocz(size)       tcc_mallocz_debug(size, __FILE__, __LINE__)
#define tcc_realloc(ptr,size)   tcc_realloc_debug(ptr, size, __FILE__, __LINE__)
#define tcc_strdup(str)         tcc_strdup_debug(str, __FILE__, __LINE__)
PUB_FUNC void tcc_free_debug(void *ptr);
PUB_FUNC void *tcc_malloc_debug(unsigned long size, const char *file, int line);
PUB_FUNC void *tcc_mallocz_debug(unsigned long size, const char *file, int line);
PUB_FUNC void *tcc_realloc_debug(void *ptr, unsigned long size, const char *file, int line);
PUB_FUNC char *tcc_strdup_debug(const char *str, const char *file, int line);
#endif

#define free(p) use_tcc_free(p)
#define malloc(s) use_tcc_malloc(s)
#define realloc(p, s) use_tcc_realloc(p, s)
#undef strdup
#define strdup(s) use_tcc_strdup(s)
PUB_FUNC void _tcc_error_noabort(const char *fmt, ...);
PUB_FUNC NORETURN void _tcc_error(const char *fmt, ...);
PUB_FUNC void _tcc_warning(const char *fmt, ...);

/* other utilities */
ST_FUNC void dynarray_add(void *ptab, int *nb_ptr, void *data);
ST_FUNC void dynarray_reset(void *pp, int *n);
ST_INLN void cstr_ccat(CString *cstr, int ch);
ST_FUNC void cstr_cat(CString *cstr, const char *str, int len);
ST_FUNC void cstr_wccat(CString *cstr, int ch);
ST_FUNC void cstr_new(CString *cstr);
ST_FUNC void cstr_free(CString *cstr);
ST_FUNC int cstr_printf(CString *cs, const char *fmt, ...);
ST_FUNC void cstr_reset(CString *cstr);

ST_INLN void sym_free(Sym *sym);
ST_FUNC Sym *sym_push2(Sym **ps, int v, int t, int c);
ST_FUNC Sym *sym_find2(Sym *s, int v);
ST_FUNC Sym *sym_push(int v, CType *type, int r, int c);
ST_FUNC void sym_pop(Sym **ptop, Sym *b, int keep);
ST_INLN Sym *struct_find(int v);
ST_INLN Sym *sym_find(int v);
ST_FUNC Sym *global_identifier_push(int v, int t, int c);

ST_FUNC void tcc_open_bf(TCCState *s1, const char *filename, int initlen);
ST_FUNC int tcc_open(TCCState *s1, const char *filename);
ST_FUNC void tcc_close(void);

ST_FUNC int tcc_add_file_internal(TCCState *s1, const char *filename, int flags);
/* flags: */
#define AFF_PRINT_ERROR     0x10 /* print error if file not found */
#define AFF_REFERENCED_DLL  0x20 /* load a referenced dll from another dll */
#define AFF_TYPE_BIN        0x40 /* file to add is binary */
#define AFF_WHOLE_ARCHIVE   0x80 /* load all objects from archive */
/* s->filetype: */
#define AFF_TYPE_NONE   0
#define AFF_TYPE_C      1
#define AFF_TYPE_ASM    2
#define AFF_TYPE_ASMPP  4
#define AFF_TYPE_LIB    8
#define AFF_TYPE_MASK   (15 | AFF_TYPE_BIN)
/* values from tcc_object_type(...) */
#define AFF_BINTYPE_REL 1
#define AFF_BINTYPE_DYN 2
#define AFF_BINTYPE_AR  3
#define AFF_BINTYPE_C67 4


#ifndef TCC_TARGET_PE
ST_FUNC int tcc_add_crt(TCCState *s, const char *filename);
#endif
ST_FUNC int tcc_add_dll(TCCState *s, const char *filename, int flags);
#ifdef CONFIG_TCC_BCHECK
ST_FUNC void tcc_add_bcheck(TCCState *s1);
#endif
#ifdef CONFIG_TCC_BACKTRACE
ST_FUNC void tcc_add_btstub(TCCState *s1);
#endif
ST_FUNC void tcc_add_pragma_libs(TCCState *s1);
PUB_FUNC int tcc_add_library_err(TCCState *s, const char *f);
PUB_FUNC void tcc_print_stats(TCCState *s, unsigned total_time);
PUB_FUNC int tcc_parse_args(TCCState *s, int *argc, char ***argv, int optind);
#ifdef _WIN32
ST_FUNC char *normalize_slashes(char *path);
#endif

/* tcc_parse_args return codes: */
#define OPT_HELP 1
#define OPT_HELP2 2
#define OPT_V 3
#define OPT_PRINT_DIRS 4
#define OPT_AR 5
#define OPT_IMPDEF 6
#define OPT_M32 32
#define OPT_M64 64

/* ------------ tccpp.c ------------ */

ST_DATA struct BufferedFile *file;
ST_DATA int ch, tok;
ST_DATA CValue tokc;
ST_DATA const int *macro_ptr;
ST_DATA int parse_flags;
ST_DATA int tok_flags;
ST_DATA CString tokcstr; /* current parsed string, if any */

/* display benchmark infos */
ST_DATA int tok_ident;
ST_DATA TokenSym **table_ident;

#define TOK_FLAG_BOL   0x0001 /* beginning of line before */
#define TOK_FLAG_BOF   0x0002 /* beginning of file before */
#define TOK_FLAG_ENDIF 0x0004 /* a endif was found matching starting #ifdef */
#define TOK_FLAG_EOF   0x0008 /* end of file */

#define PARSE_FLAG_PREPROCESS 0x0001 /* activate preprocessing */
#define PARSE_FLAG_TOK_NUM    0x0002 /* return numbers instead of TOK_PPNUM */
#define PARSE_FLAG_LINEFEED   0x0004 /* line feed is returned as a
                                        token. line feed is also
                                        returned at eof */
#define PARSE_FLAG_ASM_FILE 0x0008 /* we processing an asm file: '#' can be used for line comment, etc. */
#define PARSE_FLAG_SPACES     0x0010 /* next() returns space tokens (for -E) */
#define PARSE_FLAG_ACCEPT_STRAYS 0x0020 /* next() returns '\\' token */
#define PARSE_FLAG_TOK_STR    0x0040 /* return parsed strings instead of TOK_PPSTR */

/* isidnum_table flags: */
#define IS_SPC 1
#define IS_ID  2
#define IS_NUM 4

ST_FUNC TokenSym *tok_alloc(const char *str, int len);
ST_FUNC const char *get_tok_str(int v, CValue *cv);
ST_FUNC void begin_macro(TokenString *str, int alloc);
ST_FUNC void end_macro(void);
ST_FUNC int set_idnum(int c, int val);
ST_INLN void tok_str_new(TokenString *s);
ST_FUNC TokenString *tok_str_alloc(void);
ST_FUNC void tok_str_free(TokenString *s);
ST_FUNC void tok_str_free_str(int *str);
ST_FUNC void tok_str_add(TokenString *s, int t);
ST_FUNC void tok_str_add_tok(TokenString *s);
ST_INLN void define_push(int v, int macro_type, int *str, Sym *first_arg);
ST_FUNC void define_undef(Sym *s);
ST_INLN Sym *define_find(int v);
ST_FUNC void free_defines(Sym *b);
ST_FUNC Sym *label_find(int v);
ST_FUNC Sym *label_push(Sym **ptop, int v, int flags);
ST_FUNC void label_pop(Sym **ptop, Sym *slast, int keep);
ST_FUNC void parse_define(void);
ST_FUNC void preprocess(int is_bof);
ST_FUNC void next_nomacro(void);
ST_FUNC void next(void);
ST_INLN void unget_tok(int last_tok);
ST_FUNC void preprocess_start(TCCState *s1, int is_asm);
ST_FUNC void preprocess_end(TCCState *s1);
ST_FUNC void tccpp_new(TCCState *s);
ST_FUNC void tccpp_delete(TCCState *s);
ST_FUNC int tcc_preprocess(TCCState *s1);
ST_FUNC void skip(int c);
ST_FUNC NORETURN void expect(const char *msg);

/* space excluding newline */
static inline int is_space(int ch)
{
	return ch == ' ' || ch == '\t' || ch == '\v' || ch == '\f' || ch == '\r';
}
static inline int isid(int c)
{
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}
static inline int isnum(int c)
{
	return c >= '0' && c <= '9';
}
static inline int isoct(int c)
{
	return c >= '0' && c <= '7';
}
static inline int toup(int c)
{
	return (c >= 'a' && c <= 'z') ? c - 'a' + 'A' : c;
}

/* ------------ tccgen.c ------------ */

#define SYM_POOL_NB (8192 / sizeof(Sym))

ST_DATA Sym *global_stack;
ST_DATA Sym *local_stack;
ST_DATA Sym *local_label_stack;
ST_DATA Sym *global_label_stack;
ST_DATA Sym *define_stack;
ST_DATA CType int_type, func_old_type, char_pointer_type;
ST_DATA SValue *vtop;
ST_DATA int rsym, anon_sym, ind, loc;

ST_DATA int const_wanted; /* true if constant wanted */
ST_DATA int nocode_wanted; /* true if no code generation wanted for an expression */
ST_DATA int global_expr;  /* true if compound literals must be allocated globally (used during initializers parsing */
ST_DATA CType func_vt; /* current function return type (used by return instruction) */
ST_DATA int func_var; /* true if current function is variadic */
ST_DATA int func_vc;
ST_DATA const char *funcname;

ST_FUNC void tcc_debug_start(TCCState *s1);
ST_FUNC void tcc_debug_end(TCCState *s1);
ST_FUNC void tcc_debug_bincl(TCCState *s1);
ST_FUNC void tcc_debug_eincl(TCCState *s1);
ST_FUNC void tcc_debug_putfile(TCCState *s1, const char *filename);
ST_FUNC void tcc_debug_funcstart(TCCState *s1, Sym *sym);
ST_FUNC void tcc_debug_funcend(TCCState *s1, int size);
ST_FUNC void tcc_debug_line(TCCState *s1);

ST_FUNC void tccgen_init(TCCState *s1);
ST_FUNC int tccgen_compile(TCCState *s1);
ST_FUNC void tccgen_finish(TCCState *s1);
ST_FUNC void check_vstack(void);

ST_INLN int is_float(int t);
ST_FUNC int ieee_finite(double d);
ST_FUNC void test_lvalue(void);
ST_FUNC void vpushi(int v);
ST_FUNC ElfSym *elfsym(Sym *);
ST_FUNC void update_storage(Sym *sym);
ST_FUNC Sym *external_global_sym(int v, CType *type);
ST_FUNC void vset(CType *type, int r, int v);
ST_FUNC void vset_VT_CMP(int op);
ST_FUNC void vswap(void);
ST_FUNC void vpush_global_sym(CType *type, int v);
ST_FUNC void vrote(SValue *e, int n);
ST_FUNC void vrott(int n);
ST_FUNC void vrotb(int n);
#if PTR_SIZE == 4
ST_FUNC void lexpand(void);
#endif
#ifdef TCC_TARGET_ARM
ST_FUNC int get_reg_ex(int rc, int rc2);
#endif
ST_FUNC void vpushv(SValue *v);
ST_FUNC void save_reg(int r);
ST_FUNC void save_reg_upstack(int r, int n);
ST_FUNC int get_reg(int rc);
ST_FUNC void save_regs(int n);
ST_FUNC void gaddrof(void);
ST_FUNC int gv(int rc);
ST_FUNC void gv2(int rc1, int rc2);
ST_FUNC void vpop(void);
ST_FUNC void gen_op(int op);
ST_FUNC int type_size(CType *type, int *a);
ST_FUNC void mk_pointer(CType *type);
ST_FUNC void vstore(void);
ST_FUNC void inc(int post, int c);
ST_FUNC void parse_mult_str (CString *astr, const char *msg);
ST_FUNC void parse_asm_str(CString *astr);
ST_FUNC void indir(void);
ST_FUNC void unary(void);
ST_FUNC void gexpr(void);
ST_FUNC int expr_const(void);
#if defined CONFIG_TCC_BCHECK || defined TCC_TARGET_C67
ST_FUNC Sym *get_sym_ref(CType *type, Section *sec, unsigned long offset, unsigned long size);
#endif
#if defined TCC_TARGET_X86_64 && !defined TCC_TARGET_PE
ST_FUNC int classify_x86_64_va_arg(CType *ty);
#endif
#ifdef CONFIG_TCC_BCHECK
ST_FUNC void gbound_args(int nb_args);
#endif

/* ------------ tccelf.c ------------ */

#define TCC_OUTPUT_FORMAT_ELF    0 /* default output format: ELF */
#define TCC_OUTPUT_FORMAT_BINARY 1 /* binary image output */
#define TCC_OUTPUT_FORMAT_COFF   2 /* COFF */

#define ARMAG  "!<arch>\012"    /* For COFF and a.out archives */

typedef struct
{
	unsigned int n_strx;         /* index into string table of name */
	unsigned char n_type;         /* type of symbol */
	unsigned char n_other;        /* misc info (usually empty) */
	unsigned short n_desc;        /* description field */
	unsigned int n_value;        /* value of symbol */
} Stab_Sym;

ST_FUNC void tccelf_new(TCCState *s);
ST_FUNC void tccelf_delete(TCCState *s);
ST_FUNC void tccelf_stab_new(TCCState *s);
ST_FUNC void tccelf_begin_file(TCCState *s1);
ST_FUNC void tccelf_end_file(TCCState *s1);
#ifdef CONFIG_TCC_BCHECK
ST_FUNC void tccelf_bounds_new(TCCState *s);
#endif
ST_FUNC Section *new_section(TCCState *s1, const char *name, int sh_type, int sh_flags);
ST_FUNC void section_realloc(Section *sec, unsigned long new_size);
ST_FUNC size_t section_add(Section *sec, addr_t size, int align);
ST_FUNC void *section_ptr_add(Section *sec, addr_t size);
ST_FUNC void section_reserve(Section *sec, unsigned long size);
ST_FUNC Section *find_section(TCCState *s1, const char *name);
ST_FUNC Section *new_symtab(TCCState *s1, const char *symtab_name, int sh_type, int sh_flags, const char *strtab_name, const char *hash_name, int hash_sh_flags);

ST_FUNC void put_extern_sym2(Sym *sym, int sh_num, addr_t value, unsigned long size, int can_add_underscore);
ST_FUNC void put_extern_sym(Sym *sym, Section *section, addr_t value, unsigned long size);
#if PTR_SIZE == 4
ST_FUNC void greloc(Section *s, Sym *sym, unsigned long offset, int type);
#endif
ST_FUNC void greloca(Section *s, Sym *sym, unsigned long offset, int type, addr_t addend);

ST_FUNC int put_elf_str(Section *s, const char *sym);
ST_FUNC int put_elf_sym(Section *s, addr_t value, unsigned long size, int info, int other, int shndx, const char *name);
ST_FUNC int set_elf_sym(Section *s, addr_t value, unsigned long size, int info, int other, int shndx, const char *name);
ST_FUNC int find_elf_sym(Section *s, const char *name);
ST_FUNC void put_elf_reloc(Section *symtab, Section *s, unsigned long offset, int type, int symbol);
ST_FUNC void put_elf_reloca(Section *symtab, Section *s, unsigned long offset, int type, int symbol, addr_t addend);

ST_FUNC void put_stabs(TCCState *s1, const char *str, int type, int other, int desc, unsigned long value);
ST_FUNC void put_stabs_r(TCCState *s1, const char *str, int type, int other, int desc, unsigned long value, Section *sec, int sym_index);
ST_FUNC void put_stabn(TCCState *s1, int type, int other, int desc, int value);

ST_FUNC void resolve_common_syms(TCCState *s1);
ST_FUNC void relocate_syms(TCCState *s1, Section *symtab, int do_resolve);
ST_FUNC void relocate_section(TCCState *s1, Section *s);

ST_FUNC int tcc_object_type(int fd, ElfW(Ehdr) *h);
ST_FUNC int tcc_load_object_file(TCCState *s1, int fd, unsigned long file_offset);
ST_FUNC int tcc_load_archive(TCCState *s1, int fd, int alacarte);
ST_FUNC void add_array(TCCState *s1, const char *sec, int c);

#ifndef ELF_OBJ_ONLY
ST_FUNC void build_got_entries(TCCState *s1);
#endif
ST_FUNC struct sym_attr *get_sym_attr(TCCState *s1, int index, int alloc);
ST_FUNC void squeeze_multi_relocs(Section *sec, size_t oldrelocoffset);

ST_FUNC addr_t get_elf_sym_addr(TCCState *s, const char *name, int err);
ST_FUNC void list_elf_symbols(TCCState *s, void *ctx,
                              void (*symbol_cb)(void *ctx, const char *name, const void *val));
#if defined TCC_IS_NATIVE || defined TCC_TARGET_PE
ST_FUNC void *tcc_get_symbol_err(TCCState *s, const char *name);
#endif

ST_FUNC int set_global_sym(TCCState *s1, const char *name, Section *sec, long offs);

#ifndef TCC_TARGET_PE
ST_FUNC int tcc_load_dll(TCCState *s1, int fd, const char *filename, int level);
ST_FUNC int tcc_load_ldscript(TCCState *s1, int fd);
ST_FUNC void tcc_add_runtime(TCCState *s1);
#endif

/* ------------ xxx-link.c ------------ */

/* Whether to generate a GOT/PLT entry and when. NO_GOTPLT_ENTRY is first so
   that unknown relocation don't create a GOT or PLT entry */
enum gotplt_entry
{
	NO_GOTPLT_ENTRY,	/* never generate (eg. GLOB_DAT & JMP_SLOT relocs) */
	BUILD_GOT_ONLY,	/* only build GOT (eg. TPOFF relocs) */
	AUTO_GOTPLT_ENTRY,	/* generate if sym is UNDEF */
	ALWAYS_GOTPLT_ENTRY	/* always generate (eg. PLTOFF relocs) */
};

#ifndef ELF_OBJ_ONLY
ST_FUNC int code_reloc (int reloc_type);
ST_FUNC int gotplt_entry_type (int reloc_type);
ST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr);
ST_FUNC void relocate_plt(TCCState *s1);
#endif
ST_FUNC void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val);

/* ------------ xxx-gen.c ------------ */

ST_DATA const int reg_classes[NB_REGS];

ST_FUNC void gsym_addr(int t, int a);
ST_FUNC void gsym(int t);
ST_FUNC void load(int r, SValue *sv);
ST_FUNC void store(int r, SValue *v);
ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *align, int *regsize);
ST_FUNC void gfunc_call(int nb_args);
ST_FUNC void gfunc_prolog(Sym *func_sym);
ST_FUNC void gfunc_epilog(void);
ST_FUNC void gen_fill_nops(int);
ST_FUNC int gjmp(int t);
ST_FUNC void gjmp_addr(int a);
ST_FUNC int gjmp_cond(int op, int t);
ST_FUNC int gjmp_append(int n, int t);
ST_FUNC void gen_opi(int op);
ST_FUNC void gen_opf(int op);
ST_FUNC void gen_cvt_ftoi(int t);
ST_FUNC void gen_cvt_itof(int t);
ST_FUNC void gen_cvt_ftof(int t);
ST_FUNC void ggoto(void);
#ifndef TCC_TARGET_C67
ST_FUNC void o(unsigned int c);
#endif
ST_FUNC void gen_vla_sp_save(int addr);
ST_FUNC void gen_vla_sp_restore(int addr);
ST_FUNC void gen_vla_alloc(CType *type, int align);

static inline uint16_t read16le(unsigned char *p)
{
	return p[0] | (uint16_t)p[1] << 8;
}
static inline void write16le(unsigned char *p, uint16_t x)
{
	p[0] = x & 255;
	p[1] = x >> 8 & 255;
}
static inline uint32_t read32le(unsigned char *p)
{
	return read16le(p) | (uint32_t)read16le(p + 2) << 16;
}
static inline void write32le(unsigned char *p, uint32_t x)
{
	write16le(p, x);
	write16le(p + 2, x >> 16);
}
static inline void add32le(unsigned char *p, int32_t x)
{
	write32le(p, read32le(p) + x);
}
static inline uint64_t read64le(unsigned char *p)
{
	return read32le(p) | (uint64_t)read32le(p + 4) << 32;
}
static inline void write64le(unsigned char *p, uint64_t x)
{
	write32le(p, x);
	write32le(p + 4, x >> 32);
}
static inline void add64le(unsigned char *p, int64_t x)
{
	write64le(p, read64le(p) + x);
}

/* ------------ i386-gen.c ------------ */
#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
ST_FUNC void g(int c);
ST_FUNC void gen_le16(int c);
ST_FUNC void gen_le32(int c);
ST_FUNC void gen_addr32(int r, Sym *sym, int c);
ST_FUNC void gen_addrpc32(int r, Sym *sym, int c);
ST_FUNC void gen_cvt_csti(int t);
#endif

#ifdef CONFIG_TCC_BCHECK
ST_FUNC void gen_bounded_ptr_add(void);
ST_FUNC void gen_bounded_ptr_deref(void);
#endif

/* ------------ x86_64-gen.c ------------ */
#ifdef TCC_TARGET_X86_64
ST_FUNC void gen_addr64(int r, Sym *sym, int64_t c);
ST_FUNC void gen_opl(int op);
#ifdef TCC_TARGET_PE
ST_FUNC void gen_vla_result(int addr);
#endif
ST_FUNC void gen_cvt_sxtw(void);
ST_FUNC void gen_cvt_csti(int t);
#endif

/* ------------ arm-gen.c ------------ */
#ifdef TCC_TARGET_ARM
#if defined(TCC_ARM_EABI) && !defined(CONFIG_TCC_ELFINTERP)
PUB_FUNC const char *default_elfinterp(struct TCCState *s);
#endif
ST_FUNC void arm_init(struct TCCState *s);
#endif

/* ------------ arm64-gen.c ------------ */
#ifdef TCC_TARGET_ARM64
ST_FUNC void gen_opl(int op);
ST_FUNC void gfunc_return(CType *func_type);
ST_FUNC void gen_va_start(void);
ST_FUNC void gen_va_arg(CType *t);
ST_FUNC void gen_clear_cache(void);
ST_FUNC void gen_cvt_sxtw(void);
ST_FUNC void gen_cvt_csti(int t);
#endif

/* ------------ riscv64-gen.c ------------ */
#ifdef TCC_TARGET_RISCV64
ST_FUNC void gen_opl(int op);
//ST_FUNC void gfunc_return(CType *func_type);
ST_FUNC void gen_va_start(void);
ST_FUNC void arch_transfer_ret_regs(int);
ST_FUNC void gen_cvt_sxtw(void);
#endif

/* ------------ c67-gen.c ------------ */
#ifdef TCC_TARGET_C67
#endif

/* ------------ tcccoff.c ------------ */

#ifdef TCC_TARGET_COFF
ST_FUNC int tcc_output_coff(TCCState *s1, FILE *f);
ST_FUNC int tcc_load_coff(TCCState * s1, int fd);
#endif

/* ------------ tccasm.c ------------ */
ST_FUNC void asm_instr(void);
ST_FUNC void asm_global_instr(void);
#ifdef CONFIG_TCC_ASM
ST_FUNC int find_constraint(ASMOperand *operands, int nb_operands, const char *name, const char **pp);
ST_FUNC Sym* get_asm_sym(int name, Sym *csym);
ST_FUNC void asm_expr(TCCState *s1, ExprValue *pe);
ST_FUNC int asm_int_expr(TCCState *s1);
ST_FUNC int tcc_assemble(TCCState *s1, int do_preprocess);
/* ------------ i386-asm.c ------------ */
ST_FUNC void gen_expr32(ExprValue *pe);
#ifdef TCC_TARGET_X86_64
ST_FUNC void gen_expr64(ExprValue *pe);
#endif
ST_FUNC void asm_opcode(TCCState *s1, int opcode);
ST_FUNC int asm_parse_regvar(int t);
ST_FUNC void asm_compute_constraints(ASMOperand *operands, int nb_operands, int nb_outputs, const uint8_t *clobber_regs, int *pout_reg);
ST_FUNC void subst_asm_operand(CString *add_str, SValue *sv, int modifier);
ST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands, int nb_outputs, int is_output, uint8_t *clobber_regs, int out_reg);
ST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str);
#endif

/* ------------ tccpe.c -------------- */
#ifdef TCC_TARGET_PE
ST_FUNC int pe_load_file(struct TCCState *s1, const char *filename, int fd);
ST_FUNC int pe_output_file(TCCState * s1, const char *filename);
ST_FUNC int pe_putimport(TCCState *s1, int dllindex, const char *name, addr_t value);
#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
ST_FUNC SValue *pe_getimport(SValue *sv, SValue *v2);
#endif
#ifdef TCC_TARGET_X86_64
ST_FUNC void pe_add_unwind_data(unsigned start, unsigned end, unsigned stack);
#endif
PUB_FUNC int tcc_get_dllexports(const char *filename, char **pp);
/* symbol properties stored in Elf32_Sym->st_other */
# define ST_PE_EXPORT 0x10
# define ST_PE_IMPORT 0x20
# define ST_PE_STDCALL 0x40
#endif
#define ST_ASM_SET 0x04

/* ------------ tccrun.c ----------------- */
#ifdef TCC_IS_NATIVE
#ifdef CONFIG_TCC_STATIC
#define RTLD_LAZY       0x001
#define RTLD_NOW        0x002
#define RTLD_GLOBAL     0x100
#define RTLD_DEFAULT    NULL
/* dummy function for profiling */
ST_FUNC void *dlopen(const char *filename, int flag);
ST_FUNC void dlclose(void *p);
ST_FUNC const char *dlerror(void);
ST_FUNC void *dlsym(void *handle, const char *symbol);
#endif
ST_FUNC void tcc_run_free(TCCState *s1);
#endif

/* ------------ tcctools.c ----------------- */
#if 0 /* included in tcc.c */
ST_FUNC int tcc_tool_ar(TCCState *s, int argc, char **argv);
#ifdef TCC_TARGET_PE
ST_FUNC int tcc_tool_impdef(TCCState *s, int argc, char **argv);
#endif
ST_FUNC void tcc_tool_cross(TCCState *s, char **argv, int option);
ST_FUNC void gen_makedeps(TCCState *s, const char *target, const char *filename);
#endif

/********************************************************/
#undef ST_DATA
#if ONE_SOURCE
#define ST_DATA static
#else
#define ST_DATA
#endif
/********************************************************/

#define text_section        TCC_STATE_VAR(text_section)
#define data_section        TCC_STATE_VAR(data_section)
#define bss_section         TCC_STATE_VAR(bss_section)
#define common_section      TCC_STATE_VAR(common_section)
#define cur_text_section    TCC_STATE_VAR(cur_text_section)
#define bounds_section      TCC_STATE_VAR(bounds_section)
#define lbounds_section     TCC_STATE_VAR(lbounds_section)
#define symtab_section      TCC_STATE_VAR(symtab_section)
#define stab_section        TCC_STATE_VAR(stab_section)
#define stabstr_section     stab_section->link
#define gnu_ext             TCC_STATE_VAR(gnu_ext)
#define tcc_error_noabort   TCC_SET_STATE(_tcc_error_noabort)
#define tcc_error           TCC_SET_STATE(_tcc_error)
#define tcc_warning         TCC_SET_STATE(_tcc_warning)

#define total_idents        TCC_STATE_VAR(total_idents)
#define total_lines         TCC_STATE_VAR(total_lines)
#define total_bytes         TCC_STATE_VAR(total_bytes)

PUB_FUNC void tcc_enter_state(TCCState *s1);

//START CLIB
//Functions replacing Clib

int isalpha(int c)
{
    char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                      "abcdefghijklmnopqrstuvwxyz";
    char *letter = alphabet;

    while(*letter != '\0' && *letter != c)
        ++letter;

    if (*letter)
        return 1;

    return 0;
}

int isdigit(int c)
{
        if (c >= '0' && c <= '9')
                return c;
        else
                return 0;
}

int isupper(int c)
{
	if (c >= 'A' && c <= 'Z')
		return c;
	else
		return 0;
}

int isspace(int c)
{
	switch (c)
	{
		case ' ':
			return 1;
		case '\n':
			return 1;
		case '\t':
			return 1;
		case '\r':
			return 1;
		case '\v':
			return 1;
		case '\f':
			return 1;
	}
	return 0;
}

void strlwr(char *string)
{
	while (*string)
	{
		if (*string >= 'A' && *string <= 'Z')
		{
			*string = *string + 32;
		}
		string++;
	}
}


char *strcpy(char *dest, const char *src)
{
	while (*src)
	{
		*dest++ = *src++;
	}
	*dest++ = 0;
	return dest;
}

char *strncpy(char *dest, const char *src, size_t count)
{
	while (*src && count--)
	{
		*dest++ = *src++;
	}
	if (count)
		*dest++ = 0;
	return dest;
}

size_t strlen(const char *str)
{
	int		count;

	count = 0;
	while (str[count])
		count++;

	return count;
}

int dstrlen (const char *s, char delim)
{
	register const char* i;
	for(i=s; *i != delim; ++i);
	return (i-s);
}

int chstrlen (const char* s, char ch) 
{
	register const char* i;
	for(i=s; *i != ch; ++i);
	return (i-s)+1;
}

char *strrchr(const char *s, int c)
{
	int len = strlen(s);
	s += len;
	while (len--)
	{
		if (*--s == c)
			return (char *)s;
	}
	return NULL;
}

char *strcat(char *dest, const char *src)
{
	dest += strlen(dest);
	strcpy (dest, src);
	return dest;
}

char* fstrcat(char *dest, char *src)
{
     while (*dest) dest++;
     while (*dest++ = *src++);
     return --dest;
}

char *strchr(const char *s, int c)
{
    while (*s != (char)c)
        if (!*s++)
            return 0;
    return (char *)s;
}

int strcmp(const char *X, const char *Y)
{
	while(*X)
	{
		// if characters differ or end of second string is reached
		if (*X != *Y)
			break;

		// move to next pair of characters
		X++;
		Y++;
	}

	// return the ASCII difference after converting char* to unsigned char*
	return *(const unsigned char*)X - *(const unsigned char*)Y;
}

int fstrcmp(const char *X, const char *Y)
{
	while(*X)
	{
		if (*X != *Y)
		{
			return -1;
		}
		X++;
		Y++;
	}
	return 0; //are equal
}

int fstrncmp(const char *s1, const char *s2, size_t count)
{
	while (1)
	{
		if (!count--)
			return 0;
		if (*s1 != *s2)
			return -1;		// strings not equal
		if (!*s1)
			return 0;		// strings are equal
		s1++;
		s2++;
	}

	return -1;
}

char *strstr(const char *str1, const char *str2)
{
	while (*str1 != '\0')
	{
		if ((*str1 == *str2) && strcmp(str1, str2) == 0)
			return (char*)str1;
		str1++;
	}

	return NULL;
}

int atoi(const char* str) 
{ 
    if (*str == '\0') 
        return 0; 
  
    int res = 0; // Initialize result 
    int sign = 1; // Initialize sign as positive 
    int i = 0; // Initialize index of first digit 
  
    if (str[0] == '-') { 
        sign = -1; 
        i++; // Also update index of first digit 
    } 
    for (; str[i] != '\0'; ++i) { 
        if (isdigit(str[i]) == 0) 
            return 0; 
        res = res * 10 + str[i] - '0'; 
    } 
    return sign * res; 
} 

//END CLIB


//START PLATFORM IMPL 

#ifdef TCC_TARGET_I386
//# include "i386-gen.c"

//START i386-gen.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE
# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

/* define to 1/0 to [not] have EBX as 4th register */
#define USE_EBX 0

ST_DATA const int reg_classes[NB_REGS] =
{
	/* eax */ RC_INT | RC_EAX,
	/* ecx */ RC_INT | RC_ECX,
	/* edx */ RC_INT | RC_EDX,
	/* ebx */ (RC_INT | RC_EBX) * USE_EBX,
	/* st0 */ RC_FLOAT | RC_ST0,
};

static unsigned long func_sub_sp_offset;
static int func_ret_sub;
#ifdef CONFIG_TCC_BCHECK
static addr_t func_bound_offset;
static unsigned long func_bound_ind;
static void gen_bounds_prolog(void);
static void gen_bounds_epilog(void);
#endif

/* XXX: make it faster ? */
ST_FUNC void g(int c)
{
	int ind1;
	if (nocode_wanted)
		return;
	ind1 = ind + 1;
	if (ind1 > cur_text_section->data_allocated)
		section_realloc(cur_text_section, ind1);
	cur_text_section->data[ind] = c;
	ind = ind1;
}

ST_FUNC void o(unsigned int c)
{
	while (c)
	{
		g(c);
		c = c >> 8;
	}
}

ST_FUNC void gen_le16(int v)
{
	g(v);
	g(v >> 8);
}

ST_FUNC void gen_le32(int c)
{
	g(c);
	g(c >> 8);
	g(c >> 16);
	g(c >> 24);
}

/* output a symbol and patch all calls to it */
ST_FUNC void gsym_addr(int t, int a)
{
	while (t)
	{
		unsigned char *ptr = cur_text_section->data + t;
		uint32_t n = read32le(ptr); /* next value */
		write32le(ptr, a - t - 4);
		t = n;
	}
}

/* instruction + 4 bytes data. Return the address of the data */
static int oad(int c, int s)
{
	int t;
	if (nocode_wanted)
		return s;
	o(c);
	t = ind;
	gen_le32(s);
	return t;
}

ST_FUNC void gen_fill_nops(int bytes)
{
	while (bytes--)
		g(0x90);
}

/* generate jmp to a label */
#define gjmp2(instr,lbl) oad(instr,lbl)

/* output constant with relocation if 'r & VT_SYM' is true */
ST_FUNC void gen_addr32(int r, Sym *sym, int c)
{
	if (r & VT_SYM)
		greloc(cur_text_section, sym, ind, R_386_32);
	gen_le32(c);
}

ST_FUNC void gen_addrpc32(int r, Sym *sym, int c)
{
	if (r & VT_SYM)
		greloc(cur_text_section, sym, ind, R_386_PC32);
	gen_le32(c - 4);
}

/* generate a modrm reference. 'op_reg' contains the additional 3
   opcode bits */
static void gen_modrm(int op_reg, int r, Sym *sym, int c)
{
	op_reg = op_reg << 3;
	if ((r & VT_VALMASK) == VT_CONST)
	{
		/* constant memory reference */
		o(0x05 | op_reg);
		gen_addr32(r, sym, c);
	}
	else if ((r & VT_VALMASK) == VT_LOCAL)
	{
		/* currently, we use only ebp as base */
		if (c == (char)c)
		{
			/* short reference */
			o(0x45 | op_reg);
			g(c);
		}
		else
		{
			oad(0x85 | op_reg, c);
		}
	}
	else
	{
		g(0x00 | op_reg | (r & VT_VALMASK));
	}
}

/* load 'r' from value 'sv' */
ST_FUNC void load(int r, SValue *sv)
{
	int v, t, ft, fc, fr;
	SValue v1;

#ifdef TCC_TARGET_PE
	SValue v2;
	sv = pe_getimport(sv, &v2);
#endif

	fr = sv->r;
	ft = sv->type.t & ~VT_DEFSIGN;
	fc = sv->c.i;

	ft &= ~(VT_VOLATILE | VT_CONSTANT);

	v = fr & VT_VALMASK;
	if (fr & VT_LVAL)
	{
		if (v == VT_LLOCAL)
		{
			v1.type.t = VT_INT;
			v1.r = VT_LOCAL | VT_LVAL;
			v1.c.i = fc;
			fr = r;
			if (!(reg_classes[fr] & RC_INT))
				fr = get_reg(RC_INT);
			load(fr, &v1);
		}
		if ((ft & VT_BTYPE) == VT_FLOAT)
		{
			o(0xd9); /* flds */
			r = 0;
		}
		else if ((ft & VT_BTYPE) == VT_DOUBLE)
		{
			o(0xdd); /* fldl */
			r = 0;
		}
		else if ((ft & VT_BTYPE) == VT_LDOUBLE)
		{
			o(0xdb); /* fldt */
			r = 5;
		}
		else if ((ft & VT_TYPE) == VT_BYTE || (ft & VT_TYPE) == VT_BOOL)
		{
			o(0xbe0f);   /* movsbl */
		}
		else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED))
		{
			o(0xb60f);   /* movzbl */
		}
		else if ((ft & VT_TYPE) == VT_SHORT)
		{
			o(0xbf0f);   /* movswl */
		}
		else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED))
		{
			o(0xb70f);   /* movzwl */
		}
		else
		{
			o(0x8b);     /* movl */
		}
		gen_modrm(r, fr, sv->sym, fc);
	}
	else
	{
		if (v == VT_CONST)
		{
			o(0xb8 + r); /* mov $xx, r */
			gen_addr32(fr, sv->sym, fc);
		}
		else if (v == VT_LOCAL)
		{
			if (fc)
			{
				o(0x8d); /* lea xxx(%ebp), r */
				gen_modrm(r, VT_LOCAL, sv->sym, fc);
			}
			else
			{
				o(0x89);
				o(0xe8 + r); /* mov %ebp, r */
			}
		}
		else if (v == VT_CMP)
		{
			o(0x0f); /* setxx %br */
			o(fc);
			o(0xc0 + r);
			o(0xc0b60f + r * 0x90000); /* movzbl %al, %eax */
		}
		else if (v == VT_JMP || v == VT_JMPI)
		{
			t = v & 1;
			oad(0xb8 + r, t); /* mov $1, r */
			o(0x05eb); /* jmp after */
			gsym(fc);
			oad(0xb8 + r, t ^ 1); /* mov $0, r */
		}
		else if (v != r)
		{
			o(0x89);
			o(0xc0 + r + v * 8); /* mov v, r */
		}
	}
}

/* store register 'r' in lvalue 'v' */
ST_FUNC void store(int r, SValue *v)
{
	int fr, bt, ft, fc;

#ifdef TCC_TARGET_PE
	SValue v2;
	v = pe_getimport(v, &v2);
#endif

	ft = v->type.t;
	fc = v->c.i;
	fr = v->r & VT_VALMASK;
	ft &= ~(VT_VOLATILE | VT_CONSTANT);
	bt = ft & VT_BTYPE;
	/* XXX: incorrect if float reg to reg */
	if (bt == VT_FLOAT)
	{
		o(0xd9); /* fsts */
		r = 2;
	}
	else if (bt == VT_DOUBLE)
	{
		o(0xdd); /* fstpl */
		r = 2;
	}
	else if (bt == VT_LDOUBLE)
	{
		o(0xc0d9); /* fld %st(0) */
		o(0xdb); /* fstpt */
		r = 7;
	}
	else
	{
		if (bt == VT_SHORT)
			o(0x66);
		if (bt == VT_BYTE || bt == VT_BOOL)
			o(0x88);
		else
			o(0x89);
	}
	if (fr == VT_CONST ||
	        fr == VT_LOCAL ||
	        (v->r & VT_LVAL))
	{
		gen_modrm(r, v->r, v->sym, fc);
	}
	else if (fr != r)
	{
		o(0xc0 + fr + r * 8); /* mov r, fr */
	}
}

static void gadd_sp(int val)
{
	if (val == (char)val)
	{
		o(0xc483);
		g(val);
	}
	else
	{
		oad(0xc481, val); /* add $xxx, %esp */
	}
}

#if defined CONFIG_TCC_BCHECK || defined TCC_TARGET_PE
static void gen_static_call(int v)
{
	Sym *sym;

	sym = external_global_sym(v, &func_old_type);
	oad(0xe8, -4);
	greloc(cur_text_section, sym, ind-4, R_386_PC32);
}
#endif

/* 'is_jmp' is '1' if it is a jump */
static void gcall_or_jmp(int is_jmp)
{
	int r;
	if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST && (vtop->r & VT_SYM))
	{
		/* constant and relocation case */
		greloc(cur_text_section, vtop->sym, ind + 1, R_386_PC32);
		oad(0xe8 + is_jmp, vtop->c.i - 4); /* call/jmp im */
	}
	else
	{
		/* otherwise, indirect call */
		r = gv(RC_INT);
		o(0xff); /* call/jmp *r */
		o(0xd0 + r + (is_jmp << 4));
	}
}

static uint8_t fastcall_regs[3] = { TREG_EAX, TREG_EDX, TREG_ECX };
static uint8_t fastcallw_regs[2] = { TREG_ECX, TREG_EDX };

/* Return the number of registers needed to return the struct, or 0 if
   returning via struct pointer. */
ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)
{
#ifdef TCC_TARGET_PE
	int size, align;
	*ret_align = 1; // Never have to re-align return values for x86
	*regsize = 4;
	size = type_size(vt, &align);
	if (size > 8 || (size & (size - 1)))
		return 0;
	if (size == 8)
		ret->t = VT_LLONG;
	else if (size == 4)
		ret->t = VT_INT;
	else if (size == 2)
		ret->t = VT_SHORT;
	else
		ret->t = VT_BYTE;
	ret->ref = NULL;
	return 1;
#else
	*ret_align = 1; // Never have to re-align return values for x86
	return 0;
#endif
}

/* Generate function call. The function address is pushed first, then
   all the parameters in call order. This functions pops all the
   parameters and the function address. */
ST_FUNC void gfunc_call(int nb_args)
{
	int size, align, r, args_size, i, func_call;
	Sym *func_sym;

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gbound_args(nb_args);
#endif

	args_size = 0;
	for(i = 0; i < nb_args; i++)
	{
		if ((vtop->type.t & VT_BTYPE) == VT_STRUCT)
		{
			size = type_size(&vtop->type, &align);
			/* align to stack align size */
			size = (size + 3) & ~3;
			/* allocate the necessary size on stack */
			oad(0xec81, size); /* sub $xxx, %esp */
			/* generate structure store */
			r = get_reg(RC_INT);
			o(0x89); /* mov %esp, r */
			o(0xe0 + r);
			vset(&vtop->type, r | VT_LVAL, 0);
			vswap();
			vstore();
			args_size += size;
		}
		else if (is_float(vtop->type.t))
		{
			gv(RC_FLOAT); /* only one float register */
			if ((vtop->type.t & VT_BTYPE) == VT_FLOAT)
				size = 4;
			else if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)
				size = 8;
			else
				size = 12;
			oad(0xec81, size); /* sub $xxx, %esp */
			if (size == 12)
				o(0x7cdb);
			else
				o(0x5cd9 + size - 4); /* fstp[s|l] 0(%esp) */
			g(0x24);
			g(0x00);
			args_size += size;
		}
		else
		{
			/* simple type (currently always same size) */
			/* XXX: implicit cast ? */
			r = gv(RC_INT);
			if ((vtop->type.t & VT_BTYPE) == VT_LLONG)
			{
				size = 8;
				o(0x50 + vtop->r2); /* push r */
			}
			else
			{
				size = 4;
			}
			o(0x50 + r); /* push r */
			args_size += size;
		}
		vtop--;
	}
	save_regs(0); /* save used temporary registers */
	func_sym = vtop->type.ref;
	func_call = func_sym->f.func_call;
	/* fast call case */
	if ((func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3) ||
	        func_call == FUNC_FASTCALLW)
	{
		int fastcall_nb_regs;
		uint8_t *fastcall_regs_ptr;
		if (func_call == FUNC_FASTCALLW)
		{
			fastcall_regs_ptr = fastcallw_regs;
			fastcall_nb_regs = 2;
		}
		else
		{
			fastcall_regs_ptr = fastcall_regs;
			fastcall_nb_regs = func_call - FUNC_FASTCALL1 + 1;
		}
		for(i = 0; i < fastcall_nb_regs; i++)
		{
			if (args_size <= 0)
				break;
			o(0x58 + fastcall_regs_ptr[i]); /* pop r */
			/* XXX: incorrect for struct/floats */
			args_size -= 4;
		}
	}
#ifndef TCC_TARGET_PE
	else if ((vtop->type.ref->type.t & VT_BTYPE) == VT_STRUCT)
		args_size -= 4;
#endif

	gcall_or_jmp(0);

	if (args_size && func_call != FUNC_STDCALL && func_call != FUNC_FASTCALLW)
		gadd_sp(args_size);
	vtop--;
}

#ifdef TCC_TARGET_PE
#define FUNC_PROLOG_SIZE (10 + USE_EBX)
#else
#define FUNC_PROLOG_SIZE (9 + USE_EBX)
#endif

/* generate function prolog of type 't' */
ST_FUNC void gfunc_prolog(Sym *func_sym)
{
	CType *func_type = &func_sym->type;
	int addr, align, size, func_call, fastcall_nb_regs;
	int param_index, param_addr;
	uint8_t *fastcall_regs_ptr;
	Sym *sym;
	CType *type;

	sym = func_type->ref;
	func_call = sym->f.func_call;
	addr = 8;
	loc = 0;
	func_vc = 0;

	if (func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3)
	{
		fastcall_nb_regs = func_call - FUNC_FASTCALL1 + 1;
		fastcall_regs_ptr = fastcall_regs;
	}
	else if (func_call == FUNC_FASTCALLW)
	{
		fastcall_nb_regs = 2;
		fastcall_regs_ptr = fastcallw_regs;
	}
	else
	{
		fastcall_nb_regs = 0;
		fastcall_regs_ptr = NULL;
	}
	param_index = 0;

	ind += FUNC_PROLOG_SIZE;
	func_sub_sp_offset = ind;
	/* if the function returns a structure, then add an
	   implicit pointer parameter */
	func_vt = sym->type;
	func_var = (sym->f.func_type == FUNC_ELLIPSIS);
#ifdef TCC_TARGET_PE
	size = type_size(&func_vt,&align);
	if (((func_vt.t & VT_BTYPE) == VT_STRUCT)
	        && (size > 8 || (size & (size - 1))))
	{
#else
	if ((func_vt.t & VT_BTYPE) == VT_STRUCT)
	{
#endif
		/* XXX: fastcall case ? */
		func_vc = addr;
		addr += 4;
		param_index++;
	}
	/* define parameters */
	while ((sym = sym->next) != NULL)
	{
		type = &sym->type;
		size = type_size(type, &align);
		size = (size + 3) & ~3;
#ifdef FUNC_STRUCT_PARAM_AS_PTR
		/* structs are passed as pointer */
		if ((type->t & VT_BTYPE) == VT_STRUCT)
		{
			size = 4;
		}
#endif
		if (param_index < fastcall_nb_regs)
		{
			/* save FASTCALL register */
			loc -= 4;
			o(0x89);     /* movl */
			gen_modrm(fastcall_regs_ptr[param_index], VT_LOCAL, NULL, loc);
			param_addr = loc;
		}
		else
		{
			param_addr = addr;
			addr += size;
		}
		sym_push(sym->v & ~SYM_FIELD, type,
		         VT_LOCAL | VT_LVAL, param_addr);
		param_index++;
	}
	func_ret_sub = 0;
	/* pascal type call or fastcall ? */
	if (func_call == FUNC_STDCALL || func_call == FUNC_FASTCALLW)
		func_ret_sub = addr - 8;
#ifndef TCC_TARGET_PE
	else if (func_vc)
		func_ret_sub = 4;
#endif

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gen_bounds_prolog();
#endif
}

/* generate function epilog */
ST_FUNC void gfunc_epilog(void)
{
	addr_t v, saved_ind;

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gen_bounds_epilog();
#endif

	/* align local size to word & save local variables */
	v = (-loc + 3) & -4;

#if USE_EBX
	o(0x8b);
	gen_modrm(TREG_EBX, VT_LOCAL, NULL, -(v+4));
#endif

	o(0xc9); /* leave */
	if (func_ret_sub == 0)
	{
		o(0xc3); /* ret */
	}
	else
	{
		o(0xc2); /* ret n */
		g(func_ret_sub);
		g(func_ret_sub >> 8);
	}
	saved_ind = ind;
	ind = func_sub_sp_offset - FUNC_PROLOG_SIZE;
#ifdef TCC_TARGET_PE
	if (v >= 4096)
	{
		oad(0xb8, v); /* mov stacksize, %eax */
		gen_static_call(TOK___chkstk); /* call __chkstk, (does the stackframe too) */
	}
	else
#endif
	{
		o(0xe58955);  /* push %ebp, mov %esp, %ebp */
		o(0xec81);  /* sub esp, stacksize */
		gen_le32(v);
#ifdef TCC_TARGET_PE
		o(0x90);  /* adjust to FUNC_PROLOG_SIZE */
#endif
	}
	o(0x53 * USE_EBX); /* push ebx */
	ind = saved_ind;
}

/* generate a jump to a label */
ST_FUNC int gjmp(int t)
{
	return gjmp2(0xe9, t);
}

/* generate a jump to a fixed address */
ST_FUNC void gjmp_addr(int a)
{
	int r;
	r = a - ind - 2;
	if (r == (char)r)
	{
		g(0xeb);
		g(r);
	}
	else
	{
		oad(0xe9, a - ind - 5);
	}
}

#if 0
/* generate a jump to a fixed address */
ST_FUNC void gjmp_cond_addr(int a, int op)
{
	int r = a - ind - 2;
	if (r == (char)r)
		g(op - 32), g(r);
	else
		g(0x0f), gjmp2(op - 16, r - 4);
}
#endif

ST_FUNC int gjmp_append(int n, int t)
{
	void *p;
	/* insert vtop->c jump list in t */
	if (n)
	{
		uint32_t n1 = n, n2;
		while ((n2 = read32le(p = cur_text_section->data + n1)))
			n1 = n2;
		write32le(p, t);
		t = n;
	}
	return t;
}

ST_FUNC int gjmp_cond(int op, int t)
{
	g(0x0f);
	t = gjmp2(op - 16, t);
	return t;
}

ST_FUNC void gen_opi(int op)
{
	int r, fr, opc, c;

	switch(op)
	{
	case '+':
	case TOK_ADDC1: /* add with carry generation */
		opc = 0;
gen_op8:
		if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
		{
			/* constant case */
			vswap();
			r = gv(RC_INT);
			vswap();
			c = vtop->c.i;
			if (c == (char)c)
			{
				/* generate inc and dec for smaller code */
				if ((c == 1 || c == -1) && (op == '+' || op == '-'))
				{
					opc = (c == 1) ^ (op == '+');
					o (0x40 | (opc << 3) | r); // inc,dec
				}
				else
				{
					o(0x83);
					o(0xc0 | (opc << 3) | r);
					g(c);
				}
			}
			else
			{
				o(0x81);
				oad(0xc0 | (opc << 3) | r, c);
			}
		}
		else
		{
			gv2(RC_INT, RC_INT);
			r = vtop[-1].r;
			fr = vtop[0].r;
			o((opc << 3) | 0x01);
			o(0xc0 + r + fr * 8);
		}
		vtop--;
		if (op >= TOK_ULT && op <= TOK_GT)
			vset_VT_CMP(op);
		break;
	case '-':
	case TOK_SUBC1: /* sub with carry generation */
		opc = 5;
		goto gen_op8;
	case TOK_ADDC2: /* add with carry use */
		opc = 2;
		goto gen_op8;
	case TOK_SUBC2: /* sub with carry use */
		opc = 3;
		goto gen_op8;
	case '&':
		opc = 4;
		goto gen_op8;
	case '^':
		opc = 6;
		goto gen_op8;
	case '|':
		opc = 1;
		goto gen_op8;
	case '*':
		gv2(RC_INT, RC_INT);
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		o(0xaf0f); /* imul fr, r */
		o(0xc0 + fr + r * 8);
		break;
	case TOK_SHL:
		opc = 4;
		goto gen_shift;
	case TOK_SHR:
		opc = 5;
		goto gen_shift;
	case TOK_SAR:
		opc = 7;
gen_shift:
		opc = 0xc0 | (opc << 3);
		if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
		{
			/* constant case */
			vswap();
			r = gv(RC_INT);
			vswap();
			c = vtop->c.i & 0x1f;
			o(0xc1); /* shl/shr/sar $xxx, r */
			o(opc | r);
			g(c);
		}
		else
		{
			/* we generate the shift in ecx */
			gv2(RC_INT, RC_ECX);
			r = vtop[-1].r;
			o(0xd3); /* shl/shr/sar %cl, r */
			o(opc | r);
		}
		vtop--;
		break;
	case '/':
	case TOK_UDIV:
	case TOK_PDIV:
	case '%':
	case TOK_UMOD:
	case TOK_UMULL:
		/* first operand must be in eax */
		/* XXX: need better constraint for second operand */
		gv2(RC_EAX, RC_ECX);
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		save_reg(TREG_EDX);
		/* save EAX too if used otherwise */
		save_reg_upstack(TREG_EAX, 1);
		if (op == TOK_UMULL)
		{
			o(0xf7); /* mul fr */
			o(0xe0 + fr);
			vtop->r2 = TREG_EDX;
			r = TREG_EAX;
		}
		else
		{
			if (op == TOK_UDIV || op == TOK_UMOD)
			{
				o(0xf7d231); /* xor %edx, %edx, div fr, %eax */
				o(0xf0 + fr);
			}
			else
			{
				o(0xf799); /* cltd, idiv fr, %eax */
				o(0xf8 + fr);
			}
			if (op == '%' || op == TOK_UMOD)
				r = TREG_EDX;
			else
				r = TREG_EAX;
		}
		vtop->r = r;
		break;
	default:
		opc = 7;
		goto gen_op8;
	}
}

/* generate a floating point operation 'v = t1 op t2' instruction. The
   two operands are guaranteed to have the same floating point type */
/* XXX: need to use ST1 too */
ST_FUNC void gen_opf(int op)
{
	int a, ft, fc, swapped, r;

	/* convert constants to memory references */
	if ((vtop[-1].r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
	{
		vswap();
		gv(RC_FLOAT);
		vswap();
	}
	if ((vtop[0].r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
		gv(RC_FLOAT);

	/* must put at least one value in the floating point register */
	if ((vtop[-1].r & VT_LVAL) &&
	        (vtop[0].r & VT_LVAL))
	{
		vswap();
		gv(RC_FLOAT);
		vswap();
	}
	swapped = 0;
	/* swap the stack if needed so that t1 is the register and t2 is
	   the memory reference */
	if (vtop[-1].r & VT_LVAL)
	{
		vswap();
		swapped = 1;
	}
	if (op >= TOK_ULT && op <= TOK_GT)
	{
		/* load on stack second operand */
		load(TREG_ST0, vtop);
		save_reg(TREG_EAX); /* eax is used by FP comparison code */
		if (op == TOK_GE || op == TOK_GT)
			swapped = !swapped;
		else if (op == TOK_EQ || op == TOK_NE)
			swapped = 0;
		if (swapped)
			o(0xc9d9); /* fxch %st(1) */
		if (op == TOK_EQ || op == TOK_NE)
			o(0xe9da); /* fucompp */
		else
			o(0xd9de); /* fcompp */
		o(0xe0df); /* fnstsw %ax */
		if (op == TOK_EQ)
		{
			o(0x45e480); /* and $0x45, %ah */
			o(0x40fC80); /* cmp $0x40, %ah */
		}
		else if (op == TOK_NE)
		{
			o(0x45e480); /* and $0x45, %ah */
			o(0x40f480); /* xor $0x40, %ah */
			op = TOK_NE;
		}
		else if (op == TOK_GE || op == TOK_LE)
		{
			o(0x05c4f6); /* test $0x05, %ah */
			op = TOK_EQ;
		}
		else
		{
			o(0x45c4f6); /* test $0x45, %ah */
			op = TOK_EQ;
		}
		vtop--;
		vset_VT_CMP(op);
	}
	else
	{
		/* no memory reference possible for long double operations */
		if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE)
		{
			load(TREG_ST0, vtop);
			swapped = !swapped;
		}

		switch(op)
		{
		default:
		case '+':
			a = 0;
			break;
		case '-':
			a = 4;
			if (swapped)
				a++;
			break;
		case '*':
			a = 1;
			break;
		case '/':
			a = 6;
			if (swapped)
				a++;
			break;
		}
		ft = vtop->type.t;
		fc = vtop->c.i;
		if ((ft & VT_BTYPE) == VT_LDOUBLE)
		{
			o(0xde); /* fxxxp %st, %st(1) */
			o(0xc1 + (a << 3));
		}
		else
		{
			/* if saved lvalue, then we must reload it */
			r = vtop->r;
			if ((r & VT_VALMASK) == VT_LLOCAL)
			{
				SValue v1;
				r = get_reg(RC_INT);
				v1.type.t = VT_INT;
				v1.r = VT_LOCAL | VT_LVAL;
				v1.c.i = fc;
				load(r, &v1);
				fc = 0;
			}

			if ((ft & VT_BTYPE) == VT_DOUBLE)
				o(0xdc);
			else
				o(0xd8);
			gen_modrm(a, r, vtop->sym, fc);
		}
		vtop--;
	}
}

/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'
   and 'long long' cases. */
ST_FUNC void gen_cvt_itof(int t)
{
	save_reg(TREG_ST0);
	gv(RC_INT);
	if ((vtop->type.t & VT_BTYPE) == VT_LLONG)
	{
		/* signed long long to float/double/long double (unsigned case
		   is handled generically) */
		o(0x50 + vtop->r2); /* push r2 */
		o(0x50 + (vtop->r & VT_VALMASK)); /* push r */
		o(0x242cdf); /* fildll (%esp) */
		o(0x08c483); /* add $8, %esp */
		vtop->r2 = VT_CONST;
	}
	else if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) ==
	         (VT_INT | VT_UNSIGNED))
	{
		/* unsigned int to float/double/long double */
		o(0x6a); /* push $0 */
		g(0x00);
		o(0x50 + (vtop->r & VT_VALMASK)); /* push r */
		o(0x242cdf); /* fildll (%esp) */
		o(0x08c483); /* add $8, %esp */
	}
	else
	{
		/* int to float/double/long double */
		o(0x50 + (vtop->r & VT_VALMASK)); /* push r */
		o(0x2404db); /* fildl (%esp) */
		o(0x04c483); /* add $4, %esp */
	}
	vtop->r2 = VT_CONST;
	vtop->r = TREG_ST0;
}

/* convert fp to int 't' type */
ST_FUNC void gen_cvt_ftoi(int t)
{
	int bt = vtop->type.t & VT_BTYPE;
	if (bt == VT_FLOAT)
		vpush_global_sym(&func_old_type, TOK___fixsfdi);
	else if (bt == VT_LDOUBLE)
		vpush_global_sym(&func_old_type, TOK___fixxfdi);
	else
		vpush_global_sym(&func_old_type, TOK___fixdfdi);
	vswap();
	gfunc_call(1);
	vpushi(0);
	vtop->r = REG_IRET;
	if ((t & VT_BTYPE) == VT_LLONG)
		vtop->r2 = REG_IRE2;
}

/* convert from one floating point type to another */
ST_FUNC void gen_cvt_ftof(int t)
{
	/* all we have to do on i386 is to put the float in a register */
	gv(RC_FLOAT);
}

/* char/short to int conversion */
ST_FUNC void gen_cvt_csti(int t)
{
	int r, sz, xl;
	r = gv(RC_INT);
	sz = !(t & VT_UNSIGNED);
	xl = (t & VT_BTYPE) == VT_SHORT;
	o(0xc0b60f /* mov[sz] %a[xl], %eax */
	  | (sz << 3 | xl) << 8
	  | (r << 3 | r) << 16
	 );
}

/* computed goto support */
ST_FUNC void ggoto(void)
{
	gcall_or_jmp(1);
	vtop--;
}

/* bound check support functions */
#ifdef CONFIG_TCC_BCHECK
/* generate a bounded pointer addition */
ST_FUNC void gen_bounded_ptr_add(void)
{
	vpush_global_sym(&func_old_type, TOK___bound_ptr_add);
	vrott(3);
	gfunc_call(2);
	vpushi(0);
	/* returned pointer is in eax */
	vtop->r = TREG_EAX | VT_BOUNDED;
	if (nocode_wanted)
		return;
	/* relocation offset of the bounding function call point */
	vtop->c.i = (cur_text_section->reloc->data_offset - sizeof(Elf32_Rel));
}

/* patch pointer addition in vtop so that pointer dereferencing is
   also tested */
ST_FUNC void gen_bounded_ptr_deref(void)
{
	addr_t func;
	int  size, align;
	Elf32_Rel *rel;
	Sym *sym;

	if (nocode_wanted)
		return;

	size = type_size(&vtop->type, &align);
	switch(size)
	{
	case  1:
		func = TOK___bound_ptr_indir1;
		break;
	case  2:
		func = TOK___bound_ptr_indir2;
		break;
	case  4:
		func = TOK___bound_ptr_indir4;
		break;
	case  8:
		func = TOK___bound_ptr_indir8;
		break;
	case 12:
		func = TOK___bound_ptr_indir12;
		break;
	case 16:
		func = TOK___bound_ptr_indir16;
		break;
	default:
		/* may happen with struct member access */
		return;
		//tcc_error("unhandled size when dereferencing bounded pointer");
		//func = 0;
		//break;
	}
	sym = external_global_sym(func, &func_old_type);
	if (!sym->c)
		put_extern_sym(sym, NULL, 0, 0);
	/* patch relocation */
	/* XXX: find a better solution ? */
	rel = (Elf32_Rel *)(cur_text_section->reloc->data + vtop->c.i);
	rel->r_info = ELF32_R_INFO(sym->c, ELF32_R_TYPE(rel->r_info));
}

static void gen_bounds_prolog(void)
{
	/* leave some room for bound checking code */
	func_bound_offset = lbounds_section->data_offset;
	func_bound_ind = ind;
	oad(0xb8, 0); /* lbound section pointer */
	oad(0xb8, 0); /* call to function */
}

static void gen_bounds_epilog(void)
{
	addr_t saved_ind;
	addr_t *bounds_ptr;
	Sym *sym_data;

	/* add end of table info */
	bounds_ptr = section_ptr_add(lbounds_section, sizeof(addr_t));
	*bounds_ptr = 0;

	/* generate bound local allocation */
	saved_ind = ind;
	ind = func_bound_ind;
	sym_data = get_sym_ref(&char_pointer_type, lbounds_section,
	                       func_bound_offset, lbounds_section->data_offset);
	greloc(cur_text_section, sym_data, ind + 1, R_386_32);
	ind = ind + 5;
	gen_static_call(TOK___bound_local_new);
	ind = saved_ind;

	/* generate bound check local freeing */
	o(0x5250); /* save returned value, if any */
	greloc(cur_text_section, sym_data, ind + 1, R_386_32);
	oad(0xb8, 0); /* mov %eax, xxx */
	gen_static_call(TOK___bound_local_delete);
	o(0x585a); /* restore returned value, if any */
}
#endif

/* Save the stack pointer onto the stack */
ST_FUNC void gen_vla_sp_save(int addr)
{
	/* mov %esp,addr(%ebp)*/
	o(0x89);
	gen_modrm(TREG_ESP, VT_LOCAL, NULL, addr);
}

/* Restore the SP from a location on the stack */
ST_FUNC void gen_vla_sp_restore(int addr)
{
	o(0x8b);
	gen_modrm(TREG_ESP, VT_LOCAL, NULL, addr);
}

/* Subtract from the stack pointer, and push the resulting value onto the stack */
ST_FUNC void gen_vla_alloc(CType *type, int align)
{
	int use_call = 0;

#if defined(CONFIG_TCC_BCHECK)
	use_call = tcc_state->do_bounds_check;
#endif
#ifdef TCC_TARGET_PE    /* alloca does more than just adjust %rsp on Windows */
	use_call = 1;
#endif
	if (use_call)
	{
		vpush_global_sym(&func_old_type, TOK_alloca);
		vswap(); /* Move alloca ref past allocation size */
		gfunc_call(1);
	}
	else
	{
		int r;
		r = gv(RC_INT); /* allocation size */
		/* sub r,%rsp */
		o(0x2b);
		o(0xe0 | r);
		/* We align to 16 bytes rather than align */
		/* and ~15, %esp */
		o(0xf0e483);
		vpop();
	}
}

/* end of X86 code generator */

//END i386-gen.c


//START i386-link.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

#ifndef ELF_OBJ_ONLY
/* Returns 1 for a code relocation, 0 for a data relocation. For unknown
   relocations, returns -1. */
int code_reloc (int reloc_type)
{
	switch (reloc_type)
	{
	case R_386_RELATIVE:
	case R_386_16:
	case R_386_32:
	case R_386_GOTPC:
	case R_386_GOTOFF:
	case R_386_GOT32:
	case R_386_GOT32X:
	case R_386_GLOB_DAT:
	case R_386_COPY:
		return 0;

	case R_386_PC16:
	case R_386_PC32:
	case R_386_PLT32:
	case R_386_JMP_SLOT:
		return 1;
	}
	return -1;
}

/* Returns an enumerator to describe whether and when the relocation needs a
   GOT and/or PLT entry to be created. See tcc.h for a description of the
   different values. */
int gotplt_entry_type (int reloc_type)
{
	switch (reloc_type)
	{
	case R_386_RELATIVE:
	case R_386_16:
	case R_386_GLOB_DAT:
	case R_386_JMP_SLOT:
	case R_386_COPY:
		return NO_GOTPLT_ENTRY;

	case R_386_32:
		/* This relocations shouldn't normally need GOT or PLT
		   slots if it weren't for simplicity in the code generator.
		   See our caller for comments.  */
		return AUTO_GOTPLT_ENTRY;

	case R_386_PC16:
	case R_386_PC32:
		return AUTO_GOTPLT_ENTRY;

	case R_386_GOTPC:
	case R_386_GOTOFF:
		return BUILD_GOT_ONLY;

	case R_386_GOT32:
	case R_386_GOT32X:
	case R_386_PLT32:
		return ALWAYS_GOTPLT_ENTRY;
	}
	return -1;
}

ST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)
{
	Section *plt = s1->plt;
	uint8_t *p;
	int modrm;
	unsigned plt_offset, relofs;

	/* on i386 if we build a DLL, we add a %ebx offset */
	if (s1->output_type == TCC_OUTPUT_DLL)
		modrm = 0xa3;
	else
		modrm = 0x25;

	/* empty PLT: create PLT0 entry that pushes the library identifier
	   (GOT + PTR_SIZE) and jumps to ld.so resolution routine
	   (GOT + 2 * PTR_SIZE) */
	if (plt->data_offset == 0)
	{
		p = section_ptr_add(plt, 16);
		p[0] = 0xff; /* pushl got + PTR_SIZE */
		p[1] = modrm + 0x10;
		write32le(p + 2, PTR_SIZE);
		p[6] = 0xff; /* jmp *(got + PTR_SIZE * 2) */
		p[7] = modrm;
		write32le(p + 8, PTR_SIZE * 2);
	}
	plt_offset = plt->data_offset;

	/* The PLT slot refers to the relocation entry it needs via offset.
	   The reloc entry is created below, so its offset is the current
	   data_offset */
	relofs = s1->got->reloc ? s1->got->reloc->data_offset : 0;

	/* Jump to GOT entry where ld.so initially put the address of ip + 4 */
	p = section_ptr_add(plt, 16);
	p[0] = 0xff; /* jmp *(got + x) */
	p[1] = modrm;
	write32le(p + 2, got_offset);
	p[6] = 0x68; /* push $xxx */
	write32le(p + 7, relofs);
	p[11] = 0xe9; /* jmp plt_start */
	write32le(p + 12, -(plt->data_offset));
	return plt_offset;
}

/* relocate the PLT: compute addresses and offsets in the PLT now that final
   address for PLT and GOT are known (see fill_program_header) */
ST_FUNC void relocate_plt(TCCState *s1)
{
	uint8_t *p, *p_end;

	if (!s1->plt)
		return;

	p = s1->plt->data;
	p_end = p + s1->plt->data_offset;

	if (p < p_end)
	{
		add32le(p + 2, s1->got->sh_addr);
		add32le(p + 8, s1->got->sh_addr);
		p += 16;
		while (p < p_end)
		{
			add32le(p + 2, s1->got->sh_addr);
			p += 16;
		}
	}
}
#endif

void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)
{
	int sym_index, esym_index;

	sym_index = ELFW(R_SYM)(rel->r_info);

	switch (type)
	{
	case R_386_32:
		if (s1->output_type == TCC_OUTPUT_DLL)
		{
			esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;
			qrel->r_offset = rel->r_offset;
			if (esym_index)
			{
				qrel->r_info = ELFW(R_INFO)(esym_index, R_386_32);
				qrel++;
				return;
			}
			else
			{
				qrel->r_info = ELFW(R_INFO)(0, R_386_RELATIVE);
				qrel++;
			}
		}
		add32le(ptr, val);
		return;
	case R_386_PC32:
		if (s1->output_type == TCC_OUTPUT_DLL)
		{
			/* DLL relocation */
			esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;
			if (esym_index)
			{
				qrel->r_offset = rel->r_offset;
				qrel->r_info = ELFW(R_INFO)(esym_index, R_386_PC32);
				qrel++;
				return;
			}
		}
		add32le(ptr, val - addr);
		return;
	case R_386_PLT32:
		add32le(ptr, val - addr);
		return;
	case R_386_GLOB_DAT:
	case R_386_JMP_SLOT:
		write32le(ptr, val);
		return;
	case R_386_GOTPC:
		add32le(ptr, s1->got->sh_addr - addr);
		return;
	case R_386_GOTOFF:
		add32le(ptr, val - s1->got->sh_addr);
		return;
	case R_386_GOT32:
	case R_386_GOT32X:
		/* we load the got offset */
		add32le(ptr, get_sym_attr(s1, sym_index, 0)->got_offset);
		return;
	case R_386_16:
		if (s1->output_format != TCC_OUTPUT_FORMAT_BINARY)
		{
output_file:
			tcc_error("can only produce 16-bit binary files");
		}
		write16le(ptr, read16le(ptr) + val);
		return;
	case R_386_PC16:
		if (s1->output_format != TCC_OUTPUT_FORMAT_BINARY)
			goto output_file;
		write16le(ptr, read16le(ptr) + val - addr);
		return;
	case R_386_RELATIVE:
#ifdef TCC_TARGET_PE
		add32le(ptr, val - s1->pe_imagebase);
#endif
		/* do nothing */
		return;
	case R_386_COPY:
		/* This relocation must copy initialized data from the library
		to the program .bss segment. Currently made like for ARM
		(to remove noise of default case). Is this true?
		*/
		return;
	default:
		fprintf(stderr,"FIXME: handle reloc type %d at %x [%p] to %x\n",
		        type, (unsigned)addr, ptr, (unsigned)val);
		return;
	}
}


//END i386-link.c

#elif defined TCC_TARGET_X86_64
//START x86_64-gen.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

ST_DATA const int reg_classes[NB_REGS] =
{
	/* eax */ RC_INT | RC_RAX,
	/* ecx */ RC_INT | RC_RCX,
	/* edx */ RC_INT | RC_RDX,
	0,
	0,
	0,
	0,
	0,
	RC_R8,
	RC_R9,
	RC_R10,
	RC_R11,
	0,
	0,
	0,
	0,
	/* xmm0 */ RC_FLOAT | RC_XMM0,
	/* xmm1 */ RC_FLOAT | RC_XMM1,
	/* xmm2 */ RC_FLOAT | RC_XMM2,
	/* xmm3 */ RC_FLOAT | RC_XMM3,
	/* xmm4 */ RC_FLOAT | RC_XMM4,
	/* xmm5 */ RC_FLOAT | RC_XMM5,
	/* xmm6 an xmm7 are included so gv() can be used on them,
	   but they are not tagged with RC_FLOAT because they are
	   callee saved on Windows */
	RC_XMM6,
	RC_XMM7,
	/* st0 */ RC_ST0
};

static unsigned long func_sub_sp_offset;
static int func_ret_sub;

/* XXX: make it faster ? */
ST_FUNC void g(int c)
{
	int ind1;
	if (nocode_wanted)
		return;
	ind1 = ind + 1;
	if (ind1 > cur_text_section->data_allocated)
		section_realloc(cur_text_section, ind1);
	cur_text_section->data[ind] = c;
	ind = ind1;
}

ST_FUNC void o(unsigned int c)
{
	while (c)
	{
		g(c);
		c = c >> 8;
	}
}

ST_FUNC void gen_le16(int v)
{
	g(v);
	g(v >> 8);
}

ST_FUNC void gen_le32(int c)
{
	g(c);
	g(c >> 8);
	g(c >> 16);
	g(c >> 24);
}

ST_FUNC void gen_le64(int64_t c)
{
	g(c);
	g(c >> 8);
	g(c >> 16);
	g(c >> 24);
	g(c >> 32);
	g(c >> 40);
	g(c >> 48);
	g(c >> 56);
}

static void orex(int ll, int r, int r2, int b)
{
	if ((r & VT_VALMASK) >= VT_CONST)
		r = 0;
	if ((r2 & VT_VALMASK) >= VT_CONST)
		r2 = 0;
	if (ll || REX_BASE(r) || REX_BASE(r2))
		o(0x40 | REX_BASE(r) | (REX_BASE(r2) << 2) | (ll << 3));
	o(b);
}

/* output a symbol and patch all calls to it */
ST_FUNC void gsym_addr(int t, int a)
{
	while (t)
	{
		unsigned char *ptr = cur_text_section->data + t;
		uint32_t n = read32le(ptr); /* next value */
		write32le(ptr, a < 0 ? -a : a - t - 4);
		t = n;
	}
}

static int is64_type(int t)
{
	return ((t & VT_BTYPE) == VT_PTR ||
	        (t & VT_BTYPE) == VT_FUNC ||
	        (t & VT_BTYPE) == VT_LLONG);
}

/* instruction + 4 bytes data. Return the address of the data */
static int oad(int c, int s)
{
	int t;
	if (nocode_wanted)
		return s;
	o(c);
	t = ind;
	gen_le32(s);
	return t;
}

/* generate jmp to a label */
#define gjmp2(instr,lbl) oad(instr,lbl)

ST_FUNC void gen_addr32(int r, Sym *sym, int c)
{
	if (r & VT_SYM)
		greloca(cur_text_section, sym, ind, R_X86_64_32S, c), c=0;
	gen_le32(c);
}

/* output constant with relocation if 'r & VT_SYM' is true */
ST_FUNC void gen_addr64(int r, Sym *sym, int64_t c)
{
	if (r & VT_SYM)
		greloca(cur_text_section, sym, ind, R_X86_64_64, c), c=0;
	gen_le64(c);
}

/* output constant with relocation if 'r & VT_SYM' is true */
ST_FUNC void gen_addrpc32(int r, Sym *sym, int c)
{
	if (r & VT_SYM)
		greloca(cur_text_section, sym, ind, R_X86_64_PC32, c-4), c=4;
	gen_le32(c-4);
}

/* output got address with relocation */
static void gen_gotpcrel(int r, Sym *sym, int c)
{
#ifdef TCC_TARGET_PE
	tcc_error("internal error: no GOT on PE: %s %x %x | %02x %02x %02x\n",
	          get_tok_str(sym->v, NULL), c, r,
	          cur_text_section->data[ind-3],
	          cur_text_section->data[ind-2],
	          cur_text_section->data[ind-1]
	         );
#endif
	greloca(cur_text_section, sym, ind, R_X86_64_GOTPCREL, -4);
	gen_le32(0);
	if (c)
	{
		/* we use add c, %xxx for displacement */
		orex(1, r, 0, 0x81);
		o(0xc0 + REG_VALUE(r));
		gen_le32(c);
	}
}

static void gen_modrm_impl(int op_reg, int r, Sym *sym, int c, int is_got)
{
	op_reg = REG_VALUE(op_reg) << 3;
	if ((r & VT_VALMASK) == VT_CONST)
	{
		/* constant memory reference */
		if (!(r & VT_SYM))
		{
			/* Absolute memory reference */
			o(0x04 | op_reg); /* [sib] | destreg */
			oad(0x25, c);     /* disp32 */
		}
		else
		{
			o(0x05 | op_reg); /* (%rip)+disp32 | destreg */
			if (is_got)
			{
				gen_gotpcrel(r, sym, c);
			}
			else
			{
				gen_addrpc32(r, sym, c);
			}
		}
	}
	else if ((r & VT_VALMASK) == VT_LOCAL)
	{
		/* currently, we use only ebp as base */
		if (c == (char)c)
		{
			/* short reference */
			o(0x45 | op_reg);
			g(c);
		}
		else
		{
			oad(0x85 | op_reg, c);
		}
	}
	else if ((r & VT_VALMASK) >= TREG_MEM)
	{
		if (c)
		{
			g(0x80 | op_reg | REG_VALUE(r));
			gen_le32(c);
		}
		else
		{
			g(0x00 | op_reg | REG_VALUE(r));
		}
	}
	else
	{
		g(0x00 | op_reg | REG_VALUE(r));
	}
}

/* generate a modrm reference. 'op_reg' contains the additional 3
   opcode bits */
static void gen_modrm(int op_reg, int r, Sym *sym, int c)
{
	gen_modrm_impl(op_reg, r, sym, c, 0);
}

/* generate a modrm reference. 'op_reg' contains the additional 3
   opcode bits */
static void gen_modrm64(int opcode, int op_reg, int r, Sym *sym, int c)
{
	int is_got;
	is_got = (op_reg & TREG_MEM) && !(sym->type.t & VT_STATIC);
	orex(1, r, op_reg, opcode);
	gen_modrm_impl(op_reg, r, sym, c, is_got);
}


/* load 'r' from value 'sv' */
void load(int r, SValue *sv)
{
	int v, t, ft, fc, fr;
	SValue v1;

#ifdef TCC_TARGET_PE
	SValue v2;
	sv = pe_getimport(sv, &v2);
#endif

	fr = sv->r;
	ft = sv->type.t & ~VT_DEFSIGN;
	fc = sv->c.i;
	if (fc != sv->c.i && (fr & VT_SYM))
		tcc_error("64 bit addend in load");

	ft &= ~(VT_VOLATILE | VT_CONSTANT);

#ifndef TCC_TARGET_PE
	/* we use indirect access via got */
	if ((fr & VT_VALMASK) == VT_CONST && (fr & VT_SYM) &&
	        (fr & VT_LVAL) && !(sv->sym->type.t & VT_STATIC))
	{
		/* use the result register as a temporal register */
		int tr = r | TREG_MEM;
		if (is_float(ft))
		{
			/* we cannot use float registers as a temporal register */
			tr = get_reg(RC_INT) | TREG_MEM;
		}
		gen_modrm64(0x8b, tr, fr, sv->sym, 0);

		/* load from the temporal register */
		fr = tr | VT_LVAL;
	}
#endif

	v = fr & VT_VALMASK;
	if (fr & VT_LVAL)
	{
		int b, ll;
		if (v == VT_LLOCAL)
		{
			v1.type.t = VT_PTR;
			v1.r = VT_LOCAL | VT_LVAL;
			v1.c.i = fc;
			fr = r;
			if (!(reg_classes[fr] & (RC_INT|RC_R11)))
				fr = get_reg(RC_INT);
			load(fr, &v1);
		}
		if (fc != sv->c.i)
		{
			/* If the addends doesn't fit into a 32bit signed
			   we must use a 64bit move.  We've checked above
			   that this doesn't have a sym associated.  */
			v1.type.t = VT_LLONG;
			v1.r = VT_CONST;
			v1.c.i = sv->c.i;
			fr = r;
			if (!(reg_classes[fr] & (RC_INT|RC_R11)))
				fr = get_reg(RC_INT);
			load(fr, &v1);
			fc = 0;
		}
		ll = 0;
		/* Like GCC we can load from small enough properly sized
		   structs and unions as well.
		   XXX maybe move to generic operand handling, but should
		   occur only with asm, so tccasm.c might also be a better place */
		if ((ft & VT_BTYPE) == VT_STRUCT)
		{
			int align;
			switch (type_size(&sv->type, &align))
			{
			case 1:
				ft = VT_BYTE;
				break;
			case 2:
				ft = VT_SHORT;
				break;
			case 4:
				ft = VT_INT;
				break;
			case 8:
				ft = VT_LLONG;
				break;
			default:
				tcc_error("invalid aggregate type for register load");
				break;
			}
		}
		if ((ft & VT_BTYPE) == VT_FLOAT)
		{
			b = 0x6e0f66;
			r = REG_VALUE(r); /* movd */
		}
		else if ((ft & VT_BTYPE) == VT_DOUBLE)
		{
			b = 0x7e0ff3; /* movq */
			r = REG_VALUE(r);
		}
		else if ((ft & VT_BTYPE) == VT_LDOUBLE)
		{
			b = 0xdb, r = 5; /* fldt */
		}
		else if ((ft & VT_TYPE) == VT_BYTE || (ft & VT_TYPE) == VT_BOOL)
		{
			b = 0xbe0f;   /* movsbl */
		}
		else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED))
		{
			b = 0xb60f;   /* movzbl */
		}
		else if ((ft & VT_TYPE) == VT_SHORT)
		{
			b = 0xbf0f;   /* movswl */
		}
		else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED))
		{
			b = 0xb70f;   /* movzwl */
		}
		else
		{
			assert(((ft & VT_BTYPE) == VT_INT)
			       || ((ft & VT_BTYPE) == VT_LLONG)
			       || ((ft & VT_BTYPE) == VT_PTR)
			       || ((ft & VT_BTYPE) == VT_FUNC)
			      );
			ll = is64_type(ft);
			b = 0x8b;
		}
		if (ll)
		{
			gen_modrm64(b, r, fr, sv->sym, fc);
		}
		else
		{
			orex(ll, fr, r, b);
			gen_modrm(r, fr, sv->sym, fc);
		}
	}
	else
	{
		if (v == VT_CONST)
		{
			if (fr & VT_SYM)
			{
#ifdef TCC_TARGET_PE
				orex(1,0,r,0x8d);
				o(0x05 + REG_VALUE(r) * 8); /* lea xx(%rip), r */
				gen_addrpc32(fr, sv->sym, fc);
#else
				if (sv->sym->type.t & VT_STATIC)
				{
					orex(1,0,r,0x8d);
					o(0x05 + REG_VALUE(r) * 8); /* lea xx(%rip), r */
					gen_addrpc32(fr, sv->sym, fc);
				}
				else
				{
					orex(1,0,r,0x8b);
					o(0x05 + REG_VALUE(r) * 8); /* mov xx(%rip), r */
					gen_gotpcrel(r, sv->sym, fc);
				}
#endif
			}
			else if (is64_type(ft))
			{
				orex(1,r,0, 0xb8 + REG_VALUE(r)); /* mov $xx, r */
				gen_le64(sv->c.i);
			}
			else
			{
				orex(0,r,0, 0xb8 + REG_VALUE(r)); /* mov $xx, r */
				gen_le32(fc);
			}
		}
		else if (v == VT_LOCAL)
		{
			orex(1,0,r,0x8d); /* lea xxx(%ebp), r */
			gen_modrm(r, VT_LOCAL, sv->sym, fc);
		}
		else if (v == VT_CMP)
		{
			if (fc & 0x100)
			{
				v = vtop->cmp_r;
				fc &= ~0x100;
				/* This was a float compare.  If the parity bit is
				set the result was unordered, meaning false for everything
				   except TOK_NE, and true for TOK_NE.  */
				orex(0, r, 0, 0xb0 + REG_VALUE(r)); /* mov $0/1,%al */
				g(v ^ fc ^ (v == TOK_NE));
				o(0x037a + (REX_BASE(r) << 8));
			}
			orex(0,r,0, 0x0f); /* setxx %br */
			o(fc);
			o(0xc0 + REG_VALUE(r));
			orex(0,r,0, 0x0f);
			o(0xc0b6 + REG_VALUE(r) * 0x900); /* movzbl %al, %eax */
		}
		else if (v == VT_JMP || v == VT_JMPI)
		{
			t = v & 1;
			orex(0,r,0,0);
			oad(0xb8 + REG_VALUE(r), t); /* mov $1, r */
			o(0x05eb + (REX_BASE(r) << 8)); /* jmp after */
			gsym(fc);
			orex(0,r,0,0);
			oad(0xb8 + REG_VALUE(r), t ^ 1); /* mov $0, r */
		}
		else if (v != r)
		{
			if ((r >= TREG_XMM0) && (r <= TREG_XMM7))
			{
				if (v == TREG_ST0)
				{
					/* gen_cvt_ftof(VT_DOUBLE); */
					o(0xf0245cdd); /* fstpl -0x10(%rsp) */
					/* movsd -0x10(%rsp),%xmmN */
					o(0x100ff2);
					o(0x44 + REG_VALUE(r)*8); /* %xmmN */
					o(0xf024);
				}
				else
				{
					assert((v >= TREG_XMM0) && (v <= TREG_XMM7));
					if ((ft & VT_BTYPE) == VT_FLOAT)
					{
						o(0x100ff3);
					}
					else
					{
						assert((ft & VT_BTYPE) == VT_DOUBLE);
						o(0x100ff2);
					}
					o(0xc0 + REG_VALUE(v) + REG_VALUE(r)*8);
				}
			}
			else if (r == TREG_ST0)
			{
				assert((v >= TREG_XMM0) && (v <= TREG_XMM7));
				/* gen_cvt_ftof(VT_LDOUBLE); */
				/* movsd %xmmN,-0x10(%rsp) */
				o(0x110ff2);
				o(0x44 + REG_VALUE(r)*8); /* %xmmN */
				o(0xf024);
				o(0xf02444dd); /* fldl -0x10(%rsp) */
			}
			else
			{
				orex(is64_type(ft), r, v, 0x89);
				o(0xc0 + REG_VALUE(r) + REG_VALUE(v) * 8); /* mov v, r */
			}
		}
	}
}

/* store register 'r' in lvalue 'v' */
void store(int r, SValue *v)
{
	int fr, bt, ft, fc;
	int op64 = 0;
	/* store the REX prefix in this variable when PIC is enabled */
	int pic = 0;

#ifdef TCC_TARGET_PE
	SValue v2;
	v = pe_getimport(v, &v2);
#endif

	fr = v->r & VT_VALMASK;
	ft = v->type.t;
	fc = v->c.i;
	if (fc != v->c.i && (fr & VT_SYM))
		tcc_error("64 bit addend in store");
	ft &= ~(VT_VOLATILE | VT_CONSTANT);
	bt = ft & VT_BTYPE;

#ifndef TCC_TARGET_PE
	/* we need to access the variable via got */
	if (fr == VT_CONST && (v->r & VT_SYM))
	{
		/* mov xx(%rip), %r11 */
		o(0x1d8b4c);
		gen_gotpcrel(TREG_R11, v->sym, v->c.i);
		pic = is64_type(bt) ? 0x49 : 0x41;
	}
#endif

	/* XXX: incorrect if float reg to reg */
	if (bt == VT_FLOAT)
	{
		o(0x66);
		o(pic);
		o(0x7e0f); /* movd */
		r = REG_VALUE(r);
	}
	else if (bt == VT_DOUBLE)
	{
		o(0x66);
		o(pic);
		o(0xd60f); /* movq */
		r = REG_VALUE(r);
	}
	else if (bt == VT_LDOUBLE)
	{
		o(0xc0d9); /* fld %st(0) */
		o(pic);
		o(0xdb); /* fstpt */
		r = 7;
	}
	else
	{
		if (bt == VT_SHORT)
			o(0x66);
		o(pic);
		if (bt == VT_BYTE || bt == VT_BOOL)
			orex(0, 0, r, 0x88);
		else if (is64_type(bt))
			op64 = 0x89;
		else
			orex(0, 0, r, 0x89);
	}
	if (pic)
	{
		/* xxx r, (%r11) where xxx is mov, movq, fld, or etc */
		if (op64)
			o(op64);
		o(3 + (r << 3));
	}
	else if (op64)
	{
		if (fr == VT_CONST || fr == VT_LOCAL || (v->r & VT_LVAL))
		{
			gen_modrm64(op64, r, v->r, v->sym, fc);
		}
		else if (fr != r)
		{
			orex(1, fr, r, op64);
			o(0xc0 + fr + r * 8); /* mov r, fr */
		}
	}
	else
	{
		if (fr == VT_CONST || fr == VT_LOCAL || (v->r & VT_LVAL))
		{
			gen_modrm(r, v->r, v->sym, fc);
		}
		else if (fr != r)
		{
			o(0xc0 + fr + r * 8); /* mov r, fr */
		}
	}
}

/* 'is_jmp' is '1' if it is a jump */
static void gcall_or_jmp(int is_jmp)
{
	int r;
	if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&
	        ((vtop->r & VT_SYM) && (vtop->c.i-4) == (int)(vtop->c.i-4)))
	{
		/* constant symbolic case -> simple relocation */
#ifdef TCC_TARGET_PE
		greloca(cur_text_section, vtop->sym, ind + 1, R_X86_64_PC32, (int)(vtop->c.i-4));
#else
		greloca(cur_text_section, vtop->sym, ind + 1, R_X86_64_PLT32, (int)(vtop->c.i-4));
#endif
		oad(0xe8 + is_jmp, 0); /* call/jmp im */
	}
	else
	{
		/* otherwise, indirect call */
		r = TREG_R11;
		load(r, vtop);
		o(0x41); /* REX */
		o(0xff); /* call/jmp *r */
		o(0xd0 + REG_VALUE(r) + (is_jmp << 4));
	}
}

#if defined(CONFIG_TCC_BCHECK)
static addr_t func_bound_offset;
static unsigned long func_bound_ind;

static void gen_bounds_call(int v)
{
	Sym *sym = external_global_sym(v, &func_old_type);
	oad(0xe8, 0);
#ifdef TCC_TARGET_PE
	greloca(cur_text_section, sym, ind-4, R_X86_64_PC32, -4);
#else
	greloca(cur_text_section, sym, ind-4, R_X86_64_PLT32, -4);
#endif
}

/* generate a bounded pointer addition */
ST_FUNC void gen_bounded_ptr_add(void)
{
	vpush_global_sym(&func_old_type, TOK___bound_ptr_add);
	vrott(3);
	gfunc_call(2);
	vpushi(0);
	/* returned pointer is in rax */
	vtop->r = TREG_RAX | VT_BOUNDED;
	if (nocode_wanted)
		return;
	/* relocation offset of the bounding function call point */
	vtop->c.i = (cur_text_section->reloc->data_offset - sizeof(ElfW(Rela)));
}

/* patch pointer addition in vtop so that pointer dereferencing is
   also tested */
ST_FUNC void gen_bounded_ptr_deref(void)
{
	addr_t func;
	int size, align;
	ElfW(Rela) *rel;
	Sym *sym;

	if (nocode_wanted)
		return;

	size = type_size(&vtop->type, &align);
	switch(size)
	{
	case  1:
		func = TOK___bound_ptr_indir1;
		break;
	case  2:
		func = TOK___bound_ptr_indir2;
		break;
	case  4:
		func = TOK___bound_ptr_indir4;
		break;
	case  8:
		func = TOK___bound_ptr_indir8;
		break;
	case 12:
		func = TOK___bound_ptr_indir12;
		break;
	case 16:
		func = TOK___bound_ptr_indir16;
		break;
	default:
		/* may happen with struct member access */
		return;
		//tcc_error("unhandled size when dereferencing bounded pointer");
		//func = 0;
		//break;
	}
	sym = external_global_sym(func, &func_old_type);
	if (!sym->c)
		put_extern_sym(sym, NULL, 0, 0);
	/* patch relocation */
	/* XXX: find a better solution ? */
	rel = (ElfW(Rela) *)(cur_text_section->reloc->data + vtop->c.i);
	rel->r_info = ELF64_R_INFO(sym->c, ELF64_R_TYPE(rel->r_info));
}

#ifdef TCC_TARGET_PE
# define TREG_FASTCALL_1 TREG_RCX
#else
# define TREG_FASTCALL_1 TREG_RDI
#endif

static void gen_bounds_prolog(void)
{
	/* leave some room for bound checking code */
	func_bound_offset = lbounds_section->data_offset;
	func_bound_ind = ind;
	o(0xb848 + TREG_FASTCALL_1 * 0x100); /*lbound section pointer */
	gen_le64 (0);
	oad(0xb8, 0); /* call to function */
}

static void gen_bounds_epilog(void)
{
	addr_t saved_ind;
	addr_t *bounds_ptr;
	Sym *sym_data;

	/* add end of table info */
	bounds_ptr = section_ptr_add(lbounds_section, sizeof(addr_t));
	*bounds_ptr = 0;

	/* generate bound local allocation */
	sym_data = get_sym_ref(&char_pointer_type, lbounds_section,
	                       func_bound_offset, lbounds_section->data_offset);
	saved_ind = ind;
	ind = func_bound_ind;
	greloca(cur_text_section, sym_data, ind + 2, R_X86_64_64, 0);
	ind = ind + 10;
	gen_bounds_call(TOK___bound_local_new);
	ind = saved_ind;

	/* generate bound check local freeing */
	o(0x525051); /* save returned value, if any (+ scratch-space for windows) */
	greloca(cur_text_section, sym_data, ind + 2, R_X86_64_64, 0);
	o(0xb848 + TREG_FASTCALL_1 * 0x100); /* mov xxx, %rcx/di */
	gen_le64 (0);
	gen_bounds_call(TOK___bound_local_delete);
	o(0x59585a); /* restore returned value, if any */
}
#endif

#ifdef TCC_TARGET_PE

static int func_scratch, func_alloca;

#define REGN 4
static const uint8_t arg_regs[REGN] =
{
	TREG_RCX, TREG_RDX, TREG_R8, TREG_R9
};

/* Prepare arguments in R10 and R11 rather than RCX and RDX
   because gv() will not ever use these */
static int arg_prepare_reg(int idx)
{
	if (idx == 0 || idx == 1)
		/* idx=0: r10, idx=1: r11 */
		return idx + 10;
	else
		return arg_regs[idx];
}

/* Generate function call. The function address is pushed first, then
   all the parameters in call order. This functions pops all the
   parameters and the function address. */

static void gen_offs_sp(int b, int r, int d)
{
	orex(1,0,r & 0x100 ? 0 : r, b);
	if (d == (char)d)
	{
		o(0x2444 | (REG_VALUE(r) << 3));
		g(d);
	}
	else
	{
		o(0x2484 | (REG_VALUE(r) << 3));
		gen_le32(d);
	}
}

static int using_regs(int size)
{
	return !(size > 8 || (size & (size - 1)));
}

/* Return the number of registers needed to return the struct, or 0 if
   returning via struct pointer. */
ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)
{
	int size, align;
	*ret_align = 1; // Never have to re-align return values for x86-64
	*regsize = 8;
	size = type_size(vt, &align);
	if (!using_regs(size))
		return 0;
	if (size == 8)
		ret->t = VT_LLONG;
	else if (size == 4)
		ret->t = VT_INT;
	else if (size == 2)
		ret->t = VT_SHORT;
	else
		ret->t = VT_BYTE;
	ret->ref = NULL;
	return 1;
}

static int is_sse_float(int t)
{
	int bt;
	bt = t & VT_BTYPE;
	return bt == VT_DOUBLE || bt == VT_FLOAT;
}

static int gfunc_arg_size(CType *type)
{
	int align;
	if (type->t & (VT_ARRAY|VT_BITFIELD))
		return 8;
	return type_size(type, &align);
}

void gfunc_call(int nb_args)
{
	int size, r, args_size, i, d, bt, struct_size;
	int arg;

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gbound_args(nb_args);
#endif

	args_size = (nb_args < REGN ? REGN : nb_args) * PTR_SIZE;
	arg = nb_args;

	/* for struct arguments, we need to call memcpy and the function
	   call breaks register passing arguments we are preparing.
	   So, we process arguments which will be passed by stack first. */
	struct_size = args_size;
	for(i = 0; i < nb_args; i++)
	{
		SValue *sv;

		--arg;
		sv = &vtop[-i];
		bt = (sv->type.t & VT_BTYPE);
		size = gfunc_arg_size(&sv->type);

		if (using_regs(size))
			continue; /* arguments smaller than 8 bytes passed in registers or on stack */

		if (bt == VT_STRUCT)
		{
			/* align to stack align size */
			size = (size + 15) & ~15;
			/* generate structure store */
			r = get_reg(RC_INT);
			gen_offs_sp(0x8d, r, struct_size);
			struct_size += size;

			/* generate memcpy call */
			vset(&sv->type, r | VT_LVAL, 0);
			vpushv(sv);
			vstore();
			--vtop;
		}
		else if (bt == VT_LDOUBLE)
		{
			gv(RC_ST0);
			gen_offs_sp(0xdb, 0x107, struct_size);
			struct_size += 16;
		}
	}

	if (func_scratch < struct_size)
		func_scratch = struct_size;

	arg = nb_args;
	struct_size = args_size;

	for(i = 0; i < nb_args; i++)
	{
		--arg;
		bt = (vtop->type.t & VT_BTYPE);

		size = gfunc_arg_size(&vtop->type);
		if (!using_regs(size))
		{
			/* align to stack align size */
			size = (size + 15) & ~15;
			if (arg >= REGN)
			{
				d = get_reg(RC_INT);
				gen_offs_sp(0x8d, d, struct_size);
				gen_offs_sp(0x89, d, arg*8);
			}
			else
			{
				d = arg_prepare_reg(arg);
				gen_offs_sp(0x8d, d, struct_size);
			}
			struct_size += size;
		}
		else
		{
			if (is_sse_float(vtop->type.t))
			{
				if (tcc_state->nosse)
					tcc_error("SSE disabled");
				if (arg >= REGN)
				{
					gv(RC_XMM0);
					/* movq %xmm0, j*8(%rsp) */
					gen_offs_sp(0xd60f66, 0x100, arg*8);
				}
				else
				{
					/* Load directly to xmmN register */
					gv(RC_XMM0 << arg);
					d = arg_prepare_reg(arg);
					/* mov %xmmN, %rxx */
					o(0x66);
					orex(1,d,0, 0x7e0f);
					o(0xc0 + arg*8 + REG_VALUE(d));
				}
			}
			else
			{
				if (bt == VT_STRUCT)
				{
					vtop->type.ref = NULL;
					vtop->type.t = size > 4 ? VT_LLONG : size > 2 ? VT_INT
					               : size > 1 ? VT_SHORT : VT_BYTE;
				}

				r = gv(RC_INT);
				if (arg >= REGN)
				{
					gen_offs_sp(0x89, r, arg*8);
				}
				else
				{
					d = arg_prepare_reg(arg);
					orex(1,d,r,0x89); /* mov */
					o(0xc0 + REG_VALUE(r) * 8 + REG_VALUE(d));
				}
			}
		}
		vtop--;
	}
	save_regs(0);
	/* Copy R10 and R11 into RCX and RDX, respectively */
	if (nb_args > 0)
	{
		o(0xd1894c); /* mov %r10, %rcx */
		if (nb_args > 1)
		{
			o(0xda894c); /* mov %r11, %rdx */
		}
	}

	gcall_or_jmp(0);

	if ((vtop->r & VT_SYM) && vtop->sym->v == TOK_alloca)
	{
		/* need to add the "func_scratch" area after alloca */
		o(0x48);
		func_alloca = oad(0x05, func_alloca); /* add $NN, %rax */
#ifdef CONFIG_TCC_BCHECK
		if (tcc_state->do_bounds_check)
			gen_bounds_call(TOK___bound_alloca_nr); /* new region */
#endif

	}
	vtop--;
}


#define FUNC_PROLOG_SIZE 11

/* generate function prolog of type 't' */
void gfunc_prolog(Sym *func_sym)
{
	CType *func_type = &func_sym->type;
	int addr, reg_param_index, bt, size;
	Sym *sym;
	CType *type;

	func_ret_sub = 0;
	func_scratch = 32;
	func_alloca = 0;
	loc = 0;

	addr = PTR_SIZE * 2;
	ind += FUNC_PROLOG_SIZE;
	func_sub_sp_offset = ind;
	reg_param_index = 0;

	sym = func_type->ref;

	/* if the function returns a structure, then add an
	   implicit pointer parameter */
	func_vt = sym->type;
	func_var = (sym->f.func_type == FUNC_ELLIPSIS);
	size = gfunc_arg_size(&func_vt);
	if (!using_regs(size))
	{
		gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);
		func_vc = addr;
		reg_param_index++;
		addr += 8;
	}

	/* define parameters */
	while ((sym = sym->next) != NULL)
	{
		type = &sym->type;
		bt = type->t & VT_BTYPE;
		size = gfunc_arg_size(type);
		if (!using_regs(size))
		{
			if (reg_param_index < REGN)
			{
				gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);
			}
			sym_push(sym->v & ~SYM_FIELD, type,
			         VT_LLOCAL | VT_LVAL, addr);
		}
		else
		{
			if (reg_param_index < REGN)
			{
				/* save arguments passed by register */
				if ((bt == VT_FLOAT) || (bt == VT_DOUBLE))
				{
					if (tcc_state->nosse)
						tcc_error("SSE disabled");
					o(0xd60f66); /* movq */
					gen_modrm(reg_param_index, VT_LOCAL, NULL, addr);
				}
				else
				{
					gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);
				}
			}
			sym_push(sym->v & ~SYM_FIELD, type,
			         VT_LOCAL | VT_LVAL, addr);
		}
		addr += 8;
		reg_param_index++;
	}

	while (reg_param_index < REGN)
	{
		if (func_type->ref->f.func_type == FUNC_ELLIPSIS)
		{
			gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, addr);
			addr += 8;
		}
		reg_param_index++;
	}
#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gen_bounds_prolog();
#endif
}

/* generate function epilog */
void gfunc_epilog(void)
{
	int v, saved_ind;

	/* align local size to word & save local variables */
	func_scratch = (func_scratch + 15) & -16;
	loc = (loc & -16) - func_scratch;

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gen_bounds_epilog();
#endif

	o(0xc9); /* leave */
	if (func_ret_sub == 0)
	{
		o(0xc3); /* ret */
	}
	else
	{
		o(0xc2); /* ret n */
		g(func_ret_sub);
		g(func_ret_sub >> 8);
	}

	saved_ind = ind;
	ind = func_sub_sp_offset - FUNC_PROLOG_SIZE;
	v = -loc;

	if (v >= 4096)
	{
		Sym *sym = external_global_sym(TOK___chkstk, &func_old_type);
		oad(0xb8, v); /* mov stacksize, %eax */
		oad(0xe8, 0); /* call __chkstk, (does the stackframe too) */
		greloca(cur_text_section, sym, ind-4, R_X86_64_PC32, -4);
		o(0x90); /* fill for FUNC_PROLOG_SIZE = 11 bytes */
	}
	else
	{
		o(0xe5894855);  /* push %rbp, mov %rsp, %rbp */
		o(0xec8148);  /* sub rsp, stacksize */
		gen_le32(v);
	}

	/* add the "func_scratch" area after each alloca seen */
	gsym_addr(func_alloca, -func_scratch);

	cur_text_section->data_offset = saved_ind;
	pe_add_unwind_data(ind, saved_ind, v);
	ind = cur_text_section->data_offset;
}

#else

static void gadd_sp(int val)
{
	if (val == (char)val)
	{
		o(0xc48348);
		g(val);
	}
	else
	{
		oad(0xc48148, val); /* add $xxx, %rsp */
	}
}

typedef enum X86_64_Mode
{
	x86_64_mode_none,
	x86_64_mode_memory,
	x86_64_mode_integer,
	x86_64_mode_sse,
	x86_64_mode_x87
} X86_64_Mode;

static X86_64_Mode classify_x86_64_merge(X86_64_Mode a, X86_64_Mode b)
{
	if (a == b)
		return a;
	else if (a == x86_64_mode_none)
		return b;
	else if (b == x86_64_mode_none)
		return a;
	else if ((a == x86_64_mode_memory) || (b == x86_64_mode_memory))
		return x86_64_mode_memory;
	else if ((a == x86_64_mode_integer) || (b == x86_64_mode_integer))
		return x86_64_mode_integer;
	else if ((a == x86_64_mode_x87) || (b == x86_64_mode_x87))
		return x86_64_mode_memory;
	else
		return x86_64_mode_sse;
}

static X86_64_Mode classify_x86_64_inner(CType *ty)
{
	X86_64_Mode mode;
	Sym *f;

	switch (ty->t & VT_BTYPE)
	{
	case VT_VOID:
		return x86_64_mode_none;

	case VT_INT:
	case VT_BYTE:
	case VT_SHORT:
	case VT_LLONG:
	case VT_BOOL:
	case VT_PTR:
	case VT_FUNC:
		return x86_64_mode_integer;

	case VT_FLOAT:
	case VT_DOUBLE:
		return x86_64_mode_sse;

	case VT_LDOUBLE:
		return x86_64_mode_x87;

	case VT_STRUCT:
		f = ty->ref;

		mode = x86_64_mode_none;
		for (f = f->next; f; f = f->next)
			mode = classify_x86_64_merge(mode, classify_x86_64_inner(&f->type));

		return mode;
	}
	assert(0);
	return 0;
}

static X86_64_Mode classify_x86_64_arg(CType *ty, CType *ret, int *psize, int *palign, int *reg_count)
{
	X86_64_Mode mode;
	int size, align, ret_t = 0;

	if (ty->t & (VT_BITFIELD|VT_ARRAY))
	{
		*psize = 8;
		*palign = 8;
		*reg_count = 1;
		ret_t = ty->t;
		mode = x86_64_mode_integer;
	}
	else
	{
		size = type_size(ty, &align);
		*psize = (size + 7) & ~7;
		*palign = (align + 7) & ~7;

		if (size > 16)
		{
			mode = x86_64_mode_memory;
		}
		else
		{
			mode = classify_x86_64_inner(ty);
			switch (mode)
			{
			case x86_64_mode_integer:
				if (size > 8)
				{
					*reg_count = 2;
					ret_t = VT_QLONG;
				}
				else
				{
					*reg_count = 1;
					if (size > 4)
						ret_t = VT_LLONG;
					else if (size > 2)
						ret_t = VT_INT;
					else if (size > 1)
						ret_t = VT_SHORT;
					else
						ret_t = VT_BYTE;
					if ((ty->t & VT_BTYPE) == VT_STRUCT || (ty->t & VT_UNSIGNED))
						ret_t |= VT_UNSIGNED;
				}
				break;

			case x86_64_mode_x87:
				*reg_count = 1;
				ret_t = VT_LDOUBLE;
				break;

			case x86_64_mode_sse:
				if (size > 8)
				{
					*reg_count = 2;
					ret_t = VT_QFLOAT;
				}
				else
				{
					*reg_count = 1;
					ret_t = (size > 4) ? VT_DOUBLE : VT_FLOAT;
				}
				break;
			default:
				break; /* nothing to be done for x86_64_mode_memory and x86_64_mode_none*/
			}
		}
	}

	if (ret)
	{
		ret->ref = NULL;
		ret->t = ret_t;
	}

	return mode;
}

ST_FUNC int classify_x86_64_va_arg(CType *ty)
{
	/* This definition must be synced with stdarg.h */
	enum __va_arg_type
	{
		__va_gen_reg, __va_float_reg, __va_stack
	};
	int size, align, reg_count;
	X86_64_Mode mode = classify_x86_64_arg(ty, NULL, &size, &align, &reg_count);
	switch (mode)
	{
	default:
		return __va_stack;
	case x86_64_mode_integer:
		return __va_gen_reg;
	case x86_64_mode_sse:
		return __va_float_reg;
	}
}

/* Return the number of registers needed to return the struct, or 0 if
   returning via struct pointer. */
ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)
{
	int size, align, reg_count;
	*ret_align = 1; // Never have to re-align return values for x86-64
	*regsize = 8;
	return (classify_x86_64_arg(vt, ret, &size, &align, &reg_count) != x86_64_mode_memory);
}

#define REGN 6
static const uint8_t arg_regs[REGN] =
{
	TREG_RDI, TREG_RSI, TREG_RDX, TREG_RCX, TREG_R8, TREG_R9
};

static int arg_prepare_reg(int idx)
{
	if (idx == 2 || idx == 3)
		/* idx=2: r10, idx=3: r11 */
		return idx + 8;
	else
		return arg_regs[idx];
}

/* Generate function call. The function address is pushed first, then
   all the parameters in call order. This functions pops all the
   parameters and the function address. */
void gfunc_call(int nb_args)
{
	X86_64_Mode mode;
	CType type;
	int size, align, r, args_size, stack_adjust, i, reg_count;
	int nb_reg_args = 0;
	int nb_sse_args = 0;
	int sse_reg, gen_reg;
	char _onstack[nb_args ? nb_args : 1], *onstack = _onstack;

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gbound_args(nb_args);
#endif

	/* calculate the number of integer/float register arguments, remember
	   arguments to be passed via stack (in onstack[]), and also remember
	   if we have to align the stack pointer to 16 (onstack[i] == 2).  Needs
	   to be done in a left-to-right pass over arguments.  */
	stack_adjust = 0;
	for(i = nb_args - 1; i >= 0; i--)
	{
		mode = classify_x86_64_arg(&vtop[-i].type, NULL, &size, &align, &reg_count);
		if (mode == x86_64_mode_sse && nb_sse_args + reg_count <= 8)
		{
			nb_sse_args += reg_count;
			onstack[i] = 0;
		}
		else if (mode == x86_64_mode_integer && nb_reg_args + reg_count <= REGN)
		{
			nb_reg_args += reg_count;
			onstack[i] = 0;
		}
		else if (mode == x86_64_mode_none)
		{
			onstack[i] = 0;
		}
		else
		{
			if (align == 16 && (stack_adjust &= 15))
			{
				onstack[i] = 2;
				stack_adjust = 0;
			}
			else
				onstack[i] = 1;
			stack_adjust += size;
		}
	}

	if (nb_sse_args && tcc_state->nosse)
		tcc_error("SSE disabled but floating point arguments passed");

	/* fetch cpu flag before generating any code */
	if ((vtop->r & VT_VALMASK) == VT_CMP)
		gv(RC_INT);

	/* for struct arguments, we need to call memcpy and the function
	   call breaks register passing arguments we are preparing.
	   So, we process arguments which will be passed by stack first. */
	gen_reg = nb_reg_args;
	sse_reg = nb_sse_args;
	args_size = 0;
	stack_adjust &= 15;
	for (i = 0; i < nb_args;)
	{
		mode = classify_x86_64_arg(&vtop[-i].type, NULL, &size, &align, &reg_count);
		if (!onstack[i])
		{
			++i;
			continue;
		}
		/* Possibly adjust stack to align SSE boundary.  We're processing
		args from right to left while allocating happens left to right
		(stack grows down), so the adjustment needs to happen _after_
		an argument that requires it.  */
		if (stack_adjust)
		{
			o(0x50); /* push %rax; aka sub $8,%rsp */
			args_size += 8;
			stack_adjust = 0;
		}
		if (onstack[i] == 2)
			stack_adjust = 1;

		vrotb(i+1);

		switch (vtop->type.t & VT_BTYPE)
		{
		case VT_STRUCT:
			/* allocate the necessary size on stack */
			o(0x48);
			oad(0xec81, size); /* sub $xxx, %rsp */
			/* generate structure store */
			r = get_reg(RC_INT);
			orex(1, r, 0, 0x89); /* mov %rsp, r */
			o(0xe0 + REG_VALUE(r));
			vset(&vtop->type, r | VT_LVAL, 0);
			vswap();
			vstore();
			break;

		case VT_LDOUBLE:
			gv(RC_ST0);
			oad(0xec8148, size); /* sub $xxx, %rsp */
			o(0x7cdb); /* fstpt 0(%rsp) */
			g(0x24);
			g(0x00);
			break;

		case VT_FLOAT:
		case VT_DOUBLE:
			assert(mode == x86_64_mode_sse);
			r = gv(RC_FLOAT);
			o(0x50); /* push $rax */
			/* movq %xmmN, (%rsp) */
			o(0xd60f66);
			o(0x04 + REG_VALUE(r)*8);
			o(0x24);
			break;

		default:
			assert(mode == x86_64_mode_integer);
			/* simple type */
			/* XXX: implicit cast ? */
			r = gv(RC_INT);
			orex(0,r,0,0x50 + REG_VALUE(r)); /* push r */
			break;
		}
		args_size += size;

		vpop();
		--nb_args;
		onstack++;
	}

	/* XXX This should be superfluous.  */
	save_regs(0); /* save used temporary registers */

	/* then, we prepare register passing arguments.
	   Note that we cannot set RDX and RCX in this loop because gv()
	   may break these temporary registers. Let's use R10 and R11
	   instead of them */
	assert(gen_reg <= REGN);
	assert(sse_reg <= 8);
	for(i = 0; i < nb_args; i++)
	{
		mode = classify_x86_64_arg(&vtop->type, &type, &size, &align, &reg_count);
		/* Alter stack entry type so that gv() knows how to treat it */
		vtop->type = type;
		if (mode == x86_64_mode_sse)
		{
			if (reg_count == 2)
			{
				sse_reg -= 2;
				gv(RC_FRET); /* Use pair load into xmm0 & xmm1 */
				if (sse_reg)   /* avoid redundant movaps %xmm0, %xmm0 */
				{
					/* movaps %xmm1, %xmmN */
					o(0x280f);
					o(0xc1 + ((sse_reg+1) << 3));
					/* movaps %xmm0, %xmmN */
					o(0x280f);
					o(0xc0 + (sse_reg << 3));
				}
			}
			else
			{
				assert(reg_count == 1);
				--sse_reg;
				/* Load directly to register */
				gv(RC_XMM0 << sse_reg);
			}
		}
		else if (mode == x86_64_mode_integer)
		{
			/* simple type */
			/* XXX: implicit cast ? */
			int d;
			gen_reg -= reg_count;
			r = gv(RC_INT);
			d = arg_prepare_reg(gen_reg);
			orex(1,d,r,0x89); /* mov */
			o(0xc0 + REG_VALUE(r) * 8 + REG_VALUE(d));
			if (reg_count == 2)
			{
				d = arg_prepare_reg(gen_reg+1);
				orex(1,d,vtop->r2,0x89); /* mov */
				o(0xc0 + REG_VALUE(vtop->r2) * 8 + REG_VALUE(d));
			}
		}
		vtop--;
	}
	assert(gen_reg == 0);
	assert(sse_reg == 0);

	/* We shouldn't have many operands on the stack anymore, but the
	   call address itself is still there, and it might be in %eax
	   (or edx/ecx) currently, which the below writes would clobber.
	   So evict all remaining operands here.  */
	save_regs(0);

	/* Copy R10 and R11 into RDX and RCX, respectively */
	if (nb_reg_args > 2)
	{
		o(0xd2894c); /* mov %r10, %rdx */
		if (nb_reg_args > 3)
		{
			o(0xd9894c); /* mov %r11, %rcx */
		}
	}

	if (vtop->type.ref->f.func_type != FUNC_NEW) /* implies FUNC_OLD or FUNC_ELLIPSIS */
		oad(0xb8, nb_sse_args < 8 ? nb_sse_args : 8); /* mov nb_sse_args, %eax */
	gcall_or_jmp(0);
	if (args_size)
		gadd_sp(args_size);
	vtop--;
}

#define FUNC_PROLOG_SIZE 11

static void push_arg_reg(int i)
{
	loc -= 8;
	gen_modrm64(0x89, arg_regs[i], VT_LOCAL, NULL, loc);
}

/* generate function prolog of type 't' */
void gfunc_prolog(Sym *func_sym)
{
	CType *func_type = &func_sym->type;
	X86_64_Mode mode;
	int i, addr, align, size, reg_count;
	int param_addr = 0, reg_param_index, sse_param_index;
	Sym *sym;
	CType *type;

	sym = func_type->ref;
	addr = PTR_SIZE * 2;
	loc = 0;
	ind += FUNC_PROLOG_SIZE;
	func_sub_sp_offset = ind;
	func_ret_sub = 0;

	if (sym->f.func_type == FUNC_ELLIPSIS)
	{
		int seen_reg_num, seen_sse_num, seen_stack_size;
		seen_reg_num = seen_sse_num = 0;
		/* frame pointer and return address */
		seen_stack_size = PTR_SIZE * 2;
		/* count the number of seen parameters */
		sym = func_type->ref;
		while ((sym = sym->next) != NULL)
		{
			type = &sym->type;
			mode = classify_x86_64_arg(type, NULL, &size, &align, &reg_count);
			switch (mode)
			{
			default:
stack_arg:
				seen_stack_size = ((seen_stack_size + align - 1) & -align) + size;
				break;

			case x86_64_mode_integer:
				if (seen_reg_num + reg_count > REGN)
					goto stack_arg;
				seen_reg_num += reg_count;
				break;

			case x86_64_mode_sse:
				if (seen_sse_num + reg_count > 8)
					goto stack_arg;
				seen_sse_num += reg_count;
				break;
			}
		}

		loc -= 16;
		/* movl $0x????????, -0x10(%rbp) */
		o(0xf045c7);
		gen_le32(seen_reg_num * 8);
		/* movl $0x????????, -0xc(%rbp) */
		o(0xf445c7);
		gen_le32(seen_sse_num * 16 + 48);
		/* movl $0x????????, -0x8(%rbp) */
		o(0xf845c7);
		gen_le32(seen_stack_size);

		/* save all register passing arguments */
		for (i = 0; i < 8; i++)
		{
			loc -= 16;
			if (!tcc_state->nosse)
			{
				o(0xd60f66); /* movq */
				gen_modrm(7 - i, VT_LOCAL, NULL, loc);
			}
			/* movq $0, loc+8(%rbp) */
			o(0x85c748);
			gen_le32(loc + 8);
			gen_le32(0);
		}
		for (i = 0; i < REGN; i++)
		{
			push_arg_reg(REGN-1-i);
		}
	}

	sym = func_type->ref;
	reg_param_index = 0;
	sse_param_index = 0;

	/* if the function returns a structure, then add an
	   implicit pointer parameter */
	func_vt = sym->type;
	mode = classify_x86_64_arg(&func_vt, NULL, &size, &align, &reg_count);
	if (mode == x86_64_mode_memory)
	{
		push_arg_reg(reg_param_index);
		func_vc = loc;
		reg_param_index++;
	}
	/* define parameters */
	while ((sym = sym->next) != NULL)
	{
		type = &sym->type;
		mode = classify_x86_64_arg(type, NULL, &size, &align, &reg_count);
		switch (mode)
		{
		case x86_64_mode_sse:
			if (tcc_state->nosse)
				tcc_error("SSE disabled but floating point arguments used");
			if (sse_param_index + reg_count <= 8)
			{
				/* save arguments passed by register */
				loc -= reg_count * 8;
				param_addr = loc;
				for (i = 0; i < reg_count; ++i)
				{
					o(0xd60f66); /* movq */
					gen_modrm(sse_param_index, VT_LOCAL, NULL, param_addr + i*8);
					++sse_param_index;
				}
			}
			else
			{
				addr = (addr + align - 1) & -align;
				param_addr = addr;
				addr += size;
			}
			break;

		case x86_64_mode_memory:
		case x86_64_mode_x87:
			addr = (addr + align - 1) & -align;
			param_addr = addr;
			addr += size;
			break;

		case x86_64_mode_integer:
		{
			if (reg_param_index + reg_count <= REGN)
			{
				/* save arguments passed by register */
				loc -= reg_count * 8;
				param_addr = loc;
				for (i = 0; i < reg_count; ++i)
				{
					gen_modrm64(0x89, arg_regs[reg_param_index], VT_LOCAL, NULL, param_addr + i*8);
					++reg_param_index;
				}
			}
			else
			{
				addr = (addr + align - 1) & -align;
				param_addr = addr;
				addr += size;
			}
			break;
		}
		default:
			break; /* nothing to be done for x86_64_mode_none */
		}
		sym_push(sym->v & ~SYM_FIELD, type,
		         VT_LOCAL | VT_LVAL, param_addr);
	}

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gen_bounds_prolog();
#endif
}

/* generate function epilog */
void gfunc_epilog(void)
{
	int v, saved_ind;

#ifdef CONFIG_TCC_BCHECK
	if (tcc_state->do_bounds_check)
		gen_bounds_epilog();
#endif
	o(0xc9); /* leave */
	if (func_ret_sub == 0)
	{
		o(0xc3); /* ret */
	}
	else
	{
		o(0xc2); /* ret n */
		g(func_ret_sub);
		g(func_ret_sub >> 8);
	}
	/* align local size to word & save local variables */
	v = (-loc + 15) & -16;
	saved_ind = ind;
	ind = func_sub_sp_offset - FUNC_PROLOG_SIZE;
	o(0xe5894855);  /* push %rbp, mov %rsp, %rbp */
	o(0xec8148);  /* sub rsp, stacksize */
	gen_le32(v);
	ind = saved_ind;
}

#endif /* not PE */

ST_FUNC void gen_fill_nops(int bytes)
{
	while (bytes--)
		g(0x90);
}

/* generate a jump to a label */
int gjmp(int t)
{
	return gjmp2(0xe9, t);
}

/* generate a jump to a fixed address */
void gjmp_addr(int a)
{
	int r;
	r = a - ind - 2;
	if (r == (char)r)
	{
		g(0xeb);
		g(r);
	}
	else
	{
		oad(0xe9, a - ind - 5);
	}
}

ST_FUNC int gjmp_append(int n, int t)
{
	void *p;
	/* insert vtop->c jump list in t */
	if (n)
	{
		uint32_t n1 = n, n2;
		while ((n2 = read32le(p = cur_text_section->data + n1)))
			n1 = n2;
		write32le(p, t);
		t = n;
	}
	return t;
}

ST_FUNC int gjmp_cond(int op, int t)
{
	if (op & 0x100)
	{
		/* This was a float compare.  If the parity flag is set
		   the result was unordered.  For anything except != this
		   means false and we don't jump (anding both conditions).
		   For != this means true (oring both).
		   Take care about inverting the test.  We need to jump
		   to our target if the result was unordered and test wasn't NE,
		   otherwise if unordered we don't want to jump.  */
		int v = vtop->cmp_r;
		op &= ~0x100;
		if (op ^ v ^ (v != TOK_NE))
			o(0x067a);  /* jp +6 */
		else
		{
			g(0x0f);
			t = gjmp2(0x8a, t); /* jp t */
		}
	}
	g(0x0f);
	t = gjmp2(op - 16, t);
	return t;
}

/* generate an integer binary operation */
void gen_opi(int op)
{
	int r, fr, opc, c;
	int ll, uu, cc;

	ll = is64_type(vtop[-1].type.t);
	uu = (vtop[-1].type.t & VT_UNSIGNED) != 0;
	cc = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;

	switch(op)
	{
	case '+':
	case TOK_ADDC1: /* add with carry generation */
		opc = 0;
gen_op8:
		if (cc && (!ll || (int)vtop->c.i == vtop->c.i))
		{
			/* constant case */
			vswap();
			r = gv(RC_INT);
			vswap();
			c = vtop->c.i;
			if (c == (char)c)
			{
				/* XXX: generate inc and dec for smaller code ? */
				orex(ll, r, 0, 0x83);
				o(0xc0 | (opc << 3) | REG_VALUE(r));
				g(c);
			}
			else
			{
				orex(ll, r, 0, 0x81);
				oad(0xc0 | (opc << 3) | REG_VALUE(r), c);
			}
		}
		else
		{
			gv2(RC_INT, RC_INT);
			r = vtop[-1].r;
			fr = vtop[0].r;
			orex(ll, r, fr, (opc << 3) | 0x01);
			o(0xc0 + REG_VALUE(r) + REG_VALUE(fr) * 8);
		}
		vtop--;
		if (op >= TOK_ULT && op <= TOK_GT)
			vset_VT_CMP(op);
		break;
	case '-':
	case TOK_SUBC1: /* sub with carry generation */
		opc = 5;
		goto gen_op8;
	case TOK_ADDC2: /* add with carry use */
		opc = 2;
		goto gen_op8;
	case TOK_SUBC2: /* sub with carry use */
		opc = 3;
		goto gen_op8;
	case '&':
		opc = 4;
		goto gen_op8;
	case '^':
		opc = 6;
		goto gen_op8;
	case '|':
		opc = 1;
		goto gen_op8;
	case '*':
		gv2(RC_INT, RC_INT);
		r = vtop[-1].r;
		fr = vtop[0].r;
		orex(ll, fr, r, 0xaf0f); /* imul fr, r */
		o(0xc0 + REG_VALUE(fr) + REG_VALUE(r) * 8);
		vtop--;
		break;
	case TOK_SHL:
		opc = 4;
		goto gen_shift;
	case TOK_SHR:
		opc = 5;
		goto gen_shift;
	case TOK_SAR:
		opc = 7;
gen_shift:
		opc = 0xc0 | (opc << 3);
		if (cc)
		{
			/* constant case */
			vswap();
			r = gv(RC_INT);
			vswap();
			orex(ll, r, 0, 0xc1); /* shl/shr/sar $xxx, r */
			o(opc | REG_VALUE(r));
			g(vtop->c.i & (ll ? 63 : 31));
		}
		else
		{
			/* we generate the shift in ecx */
			gv2(RC_INT, RC_RCX);
			r = vtop[-1].r;
			orex(ll, r, 0, 0xd3); /* shl/shr/sar %cl, r */
			o(opc | REG_VALUE(r));
		}
		vtop--;
		break;
	case TOK_UDIV:
	case TOK_UMOD:
		uu = 1;
		goto divmod;
	case '/':
	case '%':
	case TOK_PDIV:
		uu = 0;
divmod:
		/* first operand must be in eax */
		/* XXX: need better constraint for second operand */
		gv2(RC_RAX, RC_RCX);
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		save_reg(TREG_RDX);
		orex(ll, 0, 0, uu ? 0xd231 : 0x99); /* xor %edx,%edx : cqto */
		orex(ll, fr, 0, 0xf7); /* div fr, %eax */
		o((uu ? 0xf0 : 0xf8) + REG_VALUE(fr));
		if (op == '%' || op == TOK_UMOD)
			r = TREG_RDX;
		else
			r = TREG_RAX;
		vtop->r = r;
		break;
	default:
		opc = 7;
		goto gen_op8;
	}
}

void gen_opl(int op)
{
	gen_opi(op);
}

/* generate a floating point operation 'v = t1 op t2' instruction. The
   two operands are guaranteed to have the same floating point type */
/* XXX: need to use ST1 too */
void gen_opf(int op)
{
	int a, ft, fc, swapped, r;
	int float_type =
	    (vtop->type.t & VT_BTYPE) == VT_LDOUBLE ? RC_ST0 : RC_FLOAT;

	/* convert constants to memory references */
	if ((vtop[-1].r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
	{
		vswap();
		gv(float_type);
		vswap();
	}
	if ((vtop[0].r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
		gv(float_type);

	/* must put at least one value in the floating point register */
	if ((vtop[-1].r & VT_LVAL) &&
	        (vtop[0].r & VT_LVAL))
	{
		vswap();
		gv(float_type);
		vswap();
	}
	swapped = 0;
	/* swap the stack if needed so that t1 is the register and t2 is
	   the memory reference */
	if (vtop[-1].r & VT_LVAL)
	{
		vswap();
		swapped = 1;
	}
	if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE)
	{
		if (op >= TOK_ULT && op <= TOK_GT)
		{
			/* load on stack second operand */
			load(TREG_ST0, vtop);
			save_reg(TREG_RAX); /* eax is used by FP comparison code */
			if (op == TOK_GE || op == TOK_GT)
				swapped = !swapped;
			else if (op == TOK_EQ || op == TOK_NE)
				swapped = 0;
			if (swapped)
				o(0xc9d9); /* fxch %st(1) */
			if (op == TOK_EQ || op == TOK_NE)
				o(0xe9da); /* fucompp */
			else
				o(0xd9de); /* fcompp */
			o(0xe0df); /* fnstsw %ax */
			if (op == TOK_EQ)
			{
				o(0x45e480); /* and $0x45, %ah */
				o(0x40fC80); /* cmp $0x40, %ah */
			}
			else if (op == TOK_NE)
			{
				o(0x45e480); /* and $0x45, %ah */
				o(0x40f480); /* xor $0x40, %ah */
				op = TOK_NE;
			}
			else if (op == TOK_GE || op == TOK_LE)
			{
				o(0x05c4f6); /* test $0x05, %ah */
				op = TOK_EQ;
			}
			else
			{
				o(0x45c4f6); /* test $0x45, %ah */
				op = TOK_EQ;
			}
			vtop--;
			vset_VT_CMP(op);
		}
		else
		{
			/* no memory reference possible for long double operations */
			load(TREG_ST0, vtop);
			swapped = !swapped;

			switch(op)
			{
			default:
			case '+':
				a = 0;
				break;
			case '-':
				a = 4;
				if (swapped)
					a++;
				break;
			case '*':
				a = 1;
				break;
			case '/':
				a = 6;
				if (swapped)
					a++;
				break;
			}
			ft = vtop->type.t;
			fc = vtop->c.i;
			o(0xde); /* fxxxp %st, %st(1) */
			o(0xc1 + (a << 3));
			vtop--;
		}
	}
	else
	{
		if (op >= TOK_ULT && op <= TOK_GT)
		{
			/* if saved lvalue, then we must reload it */
			r = vtop->r;
			fc = vtop->c.i;
			if ((r & VT_VALMASK) == VT_LLOCAL)
			{
				SValue v1;
				r = get_reg(RC_INT);
				v1.type.t = VT_PTR;
				v1.r = VT_LOCAL | VT_LVAL;
				v1.c.i = fc;
				load(r, &v1);
				fc = 0;
				vtop->r = r = r | VT_LVAL;
			}

			if (op == TOK_EQ || op == TOK_NE)
			{
				swapped = 0;
			}
			else
			{
				if (op == TOK_LE || op == TOK_LT)
					swapped = !swapped;
				if (op == TOK_LE || op == TOK_GE)
				{
					op = 0x93; /* setae */
				}
				else
				{
					op = 0x97; /* seta */
				}
			}

			if (swapped)
			{
				gv(RC_FLOAT);
				vswap();
			}
			assert(!(vtop[-1].r & VT_LVAL));

			if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)
				o(0x66);
			if (op == TOK_EQ || op == TOK_NE)
				o(0x2e0f); /* ucomisd */
			else
				o(0x2f0f); /* comisd */

			if (vtop->r & VT_LVAL)
			{
				gen_modrm(vtop[-1].r, r, vtop->sym, fc);
			}
			else
			{
				o(0xc0 + REG_VALUE(vtop[0].r) + REG_VALUE(vtop[-1].r)*8);
			}

			vtop--;
			vset_VT_CMP(op | 0x100);
			vtop->cmp_r = op;
		}
		else
		{
			assert((vtop->type.t & VT_BTYPE) != VT_LDOUBLE);
			switch(op)
			{
			default:
			case '+':
				a = 0;
				break;
			case '-':
				a = 4;
				break;
			case '*':
				a = 1;
				break;
			case '/':
				a = 6;
				break;
			}
			ft = vtop->type.t;
			fc = vtop->c.i;
			assert((ft & VT_BTYPE) != VT_LDOUBLE);

			r = vtop->r;
			/* if saved lvalue, then we must reload it */
			if ((vtop->r & VT_VALMASK) == VT_LLOCAL)
			{
				SValue v1;
				r = get_reg(RC_INT);
				v1.type.t = VT_PTR;
				v1.r = VT_LOCAL | VT_LVAL;
				v1.c.i = fc;
				load(r, &v1);
				fc = 0;
				vtop->r = r = r | VT_LVAL;
			}

			assert(!(vtop[-1].r & VT_LVAL));
			if (swapped)
			{
				assert(vtop->r & VT_LVAL);
				gv(RC_FLOAT);
				vswap();
			}

			if ((ft & VT_BTYPE) == VT_DOUBLE)
			{
				o(0xf2);
			}
			else
			{
				o(0xf3);
			}
			o(0x0f);
			o(0x58 + a);

			if (vtop->r & VT_LVAL)
			{
				gen_modrm(vtop[-1].r, r, vtop->sym, fc);
			}
			else
			{
				o(0xc0 + REG_VALUE(vtop[0].r) + REG_VALUE(vtop[-1].r)*8);
			}

			vtop--;
		}
	}
}

/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'
   and 'long long' cases. */
void gen_cvt_itof(int t)
{
	if ((t & VT_BTYPE) == VT_LDOUBLE)
	{
		save_reg(TREG_ST0);
		gv(RC_INT);
		if ((vtop->type.t & VT_BTYPE) == VT_LLONG)
		{
			/* signed long long to float/double/long double (unsigned case
			   is handled generically) */
			o(0x50 + (vtop->r & VT_VALMASK)); /* push r */
			o(0x242cdf); /* fildll (%rsp) */
			o(0x08c48348); /* add $8, %rsp */
		}
		else if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) ==
		         (VT_INT | VT_UNSIGNED))
		{
			/* unsigned int to float/double/long double */
			o(0x6a); /* push $0 */
			g(0x00);
			o(0x50 + (vtop->r & VT_VALMASK)); /* push r */
			o(0x242cdf); /* fildll (%rsp) */
			o(0x10c48348); /* add $16, %rsp */
		}
		else
		{
			/* int to float/double/long double */
			o(0x50 + (vtop->r & VT_VALMASK)); /* push r */
			o(0x2404db); /* fildl (%rsp) */
			o(0x08c48348); /* add $8, %rsp */
		}
		vtop->r = TREG_ST0;
	}
	else
	{
		int r = get_reg(RC_FLOAT);
		gv(RC_INT);
		o(0xf2 + ((t & VT_BTYPE) == VT_FLOAT?1:0));
		if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) ==
		        (VT_INT | VT_UNSIGNED) ||
		        (vtop->type.t & VT_BTYPE) == VT_LLONG)
		{
			o(0x48); /* REX */
		}
		o(0x2a0f);
		o(0xc0 + (vtop->r & VT_VALMASK) + REG_VALUE(r)*8); /* cvtsi2sd */
		vtop->r = r;
	}
}

/* convert from one floating point type to another */
void gen_cvt_ftof(int t)
{
	int ft, bt, tbt;

	ft = vtop->type.t;
	bt = ft & VT_BTYPE;
	tbt = t & VT_BTYPE;

	if (bt == VT_FLOAT)
	{
		gv(RC_FLOAT);
		if (tbt == VT_DOUBLE)
		{
			o(0x140f); /* unpcklps */
			o(0xc0 + REG_VALUE(vtop->r)*9);
			o(0x5a0f); /* cvtps2pd */
			o(0xc0 + REG_VALUE(vtop->r)*9);
		}
		else if (tbt == VT_LDOUBLE)
		{
			save_reg(RC_ST0);
			/* movss %xmm0,-0x10(%rsp) */
			o(0x110ff3);
			o(0x44 + REG_VALUE(vtop->r)*8);
			o(0xf024);
			o(0xf02444d9); /* flds -0x10(%rsp) */
			vtop->r = TREG_ST0;
		}
	}
	else if (bt == VT_DOUBLE)
	{
		gv(RC_FLOAT);
		if (tbt == VT_FLOAT)
		{
			o(0x140f66); /* unpcklpd */
			o(0xc0 + REG_VALUE(vtop->r)*9);
			o(0x5a0f66); /* cvtpd2ps */
			o(0xc0 + REG_VALUE(vtop->r)*9);
		}
		else if (tbt == VT_LDOUBLE)
		{
			save_reg(RC_ST0);
			/* movsd %xmm0,-0x10(%rsp) */
			o(0x110ff2);
			o(0x44 + REG_VALUE(vtop->r)*8);
			o(0xf024);
			o(0xf02444dd); /* fldl -0x10(%rsp) */
			vtop->r = TREG_ST0;
		}
	}
	else
	{
		int r;
		gv(RC_ST0);
		r = get_reg(RC_FLOAT);
		if (tbt == VT_DOUBLE)
		{
			o(0xf0245cdd); /* fstpl -0x10(%rsp) */
			/* movsd -0x10(%rsp),%xmm0 */
			o(0x100ff2);
			o(0x44 + REG_VALUE(r)*8);
			o(0xf024);
			vtop->r = r;
		}
		else if (tbt == VT_FLOAT)
		{
			o(0xf0245cd9); /* fstps -0x10(%rsp) */
			/* movss -0x10(%rsp),%xmm0 */
			o(0x100ff3);
			o(0x44 + REG_VALUE(r)*8);
			o(0xf024);
			vtop->r = r;
		}
	}
}

/* convert fp to int 't' type */
void gen_cvt_ftoi(int t)
{
	int ft, bt, size, r;
	ft = vtop->type.t;
	bt = ft & VT_BTYPE;
	if (bt == VT_LDOUBLE)
	{
		gen_cvt_ftof(VT_DOUBLE);
		bt = VT_DOUBLE;
	}

	gv(RC_FLOAT);
	if (t != VT_INT)
		size = 8;
	else
		size = 4;

	r = get_reg(RC_INT);
	if (bt == VT_FLOAT)
	{
		o(0xf3);
	}
	else if (bt == VT_DOUBLE)
	{
		o(0xf2);
	}
	else
	{
		assert(0);
	}
	orex(size == 8, r, 0, 0x2c0f); /* cvttss2si or cvttsd2si */
	o(0xc0 + REG_VALUE(vtop->r) + REG_VALUE(r)*8);
	vtop->r = r;
}

// Generate sign extension from 32 to 64 bits:
ST_FUNC void gen_cvt_sxtw(void)
{
	int r = gv(RC_INT);
	/* x86_64 specific: movslq */
	o(0x6348);
	o(0xc0 + (REG_VALUE(r) << 3) + REG_VALUE(r));
}

/* char/short to int conversion */
ST_FUNC void gen_cvt_csti(int t)
{
	int r, sz, xl, ll;
	r = gv(RC_INT);
	sz = !(t & VT_UNSIGNED);
	xl = (t & VT_BTYPE) == VT_SHORT;
	ll = (vtop->type.t & VT_BTYPE) == VT_LLONG;
	orex(ll, r, 0, 0xc0b60f /* mov[sz] %a[xl], %eax */
	     | (sz << 3 | xl) << 8
	     | (REG_VALUE(r) << 3 | REG_VALUE(r)) << 16
	    );
}

/* computed goto support */
void ggoto(void)
{
	gcall_or_jmp(1);
	vtop--;
}

/* Save the stack pointer onto the stack and return the location of its address */
ST_FUNC void gen_vla_sp_save(int addr)
{
	/* mov %rsp,addr(%rbp)*/
	gen_modrm64(0x89, TREG_RSP, VT_LOCAL, NULL, addr);
}

/* Restore the SP from a location on the stack */
ST_FUNC void gen_vla_sp_restore(int addr)
{
	gen_modrm64(0x8b, TREG_RSP, VT_LOCAL, NULL, addr);
}

#ifdef TCC_TARGET_PE
/* Save result of gen_vla_alloc onto the stack */
ST_FUNC void gen_vla_result(int addr)
{
	/* mov %rax,addr(%rbp)*/
	gen_modrm64(0x89, TREG_RAX, VT_LOCAL, NULL, addr);
}
#endif

/* Subtract from the stack pointer, and push the resulting value onto the stack */
ST_FUNC void gen_vla_alloc(CType *type, int align)
{
	int use_call = 0;

#if defined(CONFIG_TCC_BCHECK)
	use_call = tcc_state->do_bounds_check;
#endif
#ifdef TCC_TARGET_PE	/* alloca does more than just adjust %rsp on Windows */
	use_call = 1;
#endif
	if (use_call)
	{
		vpush_global_sym(&func_old_type, TOK_alloca);
		vswap(); /* Move alloca ref past allocation size */
		gfunc_call(1);
	}
	else
	{
		int r;
		r = gv(RC_INT); /* allocation size */
		/* sub r,%rsp */
		o(0x2b48);
		o(0xe0 | REG_VALUE(r));
		/* We align to 16 bytes rather than align */
		/* and ~15, %rsp */
		o(0xf0e48348);
		vpop();
	}
}


/* end of x86-64 code generator */


//END x86_64-gen.c



//START x86_64-link.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)


#ifndef ELF_OBJ_ONLY
/* Returns 1 for a code relocation, 0 for a data relocation. For unknown
   relocations, returns -1. */
int code_reloc (int reloc_type)
{
	switch (reloc_type)
	{
	case R_X86_64_32:
	case R_X86_64_32S:
	case R_X86_64_64:
	case R_X86_64_GOTPC32:
	case R_X86_64_GOTPC64:
	case R_X86_64_GOTPCREL:
	case R_X86_64_GOTPCRELX:
	case R_X86_64_REX_GOTPCRELX:
	case R_X86_64_GOTTPOFF:
	case R_X86_64_GOT32:
	case R_X86_64_GOT64:
	case R_X86_64_GLOB_DAT:
	case R_X86_64_COPY:
	case R_X86_64_RELATIVE:
	case R_X86_64_GOTOFF64:
		return 0;

	case R_X86_64_PC32:
	case R_X86_64_PC64:
	case R_X86_64_PLT32:
	case R_X86_64_PLTOFF64:
	case R_X86_64_JUMP_SLOT:
		return 1;
	}
	return -1;
}

/* Returns an enumerator to describe whether and when the relocation needs a
   GOT and/or PLT entry to be created. See tcc.h for a description of the
   different values. */
int gotplt_entry_type (int reloc_type)
{
	switch (reloc_type)
	{
	case R_X86_64_GLOB_DAT:
	case R_X86_64_JUMP_SLOT:
	case R_X86_64_COPY:
	case R_X86_64_RELATIVE:
		return NO_GOTPLT_ENTRY;

	/* The following relocs wouldn't normally need GOT or PLT
	   slots, but we need them for simplicity in the link
	   editor part.  See our caller for comments.  */
	case R_X86_64_32:
	case R_X86_64_32S:
	case R_X86_64_64:
	case R_X86_64_PC32:
	case R_X86_64_PC64:
		return AUTO_GOTPLT_ENTRY;

	case R_X86_64_GOTTPOFF:
		return BUILD_GOT_ONLY;

	case R_X86_64_GOT32:
	case R_X86_64_GOT64:
	case R_X86_64_GOTPC32:
	case R_X86_64_GOTPC64:
	case R_X86_64_GOTOFF64:
	case R_X86_64_GOTPCREL:
	case R_X86_64_GOTPCRELX:
	case R_X86_64_REX_GOTPCRELX:
	case R_X86_64_PLT32:
	case R_X86_64_PLTOFF64:
		return ALWAYS_GOTPLT_ENTRY;
	}

	return -1;
}

ST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)
{
	Section *plt = s1->plt;
	uint8_t *p;
	int modrm;
	unsigned plt_offset, relofs;

	modrm = 0x25;

	/* empty PLT: create PLT0 entry that pushes the library identifier
	   (GOT + PTR_SIZE) and jumps to ld.so resolution routine
	   (GOT + 2 * PTR_SIZE) */
	if (plt->data_offset == 0)
	{
		p = section_ptr_add(plt, 16);
		p[0] = 0xff; /* pushl got + PTR_SIZE */
		p[1] = modrm + 0x10;
		write32le(p + 2, PTR_SIZE);
		p[6] = 0xff; /* jmp *(got + PTR_SIZE * 2) */
		p[7] = modrm;
		write32le(p + 8, PTR_SIZE * 2);
	}
	plt_offset = plt->data_offset;

	/* The PLT slot refers to the relocation entry it needs via offset.
	   The reloc entry is created below, so its offset is the current
	   data_offset */
	relofs = s1->got->reloc ? s1->got->reloc->data_offset : 0;

	/* Jump to GOT entry where ld.so initially put the address of ip + 4 */
	p = section_ptr_add(plt, 16);
	p[0] = 0xff; /* jmp *(got + x) */
	p[1] = modrm;
	write32le(p + 2, got_offset);
	p[6] = 0x68; /* push $xxx */
	/* On x86-64, the relocation is referred to by _index_ */
	write32le(p + 7, relofs / sizeof (ElfW_Rel));
	p[11] = 0xe9; /* jmp plt_start */
	write32le(p + 12, -(plt->data_offset));
	return plt_offset;
}

/* relocate the PLT: compute addresses and offsets in the PLT now that final
   address for PLT and GOT are known (see fill_program_header) */
ST_FUNC void relocate_plt(TCCState *s1)
{
	uint8_t *p, *p_end;

	if (!s1->plt)
		return;

	p = s1->plt->data;
	p_end = p + s1->plt->data_offset;

	if (p < p_end)
	{
		int x = s1->got->sh_addr - s1->plt->sh_addr - 6;
		add32le(p + 2, x);
		add32le(p + 8, x - 6);
		p += 16;
		while (p < p_end)
		{
			add32le(p + 2, x + (s1->plt->data - p));
			p += 16;
		}
	}
}
#endif

void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)
{
	int sym_index, esym_index;

	sym_index = ELFW(R_SYM)(rel->r_info);

	switch (type)
	{
	case R_X86_64_64:
		if (s1->output_type == TCC_OUTPUT_DLL)
		{
			esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;
			qrel->r_offset = rel->r_offset;
			if (esym_index)
			{
				qrel->r_info = ELFW(R_INFO)(esym_index, R_X86_64_64);
				qrel->r_addend = rel->r_addend;
				qrel++;
				break;
			}
			else
			{
				qrel->r_info = ELFW(R_INFO)(0, R_X86_64_RELATIVE);
				qrel->r_addend = read64le(ptr) + val;
				qrel++;
			}
		}
		add64le(ptr, val);
		break;
	case R_X86_64_32:
	case R_X86_64_32S:
		if (s1->output_type == TCC_OUTPUT_DLL)
		{
			/* XXX: this logic may depend on TCC's codegen
			   now TCC uses R_X86_64_32 even for a 64bit pointer */
			qrel->r_offset = rel->r_offset;
			qrel->r_info = ELFW(R_INFO)(0, R_X86_64_RELATIVE);
			/* Use sign extension! */
			qrel->r_addend = (int)read32le(ptr) + val;
			qrel++;
		}
		add32le(ptr, val);
		break;

	case R_X86_64_PC32:
		if (s1->output_type == TCC_OUTPUT_DLL)
		{
			/* DLL relocation */
			esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;
			if (esym_index)
			{
				qrel->r_offset = rel->r_offset;
				qrel->r_info = ELFW(R_INFO)(esym_index, R_X86_64_PC32);
				/* Use sign extension! */
				qrel->r_addend = (int)read32le(ptr) + rel->r_addend;
				qrel++;
				break;
			}
		}
		goto plt32pc32;

	case R_X86_64_PLT32:
		/* fallthrough: val already holds the PLT slot address */

plt32pc32:
		{
			long long diff;
			diff = (long long)val - addr;
			if (diff < -2147483648LL || diff > 2147483647LL)
			{
				tcc_error("internal error: relocation failed");
			}
			add32le(ptr, diff);
		}
		break;

	case R_X86_64_PLTOFF64:
		add64le(ptr, val - s1->got->sh_addr + rel->r_addend);
		break;

	case R_X86_64_PC64:
		if (s1->output_type == TCC_OUTPUT_DLL)
		{
			/* DLL relocation */
			esym_index = get_sym_attr(s1, sym_index, 0)->dyn_index;
			if (esym_index)
			{
				qrel->r_offset = rel->r_offset;
				qrel->r_info = ELFW(R_INFO)(esym_index, R_X86_64_PC64);
				qrel->r_addend = read64le(ptr) + rel->r_addend;
				qrel++;
				break;
			}
		}
		add64le(ptr, val - addr);
		break;

	case R_X86_64_GLOB_DAT:
	case R_X86_64_JUMP_SLOT:
		/* They don't need addend */
		write64le(ptr, val - rel->r_addend);
		break;
	case R_X86_64_GOTPCREL:
	case R_X86_64_GOTPCRELX:
	case R_X86_64_REX_GOTPCRELX:
		add32le(ptr, s1->got->sh_addr - addr +
		        get_sym_attr(s1, sym_index, 0)->got_offset - 4);
		break;
	case R_X86_64_GOTPC32:
		add32le(ptr, s1->got->sh_addr - addr + rel->r_addend);
		break;
	case R_X86_64_GOTPC64:
		add64le(ptr, s1->got->sh_addr - addr + rel->r_addend);
		break;
	case R_X86_64_GOTTPOFF:
		add32le(ptr, val - s1->got->sh_addr);
		break;
	case R_X86_64_GOT32:
		/* we load the got offset */
		add32le(ptr, get_sym_attr(s1, sym_index, 0)->got_offset);
		break;
	case R_X86_64_GOT64:
		/* we load the got offset */
		add64le(ptr, get_sym_attr(s1, sym_index, 0)->got_offset);
		break;
	case R_X86_64_GOTOFF64:
		add64le(ptr, val - s1->got->sh_addr);
		break;
	case R_X86_64_RELATIVE:
#ifdef TCC_TARGET_PE
		add32le(ptr, val - s1->pe_imagebase);
#endif
		/* do nothing */
		break;
	}
}


//END x86_64-link.c

//# include "x86_64-link.c"
#elif defined TCC_TARGET_ARM

//START arm-gen.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

enum float_abi float_abi;

ST_DATA const int reg_classes[NB_REGS] =
{
	/* r0 */ RC_INT | RC_R0,
	/* r1 */ RC_INT | RC_R1,
	/* r2 */ RC_INT | RC_R2,
	/* r3 */ RC_INT | RC_R3,
	/* r12 */ RC_INT | RC_R12,
	/* f0 */ RC_FLOAT | RC_F0,
	/* f1 */ RC_FLOAT | RC_F1,
	/* f2 */ RC_FLOAT | RC_F2,
	/* f3 */ RC_FLOAT | RC_F3,
#ifdef TCC_ARM_VFP
	/* d4/s8 */ RC_FLOAT | RC_F4,
	/* d5/s10 */ RC_FLOAT | RC_F5,
	/* d6/s12 */ RC_FLOAT | RC_F6,
	/* d7/s14 */ RC_FLOAT | RC_F7,
#endif
};

static int func_sub_sp_offset, last_itod_magic;
static int leaffunc;

#if defined(TCC_ARM_EABI) && defined(TCC_ARM_VFP)
static CType float_type, double_type, func_float_type, func_double_type;
ST_FUNC void arm_init(struct TCCState *s)
{
	float_type.t = VT_FLOAT;
	double_type.t = VT_DOUBLE;
	func_float_type.t = VT_FUNC;
	func_float_type.ref = sym_push(SYM_FIELD, &float_type, FUNC_CDECL, FUNC_OLD);
	func_double_type.t = VT_FUNC;
	func_double_type.ref = sym_push(SYM_FIELD, &double_type, FUNC_CDECL, FUNC_OLD);

	float_abi = s->float_abi;
#ifndef TCC_ARM_HARDFLOAT
# warning "soft float ABI currently not supported: default to softfp"
#endif
}
#else
#define func_float_type func_old_type
#define func_double_type func_old_type
#define func_ldouble_type func_old_type
ST_FUNC void arm_init(struct TCCState *s)
{
#if 0
#if !defined (TCC_ARM_VFP)
	tcc_warning("Support for FPA is deprecated and will be removed in next"
	            " release");
#endif
#if !defined (TCC_ARM_EABI)
	tcc_warning("Support for OABI is deprecated and will be removed in next"
	            " release");
#endif
#endif
}
#endif

static int two2mask(int a,int b)
{
	return (reg_classes[a]|reg_classes[b])&~(RC_INT|RC_FLOAT);
}

static int regmask(int r)
{
	return reg_classes[r]&~(RC_INT|RC_FLOAT);
}

/******************************************************/

#if defined(TCC_ARM_EABI) && !defined(CONFIG_TCC_ELFINTERP)
const char *default_elfinterp(struct TCCState *s)
{
	if (s->float_abi == ARM_HARD_FLOAT)
		return "/lib/ld-linux-armhf.so.3";
	else
		return "/lib/ld-linux.so.3";
}
#endif

void o(uint32_t i)
{
	/* this is a good place to start adding big-endian support*/
	int ind1;
	if (nocode_wanted)
		return;
	ind1 = ind + 4;
	if (!cur_text_section)
		tcc_error("compiler error! This happens f.ex. if the compiler\n"
		          "can't evaluate constant expressions outside of a function.");
	if (ind1 > cur_text_section->data_allocated)
		section_realloc(cur_text_section, ind1);
	cur_text_section->data[ind++] = i&255;
	i>>=8;
	cur_text_section->data[ind++] = i&255;
	i>>=8;
	cur_text_section->data[ind++] = i&255;
	i>>=8;
	cur_text_section->data[ind++] = i;
}

static uint32_t stuff_const(uint32_t op, uint32_t c)
{
	int try_neg=0;
	uint32_t nc = 0, negop = 0;

	switch(op&0x1F00000)
	{
	case 0x800000: //add
	case 0x400000: //sub
		try_neg=1;
		negop=op^0xC00000;
		nc=-c;
		break;
	case 0x1A00000: //mov
	case 0x1E00000: //mvn
		try_neg=1;
		negop=op^0x400000;
		nc=~c;
		break;
	case 0x200000: //xor
		if(c==~0)
			return (op&0xF010F000)|((op>>16)&0xF)|0x1E00000;
		break;
	case 0x0: //and
		if(c==~0)
			return (op&0xF010F000)|((op>>16)&0xF)|0x1A00000;
	case 0x1C00000: //bic
		try_neg=1;
		negop=op^0x1C00000;
		nc=~c;
		break;
	case 0x1800000: //orr
		if(c==~0)
			return (op&0xFFF0FFFF)|0x1E00000;
		break;
	}
	do
	{
		uint32_t m;
		int i;
		if(c<256) /* catch undefined <<32 */
			return op|c;
		for(i=2; i<32; i+=2)
		{
			m=(0xff>>i)|(0xff<<(32-i));
			if(!(c&~m))
				return op|(i<<7)|(c<<i)|(c>>(32-i));
		}
		op=negop;
		c=nc;
	}
	while(try_neg--);
	return 0;
}


//only add,sub
void stuff_const_harder(uint32_t op, uint32_t v)
{
	uint32_t x;
	x=stuff_const(op,v);
	if(x)
		o(x);
	else
	{
		uint32_t a[16], nv, no, o2, n2;
		int i,j,k;
		a[0]=0xff;
		o2=(op&0xfff0ffff)|((op&0xf000)<<4);;
		for(i=1; i<16; i++)
			a[i]=(a[i-1]>>2)|(a[i-1]<<30);
		for(i=0; i<12; i++)
			for(j=i<4?i+12:15; j>=i+4; j--)
				if((v&(a[i]|a[j]))==v)
				{
					o(stuff_const(op,v&a[i]));
					o(stuff_const(o2,v&a[j]));
					return;
				}
		no=op^0xC00000;
		n2=o2^0xC00000;
		nv=-v;
		for(i=0; i<12; i++)
			for(j=i<4?i+12:15; j>=i+4; j--)
				if((nv&(a[i]|a[j]))==nv)
				{
					o(stuff_const(no,nv&a[i]));
					o(stuff_const(n2,nv&a[j]));
					return;
				}
		for(i=0; i<8; i++)
			for(j=i+4; j<12; j++)
				for(k=i<4?i+12:15; k>=j+4; k--)
					if((v&(a[i]|a[j]|a[k]))==v)
					{
						o(stuff_const(op,v&a[i]));
						o(stuff_const(o2,v&a[j]));
						o(stuff_const(o2,v&a[k]));
						return;
					}
		no=op^0xC00000;
		nv=-v;
		for(i=0; i<8; i++)
			for(j=i+4; j<12; j++)
				for(k=i<4?i+12:15; k>=j+4; k--)
					if((nv&(a[i]|a[j]|a[k]))==nv)
					{
						o(stuff_const(no,nv&a[i]));
						o(stuff_const(n2,nv&a[j]));
						o(stuff_const(n2,nv&a[k]));
						return;
					}
		o(stuff_const(op,v&a[0]));
		o(stuff_const(o2,v&a[4]));
		o(stuff_const(o2,v&a[8]));
		o(stuff_const(o2,v&a[12]));
	}
}

uint32_t encbranch(int pos, int addr, int fail)
{
	addr-=pos+8;
	addr/=4;
	if(addr>=0x1000000 || addr<-0x1000000)
	{
		if(fail)
			tcc_error("FIXME: function bigger than 32MB");
		return 0;
	}
	return 0x0A000000|(addr&0xffffff);
}

int decbranch(int pos)
{
	int x;
	x=*(uint32_t *)(cur_text_section->data + pos);
	x&=0x00ffffff;
	if(x&0x800000)
		x-=0x1000000;
	return x*4+pos+8;
}

/* output a symbol and patch all calls to it */
void gsym_addr(int t, int a)
{
	uint32_t *x;
	int lt;
	while(t)
	{
		x=(uint32_t *)(cur_text_section->data + t);
		t=decbranch(lt=t);
		if(a==lt+4)
			*x=0xE1A00000; // nop
		else
		{
			*x &= 0xff000000;
			*x |= encbranch(lt,a,1);
		}
	}
}

#ifdef TCC_ARM_VFP
static uint32_t vfpr(int r)
{
	if(r<TREG_F0 || r>TREG_F7)
		tcc_error("compiler error! register %i is no vfp register",r);
	return r - TREG_F0;
}
#else
static uint32_t fpr(int r)
{
	if(r<TREG_F0 || r>TREG_F3)
		tcc_error("compiler error! register %i is no fpa register",r);
	return r - TREG_F0;
}
#endif

static uint32_t intr(int r)
{
	if(r == TREG_R12)
		return 12;
	if(r >= TREG_R0 && r <= TREG_R3)
		return r - TREG_R0;
	if (!(r >= TREG_SP && r <= TREG_LR))
		tcc_error("compiler error! register %i is no int register",r);
	return r + (13 - TREG_SP);
}

static void calcaddr(uint32_t *base, int *off, int *sgn, int maxoff, unsigned shift)
{
	if(*off>maxoff || *off&((1<<shift)-1))
	{
		uint32_t x, y;
		x=0xE280E000;
		if(*sgn)
			x=0xE240E000;
		x|=(*base)<<16;
		*base=14; // lr
		y=stuff_const(x,*off&~maxoff);
		if(y)
		{
			o(y);
			*off&=maxoff;
			return;
		}
		y=stuff_const(x,(*off+maxoff)&~maxoff);
		if(y)
		{
			o(y);
			*sgn=!*sgn;
			*off=((*off+maxoff)&~maxoff)-*off;
			return;
		}
		stuff_const_harder(x,*off&~maxoff);
		*off&=maxoff;
	}
}

static uint32_t mapcc(int cc)
{
	switch(cc)
	{
	case TOK_ULT:
		return 0x30000000; /* CC/LO */
	case TOK_UGE:
		return 0x20000000; /* CS/HS */
	case TOK_EQ:
		return 0x00000000; /* EQ */
	case TOK_NE:
		return 0x10000000; /* NE */
	case TOK_ULE:
		return 0x90000000; /* LS */
	case TOK_UGT:
		return 0x80000000; /* HI */
	case TOK_Nset:
		return 0x40000000; /* MI */
	case TOK_Nclear:
		return 0x50000000; /* PL */
	case TOK_LT:
		return 0xB0000000; /* LT */
	case TOK_GE:
		return 0xA0000000; /* GE */
	case TOK_LE:
		return 0xD0000000; /* LE */
	case TOK_GT:
		return 0xC0000000; /* GT */
	}
	tcc_error("unexpected condition code");
	return 0xE0000000; /* AL */
}

static int negcc(int cc)
{
	switch(cc)
	{
	case TOK_ULT:
		return TOK_UGE;
	case TOK_UGE:
		return TOK_ULT;
	case TOK_EQ:
		return TOK_NE;
	case TOK_NE:
		return TOK_EQ;
	case TOK_ULE:
		return TOK_UGT;
	case TOK_UGT:
		return TOK_ULE;
	case TOK_Nset:
		return TOK_Nclear;
	case TOK_Nclear:
		return TOK_Nset;
	case TOK_LT:
		return TOK_GE;
	case TOK_GE:
		return TOK_LT;
	case TOK_LE:
		return TOK_GT;
	case TOK_GT:
		return TOK_LE;
	}
	tcc_error("unexpected condition code");
	return TOK_NE;
}

/* load 'r' from value 'sv' */
void load(int r, SValue *sv)
{
	int v, ft, fc, fr, sign;
	uint32_t op;
	SValue v1;

	fr = sv->r;
	ft = sv->type.t;
	fc = sv->c.i;

	if(fc>=0)
		sign=0;
	else
	{
		sign=1;
		fc=-fc;
	}

	v = fr & VT_VALMASK;
	if (fr & VT_LVAL)
	{
		uint32_t base = 0xB; // fp
		if(v == VT_LLOCAL)
		{
			v1.type.t = VT_PTR;
			v1.r = VT_LOCAL | VT_LVAL;
			v1.c.i = sv->c.i;
			load(TREG_LR, &v1);
			base = 14; /* lr */
			fc=sign=0;
			v=VT_LOCAL;
		}
		else if(v == VT_CONST)
		{
			v1.type.t = VT_PTR;
			v1.r = fr&~VT_LVAL;
			v1.c.i = sv->c.i;
			v1.sym=sv->sym;
			load(TREG_LR, &v1);
			base = 14; /* lr */
			fc=sign=0;
			v=VT_LOCAL;
		}
		else if(v < VT_CONST)
		{
			base=intr(v);
			fc=sign=0;
			v=VT_LOCAL;
		}
		if(v == VT_LOCAL)
		{
			if(is_float(ft))
			{
				calcaddr(&base,&fc,&sign,1020,2);
#ifdef TCC_ARM_VFP
				op=0xED100A00; /* flds */
				if(!sign)
					op|=0x800000;
				if ((ft & VT_BTYPE) != VT_FLOAT)
					op|=0x100;   /* flds -> fldd */
				o(op|(vfpr(r)<<12)|(fc>>2)|(base<<16));
#else
				op=0xED100100;
				if(!sign)
					op|=0x800000;
#if LDOUBLE_SIZE == 8
				if ((ft & VT_BTYPE) != VT_FLOAT)
					op|=0x8000;
#else
				if ((ft & VT_BTYPE) == VT_DOUBLE)
					op|=0x8000;
				else if ((ft & VT_BTYPE) == VT_LDOUBLE)
					op|=0x400000;
#endif
				o(op|(fpr(r)<<12)|(fc>>2)|(base<<16));
#endif
			}
			else if((ft & (VT_BTYPE|VT_UNSIGNED)) == VT_BYTE
			        || (ft & VT_BTYPE) == VT_SHORT)
			{
				calcaddr(&base,&fc,&sign,255,0);
				op=0xE1500090;
				if ((ft & VT_BTYPE) == VT_SHORT)
					op|=0x20;
				if ((ft & VT_UNSIGNED) == 0)
					op|=0x40;
				if(!sign)
					op|=0x800000;
				o(op|(intr(r)<<12)|(base<<16)|((fc&0xf0)<<4)|(fc&0xf));
			}
			else
			{
				calcaddr(&base,&fc,&sign,4095,0);
				op=0xE5100000;
				if(!sign)
					op|=0x800000;
				if ((ft & VT_BTYPE) == VT_BYTE || (ft & VT_BTYPE) == VT_BOOL)
					op|=0x400000;
				o(op|(intr(r)<<12)|fc|(base<<16));
			}
			return;
		}
	}
	else
	{
		if (v == VT_CONST)
		{
			op=stuff_const(0xE3A00000|(intr(r)<<12),sv->c.i);
			if (fr & VT_SYM || !op)
			{
				o(0xE59F0000|(intr(r)<<12));
				o(0xEA000000);
				if(fr & VT_SYM)
					greloc(cur_text_section, sv->sym, ind, R_ARM_ABS32);
				o(sv->c.i);
			}
			else
				o(op);
			return;
		}
		else if (v == VT_LOCAL)
		{
			op=stuff_const(0xE28B0000|(intr(r)<<12),sv->c.i);
			if (fr & VT_SYM || !op)
			{
				o(0xE59F0000|(intr(r)<<12));
				o(0xEA000000);
				if(fr & VT_SYM) // needed ?
					greloc(cur_text_section, sv->sym, ind, R_ARM_ABS32);
				o(sv->c.i);
				o(0xE08B0000|(intr(r)<<12)|intr(r));
			}
			else
				o(op);
			return;
		}
		else if(v == VT_CMP)
		{
			o(mapcc(sv->c.i)|0x3A00001|(intr(r)<<12));
			o(mapcc(negcc(sv->c.i))|0x3A00000|(intr(r)<<12));
			return;
		}
		else if (v == VT_JMP || v == VT_JMPI)
		{
			int t;
			t = v & 1;
			o(0xE3A00000|(intr(r)<<12)|t);
			o(0xEA000000);
			gsym(sv->c.i);
			o(0xE3A00000|(intr(r)<<12)|(t^1));
			return;
		}
		else if (v < VT_CONST)
		{
			if(is_float(ft))
#ifdef TCC_ARM_VFP
				o(0xEEB00A40|(vfpr(r)<<12)|vfpr(v)|T2CPR(ft)); /* fcpyX */
#else
				o(0xEE008180|(fpr(r)<<12)|fpr(v));
#endif
			else
				o(0xE1A00000|(intr(r)<<12)|intr(v));
			return;
		}
	}
	tcc_error("load unimplemented!");
}

/* store register 'r' in lvalue 'v' */
void store(int r, SValue *sv)
{
	SValue v1;
	int v, ft, fc, fr, sign;
	uint32_t op;

	fr = sv->r;
	ft = sv->type.t;
	fc = sv->c.i;

	if(fc>=0)
		sign=0;
	else
	{
		sign=1;
		fc=-fc;
	}

	v = fr & VT_VALMASK;
	if (fr & VT_LVAL || fr == VT_LOCAL)
	{
		uint32_t base = 0xb; /* fp */
		if(v < VT_CONST)
		{
			base=intr(v);
			v=VT_LOCAL;
			fc=sign=0;
		}
		else if(v == VT_CONST)
		{
			v1.type.t = ft;
			v1.r = fr&~VT_LVAL;
			v1.c.i = sv->c.i;
			v1.sym=sv->sym;
			load(TREG_LR, &v1);
			base = 14; /* lr */
			fc=sign=0;
			v=VT_LOCAL;
		}
		if(v == VT_LOCAL)
		{
			if(is_float(ft))
			{
				calcaddr(&base,&fc,&sign,1020,2);
#ifdef TCC_ARM_VFP
				op=0xED000A00; /* fsts */
				if(!sign)
					op|=0x800000;
				if ((ft & VT_BTYPE) != VT_FLOAT)
					op|=0x100;   /* fsts -> fstd */
				o(op|(vfpr(r)<<12)|(fc>>2)|(base<<16));
#else
				op=0xED000100;
				if(!sign)
					op|=0x800000;
#if LDOUBLE_SIZE == 8
				if ((ft & VT_BTYPE) != VT_FLOAT)
					op|=0x8000;
#else
				if ((ft & VT_BTYPE) == VT_DOUBLE)
					op|=0x8000;
				if ((ft & VT_BTYPE) == VT_LDOUBLE)
					op|=0x400000;
#endif
				o(op|(fpr(r)<<12)|(fc>>2)|(base<<16));
#endif
				return;
			}
			else if((ft & VT_BTYPE) == VT_SHORT)
			{
				calcaddr(&base,&fc,&sign,255,0);
				op=0xE14000B0;
				if(!sign)
					op|=0x800000;
				o(op|(intr(r)<<12)|(base<<16)|((fc&0xf0)<<4)|(fc&0xf));
			}
			else
			{
				calcaddr(&base,&fc,&sign,4095,0);
				op=0xE5000000;
				if(!sign)
					op|=0x800000;
				if ((ft & VT_BTYPE) == VT_BYTE || (ft & VT_BTYPE) == VT_BOOL)
					op|=0x400000;
				o(op|(intr(r)<<12)|fc|(base<<16));
			}
			return;
		}
	}
	tcc_error("store unimplemented");
}

static void gadd_sp(int val)
{
	stuff_const_harder(0xE28DD000,val);
}

/* 'is_jmp' is '1' if it is a jump */
static void gcall_or_jmp(int is_jmp)
{
	int r;
	uint32_t x;
	if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
	{
		/* constant case */
		if(vtop->r & VT_SYM)
		{
			x=encbranch(ind,ind+vtop->c.i,0);
			if(x)
			{
				/* relocation case */
				greloc(cur_text_section, vtop->sym, ind, R_ARM_PC24);
				o(x|(is_jmp?0xE0000000:0xE1000000));
			}
			else
			{
				if(!is_jmp)
					o(0xE28FE004); // add lr,pc,#4
				o(0xE51FF004);   // ldr pc,[pc,#-4]
				greloc(cur_text_section, vtop->sym, ind, R_ARM_ABS32);
				o(vtop->c.i);
			}
		}
		else
		{
			if(!is_jmp)
				o(0xE28FE004); // add lr,pc,#4
			o(0xE51FF004);   // ldr pc,[pc,#-4]
			o(vtop->c.i);
		}
	}
	else
	{
		/* otherwise, indirect call */
		r = gv(RC_INT);
		if(!is_jmp)
			o(0xE1A0E00F);       // mov lr,pc
		o(0xE1A0F000|intr(r)); // mov pc,r
	}
}

static int unalias_ldbl(int btype)
{
#if LDOUBLE_SIZE == 8
	if (btype == VT_LDOUBLE)
		btype = VT_DOUBLE;
#endif
	return btype;
}

/* Return whether a structure is an homogeneous float aggregate or not.
   The answer is true if all the elements of the structure are of the same
   primitive float type and there is less than 4 elements.

   type: the type corresponding to the structure to be tested */
static int is_hgen_float_aggr(CType *type)
{
	if ((type->t & VT_BTYPE) == VT_STRUCT)
	{
		struct Sym *ref;
		int btype, nb_fields = 0;

		ref = type->ref->next;
		btype = unalias_ldbl(ref->type.t & VT_BTYPE);
		if (btype == VT_FLOAT || btype == VT_DOUBLE)
		{
			for(; ref && btype == unalias_ldbl(ref->type.t & VT_BTYPE); ref = ref->next, nb_fields++);
			return !ref && nb_fields <= 4;
		}
	}
	return 0;
}

struct avail_regs
{
	signed char avail[3]; /* 3 holes max with only float and double alignments */
	int first_hole; /* first available hole */
	int last_hole; /* last available hole (none if equal to first_hole) */
	int first_free_reg; /* next free register in the sequence, hole excluded */
};

#define AVAIL_REGS_INITIALIZER (struct avail_regs) { { 0, 0, 0}, 0, 0, 0 }

/* Find suitable registers for a VFP Co-Processor Register Candidate (VFP CPRC
   param) according to the rules described in the procedure call standard for
   the ARM architecture (AAPCS). If found, the registers are assigned to this
   VFP CPRC parameter. Registers are allocated in sequence unless a hole exists
   and the parameter is a single float.

   avregs: opaque structure to keep track of available VFP co-processor regs
   align: alignment constraints for the param, as returned by type_size()
   size: size of the parameter, as returned by type_size() */
int assign_vfpreg(struct avail_regs *avregs, int align, int size)
{
	int first_reg = 0;

	if (avregs->first_free_reg == -1)
		return -1;
	if (align >> 3)   /* double alignment */
	{
		first_reg = avregs->first_free_reg;
		/* alignment constraint not respected so use next reg and record hole */
		if (first_reg & 1)
			avregs->avail[avregs->last_hole++] = first_reg++;
	}
	else     /* no special alignment (float or array of float) */
	{
		/* if single float and a hole is available, assign the param to it */
		if (size == 4 && avregs->first_hole != avregs->last_hole)
			return avregs->avail[avregs->first_hole++];
		else
			first_reg = avregs->first_free_reg;
	}
	if (first_reg + size / 4 <= 16)
	{
		avregs->first_free_reg = first_reg + size / 4;
		return first_reg;
	}
	avregs->first_free_reg = -1;
	return -1;
}

/* Returns whether all params need to be passed in core registers or not.
   This is the case for function part of the runtime ABI. */
int floats_in_core_regs(SValue *sval)
{
	if (!sval->sym)
		return 0;

	switch (sval->sym->v)
	{
	case TOK___floatundisf:
	case TOK___floatundidf:
	case TOK___fixunssfdi:
	case TOK___fixunsdfdi:
#ifndef TCC_ARM_VFP
	case TOK___fixunsxfdi:
#endif
	case TOK___floatdisf:
	case TOK___floatdidf:
	case TOK___fixsfdi:
	case TOK___fixdfdi:
		return 1;

	default:
		return 0;
	}
}

/* Return the number of registers needed to return the struct, or 0 if
   returning via struct pointer. */
ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)
{
#ifdef TCC_ARM_EABI
	int size, align;
	size = type_size(vt, &align);
	if (float_abi == ARM_HARD_FLOAT && !variadic &&
	        (is_float(vt->t) || is_hgen_float_aggr(vt)))
	{
		*ret_align = 8;
		*regsize = 8;
		ret->ref = NULL;
		ret->t = VT_DOUBLE;
		return (size + 7) >> 3;
	}
	else if (size <= 4)
	{
		*ret_align = 4;
		*regsize = 4;
		ret->ref = NULL;
		ret->t = VT_INT;
		return 1;
	}
	else
		return 0;
#else
	return 0;
#endif
}

/* Parameters are classified according to how they are copied to their final
   destination for the function call. Because the copying is performed class
   after class according to the order in the union below, it is important that
   some constraints about the order of the members of this union are respected:
   - CORE_STRUCT_CLASS must come after STACK_CLASS;
   - CORE_CLASS must come after STACK_CLASS, CORE_STRUCT_CLASS and
     VFP_STRUCT_CLASS;
   - VFP_STRUCT_CLASS must come after VFP_CLASS.
   See the comment for the main loop in copy_params() for the reason. */
enum reg_class
{
	STACK_CLASS = 0,
	CORE_STRUCT_CLASS,
	VFP_CLASS,
	VFP_STRUCT_CLASS,
	CORE_CLASS,
	NB_CLASSES
};

struct param_plan
{
	int start; /* first reg or addr used depending on the class */
	int end; /* last reg used or next free addr depending on the class */
	SValue *sval; /* pointer to SValue on the value stack */
	struct param_plan *prev; /*  previous element in this class */
};

struct plan
{
	struct param_plan *pplans; /* array of all the param plans */
	struct param_plan *clsplans[NB_CLASSES]; /* per class lists of param plans */
};

#define add_param_plan(plan,pplan,class)                        \
    do {                                                        \
        pplan.prev = plan->clsplans[class];                     \
        plan->pplans[plan ## _nb] = pplan;                      \
        plan->clsplans[class] = &plan->pplans[plan ## _nb++];   \
    } while(0)

/* Assign parameters to registers and stack with alignment according to the
   rules in the procedure call standard for the ARM architecture (AAPCS).
   The overall assignment is recorded in an array of per parameter structures
   called parameter plans. The parameter plans are also further organized in a
   number of linked lists, one per class of parameter (see the comment for the
   definition of union reg_class).

   nb_args: number of parameters of the function for which a call is generated
   float_abi: float ABI in use for this function call
   plan: the structure where the overall assignment is recorded
   todo: a bitmap that record which core registers hold a parameter

   Returns the amount of stack space needed for parameter passing

   Note: this function allocated an array in plan->pplans with tcc_malloc. It
   is the responsibility of the caller to free this array once used (ie not
   before copy_params). */
static int assign_regs(int nb_args, int float_abi, struct plan *plan, int *todo)
{
	int i, size, align;
	int ncrn /* next core register number */, nsaa /* next stacked argument address*/;
	int plan_nb = 0;
	struct param_plan pplan;
	struct avail_regs avregs = AVAIL_REGS_INITIALIZER;

	ncrn = nsaa = 0;
	*todo = 0;
	plan->pplans = tcc_malloc(nb_args * sizeof(*plan->pplans));
	memset(plan->clsplans, 0, sizeof(plan->clsplans));
	for(i = nb_args; i-- ;)
	{
		int j, start_vfpreg = 0;
		CType type = vtop[-i].type;
		type.t &= ~VT_ARRAY;
		size = type_size(&type, &align);
		size = (size + 3) & ~3;
		align = (align + 3) & ~3;
		switch(vtop[-i].type.t & VT_BTYPE)
		{
		case VT_STRUCT:
		case VT_FLOAT:
		case VT_DOUBLE:
		case VT_LDOUBLE:
			if (float_abi == ARM_HARD_FLOAT)
			{
				int is_hfa = 0; /* Homogeneous float aggregate */

				if (is_float(vtop[-i].type.t)
				        || (is_hfa = is_hgen_float_aggr(&vtop[-i].type)))
				{
					int end_vfpreg;

					start_vfpreg = assign_vfpreg(&avregs, align, size);
					end_vfpreg = start_vfpreg + ((size - 1) >> 2);
					if (start_vfpreg >= 0)
					{
						pplan = (struct param_plan)
						{
							start_vfpreg, end_vfpreg, &vtop[-i]
						};
						if (is_hfa)
							add_param_plan(plan, pplan, VFP_STRUCT_CLASS);
						else
							add_param_plan(plan, pplan, VFP_CLASS);
						continue;
					}
					else
						break;
				}
			}
			ncrn = (ncrn + (align-1)/4) & ~((align/4) - 1);
			if (ncrn + size/4 <= 4 || (ncrn < 4 && start_vfpreg != -1))
			{
				/* The parameter is allocated both in core register and on stack. As
				* such, it can be of either class: it would either be the last of
				 * CORE_STRUCT_CLASS or the first of STACK_CLASS. */
				for (j = ncrn; j < 4 && j < ncrn + size / 4; j++)
					*todo|=(1<<j);
				pplan = (struct param_plan)
				{
					ncrn, j, &vtop[-i]
				};
				add_param_plan(plan, pplan, CORE_STRUCT_CLASS);
				ncrn += size/4;
				if (ncrn > 4)
					nsaa = (ncrn - 4) * 4;
			}
			else
			{
				ncrn = 4;
				break;
			}
			continue;
		default:
			if (ncrn < 4)
			{
				int is_long = (vtop[-i].type.t & VT_BTYPE) == VT_LLONG;

				if (is_long)
				{
					ncrn = (ncrn + 1) & -2;
					if (ncrn == 4)
						break;
				}
				pplan = (struct param_plan)
				{
					ncrn, ncrn, &vtop[-i]
				};
				ncrn++;
				if (is_long)
					pplan.end = ncrn++;
				add_param_plan(plan, pplan, CORE_CLASS);
				continue;
			}
		}
		nsaa = (nsaa + (align - 1)) & ~(align - 1);
		pplan = (struct param_plan)
		{
			nsaa, nsaa + size, &vtop[-i]
		};
		add_param_plan(plan, pplan, STACK_CLASS);
		nsaa += size; /* size already rounded up before */
	}
	return nsaa;
}

#undef add_param_plan

/* Copy parameters to their final destination (core reg, VFP reg or stack) for
   function call.

   nb_args: number of parameters the function take
   plan: the overall assignment plan for parameters
   todo: a bitmap indicating what core reg will hold a parameter

   Returns the number of SValue added by this function on the value stack */
static int copy_params(int nb_args, struct plan *plan, int todo)
{
	int size, align, r, i, nb_extra_sval = 0;
	struct param_plan *pplan;
	int pass = 0;

	/* Several constraints require parameters to be copied in a specific order:
	   - structures are copied to the stack before being loaded in a reg;
	   - floats loaded to an odd numbered VFP reg are first copied to the
	     preceding even numbered VFP reg and then moved to the next VFP reg.

	   It is thus important that:
	   - structures assigned to core regs must be copied after parameters
	     assigned to the stack but before structures assigned to VFP regs because
	     a structure can lie partly in core registers and partly on the stack;
	   - parameters assigned to the stack and all structures be copied before
	     parameters assigned to a core reg since copying a parameter to the stack
	     require using a core reg;
	   - parameters assigned to VFP regs be copied before structures assigned to
	     VFP regs as the copy might use an even numbered VFP reg that already
	     holds part of a structure. */
again:
	for(i = 0; i < NB_CLASSES; i++)
	{
		for(pplan = plan->clsplans[i]; pplan; pplan = pplan->prev)
		{

			if (pass
			        && (i != CORE_CLASS || pplan->sval->r < VT_CONST))
				continue;

			vpushv(pplan->sval);
			pplan->sval->r = pplan->sval->r2 = VT_CONST; /* disable entry */
			switch(i)
			{
			case STACK_CLASS:
			case CORE_STRUCT_CLASS:
			case VFP_STRUCT_CLASS:
				if ((pplan->sval->type.t & VT_BTYPE) == VT_STRUCT)
				{
					int padding = 0;
					size = type_size(&pplan->sval->type, &align);
					/* align to stack align size */
					size = (size + 3) & ~3;
					if (i == STACK_CLASS && pplan->prev)
						padding = pplan->start - pplan->prev->end;
					size += padding; /* Add padding if any */
					/* allocate the necessary size on stack */
					gadd_sp(-size);
					/* generate structure store */
					r = get_reg(RC_INT);
					o(0xE28D0000|(intr(r)<<12)|padding); /* add r, sp, padding */
					vset(&vtop->type, r | VT_LVAL, 0);
					vswap();
					vstore(); /* memcpy to current sp + potential padding */

					/* Homogeneous float aggregate are loaded to VFP registers
					   immediately since there is no way of loading data in multiple
					   non consecutive VFP registers as what is done for other
					   structures (see the use of todo). */
					if (i == VFP_STRUCT_CLASS)
					{
						int first = pplan->start, nb = pplan->end - first + 1;
						/* vpop.32 {pplan->start, ..., pplan->end} */
						o(0xECBD0A00|(first&1)<<22|(first>>1)<<12|nb);
						/* No need to write the register used to a SValue since VFP regs
						   cannot be used for gcall_or_jmp */
					}
				}
				else
				{
					if (is_float(pplan->sval->type.t))
					{
#ifdef TCC_ARM_VFP
						r = vfpr(gv(RC_FLOAT)) << 12;
						if ((pplan->sval->type.t & VT_BTYPE) == VT_FLOAT)
							size = 4;
						else
						{
							size = 8;
							r |= 0x101; /* vpush.32 -> vpush.64 */
						}
						o(0xED2D0A01 + r); /* vpush */
#else
						r = fpr(gv(RC_FLOAT)) << 12;
						if ((pplan->sval->type.t & VT_BTYPE) == VT_FLOAT)
							size = 4;
						else if ((pplan->sval->type.t & VT_BTYPE) == VT_DOUBLE)
							size = 8;
						else
							size = LDOUBLE_SIZE;

						if (size == 12)
							r |= 0x400000;
						else if(size == 8)
							r|=0x8000;

						o(0xED2D0100|r|(size>>2)); /* some kind of vpush for FPA */
#endif
					}
					else
					{
						/* simple type (currently always same size) */
						/* XXX: implicit cast ? */
						size=4;
						if ((pplan->sval->type.t & VT_BTYPE) == VT_LLONG)
						{
							lexpand();
							size = 8;
							r = gv(RC_INT);
							o(0xE52D0004|(intr(r)<<12)); /* push r */
							vtop--;
						}
						r = gv(RC_INT);
						o(0xE52D0004|(intr(r)<<12)); /* push r */
					}
					if (i == STACK_CLASS && pplan->prev)
						gadd_sp(pplan->prev->end - pplan->start); /* Add padding if any */
				}
				break;

			case VFP_CLASS:
				gv(regmask(TREG_F0 + (pplan->start >> 1)));
				if (pplan->start & 1)   /* Must be in upper part of double register */
				{
					o(0xEEF00A40|((pplan->start>>1)<<12)|(pplan->start>>1)); /* vmov.f32 s(n+1), sn */
					vtop->r = VT_CONST; /* avoid being saved on stack by gv for next float */
				}
				break;

			case CORE_CLASS:
				if ((pplan->sval->type.t & VT_BTYPE) == VT_LLONG)
				{
					lexpand();
					gv(regmask(pplan->end));
					pplan->sval->r2 = vtop->r;
					vtop--;
				}
				gv(regmask(pplan->start));
				/* Mark register as used so that gcall_or_jmp use another one
				   (regs >=4 are free as never used to pass parameters) */
				pplan->sval->r = vtop->r;
				break;
			}
			vtop--;
		}
	}

	/* second pass to restore registers that were saved on stack by accident.
	   Maybe redundant after the "lvalue_save" patch in tccgen.c:gv() */
	if (++pass < 2)
		goto again;

	/* Manually free remaining registers since next parameters are loaded
	 * manually, without the help of gv(int). */
	save_regs(nb_args);

	if(todo)
	{
		o(0xE8BD0000|todo); /* pop {todo} */
		for(pplan = plan->clsplans[CORE_STRUCT_CLASS]; pplan; pplan = pplan->prev)
		{
			int r;
			pplan->sval->r = pplan->start;
			/* An SValue can only pin 2 registers at best (r and r2) but a structure
			   can occupy more than 2 registers. Thus, we need to push on the value
			   stack some fake parameter to have on SValue for each registers used
			   by a structure (r2 is not used). */
			for (r = pplan->start + 1; r <= pplan->end; r++)
			{
				if (todo & (1 << r))
				{
					nb_extra_sval++;
					vpushi(0);
					vtop->r = r;
				}
			}
		}
	}
	return nb_extra_sval;
}

/* Generate function call. The function address is pushed first, then
   all the parameters in call order. This functions pops all the
   parameters and the function address. */
void gfunc_call(int nb_args)
{
	int r, args_size;
	int def_float_abi = float_abi;
	int todo;
	struct plan plan;

#ifdef TCC_ARM_EABI
	int variadic;

	if (float_abi == ARM_HARD_FLOAT)
	{
		variadic = (vtop[-nb_args].type.ref->f.func_type == FUNC_ELLIPSIS);
		if (variadic || floats_in_core_regs(&vtop[-nb_args]))
			float_abi = ARM_SOFTFP_FLOAT;
	}
#endif
	/* cannot let cpu flags if other instruction are generated. Also avoid leaving
	   VT_JMP anywhere except on the top of the stack because it would complicate
	   the code generator. */
	r = vtop->r & VT_VALMASK;
	if (r == VT_CMP || (r & ~1) == VT_JMP)
		gv(RC_INT);

	args_size = assign_regs(nb_args, float_abi, &plan, &todo);

#ifdef TCC_ARM_EABI
	if (args_size & 7)   /* Stack must be 8 byte aligned at fct call for EABI */
	{
		args_size = (args_size + 7) & ~7;
		o(0xE24DD004); /* sub sp, sp, #4 */
	}
#endif

	nb_args += copy_params(nb_args, &plan, todo);
	tcc_free(plan.pplans);

	/* Move fct SValue on top as required by gcall_or_jmp */
	vrotb(nb_args + 1);
	gcall_or_jmp(0);
	if (args_size)
		gadd_sp(args_size); /* pop all parameters passed on the stack */
#if defined(TCC_ARM_EABI) && defined(TCC_ARM_VFP)
	if(float_abi == ARM_SOFTFP_FLOAT && is_float(vtop->type.ref->type.t))
	{
		if((vtop->type.ref->type.t & VT_BTYPE) == VT_FLOAT)
		{
			o(0xEE000A10); /*vmov s0, r0 */
		}
		else
		{
			o(0xEE000B10); /* vmov.32 d0[0], r0 */
			o(0xEE201B10); /* vmov.32 d0[1], r1 */
		}
	}
#endif
	vtop -= nb_args + 1; /* Pop all params and fct address from value stack */
	leaffunc = 0; /* we are calling a function, so we aren't in a leaf function */
	float_abi = def_float_abi;
}

/* generate function prolog of type 't' */
void gfunc_prolog(Sym *func_sym)
{
	CType *func_type = &func_sym->type;
	Sym *sym,*sym2;
	int n, nf, size, align, rs, struct_ret = 0;
	int addr, pn, sn; /* pn=core, sn=stack */
	CType ret_type;

#ifdef TCC_ARM_EABI
	struct avail_regs avregs = AVAIL_REGS_INITIALIZER;
#endif

	sym = func_type->ref;
	func_vt = sym->type;
	func_var = (func_type->ref->f.func_type == FUNC_ELLIPSIS);

	n = nf = 0;
	if ((func_vt.t & VT_BTYPE) == VT_STRUCT &&
	        !gfunc_sret(&func_vt, func_var, &ret_type, &align, &rs))
	{
		n++;
		struct_ret = 1;
		func_vc = 12; /* Offset from fp of the place to store the result */
	}
	for(sym2 = sym->next; sym2 && (n < 4 || nf < 16); sym2 = sym2->next)
	{
		size = type_size(&sym2->type, &align);
#ifdef TCC_ARM_EABI
		if (float_abi == ARM_HARD_FLOAT && !func_var &&
		        (is_float(sym2->type.t) || is_hgen_float_aggr(&sym2->type)))
		{
			int tmpnf = assign_vfpreg(&avregs, align, size);
			tmpnf += (size + 3) / 4;
			nf = (tmpnf > nf) ? tmpnf : nf;
		}
		else
#endif
			if (n < 4)
				n += (size + 3) / 4;
	}
	o(0xE1A0C00D); /* mov ip,sp */
	if (func_var)
		n=4;
	if (n)
	{
		if(n>4)
			n=4;
#ifdef TCC_ARM_EABI
		n=(n+1)&-2;
#endif
		o(0xE92D0000|((1<<n)-1)); /* save r0-r4 on stack if needed */
	}
	if (nf)
	{
		if (nf>16)
			nf=16;
		nf=(nf+1)&-2; /* nf => HARDFLOAT => EABI */
		o(0xED2D0A00|nf); /* save s0-s15 on stack if needed */
	}
	o(0xE92D5800); /* save fp, ip, lr */
	o(0xE1A0B00D); /* mov fp, sp */
	func_sub_sp_offset = ind;
	o(0xE1A00000); /* nop, leave space for stack adjustment in epilog */

#ifdef TCC_ARM_EABI
	if (float_abi == ARM_HARD_FLOAT)
	{
		func_vc += nf * 4;
		avregs = AVAIL_REGS_INITIALIZER;
	}
#endif
	pn = struct_ret, sn = 0;
	while ((sym = sym->next))
	{
		CType *type;
		type = &sym->type;
		size = type_size(type, &align);
		size = (size + 3) >> 2;
		align = (align + 3) & ~3;
#ifdef TCC_ARM_EABI
		if (float_abi == ARM_HARD_FLOAT && !func_var && (is_float(sym->type.t)
		        || is_hgen_float_aggr(&sym->type)))
		{
			int fpn = assign_vfpreg(&avregs, align, size << 2);
			if (fpn >= 0)
				addr = fpn * 4;
			else
				goto from_stack;
		}
		else
#endif
			if (pn < 4)
			{
#ifdef TCC_ARM_EABI
				pn = (pn + (align-1)/4) & -(align/4);
#endif
				addr = (nf + pn) * 4;
				pn += size;
				if (!sn && pn > 4)
					sn = (pn - 4);
			}
			else
			{
#ifdef TCC_ARM_EABI
from_stack:
				sn = (sn + (align-1)/4) & -(align/4);
#endif
				addr = (n + nf + sn) * 4;
				sn += size;
			}
		sym_push(sym->v & ~SYM_FIELD, type, VT_LOCAL | VT_LVAL,
		         addr + 12);
	}
	last_itod_magic=0;
	leaffunc = 1;
	loc = 0;
}

/* generate function epilog */
void gfunc_epilog(void)
{
	uint32_t x;
	int diff;
	/* Copy float return value to core register if base standard is used and
	   float computation is made with VFP */
#if defined(TCC_ARM_EABI) && defined(TCC_ARM_VFP)
	if ((float_abi == ARM_SOFTFP_FLOAT || func_var) && is_float(func_vt.t))
	{
		if((func_vt.t & VT_BTYPE) == VT_FLOAT)
			o(0xEE100A10); /* fmrs r0, s0 */
		else
		{
			o(0xEE100B10); /* fmrdl r0, d0 */
			o(0xEE301B10); /* fmrdh r1, d0 */
		}
	}
#endif
	o(0xE89BA800); /* restore fp, sp, pc */
	diff = (-loc + 3) & -4;
#ifdef TCC_ARM_EABI
	if(!leaffunc)
		diff = ((diff + 11) & -8) - 4;
#endif
	if(diff > 0)
	{
		x=stuff_const(0xE24BD000, diff); /* sub sp,fp,# */
		if(x)
			*(uint32_t *)(cur_text_section->data + func_sub_sp_offset) = x;
		else
		{
			int addr;
			addr=ind;
			o(0xE59FC004); /* ldr ip,[pc+4] */
			o(0xE04BD00C); /* sub sp,fp,ip  */
			o(0xE1A0F00E); /* mov pc,lr */
			o(diff);
			*(uint32_t *)(cur_text_section->data + func_sub_sp_offset) = 0xE1000000|encbranch(func_sub_sp_offset,addr,1);
		}
	}
}

ST_FUNC void gen_fill_nops(int bytes)
{
	if ((bytes & 3))
		tcc_error("alignment of code section not multiple of 4");
	while (bytes > 0)
	{
		o(0xE1A00000);
		bytes -= 4;
	}
}

/* generate a jump to a label */
ST_FUNC int gjmp(int t)
{
	int r;
	if (nocode_wanted)
		return t;
	r=ind;
	o(0xE0000000|encbranch(r,t,1));
	return r;
}

/* generate a jump to a fixed address */
ST_FUNC void gjmp_addr(int a)
{
	gjmp(a);
}

ST_FUNC int gjmp_cond(int op, int t)
{
	int r;
	if (nocode_wanted)
		return t;
	r=ind;
	op=mapcc(op);
	op|=encbranch(r,t,1);
	o(op);
	return r;
}

ST_FUNC int gjmp_append(int n, int t)
{
	uint32_t *x;
	int p,lp;
	if(n)
	{
		p = n;
		do
		{
			p = decbranch(lp=p);
		}
		while(p);
		x = (uint32_t *)(cur_text_section->data + lp);
		*x &= 0xff000000;
		*x |= encbranch(lp,t,1);
		t = n;
	}
	return t;
}

/* generate an integer binary operation */
void gen_opi(int op)
{
	int c, func = 0;
	uint32_t opc = 0, r, fr;
	unsigned short retreg = REG_IRET;

	c=0;
	switch(op)
	{
	case '+':
		opc = 0x8;
		c=1;
		break;
	case TOK_ADDC1: /* add with carry generation */
		opc = 0x9;
		c=1;
		break;
	case '-':
		opc = 0x4;
		c=1;
		break;
	case TOK_SUBC1: /* sub with carry generation */
		opc = 0x5;
		c=1;
		break;
	case TOK_ADDC2: /* add with carry use */
		opc = 0xA;
		c=1;
		break;
	case TOK_SUBC2: /* sub with carry use */
		opc = 0xC;
		c=1;
		break;
	case '&':
		opc = 0x0;
		c=1;
		break;
	case '^':
		opc = 0x2;
		c=1;
		break;
	case '|':
		opc = 0x18;
		c=1;
		break;
	case '*':
		gv2(RC_INT, RC_INT);
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		o(0xE0000090|(intr(r)<<16)|(intr(r)<<8)|intr(fr));
		return;
	case TOK_SHL:
		opc = 0;
		c=2;
		break;
	case TOK_SHR:
		opc = 1;
		c=2;
		break;
	case TOK_SAR:
		opc = 2;
		c=2;
		break;
	case '/':
	case TOK_PDIV:
		func=TOK___divsi3;
		c=3;
		break;
	case TOK_UDIV:
		func=TOK___udivsi3;
		c=3;
		break;
	case '%':
#ifdef TCC_ARM_EABI
		func=TOK___aeabi_idivmod;
		retreg=REG_IRE2;
#else
		func=TOK___modsi3;
#endif
		c=3;
		break;
	case TOK_UMOD:
#ifdef TCC_ARM_EABI
		func=TOK___aeabi_uidivmod;
		retreg=REG_IRE2;
#else
		func=TOK___umodsi3;
#endif
		c=3;
		break;
	case TOK_UMULL:
		gv2(RC_INT, RC_INT);
		r=intr(vtop[-1].r2=get_reg(RC_INT));
		c=vtop[-1].r;
		vtop[-1].r=get_reg_ex(RC_INT,regmask(c));
		vtop--;
		o(0xE0800090|(r<<16)|(intr(vtop->r)<<12)|(intr(c)<<8)|intr(vtop[1].r));
		return;
	default:
		opc = 0x15;
		c=1;
		break;
	}
	switch(c)
	{
	case 1:
		if((vtop[-1].r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
		{
			if(opc == 4 || opc == 5 || opc == 0xc)
			{
				vswap();
				opc|=2; // sub -> rsb
			}
		}
		if ((vtop->r & VT_VALMASK) == VT_CMP ||
		        (vtop->r & (VT_VALMASK & ~1)) == VT_JMP)
			gv(RC_INT);
		vswap();
		c=intr(gv(RC_INT));
		vswap();
		opc=0xE0000000|(opc<<20)|(c<<16);
		if((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
		{
			uint32_t x;
			x=stuff_const(opc|0x2000000,vtop->c.i);
			if(x)
			{
				r=intr(vtop[-1].r=get_reg_ex(RC_INT,regmask(vtop[-1].r)));
				o(x|(r<<12));
				goto done;
			}
		}
		fr=intr(gv(RC_INT));
		r=intr(vtop[-1].r=get_reg_ex(RC_INT,two2mask(vtop->r,vtop[-1].r)));
		o(opc|(r<<12)|fr);
done:
		vtop--;
		if (op >= TOK_ULT && op <= TOK_GT)
			vset_VT_CMP(op);
		break;
	case 2:
		opc=0xE1A00000|(opc<<5);
		if ((vtop->r & VT_VALMASK) == VT_CMP ||
		        (vtop->r & (VT_VALMASK & ~1)) == VT_JMP)
			gv(RC_INT);
		vswap();
		r=intr(gv(RC_INT));
		vswap();
		opc|=r;
		if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
		{
			fr=intr(vtop[-1].r=get_reg_ex(RC_INT,regmask(vtop[-1].r)));
			c = vtop->c.i & 0x1f;
			o(opc|(c<<7)|(fr<<12));
		}
		else
		{
			fr=intr(gv(RC_INT));
			c=intr(vtop[-1].r=get_reg_ex(RC_INT,two2mask(vtop->r,vtop[-1].r)));
			o(opc|(c<<12)|(fr<<8)|0x10);
		}
		vtop--;
		break;
	case 3:
		vpush_global_sym(&func_old_type, func);
		vrott(3);
		gfunc_call(2);
		vpushi(0);
		vtop->r = retreg;
		break;
	default:
		tcc_error("gen_opi %i unimplemented!",op);
	}
}

#ifdef TCC_ARM_VFP
static int is_zero(int i)
{
	if((vtop[i].r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
		return 0;
	if (vtop[i].type.t == VT_FLOAT)
		return (vtop[i].c.f == 0.f);
	else if (vtop[i].type.t == VT_DOUBLE)
		return (vtop[i].c.d == 0.0);
	return (vtop[i].c.ld == 0.l);
}

/* generate a floating point operation 'v = t1 op t2' instruction. The
 *    two operands are guaranteed to have the same floating point type */
void gen_opf(int op)
{
	uint32_t x;
	int fneg=0,r;
	x=0xEE000A00|T2CPR(vtop->type.t);
	switch(op)
	{
	case '+':
		if(is_zero(-1))
			vswap();
		if(is_zero(0))
		{
			vtop--;
			return;
		}
		x|=0x300000;
		break;
	case '-':
		x|=0x300040;
		if(is_zero(0))
		{
			vtop--;
			return;
		}
		if(is_zero(-1))
		{
			x|=0x810000; /* fsubX -> fnegX */
			vswap();
			vtop--;
			fneg=1;
		}
		break;
	case '*':
		x|=0x200000;
		break;
	case '/':
		x|=0x800000;
		break;
	default:
		if(op < TOK_ULT || op > TOK_GT)
		{
			tcc_error("unknown fp op %x!",op);
			return;
		}
		if(is_zero(-1))
		{
			vswap();
			switch(op)
			{
			case TOK_LT:
				op=TOK_GT;
				break;
			case TOK_GE:
				op=TOK_ULE;
				break;
			case TOK_LE:
				op=TOK_GE;
				break;
			case TOK_GT:
				op=TOK_ULT;
				break;
			}
		}
		x|=0xB40040; /* fcmpX */
		if(op!=TOK_EQ && op!=TOK_NE)
			x|=0x80; /* fcmpX -> fcmpeX */
		if(is_zero(0))
		{
			vtop--;
			o(x|0x10000|(vfpr(gv(RC_FLOAT))<<12)); /* fcmp(e)X -> fcmp(e)zX */
		}
		else
		{
			x|=vfpr(gv(RC_FLOAT));
			vswap();
			o(x|(vfpr(gv(RC_FLOAT))<<12));
			vtop--;
		}
		o(0xEEF1FA10); /* fmstat */

		switch(op)
		{
		case TOK_LE:
			op=TOK_ULE;
			break;
		case TOK_LT:
			op=TOK_ULT;
			break;
		case TOK_UGE:
			op=TOK_GE;
			break;
		case TOK_UGT:
			op=TOK_GT;
			break;
		}
		vset_VT_CMP(op);
		return;
	}
	r=gv(RC_FLOAT);
	x|=vfpr(r);
	r=regmask(r);
	if(!fneg)
	{
		int r2;
		vswap();
		r2=gv(RC_FLOAT);
		x|=vfpr(r2)<<16;
		r|=regmask(r2);
	}
	vtop->r=get_reg_ex(RC_FLOAT,r);
	if(!fneg)
		vtop--;
	o(x|(vfpr(vtop->r)<<12));
}

#else
static uint32_t is_fconst()
{
	long double f;
	uint32_t r;
	if((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
		return 0;
	if (vtop->type.t == VT_FLOAT)
		f = vtop->c.f;
	else if (vtop->type.t == VT_DOUBLE)
		f = vtop->c.d;
	else
		f = vtop->c.ld;
	if(!ieee_finite(f))
		return 0;
	r=0x8;
	if(f<0.0)
	{
		r=0x18;
		f=-f;
	}
	if(f==0.0)
		return r;
	if(f==1.0)
		return r|1;
	if(f==2.0)
		return r|2;
	if(f==3.0)
		return r|3;
	if(f==4.0)
		return r|4;
	if(f==5.0)
		return r|5;
	if(f==0.5)
		return r|6;
	if(f==10.0)
		return r|7;
	return 0;
}

/* generate a floating point operation 'v = t1 op t2' instruction. The
   two operands are guaranteed to have the same floating point type */
void gen_opf(int op)
{
	uint32_t x, r, r2, c1, c2;
	//fputs("gen_opf\n",stderr);
	vswap();
	c1 = is_fconst();
	vswap();
	c2 = is_fconst();
	x=0xEE000100;
#if LDOUBLE_SIZE == 8
	if ((vtop->type.t & VT_BTYPE) != VT_FLOAT)
		x|=0x80;
#else
	if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)
		x|=0x80;
	else if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE)
		x|=0x80000;
#endif
	switch(op)
	{
	case '+':
		if(!c2)
		{
			vswap();
			c2=c1;
		}
		vswap();
		r=fpr(gv(RC_FLOAT));
		vswap();
		if(c2)
		{
			if(c2>0xf)
				x|=0x200000; // suf
			r2=c2&0xf;
		}
		else
		{
			r2=fpr(gv(RC_FLOAT));
		}
		break;
	case '-':
		if(c2)
		{
			if(c2<=0xf)
				x|=0x200000; // suf
			r2=c2&0xf;
			vswap();
			r=fpr(gv(RC_FLOAT));
			vswap();
		}
		else if(c1 && c1<=0xf)
		{
			x|=0x300000; // rsf
			r2=c1;
			r=fpr(gv(RC_FLOAT));
			vswap();
		}
		else
		{
			x|=0x200000; // suf
			vswap();
			r=fpr(gv(RC_FLOAT));
			vswap();
			r2=fpr(gv(RC_FLOAT));
		}
		break;
	case '*':
		if(!c2 || c2>0xf)
		{
			vswap();
			c2=c1;
		}
		vswap();
		r=fpr(gv(RC_FLOAT));
		vswap();
		if(c2 && c2<=0xf)
			r2=c2;
		else
			r2=fpr(gv(RC_FLOAT));
		x|=0x100000; // muf
		break;
	case '/':
		if(c2 && c2<=0xf)
		{
			x|=0x400000; // dvf
			r2=c2;
			vswap();
			r=fpr(gv(RC_FLOAT));
			vswap();
		}
		else if(c1 && c1<=0xf)
		{
			x|=0x500000; // rdf
			r2=c1;
			r=fpr(gv(RC_FLOAT));
			vswap();
		}
		else
		{
			x|=0x400000; // dvf
			vswap();
			r=fpr(gv(RC_FLOAT));
			vswap();
			r2=fpr(gv(RC_FLOAT));
		}
		break;
	default:
		if(op >= TOK_ULT && op <= TOK_GT)
		{
			x|=0xd0f110; // cmfe
			/* bug (intention?) in Linux FPU emulator
			   doesn't set carry if equal */
			switch(op)
			{
			case TOK_ULT:
			case TOK_UGE:
			case TOK_ULE:
			case TOK_UGT:
				tcc_error("unsigned comparison on floats?");
				break;
			case TOK_LT:
				op=TOK_Nset;
				break;
			case TOK_LE:
				op=TOK_ULE; /* correct in unordered case only if AC bit in FPSR set */
				break;
			case TOK_EQ:
			case TOK_NE:
				x&=~0x400000; // cmfe -> cmf
				break;
			}
			if(c1 && !c2)
			{
				c2=c1;
				vswap();
				switch(op)
				{
				case TOK_Nset:
					op=TOK_GT;
					break;
				case TOK_GE:
					op=TOK_ULE;
					break;
				case TOK_ULE:
					op=TOK_GE;
					break;
				case TOK_GT:
					op=TOK_Nset;
					break;
				}
			}
			vswap();
			r=fpr(gv(RC_FLOAT));
			vswap();
			if(c2)
			{
				if(c2>0xf)
					x|=0x200000;
				r2=c2&0xf;
			}
			else
			{
				r2=fpr(gv(RC_FLOAT));
			}
			--vtop;
			vset_VT_CMP(op);
			++vtop;
		}
		else
		{
			tcc_error("unknown fp op %x!",op);
			return;
		}
	}
	if(vtop[-1].r == VT_CMP)
		c1=15;
	else
	{
		c1=vtop->r;
		if(r2&0x8)
			c1=vtop[-1].r;
		vtop[-1].r=get_reg_ex(RC_FLOAT,two2mask(vtop[-1].r,c1));
		c1=fpr(vtop[-1].r);
	}
	vtop--;
	o(x|(r<<16)|(c1<<12)|r2);
}
#endif

/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'
   and 'long long' cases. */
ST_FUNC void gen_cvt_itof(int t)
{
	uint32_t r, r2;
	int bt;
	bt=vtop->type.t & VT_BTYPE;
	if(bt == VT_INT || bt == VT_SHORT || bt == VT_BYTE)
	{
#ifndef TCC_ARM_VFP
		uint32_t dsize = 0;
#endif
		r=intr(gv(RC_INT));
#ifdef TCC_ARM_VFP
		r2=vfpr(vtop->r=get_reg(RC_FLOAT));
		o(0xEE000A10|(r<<12)|(r2<<16)); /* fmsr */
		r2|=r2<<12;
		if(!(vtop->type.t & VT_UNSIGNED))
			r2|=0x80;                /* fuitoX -> fsituX */
		o(0xEEB80A40|r2|T2CPR(t)); /* fYitoX*/
#else
		r2=fpr(vtop->r=get_reg(RC_FLOAT));
		if((t & VT_BTYPE) != VT_FLOAT)
			dsize=0x80;    /* flts -> fltd */
		o(0xEE000110|dsize|(r2<<16)|(r<<12)); /* flts */
		if((vtop->type.t & (VT_UNSIGNED|VT_BTYPE)) == (VT_UNSIGNED|VT_INT))
		{
			uint32_t off = 0;
			o(0xE3500000|(r<<12));        /* cmp */
			r=fpr(get_reg(RC_FLOAT));
			if(last_itod_magic)
			{
				off=ind+8-last_itod_magic;
				off/=4;
				if(off>255)
					off=0;
			}
			o(0xBD1F0100|(r<<12)|off);    /* ldflts */
			if(!off)
			{
				o(0xEA000000);              /* b */
				last_itod_magic=ind;
				o(0x4F800000);              /* 4294967296.0f */
			}
			o(0xBE000100|dsize|(r2<<16)|(r2<<12)|r); /* adflt */
		}
#endif
		return;
	}
	else if(bt == VT_LLONG)
	{
		int func;
		CType *func_type = 0;
		if((t & VT_BTYPE) == VT_FLOAT)
		{
			func_type = &func_float_type;
			if(vtop->type.t & VT_UNSIGNED)
				func=TOK___floatundisf;
			else
				func=TOK___floatdisf;
#if LDOUBLE_SIZE != 8
		}
		else if((t & VT_BTYPE) == VT_LDOUBLE)
		{
			func_type = &func_ldouble_type;
			if(vtop->type.t & VT_UNSIGNED)
				func=TOK___floatundixf;
			else
				func=TOK___floatdixf;
		}
		else if((t & VT_BTYPE) == VT_DOUBLE)
		{
#else
		}
		else if((t & VT_BTYPE) == VT_DOUBLE || (t & VT_BTYPE) == VT_LDOUBLE)
		{
#endif
			func_type = &func_double_type;
			if(vtop->type.t & VT_UNSIGNED)
				func=TOK___floatundidf;
			else
				func=TOK___floatdidf;
		}
		if(func_type)
		{
			vpush_global_sym(func_type, func);
			vswap();
			gfunc_call(1);
			vpushi(0);
			vtop->r=TREG_F0;
			return;
		}
	}
	tcc_error("unimplemented gen_cvt_itof %x!",vtop->type.t);
}

/* convert fp to int 't' type */
void gen_cvt_ftoi(int t)
{
	uint32_t r, r2;
	int u, func = 0;
	u=t&VT_UNSIGNED;
	t&=VT_BTYPE;
	r2=vtop->type.t & VT_BTYPE;
	if(t==VT_INT)
	{
#ifdef TCC_ARM_VFP
		r=vfpr(gv(RC_FLOAT));
		u=u?0:0x10000;
		o(0xEEBC0AC0|(r<<12)|r|T2CPR(r2)|u); /* ftoXizY */
		r2=intr(vtop->r=get_reg(RC_INT));
		o(0xEE100A10|(r<<16)|(r2<<12));
		return;
#else
		if(u)
		{
			if(r2 == VT_FLOAT)
				func=TOK___fixunssfsi;
#if LDOUBLE_SIZE != 8
			else if(r2 == VT_LDOUBLE)
				func=TOK___fixunsxfsi;
			else if(r2 == VT_DOUBLE)
#else
			else if(r2 == VT_LDOUBLE || r2 == VT_DOUBLE)
#endif
				func=TOK___fixunsdfsi;
		}
		else
		{
			r=fpr(gv(RC_FLOAT));
			r2=intr(vtop->r=get_reg(RC_INT));
			o(0xEE100170|(r2<<12)|r);
			return;
		}
#endif
	}
	else if(t == VT_LLONG)     // unsigned handled in gen_cvt_ftoi1
	{
		if(r2 == VT_FLOAT)
			func=TOK___fixsfdi;
#if LDOUBLE_SIZE != 8
		else if(r2 == VT_LDOUBLE)
			func=TOK___fixxfdi;
		else if(r2 == VT_DOUBLE)
#else
		else if(r2 == VT_LDOUBLE || r2 == VT_DOUBLE)
#endif
			func=TOK___fixdfdi;
	}
	if(func)
	{
		vpush_global_sym(&func_old_type, func);
		vswap();
		gfunc_call(1);
		vpushi(0);
		if(t == VT_LLONG)
			vtop->r2 = REG_IRE2;
		vtop->r = REG_IRET;
		return;
	}
	tcc_error("unimplemented gen_cvt_ftoi!");
}

/* convert from one floating point type to another */
void gen_cvt_ftof(int t)
{
#ifdef TCC_ARM_VFP
	if(((vtop->type.t & VT_BTYPE) == VT_FLOAT) != ((t & VT_BTYPE) == VT_FLOAT))
	{
		uint32_t r = vfpr(gv(RC_FLOAT));
		o(0xEEB70AC0|(r<<12)|r|T2CPR(vtop->type.t));
	}
#else
	/* all we have to do on i386 and FPA ARM is to put the float in a register */
	gv(RC_FLOAT);
#endif
}

/* computed goto support */
void ggoto(void)
{
	gcall_or_jmp(1);
	vtop--;
}

/* Save the stack pointer onto the stack and return the location of its address */
ST_FUNC void gen_vla_sp_save(int addr)
{
	SValue v;
	v.type.t = VT_PTR;
	v.r = VT_LOCAL | VT_LVAL;
	v.c.i = addr;
	store(TREG_SP, &v);
}

/* Restore the SP from a location on the stack */
ST_FUNC void gen_vla_sp_restore(int addr)
{
	SValue v;
	v.type.t = VT_PTR;
	v.r = VT_LOCAL | VT_LVAL;
	v.c.i = addr;
	load(TREG_SP, &v);
}

/* Subtract from the stack pointer, and push the resulting value onto the stack */
ST_FUNC void gen_vla_alloc(CType *type, int align)
{
	int r = intr(gv(RC_INT));
	o(0xE04D0000|(r<<12)|r); /* sub r, sp, r */
#ifdef TCC_ARM_EABI
	if (align < 8)
		align = 8;
#else
	if (align < 4)
		align = 4;
#endif
	if (align & (align - 1))
		tcc_error("alignment is not a power of 2: %i", align);
	o(stuff_const(0xE3C0D000|(r<<16), align - 1)); /* bic sp, r, #align-1 */
	vpop();
}

/* end of ARM code generator */
//END arm-gen.c

//START arm-link.c

/* Returns 1 for a code relocation, 0 for a data relocation. For unknown
   relocations, returns -1. */
int code_reloc (int reloc_type)
{
	switch (reloc_type)
	{
	case R_ARM_MOVT_ABS:
	case R_ARM_MOVW_ABS_NC:
	case R_ARM_THM_MOVT_ABS:
	case R_ARM_THM_MOVW_ABS_NC:
	case R_ARM_ABS32:
	case R_ARM_REL32:
	case R_ARM_GOTPC:
	case R_ARM_GOTOFF:
	case R_ARM_GOT32:
	case R_ARM_COPY:
	case R_ARM_GLOB_DAT:
	case R_ARM_NONE:
		return 0;

	case R_ARM_PC24:
	case R_ARM_CALL:
	case R_ARM_JUMP24:
	case R_ARM_PLT32:
	case R_ARM_THM_PC22:
	case R_ARM_THM_JUMP24:
	case R_ARM_PREL31:
	case R_ARM_V4BX:
	case R_ARM_JUMP_SLOT:
		return 1;
	}
	return -1;
}

/* Returns an enumerator to describe whether and when the relocation needs a
   GOT and/or PLT entry to be created. See tcc.h for a description of the
   different values. */
int gotplt_entry_type (int reloc_type)
{
	switch (reloc_type)
	{
	case R_ARM_NONE:
	case R_ARM_COPY:
	case R_ARM_GLOB_DAT:
	case R_ARM_JUMP_SLOT:
		return NO_GOTPLT_ENTRY;

	case R_ARM_PC24:
	case R_ARM_CALL:
	case R_ARM_JUMP24:
	case R_ARM_PLT32:
	case R_ARM_THM_PC22:
	case R_ARM_THM_JUMP24:
	case R_ARM_MOVT_ABS:
	case R_ARM_MOVW_ABS_NC:
	case R_ARM_THM_MOVT_ABS:
	case R_ARM_THM_MOVW_ABS_NC:
	case R_ARM_PREL31:
	case R_ARM_ABS32:
	case R_ARM_REL32:
	case R_ARM_V4BX:
		return AUTO_GOTPLT_ENTRY;

	case R_ARM_GOTPC:
	case R_ARM_GOTOFF:
		return BUILD_GOT_ONLY;

	case R_ARM_GOT32:
		return ALWAYS_GOTPLT_ENTRY;
	}
	return -1;
}

ST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)
{
	Section *plt = s1->plt;
	uint8_t *p;
	unsigned plt_offset;

	/* when building a DLL, GOT entry accesses must be done relative to
	   start of GOT (see x86_64 example above)  */
	if (s1->output_type == TCC_OUTPUT_DLL)
		tcc_error("DLLs unimplemented!");

	/* empty PLT: create PLT0 entry that push address of call site and
	   jump to ld.so resolution routine (GOT + 8) */
	if (plt->data_offset == 0)
	{
		p = section_ptr_add(plt, 20);
		write32le(p,    0xe52de004); /* push {lr}         */
		write32le(p+4,  0xe59fe004); /* ldr lr, [pc, #4] */
		write32le(p+8,  0xe08fe00e); /* add lr, pc, lr    */
		write32le(p+12, 0xe5bef008); /* ldr pc, [lr, #8]! */
		/* p+16 is set in relocate_plt */
	}
	plt_offset = plt->data_offset;

	if (attr->plt_thumb_stub)
	{
		p = section_ptr_add(plt, 4);
		write32le(p,   0x4778); /* bx pc */
		write32le(p+2, 0x46c0); /* nop   */
	}
	p = section_ptr_add(plt, 16);
	/* Jump to GOT entry where ld.so initially put address of PLT0 */
	write32le(p,   0xe59fc004); /* ldr ip, [pc, #4] */
	write32le(p+4, 0xe08fc00c); /* add ip, pc, ip */
	write32le(p+8, 0xe59cf000); /* ldr pc, [ip] */
	/* p + 12 contains offset to GOT entry once patched by relocate_plt */
	write32le(p+12, got_offset);
	return plt_offset;
}

/* relocate the PLT: compute addresses and offsets in the PLT now that final
   address for PLT and GOT are known (see fill_program_header) */
ST_FUNC void relocate_plt(TCCState *s1)
{
	uint8_t *p, *p_end;

	if (!s1->plt)
		return;

	p = s1->plt->data;
	p_end = p + s1->plt->data_offset;

	if (p < p_end)
	{
		int x = s1->got->sh_addr - s1->plt->sh_addr - 12;
		write32le(s1->plt->data + 16, x - 16);
		p += 20;
		while (p < p_end)
		{
			if (read32le(p) == 0x46c04778) /* PLT Thumb stub present */
				p += 4;
			add32le(p + 12, x + s1->plt->data - p);
			p += 16;
		}
	}
}

void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)
{
	ElfW(Sym) *sym;
	int sym_index;

	sym_index = ELFW(R_SYM)(rel->r_info);
	sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];

	switch(type)
	{
	case R_ARM_PC24:
	case R_ARM_CALL:
	case R_ARM_JUMP24:
	case R_ARM_PLT32:
	{
		int x, is_thumb, is_call, h, blx_avail, is_bl, th_ko;
		x = (*(int *) ptr) & 0xffffff;
#ifdef DEBUG_RELOC
		printf ("reloc %d: x=0x%x val=0x%x ", type, x, val);
#endif
		(*(int *)ptr) &= 0xff000000;
		if (x & 0x800000)
			x -= 0x1000000;
		x <<= 2;
		blx_avail = (TCC_CPU_VERSION >= 5);
		is_thumb = val & 1;
		is_bl = (*(unsigned *) ptr) >> 24 == 0xeb;
		is_call = (type == R_ARM_CALL || (type == R_ARM_PC24 && is_bl));
		x += val - addr;
#ifdef DEBUG_RELOC
		printf (" newx=0x%x name=%s\n", x,
		        (char *) symtab_section->link->data + sym->st_name);
#endif
		h = x & 2;
		th_ko = (x & 3) && (!blx_avail || !is_call);
		if (th_ko || x >= 0x2000000 || x < -0x2000000)
			tcc_error("can't relocate value at %x,%d",addr, type);
		x >>= 2;
		x &= 0xffffff;
		/* Only reached if blx is avail and it is a call */
		if (is_thumb)
		{
			x |= h << 24;
			(*(int *)ptr) = 0xfa << 24; /* bl -> blx */
		}
		(*(int *) ptr) |= x;
	}
	return;
	/* Since these relocations only concern Thumb-2 and blx instruction was
	   introduced before Thumb-2, we can assume blx is available and not
	   guard its use */
	case R_ARM_THM_PC22:
	case R_ARM_THM_JUMP24:
	{
		int x, hi, lo, s, j1, j2, i1, i2, imm10, imm11;
		int to_thumb, is_call, to_plt, blx_bit = 1 << 12;
		Section *plt;

		/* weak reference */
		if (sym->st_shndx == SHN_UNDEF &&
		        ELFW(ST_BIND)(sym->st_info) == STB_WEAK)
			return;

		/* Get initial offset */
		hi = (*(uint16_t *)ptr);
		lo = (*(uint16_t *)(ptr+2));
		s = (hi >> 10) & 1;
		j1 = (lo >> 13) & 1;
		j2 = (lo >> 11) & 1;
		i1 = (j1 ^ s) ^ 1;
		i2 = (j2 ^ s) ^ 1;
		imm10 = hi & 0x3ff;
		imm11 = lo & 0x7ff;
		x = (s << 24) | (i1 << 23) | (i2 << 22) |
		    (imm10 << 12) | (imm11 << 1);
		if (x & 0x01000000)
			x -= 0x02000000;

		/* Relocation infos */
		to_thumb = val & 1;
		plt = s1->plt;
		to_plt = (val >= plt->sh_addr) &&
		         (val < plt->sh_addr + plt->data_offset);
		is_call = (type == R_ARM_THM_PC22);

		if (!to_thumb && !to_plt && !is_call)
		{
			int index;
			uint8_t *p;
			char *name, buf[1024];
			Section *text;

			name = (char *) symtab_section->link->data + sym->st_name;
			text = s1->sections[sym->st_shndx];
			/* Modify reloc to target a thumb stub to switch to ARM */
			snprintf(buf, sizeof(buf), "%s_from_thumb", name);
			index = put_elf_sym(symtab_section,
			                    text->data_offset + 1,
			                    sym->st_size, sym->st_info, 0,
			                    sym->st_shndx, buf);
			to_thumb = 1;
			val = text->data_offset + 1;
			rel->r_info = ELFW(R_INFO)(index, type);
			/* Create a thumb stub function to switch to ARM mode */
			put_elf_reloc(symtab_section, text,
			              text->data_offset + 4, R_ARM_JUMP24,
			              sym_index);
			p = section_ptr_add(text, 8);
			write32le(p,   0x4778); /* bx pc */
			write32le(p+2, 0x46c0); /* nop   */
			write32le(p+4, 0xeafffffe); /* b $sym */
		}

		/* Compute final offset */
		x += val - addr;
		if (!to_thumb && is_call)
		{
			blx_bit = 0; /* bl -> blx */
			x = (x + 3) & -4; /* Compute offset from aligned PC */
		}

		/* Check that relocation is possible
		   * offset must not be out of range
		   * if target is to be entered in arm mode:
		     - bit 1 must not set
		     - instruction must be a call (bl) or a jump to PLT */
		if (!to_thumb || x >= 0x1000000 || x < -0x1000000)
			if (to_thumb || (val & 2) || (!is_call && !to_plt))
				tcc_error("can't relocate value at %x,%d",addr, type);

		/* Compute and store final offset */
		s = (x >> 24) & 1;
		i1 = (x >> 23) & 1;
		i2 = (x >> 22) & 1;
		j1 = s ^ (i1 ^ 1);
		j2 = s ^ (i2 ^ 1);
		imm10 = (x >> 12) & 0x3ff;
		imm11 = (x >> 1) & 0x7ff;
		(*(uint16_t *)ptr) = (uint16_t) ((hi & 0xf800) |
		                                 (s << 10) | imm10);
		(*(uint16_t *)(ptr+2)) = (uint16_t) ((lo & 0xc000) |
		                                     (j1 << 13) | blx_bit | (j2 << 11) |
		                                     imm11);
	}
	return;
	case R_ARM_MOVT_ABS:
	case R_ARM_MOVW_ABS_NC:
	{
		int x, imm4, imm12;
		if (type == R_ARM_MOVT_ABS)
			val >>= 16;
		imm12 = val & 0xfff;
		imm4 = (val >> 12) & 0xf;
		x = (imm4 << 16) | imm12;
		if (type == R_ARM_THM_MOVT_ABS)
			*(int *)ptr |= x;
		else
			*(int *)ptr += x;
	}
	return;
	case R_ARM_THM_MOVT_ABS:
	case R_ARM_THM_MOVW_ABS_NC:
	{
		int x, i, imm4, imm3, imm8;
		if (type == R_ARM_THM_MOVT_ABS)
			val >>= 16;
		imm8 = val & 0xff;
		imm3 = (val >> 8) & 0x7;
		i = (val >> 11) & 1;
		imm4 = (val >> 12) & 0xf;
		x = (imm3 << 28) | (imm8 << 16) | (i << 10) | imm4;
		if (type == R_ARM_THM_MOVT_ABS)
			*(int *)ptr |= x;
		else
			*(int *)ptr += x;
	}
	return;
	case R_ARM_PREL31:
	{
		int x;
		x = (*(int *)ptr) & 0x7fffffff;
		(*(int *)ptr) &= 0x80000000;
		x = (x * 2) / 2;
		x += val - addr;
		if((x^(x>>1))&0x40000000)
			tcc_error("can't relocate value at %x,%d",addr, type);
		(*(int *)ptr) |= x & 0x7fffffff;
	}
	case R_ARM_ABS32:
		*(int *)ptr += val;
		return;
	case R_ARM_REL32:
		*(int *)ptr += val - addr;
		return;
	case R_ARM_GOTPC:
		*(int *)ptr += s1->got->sh_addr - addr;
		return;
	case R_ARM_GOTOFF:
		*(int *)ptr += val - s1->got->sh_addr;
		return;
	case R_ARM_GOT32:
		/* we load the got offset */
		*(int *)ptr += get_sym_attr(s1, sym_index, 0)->got_offset;
		return;
	case R_ARM_COPY:
		return;
	case R_ARM_V4BX:
		/* trade Thumb support for ARMv4 support */
		if ((0x0ffffff0 & *(int*)ptr) == 0x012FFF10)
			*(int*)ptr ^= 0xE12FFF10 ^ 0xE1A0F000; /* BX Rm -> MOV PC, Rm */
		return;
	case R_ARM_GLOB_DAT:
	case R_ARM_JUMP_SLOT:
		*(addr_t *)ptr = val;
		return;
	case R_ARM_NONE:
		/* Nothing to do.  Normally used to indicate a dependency
		   on a certain symbol (like for exception handling under EABI).  */
		return;
	case R_ARM_RELATIVE:
#ifdef TCC_TARGET_PE
		add32le(ptr, val - s1->pe_imagebase);
#endif
		/* do nothing */
		return;
	default:
		fprintf(stderr,"FIXME: handle reloc type %x at %x [%p] to %x\n",
		        type, (unsigned)addr, ptr, (unsigned)val);
		return;
	}
}

//END arm-link.c

//START arm-asm.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

static void asm_error(void)
{
	tcc_error("ARM asm not implemented.");
}

/* XXX: make it faster ? */
ST_FUNC void g(int c)
{
	int ind1;
	if (nocode_wanted)
		return;
	ind1 = ind + 1;
	if (ind1 > cur_text_section->data_allocated)
		section_realloc(cur_text_section, ind1);
	cur_text_section->data[ind] = c;
	ind = ind1;
}

ST_FUNC void gen_le16 (int i)
{
	g(i);
	g(i>>8);
}

ST_FUNC void gen_le32 (int i)
{
	gen_le16(i);
	gen_le16(i>>16);
}

ST_FUNC void gen_expr32(ExprValue *pe)
{
	gen_le32(pe->v);
}

ST_FUNC void asm_opcode(TCCState *s1, int opcode)
{
	asm_error();
}

ST_FUNC void subst_asm_operand(CString *add_str, SValue *sv, int modifier)
{
	asm_error();
}

/* generate prolog and epilog code for asm statement */
ST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands,
                          int nb_outputs, int is_output,
                          uint8_t *clobber_regs,
                          int out_reg)
{
}

ST_FUNC void asm_compute_constraints(ASMOperand *operands,
                                     int nb_operands, int nb_outputs,
                                     const uint8_t *clobber_regs,
                                     int *pout_reg)
{
}

ST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str)
{
	asm_error();
}

ST_FUNC int asm_parse_regvar (int t)
{
	asm_error();
	return -1;
}


//END arm-asm.c

#elif defined TCC_TARGET_ARM64

//START arm64-gen.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

ST_DATA const int reg_classes[NB_REGS] =
{
	RC_INT | RC_R(0),
	RC_INT | RC_R(1),
	RC_INT | RC_R(2),
	RC_INT | RC_R(3),
	RC_INT | RC_R(4),
	RC_INT | RC_R(5),
	RC_INT | RC_R(6),
	RC_INT | RC_R(7),
	RC_INT | RC_R(8),
	RC_INT | RC_R(9),
	RC_INT | RC_R(10),
	RC_INT | RC_R(11),
	RC_INT | RC_R(12),
	RC_INT | RC_R(13),
	RC_INT | RC_R(14),
	RC_INT | RC_R(15),
	RC_INT | RC_R(16),
	RC_INT | RC_R(17),
	RC_INT | RC_R(18),
	RC_R30, // not in RC_INT as we make special use of x30
	RC_FLOAT | RC_F(0),
	RC_FLOAT | RC_F(1),
	RC_FLOAT | RC_F(2),
	RC_FLOAT | RC_F(3),
	RC_FLOAT | RC_F(4),
	RC_FLOAT | RC_F(5),
	RC_FLOAT | RC_F(6),
	RC_FLOAT | RC_F(7)
};

#define IS_FREG(x) ((x) >= TREG_F(0))

static uint32_t intr(int r)
{
	assert(TREG_R(0) <= r && r <= TREG_R30);
	return r < TREG_R30 ? r : 30;
}

static uint32_t fltr(int r)
{
	assert(TREG_F(0) <= r && r <= TREG_F(7));
	return r - TREG_F(0);
}

// Add an instruction to text section:
ST_FUNC void o(unsigned int c)
{
	int ind1 = ind + 4;
	if (nocode_wanted)
		return;
	if (ind1 > cur_text_section->data_allocated)
		section_realloc(cur_text_section, ind1);
	write32le(cur_text_section->data + ind, c);
	ind = ind1;
}

static int arm64_encode_bimm64(uint64_t x)
{
	int neg = x & 1;
	int rep, pos, len;

	if (neg)
		x = ~x;
	if (!x)
		return -1;

	if (x >> 2 == (x & (((uint64_t)1 << (64 - 2)) - 1)))
		rep = 2, x &= ((uint64_t)1 << 2) - 1;
	else if (x >> 4 == (x & (((uint64_t)1 << (64 - 4)) - 1)))
		rep = 4, x &= ((uint64_t)1 <<  4) - 1;
	else if (x >> 8 == (x & (((uint64_t)1 << (64 - 8)) - 1)))
		rep = 8, x &= ((uint64_t)1 <<  8) - 1;
	else if (x >> 16 == (x & (((uint64_t)1 << (64 - 16)) - 1)))
		rep = 16, x &= ((uint64_t)1 << 16) - 1;
	else if (x >> 32 == (x & (((uint64_t)1 << (64 - 32)) - 1)))
		rep = 32, x &= ((uint64_t)1 << 32) - 1;
	else
		rep = 64;

	pos = 0;
	if (!(x & (((uint64_t)1 << 32) - 1))) x >>= 32, pos += 32;
	if (!(x & (((uint64_t)1 << 16) - 1))) x >>= 16, pos += 16;
	if (!(x & (((uint64_t)1 <<  8) - 1))) x >>= 8, pos += 8;
	if (!(x & (((uint64_t)1 <<  4) - 1))) x >>= 4, pos += 4;
	if (!(x & (((uint64_t)1 <<  2) - 1))) x >>= 2, pos += 2;
	if (!(x & (((uint64_t)1 <<  1) - 1))) x >>= 1, pos += 1;

	len = 0;
	if (!(~x & (((uint64_t)1 << 32) - 1))) x >>= 32, len += 32;
	if (!(~x & (((uint64_t)1 << 16) - 1))) x >>= 16, len += 16;
	if (!(~x & (((uint64_t)1 << 8) - 1))) x >>= 8, len += 8;
	if (!(~x & (((uint64_t)1 << 4) - 1))) x >>= 4, len += 4;
	if (!(~x & (((uint64_t)1 << 2) - 1))) x >>= 2, len += 2;
	if (!(~x & (((uint64_t)1 << 1) - 1))) x >>= 1, len += 1;

	if (x)
		return -1;
	if (neg)
	{
		pos = (pos + len) & (rep - 1);
		len = rep - len;
	}
	return ((0x1000 & rep << 6) | (((rep - 1) ^ 31) << 1 & 63) |
	        ((rep - pos) & (rep - 1)) << 6 | (len - 1));
}

static uint32_t arm64_movi(int r, uint64_t x)
{
	uint64_t m = 0xffff;
	int e;
	if (!(x & ~m))
		return 0x52800000 | r | x << 5; // movz w(r),#(x)
	if (!(x & ~(m << 16)))
		return 0x52a00000 | r | x >> 11; // movz w(r),#(x >> 16),lsl #16
	if (!(x & ~(m << 32)))
		return 0xd2c00000 | r | x >> 27; // movz x(r),#(x >> 32),lsl #32
	if (!(x & ~(m << 48)))
		return 0xd2e00000 | r | x >> 43; // movz x(r),#(x >> 48),lsl #48
	if ((x & ~m) == m << 16)
		return (0x12800000 | r |
		        (~x << 5 & 0x1fffe0)); // movn w(r),#(~x)
	if ((x & ~(m << 16)) == m)
		return (0x12a00000 | r |
		        (~x >> 11 & 0x1fffe0)); // movn w(r),#(~x >> 16),lsl #16
	if (!~(x | m))
		return (0x92800000 | r |
		        (~x << 5 & 0x1fffe0)); // movn x(r),#(~x)
	if (!~(x | m << 16))
		return (0x92a00000 | r |
		        (~x >> 11 & 0x1fffe0)); // movn x(r),#(~x >> 16),lsl #16
	if (!~(x | m << 32))
		return (0x92c00000 | r |
		        (~x >> 27 & 0x1fffe0)); // movn x(r),#(~x >> 32),lsl #32
	if (!~(x | m << 48))
		return (0x92e00000 | r |
		        (~x >> 43 & 0x1fffe0)); // movn x(r),#(~x >> 32),lsl #32
	if (!(x >> 32) && (e = arm64_encode_bimm64(x | x << 32)) >= 0)
		return 0x320003e0 | r | (uint32_t)e << 10; // movi w(r),#(x)
	if ((e = arm64_encode_bimm64(x)) >= 0)
		return 0xb20003e0 | r | (uint32_t)e << 10; // movi x(r),#(x)
	return 0;
}

static void arm64_movimm(int r, uint64_t x)
{
	uint32_t i;
	if ((i = arm64_movi(r, x)))
		o(i); // a single MOV
	else
	{
		// MOVZ/MOVN and 1-3 MOVKs
		int z = 0, m = 0;
		uint32_t mov1 = 0xd2800000; // movz
		uint64_t x1 = x;
		for (i = 0; i < 64; i += 16)
		{
			z += !(x >> i & 0xffff);
			m += !(~x >> i & 0xffff);
		}
		if (m > z)
		{
			x1 = ~x;
			mov1 = 0x92800000; // movn
		}
		for (i = 0; i < 64; i += 16)
			if (x1 >> i & 0xffff)
			{
				o(mov1 | r | (x1 >> i & 0xffff) << 5 | i << 17);
				// movz/movn x(r),#(*),lsl #(i)
				break;
			}
		for (i += 16; i < 64; i += 16)
			if (x1 >> i & 0xffff)
				o(0xf2800000 | r | (x >> i & 0xffff) << 5 | i << 17);
		// movk x(r),#(*),lsl #(i)
	}
}

// Patch all branches in list pointed to by t to branch to a:
ST_FUNC void gsym_addr(int t_, int a_)
{
	uint32_t t = t_;
	uint32_t a = a_;
	while (t)
	{
		unsigned char *ptr = cur_text_section->data + t;
		uint32_t next = read32le(ptr);
		if (a - t + 0x8000000 >= 0x10000000)
			tcc_error("branch out of range");
		write32le(ptr, (a - t == 4 ? 0xd503201f : // nop
		                0x14000000 | ((a - t) >> 2 & 0x3ffffff))); // b
		t = next;
	}
}

static int arm64_type_size(int t)
{
	switch (t & VT_BTYPE)
	{
	case VT_INT:
		return 2;
	case VT_BYTE:
		return 0;
	case VT_SHORT:
		return 1;
	case VT_PTR:
		return 3;
	case VT_FUNC:
		return 3;
	case VT_FLOAT:
		return 2;
	case VT_DOUBLE:
		return 3;
	case VT_LDOUBLE:
		return 4;
	case VT_BOOL:
		return 0;
	case VT_LLONG:
		return 3;
	}
	assert(0);
	return 0;
}

static void arm64_spoff(int reg, uint64_t off)
{
	uint32_t sub = off >> 63;
	if (sub)
		off = -off;
	if (off < 4096)
		o(0x910003e0 | sub << 30 | reg | off << 10);
	// (add|sub) x(reg),sp,#(off)
	else
	{
		arm64_movimm(30, off); // use x30 for offset
		o(0x8b3e63e0 | sub << 30 | reg); // (add|sub) x(reg),sp,x30
	}
}

static void arm64_ldrx(int sg, int sz_, int dst, int bas, uint64_t off)
{
	uint32_t sz = sz_;
	if (sz >= 2)
		sg = 0;
	if (!(off & ~((uint32_t)0xfff << sz)))
		o(0x39400000 | dst | bas << 5 | off << (10 - sz) |
		  (uint32_t)!!sg << 23 | sz << 30); // ldr(*) x(dst),[x(bas),#(off)]
	else if (off < 256 || -off <= 256)
		o(0x38400000 | dst | bas << 5 | (off & 511) << 12 |
		  (uint32_t)!!sg << 23 | sz << 30); // ldur(*) x(dst),[x(bas),#(off)]
	else
	{
		arm64_movimm(30, off); // use x30 for offset
		o(0x38206800 | dst | bas << 5 | (uint32_t)30 << 16 |
		  (uint32_t)(!!sg + 1) << 22 | sz << 30); // ldr(*) x(dst),[x(bas),x30]
	}
}

static void arm64_ldrv(int sz_, int dst, int bas, uint64_t off)
{
	uint32_t sz = sz_;
	if (!(off & ~((uint32_t)0xfff << sz)))
		o(0x3d400000 | dst | bas << 5 | off << (10 - sz) |
		  (sz & 4) << 21 | (sz & 3) << 30); // ldr (s|d|q)(dst),[x(bas),#(off)]
	else if (off < 256 || -off <= 256)
		o(0x3c400000 | dst | bas << 5 | (off & 511) << 12 |
		  (sz & 4) << 21 | (sz & 3) << 30); // ldur (s|d|q)(dst),[x(bas),#(off)]
	else
	{
		arm64_movimm(30, off); // use x30 for offset
		o(0x3c606800 | dst | bas << 5 | (uint32_t)30 << 16 |
		  sz << 30 | (sz & 4) << 21); // ldr (s|d|q)(dst),[x(bas),x30]
	}
}

static void arm64_ldrs(int reg_, int size)
{
	uint32_t reg = reg_;
	// Use x30 for intermediate value in some cases.
	switch (size)
	{
	default:
		assert(0);
		break;
	case 1:
		arm64_ldrx(0, 0, reg, reg, 0);
		break;
	case 2:
		arm64_ldrx(0, 1, reg, reg, 0);
		break;
	case 3:
		arm64_ldrx(0, 1, 30, reg, 0);
		arm64_ldrx(0, 0, reg, reg, 2);
		o(0x2a0043c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #16
		break;
	case 4:
		arm64_ldrx(0, 2, reg, reg, 0);
		break;
	case 5:
		arm64_ldrx(0, 2, 30, reg, 0);
		arm64_ldrx(0, 0, reg, reg, 4);
		o(0xaa0083c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #32
		break;
	case 6:
		arm64_ldrx(0, 2, 30, reg, 0);
		arm64_ldrx(0, 1, reg, reg, 4);
		o(0xaa0083c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #32
		break;
	case 7:
		arm64_ldrx(0, 2, 30, reg, 0);
		arm64_ldrx(0, 2, reg, reg, 3);
		o(0x53087c00 | reg | reg << 5); // lsr w(reg), w(reg), #8
		o(0xaa0083c0 | reg | reg << 16); // orr x(reg),x30,x(reg),lsl #32
		break;
	case 8:
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 9:
		arm64_ldrx(0, 0, reg + 1, reg, 8);
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 10:
		arm64_ldrx(0, 1, reg + 1, reg, 8);
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 11:
		arm64_ldrx(0, 2, reg + 1, reg, 7);
		o(0x53087c00 | (reg+1) | (reg+1) << 5); // lsr w(reg+1), w(reg+1), #8
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 12:
		arm64_ldrx(0, 2, reg + 1, reg, 8);
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 13:
		arm64_ldrx(0, 3, reg + 1, reg, 5);
		o(0xd358fc00 | (reg+1) | (reg+1) << 5); // lsr x(reg+1), x(reg+1), #24
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 14:
		arm64_ldrx(0, 3, reg + 1, reg, 6);
		o(0xd350fc00 | (reg+1) | (reg+1) << 5); // lsr x(reg+1), x(reg+1), #16
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 15:
		arm64_ldrx(0, 3, reg + 1, reg, 7);
		o(0xd348fc00 | (reg+1) | (reg+1) << 5); // lsr x(reg+1), x(reg+1), #8
		arm64_ldrx(0, 3, reg, reg, 0);
		break;
	case 16:
		o(0xa9400000 | reg | (reg+1) << 10 | reg << 5);
		// ldp x(reg),x(reg+1),[x(reg)]
		break;
	}
}

static void arm64_strx(int sz_, int dst, int bas, uint64_t off)
{
	uint32_t sz = sz_;
	if (!(off & ~((uint32_t)0xfff << sz)))
		o(0x39000000 | dst | bas << 5 | off << (10 - sz) | sz << 30);
	// str(*) x(dst),[x(bas],#(off)]
	else if (off < 256 || -off <= 256)
		o(0x38000000 | dst | bas << 5 | (off & 511) << 12 | sz << 30);
	// stur(*) x(dst),[x(bas],#(off)]
	else
	{
		arm64_movimm(30, off); // use x30 for offset
		o(0x38206800 | dst | bas << 5 | (uint32_t)30 << 16 | sz << 30);
		// str(*) x(dst),[x(bas),x30]
	}
}

static void arm64_strv(int sz_, int dst, int bas, uint64_t off)
{
	uint32_t sz = sz_;
	if (!(off & ~((uint32_t)0xfff << sz)))
		o(0x3d000000 | dst | bas << 5 | off << (10 - sz) |
		  (sz & 4) << 21 | (sz & 3) << 30); // str (s|d|q)(dst),[x(bas),#(off)]
	else if (off < 256 || -off <= 256)
		o(0x3c000000 | dst | bas << 5 | (off & 511) << 12 |
		  (sz & 4) << 21 | (sz & 3) << 30); // stur (s|d|q)(dst),[x(bas),#(off)]
	else
	{
		arm64_movimm(30, off); // use x30 for offset
		o(0x3c206800 | dst | bas << 5 | (uint32_t)30 << 16 |
		  sz << 30 | (sz & 4) << 21); // str (s|d|q)(dst),[x(bas),x30]
	}
}

static void arm64_sym(int r, Sym *sym, unsigned long addend)
{
	// Currently TCC's linker does not generate COPY relocations for
	// STT_OBJECTs when tcc is invoked with "-run". This typically
	// results in "R_AARCH64_ADR_PREL_PG_HI21 relocation failed" when
	// a program refers to stdin. A workaround is to avoid that
	// relocation and use only relocations with unlimited range.
	int avoid_adrp = 1;

	if (avoid_adrp || sym->a.weak)
	{
		// (GCC uses a R_AARCH64_ABS64 in this case.)
		greloca(cur_text_section, sym, ind, R_AARCH64_MOVW_UABS_G0_NC, addend);
		o(0xd2800000 | r); // mov x(rt),#0,lsl #0
		greloca(cur_text_section, sym, ind, R_AARCH64_MOVW_UABS_G1_NC, addend);
		o(0xf2a00000 | r); // movk x(rt),#0,lsl #16
		greloca(cur_text_section, sym, ind, R_AARCH64_MOVW_UABS_G2_NC, addend);
		o(0xf2c00000 | r); // movk x(rt),#0,lsl #32
		greloca(cur_text_section, sym, ind, R_AARCH64_MOVW_UABS_G3, addend);
		o(0xf2e00000 | r); // movk x(rt),#0,lsl #48
	}
	else
	{
		greloca(cur_text_section, sym, ind, R_AARCH64_ADR_PREL_PG_HI21, addend);
		o(0x90000000 | r);
		greloca(cur_text_section, sym, ind, R_AARCH64_ADD_ABS_LO12_NC, addend);
		o(0x91000000 | r | r << 5);
	}
}

static void arm64_load_cmp(int r, SValue *sv);

ST_FUNC void load(int r, SValue *sv)
{
	int svtt = sv->type.t;
	int svr = sv->r;
	int svrv = svr & VT_VALMASK;
	uint64_t svcul = (uint32_t)sv->c.i;
	svcul = svcul >> 31 & 1 ? svcul - ((uint64_t)1 << 32) : svcul;

	if (svr == (VT_LOCAL | VT_LVAL))
	{
		if (IS_FREG(r))
			arm64_ldrv(arm64_type_size(svtt), fltr(r), 29, svcul);
		else
			arm64_ldrx(!(svtt & VT_UNSIGNED), arm64_type_size(svtt),
			           intr(r), 29, svcul);
		return;
	}

	if ((svr & ~VT_VALMASK) == VT_LVAL && svrv < VT_CONST)
	{
		if (IS_FREG(r))
			arm64_ldrv(arm64_type_size(svtt), fltr(r), intr(svrv), 0);
		else
			arm64_ldrx(!(svtt & VT_UNSIGNED), arm64_type_size(svtt),
			           intr(r), intr(svrv), 0);
		return;
	}

	if (svr == (VT_CONST | VT_LVAL | VT_SYM))
	{
		arm64_sym(30, sv->sym, svcul); // use x30 for address
		if (IS_FREG(r))
			arm64_ldrv(arm64_type_size(svtt), fltr(r), 30, 0);
		else
			arm64_ldrx(!(svtt & VT_UNSIGNED), arm64_type_size(svtt),
			           intr(r), 30, 0);
		return;
	}

	if (svr == (VT_CONST | VT_SYM))
	{
		arm64_sym(intr(r), sv->sym, svcul);
		return;
	}

	if (svr == VT_CONST)
	{
		if ((svtt & VT_BTYPE) != VT_VOID)
			arm64_movimm(intr(r), arm64_type_size(svtt) == 3 ?
			             sv->c.i : (uint32_t)svcul);
		return;
	}

	if (svr < VT_CONST)
	{
		if (IS_FREG(r) && IS_FREG(svr))
			if (svtt == VT_LDOUBLE)
				o(0x4ea01c00 | fltr(r) | fltr(svr) << 5);
		// mov v(r).16b,v(svr).16b
			else
				o(0x1e604000 | fltr(r) | fltr(svr) << 5); // fmov d(r),d(svr)
		else if (!IS_FREG(r) && !IS_FREG(svr))
			o(0xaa0003e0 | intr(r) | intr(svr) << 16); // mov x(r),x(svr)
		else
			assert(0);
		return;
	}

	if (svr == VT_LOCAL)
	{
		if (-svcul < 0x1000)
			o(0xd10003a0 | intr(r) | -svcul << 10); // sub x(r),x29,#...
		else
		{
			arm64_movimm(30, -svcul); // use x30 for offset
			o(0xcb0003a0 | intr(r) | (uint32_t)30 << 16); // sub x(r),x29,x30
		}
		return;
	}

	if (svr == VT_JMP || svr == VT_JMPI)
	{
		int t = (svr == VT_JMPI);
		arm64_movimm(intr(r), t);
		o(0x14000002); // b .+8
		gsym(svcul);
		arm64_movimm(intr(r), t ^ 1);
		return;
	}

	if (svr == (VT_LLOCAL | VT_LVAL))
	{
		arm64_ldrx(0, 3, 30, 29, svcul); // use x30 for offset
		if (IS_FREG(r))
			arm64_ldrv(arm64_type_size(svtt), fltr(r), 30, 0);
		else
			arm64_ldrx(!(svtt & VT_UNSIGNED), arm64_type_size(svtt),
			           intr(r), 30, 0);
		return;
	}

	if (svr == VT_CMP)
	{
		arm64_load_cmp(r, sv);
		return;
	}

	printf("load(%x, (%x, %x, %llx))\n", r, svtt, sv->r, (long long)svcul);
	assert(0);
}

ST_FUNC void store(int r, SValue *sv)
{
	int svtt = sv->type.t;
	int svr = sv->r;
	int svrv = svr & VT_VALMASK;
	uint64_t svcul = (uint32_t)sv->c.i;
	svcul = svcul >> 31 & 1 ? svcul - ((uint64_t)1 << 32) : svcul;

	if (svr == (VT_LOCAL | VT_LVAL))
	{
		if (IS_FREG(r))
			arm64_strv(arm64_type_size(svtt), fltr(r), 29, svcul);
		else
			arm64_strx(arm64_type_size(svtt), intr(r), 29, svcul);
		return;
	}

	if ((svr & ~VT_VALMASK) == VT_LVAL && svrv < VT_CONST)
	{
		if (IS_FREG(r))
			arm64_strv(arm64_type_size(svtt), fltr(r), intr(svrv), 0);
		else
			arm64_strx(arm64_type_size(svtt), intr(r), intr(svrv), 0);
		return;
	}

	if (svr == (VT_CONST | VT_LVAL | VT_SYM))
	{
		arm64_sym(30, sv->sym, svcul); // use x30 for address
		if (IS_FREG(r))
			arm64_strv(arm64_type_size(svtt), fltr(r), 30, 0);
		else
			arm64_strx(arm64_type_size(svtt), intr(r), 30, 0);
		return;
	}

	printf("store(%x, (%x, %x, %llx))\n", r, svtt, sv->r, (long long)svcul);
	assert(0);
}

static void arm64_gen_bl_or_b(int b)
{
	if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST && (vtop->r & VT_SYM))
	{
		assert(!b);
		greloca(cur_text_section, vtop->sym, ind, R_AARCH64_CALL26, 0);
		o(0x94000000); // bl .
	}
	else
		o(0xd61f0000 | (uint32_t)!b << 21 | intr(gv(RC_R30)) << 5); // br/blr
}

static int arm64_hfa_aux(CType *type, int *fsize, int num)
{
	if (is_float(type->t))
	{
		int a, n = type_size(type, &a);
		if (num >= 4 || (*fsize && *fsize != n))
			return -1;
		*fsize = n;
		return num + 1;
	}
	else if ((type->t & VT_BTYPE) == VT_STRUCT)
	{
		int is_struct = 0; // rather than union
		Sym *field;
		for (field = type->ref->next; field; field = field->next)
			if (field->c)
			{
				is_struct = 1;
				break;
			}
		if (is_struct)
		{
			int num0 = num;
			for (field = type->ref->next; field; field = field->next)
			{
				if (field->c != (num - num0) * *fsize)
					return -1;
				num = arm64_hfa_aux(&field->type, fsize, num);
				if (num == -1)
					return -1;
			}
			if (type->ref->c != (num - num0) * *fsize)
				return -1;
			return num;
		}
		else   // union
		{
			int num0 = num;
			for (field = type->ref->next; field; field = field->next)
			{
				int num1 = arm64_hfa_aux(&field->type, fsize, num0);
				if (num1 == -1)
					return -1;
				num = num1 < num ? num : num1;
			}
			if (type->ref->c != (num - num0) * *fsize)
				return -1;
			return num;
		}
	}
	else if (type->t & VT_ARRAY)
	{
		int num1;
		if (!type->ref->c)
			return num;
		num1 = arm64_hfa_aux(&type->ref->type, fsize, num);
		if (num1 == -1 || (num1 != num && type->ref->c > 4))
			return -1;
		num1 = num + type->ref->c * (num1 - num);
		if (num1 > 4)
			return -1;
		return num1;
	}
	return -1;
}

static int arm64_hfa(CType *type, int *fsize)
{
	if ((type->t & VT_BTYPE) == VT_STRUCT || (type->t & VT_ARRAY))
	{
		int sz = 0;
		int n = arm64_hfa_aux(type, &sz, 0);
		if (0 < n && n <= 4)
		{
			if (fsize)
				*fsize = sz;
			return n;
		}
	}
	return 0;
}

static unsigned long arm64_pcs_aux(int n, CType **type, unsigned long *a)
{
	int nx = 0; // next integer register
	int nv = 0; // next vector register
	unsigned long ns = 32; // next stack offset
	int i;

	for (i = 0; i < n; i++)
	{
		int hfa = arm64_hfa(type[i], 0);
		int size, align;

		if ((type[i]->t & VT_ARRAY) ||
		        (type[i]->t & VT_BTYPE) == VT_FUNC)
			size = align = 8;
		else
			size = type_size(type[i], &align);

		if (hfa)
			// B.2
			;
		else if (size > 16)
		{
			// B.3: replace with pointer
			if (nx < 8)
				a[i] = nx++ << 1 | 1;
			else
			{
				ns = (ns + 7) & ~7;
				a[i] = ns | 1;
				ns += 8;
			}
			continue;
		}
		else if ((type[i]->t & VT_BTYPE) == VT_STRUCT)
			// B.4
			size = (size + 7) & ~7;

		// C.1
		if (is_float(type[i]->t) && nv < 8)
		{
			a[i] = 16 + (nv++ << 1);
			continue;
		}

		// C.2
		if (hfa && nv + hfa <= 8)
		{
			a[i] = 16 + (nv << 1);
			nv += hfa;
			continue;
		}

		// C.3
		if (hfa)
		{
			nv = 8;
			size = (size + 7) & ~7;
		}

		// C.4
		if (hfa || (type[i]->t & VT_BTYPE) == VT_LDOUBLE)
		{
			ns = (ns + 7) & ~7;
			ns = (ns + align - 1) & -align;
		}

		// C.5
		if ((type[i]->t & VT_BTYPE) == VT_FLOAT)
			size = 8;

		// C.6
		if (hfa || is_float(type[i]->t))
		{
			a[i] = ns;
			ns += size;
			continue;
		}

		// C.7
		if ((type[i]->t & VT_BTYPE) != VT_STRUCT && size <= 8 && nx < 8)
		{
			a[i] = nx++ << 1;
			continue;
		}

		// C.8
		if (align == 16)
			nx = (nx + 1) & ~1;

		// C.9
		if ((type[i]->t & VT_BTYPE) != VT_STRUCT && size == 16 && nx < 7)
		{
			a[i] = nx << 1;
			nx += 2;
			continue;
		}

		// C.10
		if ((type[i]->t & VT_BTYPE) == VT_STRUCT && size <= (8 - nx) * 8)
		{
			a[i] = nx << 1;
			nx += (size + 7) >> 3;
			continue;
		}

		// C.11
		nx = 8;

		// C.12
		ns = (ns + 7) & ~7;
		ns = (ns + align - 1) & -align;

		// C.13
		if ((type[i]->t & VT_BTYPE) == VT_STRUCT)
		{
			a[i] = ns;
			ns += size;
			continue;
		}

		// C.14
		if (size < 8)
			size = 8;

		// C.15
		a[i] = ns;
		ns += size;
	}

	return ns - 32;
}

static unsigned long arm64_pcs(int n, CType **type, unsigned long *a)
{
	unsigned long stack;

	// Return type:
	if ((type[0]->t & VT_BTYPE) == VT_VOID)
		a[0] = -1;
	else
	{
		arm64_pcs_aux(1, type, a);
		assert(a[0] == 0 || a[0] == 1 || a[0] == 16);
	}

	// Argument types:
	stack = arm64_pcs_aux(n, type + 1, a + 1);

	if (0)
	{
		int i;
		for (i = 0; i <= n; i++)
		{
			if (!i)
				printf("arm64_pcs return: ");
			else
				printf("arm64_pcs arg %d: ", i);
			if (a[i] == (unsigned long)-1)
				printf("void\n");
			else if (a[i] == 1 && !i)
				printf("X8 pointer\n");
			else if (a[i] < 16)
				printf("X%lu%s\n", a[i] / 2, a[i] & 1 ? " pointer" : "");
			else if (a[i] < 32)
				printf("V%lu\n", a[i] / 2 - 8);
			else
				printf("stack %lu%s\n",
				       (a[i] - 32) & ~1, a[i] & 1 ? " pointer" : "");
		}
	}

	return stack;
}

ST_FUNC void gfunc_call(int nb_args)
{
	CType *return_type;
	CType **t;
	unsigned long *a, *a1;
	unsigned long stack;
	int i;

	return_type = &vtop[-nb_args].type.ref->type;
	if ((return_type->t & VT_BTYPE) == VT_STRUCT)
		--nb_args;

	t = tcc_malloc((nb_args + 1) * sizeof(*t));
	a = tcc_malloc((nb_args + 1) * sizeof(*a));
	a1 = tcc_malloc((nb_args + 1) * sizeof(*a1));

	t[0] = return_type;
	for (i = 0; i < nb_args; i++)
		t[nb_args - i] = &vtop[-i].type;

	stack = arm64_pcs(nb_args, t, a);

	// Allocate space for structs replaced by pointer:
	for (i = nb_args; i; i--)
		if (a[i] & 1)
		{
			SValue *arg = &vtop[i - nb_args];
			int align, size = type_size(&arg->type, &align);
			assert((arg->type.t & VT_BTYPE) == VT_STRUCT);
			stack = (stack + align - 1) & -align;
			a1[i] = stack;
			stack += size;
		}

	stack = (stack + 15) >> 4 << 4;

	assert(stack < 0x1000);
	if (stack)
		o(0xd10003ff | stack << 10); // sub sp,sp,#(n)

	// First pass: set all values on stack
	for (i = nb_args; i; i--)
	{
		vpushv(vtop - nb_args + i);

		if (a[i] & 1)
		{
			// struct replaced by pointer
			int r = get_reg(RC_INT);
			arm64_spoff(intr(r), a1[i]);
			vset(&vtop->type, r | VT_LVAL, 0);
			vswap();
			vstore();
			if (a[i] >= 32)
			{
				// pointer on stack
				r = get_reg(RC_INT);
				arm64_spoff(intr(r), a1[i]);
				arm64_strx(3, intr(r), 31, (a[i] - 32) >> 1 << 1);
			}
		}
		else if (a[i] >= 32)
		{
			// value on stack
			if ((vtop->type.t & VT_BTYPE) == VT_STRUCT)
			{
				int r = get_reg(RC_INT);
				arm64_spoff(intr(r), a[i] - 32);
				vset(&vtop->type, r | VT_LVAL, 0);
				vswap();
				vstore();
			}
			else if (is_float(vtop->type.t))
			{
				gv(RC_FLOAT);
				arm64_strv(arm64_type_size(vtop[0].type.t),
				           fltr(vtop[0].r), 31, a[i] - 32);
			}
			else
			{
				gv(RC_INT);
				arm64_strx(arm64_type_size(vtop[0].type.t),
				           intr(vtop[0].r), 31, a[i] - 32);
			}
		}

		--vtop;
	}

	// Second pass: assign values to registers
	for (i = nb_args; i; i--, vtop--)
	{
		if (a[i] < 16 && !(a[i] & 1))
		{
			// value in general-purpose registers
			if ((vtop->type.t & VT_BTYPE) == VT_STRUCT)
			{
				int align, size = type_size(&vtop->type, &align);
				vtop->type.t = VT_PTR;
				gaddrof();
				gv(RC_R(a[i] / 2));
				arm64_ldrs(a[i] / 2, size);
			}
			else
				gv(RC_R(a[i] / 2));
		}
		else if (a[i] < 16)
			// struct replaced by pointer in register
			arm64_spoff(a[i] / 2, a1[i]);
		else if (a[i] < 32)
		{
			// value in floating-point registers
			if ((vtop->type.t & VT_BTYPE) == VT_STRUCT)
			{
				uint32_t j, sz, n = arm64_hfa(&vtop->type, &sz);
				vtop->type.t = VT_PTR;
				gaddrof();
				gv(RC_R30);
				for (j = 0; j < n; j++)
					o(0x3d4003c0 |
					  (sz & 16) << 19 | -(sz & 8) << 27 | (sz & 4) << 29 |
					  (a[i] / 2 - 8 + j) |
					  j << 10); // ldr ([sdq])(*),[x30,#(j * sz)]
			}
			else
				gv(RC_F(a[i] / 2 - 8));
		}
	}

	if ((return_type->t & VT_BTYPE) == VT_STRUCT)
	{
		if (a[0] == 1)
		{
			// indirect return: set x8 and discard the stack value
			gv(RC_R(8));
			--vtop;
		}
		else
			// return in registers: keep the address for after the call
			vswap();
	}

	save_regs(0);
	arm64_gen_bl_or_b(0);
	--vtop;
	if (stack)
		o(0x910003ff | stack << 10); // add sp,sp,#(n)

	{
		int rt = return_type->t;
		int bt = rt & VT_BTYPE;
		if (bt == VT_STRUCT && !(a[0] & 1))
		{
			// A struct was returned in registers, so write it out:
			gv(RC_R(8));
			--vtop;
			if (a[0] == 0)
			{
				int align, size = type_size(return_type, &align);
				assert(size <= 16);
				if (size > 8)
					o(0xa9000500); // stp x0,x1,[x8]
				else if (size)
					arm64_strx(size > 4 ? 3 : size > 2 ? 2 : size > 1, 0, 8, 0);

			}
			else if (a[0] == 16)
			{
				uint32_t j, sz, n = arm64_hfa(return_type, &sz);
				for (j = 0; j < n; j++)
					o(0x3d000100 |
					  (sz & 16) << 19 | -(sz & 8) << 27 | (sz & 4) << 29 |
					  (a[i] / 2 - 8 + j) |
					  j << 10); // str ([sdq])(*),[x8,#(j * sz)]
			}
		}
	}

	tcc_free(a1);
	tcc_free(a);
	tcc_free(t);
}

static unsigned long arm64_func_va_list_stack;
static int arm64_func_va_list_gr_offs;
static int arm64_func_va_list_vr_offs;
static int arm64_func_sub_sp_offset;

ST_FUNC void gfunc_prolog(Sym *func_sym)
{
	CType *func_type = &func_sym->type;
	int n = 0;
	int i = 0;
	Sym *sym;
	CType **t;
	unsigned long *a;

	// Why doesn't the caller (gen_function) set func_vt?
	func_vt = func_type->ref->type;
	func_vc = 144; // offset of where x8 is stored

	for (sym = func_type->ref; sym; sym = sym->next)
		++n;
	t = tcc_malloc(n * sizeof(*t));
	a = tcc_malloc(n * sizeof(*a));

	for (sym = func_type->ref; sym; sym = sym->next)
		t[i++] = &sym->type;

	arm64_func_va_list_stack = arm64_pcs(n - 1, t, a);

	o(0xa9b27bfd); // stp x29,x30,[sp,#-224]!
	o(0xad0087e0); // stp q0,q1,[sp,#16]
	o(0xad018fe2); // stp q2,q3,[sp,#48]
	o(0xad0297e4); // stp q4,q5,[sp,#80]
	o(0xad039fe6); // stp q6,q7,[sp,#112]
	o(0xa90923e8); // stp x8,x8,[sp,#144]
	o(0xa90a07e0); // stp x0,x1,[sp,#160]
	o(0xa90b0fe2); // stp x2,x3,[sp,#176]
	o(0xa90c17e4); // stp x4,x5,[sp,#192]
	o(0xa90d1fe6); // stp x6,x7,[sp,#208]

	arm64_func_va_list_gr_offs = -64;
	arm64_func_va_list_vr_offs = -128;

	for (i = 1, sym = func_type->ref->next; sym; i++, sym = sym->next)
	{
		int off = (a[i] < 16 ? 160 + a[i] / 2 * 8 :
		           a[i] < 32 ? 16 + (a[i] - 16) / 2 * 16 :
		           224 + ((a[i] - 32) >> 1 << 1));
		sym_push(sym->v & ~SYM_FIELD, &sym->type,
		         (a[i] & 1 ? VT_LLOCAL : VT_LOCAL) | VT_LVAL,
		         off);

		if (a[i] < 16)
		{
			int align, size = type_size(&sym->type, &align);
			arm64_func_va_list_gr_offs = (a[i] / 2 - 7 +
			                              (!(a[i] & 1) && size > 8)) * 8;
		}
		else if (a[i] < 32)
		{
			uint32_t hfa = arm64_hfa(&sym->type, 0);
			arm64_func_va_list_vr_offs = (a[i] / 2 - 16 +
			                              (hfa ? hfa : 1)) * 16;
		}

		// HFAs of float and double need to be written differently:
		if (16 <= a[i] && a[i] < 32 && (sym->type.t & VT_BTYPE) == VT_STRUCT)
		{
			uint32_t j, sz, k = arm64_hfa(&sym->type, &sz);
			if (sz < 16)
				for (j = 0; j < k; j++)
				{
					o(0x3d0003e0 | -(sz & 8) << 27 | (sz & 4) << 29 |
					  ((a[i] - 16) / 2 + j) | (off / sz + j) << 10);
					// str ([sdq])(*),[sp,#(j * sz)]
				}
		}
	}

	tcc_free(a);
	tcc_free(t);

	o(0x910003fd); // mov x29,sp
	arm64_func_sub_sp_offset = ind;
	// In gfunc_epilog these will be replaced with code to decrement SP:
	o(0xd503201f); // nop
	o(0xd503201f); // nop
	loc = 0;
}

ST_FUNC void gen_va_start(void)
{
	int r;
	--vtop; // we don't need the "arg"
	gaddrof();
	r = intr(gv(RC_INT));

	if (arm64_func_va_list_stack)
	{
		//xx could use add (immediate) here
		arm64_movimm(30, arm64_func_va_list_stack + 224);
		o(0x8b1e03be); // add x30,x29,x30
	}
	else
		o(0x910383be); // add x30,x29,#224
	o(0xf900001e | r << 5); // str x30,[x(r)]

	if (arm64_func_va_list_gr_offs)
	{
		if (arm64_func_va_list_stack)
			o(0x910383be); // add x30,x29,#224
		o(0xf900041e | r << 5); // str x30,[x(r),#8]
	}

	if (arm64_func_va_list_vr_offs)
	{
		o(0x910243be); // add x30,x29,#144
		o(0xf900081e | r << 5); // str x30,[x(r),#16]
	}

	arm64_movimm(30, arm64_func_va_list_gr_offs);
	o(0xb900181e | r << 5); // str w30,[x(r),#24]

	arm64_movimm(30, arm64_func_va_list_vr_offs);
	o(0xb9001c1e | r << 5); // str w30,[x(r),#28]

	--vtop;
}

ST_FUNC void gen_va_arg(CType *t)
{
	int align, size = type_size(t, &align);
	int fsize, hfa = arm64_hfa(t, &fsize);
	uint32_t r0, r1;

	if (is_float(t->t))
	{
		hfa = 1;
		fsize = size;
	}

	gaddrof();
	r0 = intr(gv(RC_INT));
	r1 = get_reg(RC_INT);
	vtop[0].r = r1 | VT_LVAL;
	r1 = intr(r1);

	if (!hfa)
	{
		uint32_t n = size > 16 ? 8 : (size + 7) & -8;
		o(0xb940181e | r0 << 5); // ldr w30,[x(r0),#24] // __gr_offs
		if (align == 16)
		{
			assert(0); // this path untested but needed for __uint128_t
			o(0x11003fde); // add w30,w30,#15
			o(0x121c6fde); // and w30,w30,#-16
		}
		o(0x310003c0 | r1 | n << 10); // adds w(r1),w30,#(n)
		o(0x540000ad); // b.le .+20
		o(0xf9400000 | r1 | r0 << 5); // ldr x(r1),[x(r0)] // __stack
		o(0x9100001e | r1 << 5 | n << 10); // add x30,x(r1),#(n)
		o(0xf900001e | r0 << 5); // str x30,[x(r0)] // __stack
		o(0x14000004); // b .+16
		o(0xb9001800 | r1 | r0 << 5); // str w(r1),[x(r0),#24] // __gr_offs
		o(0xf9400400 | r1 | r0 << 5); // ldr x(r1),[x(r0),#8] // __gr_top
		o(0x8b3ec000 | r1 | r1 << 5); // add x(r1),x(r1),w30,sxtw
		if (size > 16)
			o(0xf9400000 | r1 | r1 << 5); // ldr x(r1),[x(r1)]
	}
	else
	{
		uint32_t rsz = hfa << 4;
		uint32_t ssz = (size + 7) & -(uint32_t)8;
		uint32_t b1, b2;
		o(0xb9401c1e | r0 << 5); // ldr w30,[x(r0),#28] // __vr_offs
		o(0x310003c0 | r1 | rsz << 10); // adds w(r1),w30,#(rsz)
		b1 = ind;
		o(0x5400000d); // b.le lab1
		o(0xf9400000 | r1 | r0 << 5); // ldr x(r1),[x(r0)] // __stack
		if (fsize == 16)
		{
			o(0x91003c00 | r1 | r1 << 5); // add x(r1),x(r1),#15
			o(0x927cec00 | r1 | r1 << 5); // and x(r1),x(r1),#-16
		}
		o(0x9100001e | r1 << 5 | ssz << 10); // add x30,x(r1),#(ssz)
		o(0xf900001e | r0 << 5); // str x30,[x(r0)] // __stack
		b2 = ind;
		o(0x14000000); // b lab2
		// lab1:
		write32le(cur_text_section->data + b1, 0x5400000d | (ind - b1) << 3);
		o(0xb9001c00 | r1 | r0 << 5); // str w(r1),[x(r0),#28] // __vr_offs
		o(0xf9400800 | r1 | r0 << 5); // ldr x(r1),[x(r0),#16] // __vr_top
		if (hfa == 1 || fsize == 16)
			o(0x8b3ec000 | r1 | r1 << 5); // add x(r1),x(r1),w30,sxtw
		else
		{
			// We need to change the layout of this HFA.
			// Get some space on the stack using global variable "loc":
			loc = (loc - size) & -(uint32_t)align;
			o(0x8b3ec000 | 30 | r1 << 5); // add x30,x(r1),w30,sxtw
			arm64_movimm(r1, loc);
			o(0x8b0003a0 | r1 | r1 << 16); // add x(r1),x29,x(r1)
			o(0x4c402bdc | (uint32_t)fsize << 7 |
			  (uint32_t)(hfa == 2) << 15 |
			  (uint32_t)(hfa == 3) << 14); // ld1 {v28.(4s|2d),...},[x30]
			o(0x0d00801c | r1 << 5 | (fsize == 8) << 10 |
			  (uint32_t)(hfa != 2) << 13 |
			  (uint32_t)(hfa != 3) << 21); // st(hfa) {v28.(s|d),...}[0],[x(r1)]
		}
		// lab2:
		write32le(cur_text_section->data + b2, 0x14000000 | (ind - b2) >> 2);
	}
}

ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret,
                       int *align, int *regsize)
{
	return 0;
}

ST_FUNC void gfunc_return(CType *func_type)
{
	CType *t = func_type;
	unsigned long a;

	arm64_pcs(0, &t, &a);
	switch (a)
	{
	case -1:
		break;
	case 0:
		if ((func_type->t & VT_BTYPE) == VT_STRUCT)
		{
			int align, size = type_size(func_type, &align);
			gaddrof();
			gv(RC_R(0));
			arm64_ldrs(0, size);
		}
		else
			gv(RC_IRET);
		break;
	case 1:
	{
		CType type = *func_type;
		mk_pointer(&type);
		vset(&type, VT_LOCAL | VT_LVAL, func_vc);
		indir();
		vswap();
		vstore();
		break;
	}
	case 16:
		if ((func_type->t & VT_BTYPE) == VT_STRUCT)
		{
			uint32_t j, sz, n = arm64_hfa(&vtop->type, &sz);
			gaddrof();
			gv(RC_R(0));
			for (j = 0; j < n; j++)
				o(0x3d400000 |
				  (sz & 16) << 19 | -(sz & 8) << 27 | (sz & 4) << 29 |
				  j | j << 10); // ldr ([sdq])(*),[x0,#(j * sz)]
		}
		else
			gv(RC_FRET);
		break;
	default:
		assert(0);
	}
	vtop--;
}

ST_FUNC void gfunc_epilog(void)
{
	if (loc)
	{
		// Insert instructions to subtract size of stack frame from SP.
		unsigned char *ptr = cur_text_section->data + arm64_func_sub_sp_offset;
		uint64_t diff = (-loc + 15) & ~15;
		if (!(diff >> 24))
		{
			if (diff & 0xfff) // sub sp,sp,#(diff & 0xfff)
				write32le(ptr, 0xd10003ff | (diff & 0xfff) << 10);
			if (diff >> 12) // sub sp,sp,#(diff >> 12),lsl #12
				write32le(ptr + 4, 0xd14003ff | (diff >> 12) << 10);
		}
		else
		{
			// In this case we may subtract more than necessary,
			// but always less than 17/16 of what we were aiming for.
			int i = 0;
			int j = 0;
			while (diff >> 20)
			{
				diff = (diff + 0xffff) >> 16;
				++i;
			}
			while (diff >> 16)
			{
				diff = (diff + 1) >> 1;
				++j;
			}
			write32le(ptr, 0xd2800010 | diff << 5 | i << 21);
			// mov x16,#(diff),lsl #(16 * i)
			write32le(ptr + 4, 0xcb3063ff | j << 10);
			// sub sp,sp,x16,lsl #(j)
		}
	}
	o(0x910003bf); // mov sp,x29
	o(0xa8ce7bfd); // ldp x29,x30,[sp],#224

	o(0xd65f03c0); // ret
}

ST_FUNC void gen_fill_nops(int bytes)
{
	if ((bytes & 3))
		tcc_error("alignment of code section not multiple of 4");
	while (bytes > 0)
	{
		o(0xd503201f); // nop
		bytes -= 4;
	}
}

// Generate forward branch to label:
ST_FUNC int gjmp(int t)
{
	int r = ind;
	if (nocode_wanted)
		return t;
	o(t);
	return r;
}

// Generate branch to known address:
ST_FUNC void gjmp_addr(int a)
{
	assert(a - ind + 0x8000000 < 0x10000000);
	o(0x14000000 | ((a - ind) >> 2 & 0x3ffffff));
}

ST_FUNC int gjmp_append(int n, int t)
{
	void *p;
	/* insert vtop->c jump list in t */
	if (n)
	{
		uint32_t n1 = n, n2;
		while ((n2 = read32le(p = cur_text_section->data + n1)))
			n1 = n2;
		write32le(p, t);
		t = n;
	}
	return t;
}

void arm64_vset_VT_CMP(int op)
{
	if (op >= TOK_ULT && op <= TOK_GT)
	{
		vtop->cmp_r = vtop->r;
		vset_VT_CMP(0x80);
	}
}

static void arm64_gen_opil(int op, uint32_t l);

static void arm64_load_cmp(int r, SValue *sv)
{
	sv->r = sv->cmp_r;
	if (sv->c.i & 1)
	{
		vpushi(1);
		arm64_gen_opil('^', 0);
	}
	if (r != sv->r)
	{
		load(r, sv);
		sv->r = r;
	}
}

ST_FUNC int gjmp_cond(int op, int t)
{
	int bt = vtop->type.t & VT_BTYPE;

	int inv = op & 1;
	vtop->r = vtop->cmp_r;

	if (bt == VT_LDOUBLE)
	{
		uint32_t a, b, f = fltr(gv(RC_FLOAT));
		a = get_reg(RC_INT);
		vpushi(0);
		vtop[0].r = a;
		b = get_reg(RC_INT);
		a = intr(a);
		b = intr(b);
		o(0x4e083c00 | a | f << 5); // mov x(a),v(f).d[0]
		o(0x4e183c00 | b | f << 5); // mov x(b),v(f).d[1]
		o(0xaa000400 | a | a << 5 | b << 16); // orr x(a),x(a),x(b),lsl #1
		o(0xb4000040 | a | !!inv << 24); // cbz/cbnz x(a),.+8
		--vtop;
	}
	else if (bt == VT_FLOAT || bt == VT_DOUBLE)
	{
		uint32_t a = fltr(gv(RC_FLOAT));
		o(0x1e202008 | a << 5 | (bt != VT_FLOAT) << 22); // fcmp
		o(0x54000040 | !!inv); // b.eq/b.ne .+8
	}
	else
	{
		uint32_t ll = (bt == VT_PTR || bt == VT_LLONG);
		uint32_t a = intr(gv(RC_INT));
		o(0x34000040 | a | !!inv << 24 | ll << 31); // cbz/cbnz wA,.+8
	}
	return gjmp(t);
}

static int arm64_iconst(uint64_t *val, SValue *sv)
{
	if ((sv->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
		return 0;
	if (val)
	{
		int t = sv->type.t;
		int bt = t & VT_BTYPE;
		*val = ((bt == VT_LLONG || bt == VT_PTR) ? sv->c.i :
		        (uint32_t)sv->c.i |
		        (t & VT_UNSIGNED ? 0 : -(sv->c.i & 0x80000000)));
	}
	return 1;
}

static int arm64_gen_opic(int op, uint32_t l, int rev, uint64_t val,
                          uint32_t x, uint32_t a)
{
	if (op == '-' && !rev)
	{
		val = -val;
		op = '+';
	}
	val = l ? val : (uint32_t)val;

	switch (op)
	{

	case '+':
	{
		uint32_t s = l ? val >> 63 : val >> 31;
		val = s ? -val : val;
		val = l ? val : (uint32_t)val;
		if (!(val & ~(uint64_t)0xfff))
			o(0x11000000 | l << 31 | s << 30 | x | a << 5 | val << 10);
		else if (!(val & ~(uint64_t)0xfff000))
			o(0x11400000 | l << 31 | s << 30 | x | a << 5 | val >> 12 << 10);
		else
		{
			arm64_movimm(30, val); // use x30
			o(0x0b1e0000 | l << 31 | s << 30 | x | a << 5);
		}
		return 1;
	}

	case '-':
		if (!val)
			o(0x4b0003e0 | l << 31 | x | a << 16); // neg
		else if (val == (l ? (uint64_t)-1 : (uint32_t)-1))
			o(0x2a2003e0 | l << 31 | x | a << 16); // mvn
		else
		{
			arm64_movimm(30, val); // use x30
			o(0x4b0003c0 | l << 31 | x | a << 16); // sub
		}
		return 1;

	case '^':
		if (val == -1 || (val == 0xffffffff && !l))
		{
			o(0x2a2003e0 | l << 31 | x | a << 16); // mvn
			return 1;
		}
	// fall through
	case '&':
	case '|':
	{
		int e = arm64_encode_bimm64(l ? val : val | val << 32);
		if (e < 0)
			return 0;
		o((op == '&' ? 0x12000000 :
		   op == '|' ? 0x32000000 : 0x52000000) |
		  l << 31 | x | a << 5 | (uint32_t)e << 10);
		return 1;
	}

	case TOK_SAR:
	case TOK_SHL:
	case TOK_SHR:
	{
		uint32_t n = 32 << l;
		val = val & (n - 1);
		if (rev)
			return 0;
		if (!val)
			assert(0);
		else if (op == TOK_SHL)
			o(0x53000000 | l << 31 | l << 22 | x | a << 5 |
			  (n - val) << 16 | (n - 1 - val) << 10); // lsl
		else
			o(0x13000000 | (op == TOK_SHR) << 30 | l << 31 | l << 22 |
			  x | a << 5 | val << 16 | (n - 1) << 10); // lsr/asr
		return 1;
	}

	}
	return 0;
}

static void arm64_gen_opil(int op, uint32_t l)
{
	uint32_t x, a, b;

	// Special treatment for operations with a constant operand:
	{
		uint64_t val;
		int rev = 1;

		if (arm64_iconst(0, &vtop[0]))
		{
			vswap();
			rev = 0;
		}
		if (arm64_iconst(&val, &vtop[-1]))
		{
			gv(RC_INT);
			a = intr(vtop[0].r);
			--vtop;
			x = get_reg(RC_INT);
			++vtop;
			if (arm64_gen_opic(op, l, rev, val, intr(x), a))
			{
				vtop[0].r = x;
				vswap();
				--vtop;
				return;
			}
		}
		if (!rev)
			vswap();
	}

	gv2(RC_INT, RC_INT);
	assert(vtop[-1].r < VT_CONST && vtop[0].r < VT_CONST);
	a = intr(vtop[-1].r);
	b = intr(vtop[0].r);
	vtop -= 2;
	x = get_reg(RC_INT);
	++vtop;
	vtop[0].r = x;
	x = intr(x);

	switch (op)
	{
	case '%':
		// Use x30 for quotient:
		o(0x1ac00c00 | l << 31 | 30 | a << 5 | b << 16); // sdiv
		o(0x1b008000 | l << 31 | x | (uint32_t)30 << 5 |
		  b << 16 | a << 10); // msub
		break;
	case '&':
		o(0x0a000000 | l << 31 | x | a << 5 | b << 16); // and
		break;
	case '*':
		o(0x1b007c00 | l << 31 | x | a << 5 | b << 16); // mul
		break;
	case '+':
		o(0x0b000000 | l << 31 | x | a << 5 | b << 16); // add
		break;
	case '-':
		o(0x4b000000 | l << 31 | x | a << 5 | b << 16); // sub
		break;
	case '/':
		o(0x1ac00c00 | l << 31 | x | a << 5 | b << 16); // sdiv
		break;
	case '^':
		o(0x4a000000 | l << 31 | x | a << 5 | b << 16); // eor
		break;
	case '|':
		o(0x2a000000 | l << 31 | x | a << 5 | b << 16); // orr
		break;
	case TOK_EQ:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9f17e0 | x); // cset wA,eq
		break;
	case TOK_GE:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9fb7e0 | x); // cset wA,ge
		break;
	case TOK_GT:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9fd7e0 | x); // cset wA,gt
		break;
	case TOK_LE:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9fc7e0 | x); // cset wA,le
		break;
	case TOK_LT:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9fa7e0 | x); // cset wA,lt
		break;
	case TOK_NE:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9f07e0 | x); // cset wA,ne
		break;
	case TOK_SAR:
		o(0x1ac02800 | l << 31 | x | a << 5 | b << 16); // asr
		break;
	case TOK_SHL:
		o(0x1ac02000 | l << 31 | x | a << 5 | b << 16); // lsl
		break;
	case TOK_SHR:
		o(0x1ac02400 | l << 31 | x | a << 5 | b << 16); // lsr
		break;
	case TOK_UDIV:
	case TOK_PDIV:
		o(0x1ac00800 | l << 31 | x | a << 5 | b << 16); // udiv
		break;
	case TOK_UGE:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9f37e0 | x); // cset wA,cs
		break;
	case TOK_UGT:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9f97e0 | x); // cset wA,hi
		break;
	case TOK_ULT:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9f27e0 | x); // cset wA,cc
		break;
	case TOK_ULE:
		o(0x6b00001f | l << 31 | a << 5 | b << 16); // cmp
		o(0x1a9f87e0 | x); // cset wA,ls
		break;
	case TOK_UMOD:
		// Use x30 for quotient:
		o(0x1ac00800 | l << 31 | 30 | a << 5 | b << 16); // udiv
		o(0x1b008000 | l << 31 | x | (uint32_t)30 << 5 |
		  b << 16 | a << 10); // msub
		break;
	default:
		assert(0);
	}
}

ST_FUNC void gen_opi(int op)
{
	arm64_gen_opil(op, 0);
	arm64_vset_VT_CMP(op);
}

ST_FUNC void gen_opl(int op)
{
	arm64_gen_opil(op, 1);
	arm64_vset_VT_CMP(op);
}

ST_FUNC void gen_opf(int op)
{
	uint32_t x, a, b, dbl;

	if (vtop[0].type.t == VT_LDOUBLE)
	{
		CType type = vtop[0].type;
		int func = 0;
		int cond = -1;
		switch (op)
		{
		case '*':
			func = TOK___multf3;
			break;
		case '+':
			func = TOK___addtf3;
			break;
		case '-':
			func = TOK___subtf3;
			break;
		case '/':
			func = TOK___divtf3;
			break;
		case TOK_EQ:
			func = TOK___eqtf2;
			cond = 1;
			break;
		case TOK_NE:
			func = TOK___netf2;
			cond = 0;
			break;
		case TOK_LT:
			func = TOK___lttf2;
			cond = 10;
			break;
		case TOK_GE:
			func = TOK___getf2;
			cond = 11;
			break;
		case TOK_LE:
			func = TOK___letf2;
			cond = 12;
			break;
		case TOK_GT:
			func = TOK___gttf2;
			cond = 13;
			break;
		default:
			assert(0);
			break;
		}
		vpush_global_sym(&func_old_type, func);
		vrott(3);
		gfunc_call(2);
		vpushi(0);
		vtop->r = cond < 0 ? REG_FRET : REG_IRET;
		if (cond < 0)
			vtop->type = type;
		else
		{
			o(0x7100001f); // cmp w0,#0
			o(0x1a9f07e0 | (uint32_t)cond << 12); // cset w0,(cond)
		}
		return;
	}

	dbl = vtop[0].type.t != VT_FLOAT;
	gv2(RC_FLOAT, RC_FLOAT);
	assert(vtop[-1].r < VT_CONST && vtop[0].r < VT_CONST);
	a = fltr(vtop[-1].r);
	b = fltr(vtop[0].r);
	vtop -= 2;
	switch (op)
	{
	case TOK_EQ:
	case TOK_NE:
	case TOK_LT:
	case TOK_GE:
	case TOK_LE:
	case TOK_GT:
		x = get_reg(RC_INT);
		++vtop;
		vtop[0].r = x;
		x = intr(x);
		break;
	default:
		x = get_reg(RC_FLOAT);
		++vtop;
		vtop[0].r = x;
		x = fltr(x);
		break;
	}

	switch (op)
	{
	case '*':
		o(0x1e200800 | dbl << 22 | x | a << 5 | b << 16); // fmul
		break;
	case '+':
		o(0x1e202800 | dbl << 22 | x | a << 5 | b << 16); // fadd
		break;
	case '-':
		o(0x1e203800 | dbl << 22 | x | a << 5 | b << 16); // fsub
		break;
	case '/':
		o(0x1e201800 | dbl << 22 | x | a << 5 | b << 16); // fdiv
		break;
	case TOK_EQ:
		o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp
		o(0x1a9f17e0 | x); // cset w(x),eq
		break;
	case TOK_GE:
		o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp
		o(0x1a9fb7e0 | x); // cset w(x),ge
		break;
	case TOK_GT:
		o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp
		o(0x1a9fd7e0 | x); // cset w(x),gt
		break;
	case TOK_LE:
		o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp
		o(0x1a9f87e0 | x); // cset w(x),ls
		break;
	case TOK_LT:
		o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp
		o(0x1a9f57e0 | x); // cset w(x),mi
		break;
	case TOK_NE:
		o(0x1e202000 | dbl << 22 | a << 5 | b << 16); // fcmp
		o(0x1a9f07e0 | x); // cset w(x),ne
		break;
	default:
		assert(0);
	}
	arm64_vset_VT_CMP(op);
}

// Generate sign extension from 32 to 64 bits:
ST_FUNC void gen_cvt_sxtw(void)
{
	uint32_t r = intr(gv(RC_INT));
	o(0x93407c00 | r | r << 5); // sxtw x(r),w(r)
}

/* char/short to int conversion */
ST_FUNC void gen_cvt_csti(int t)
{
	int r = intr(gv(RC_INT));
	o(0x13001c00
	  | ((t & VT_BTYPE) == VT_SHORT) << 13
	  | (uint32_t)!!(t & VT_UNSIGNED) << 30
	  | r | r << 5); // [su]xt[bh] w(r),w(r)
}

ST_FUNC void gen_cvt_itof(int t)
{
	if (t == VT_LDOUBLE)
	{
		int f = vtop->type.t;
		int func = (f & VT_BTYPE) == VT_LLONG ?
		           (f & VT_UNSIGNED ? TOK___floatunditf : TOK___floatditf) :
		           (f & VT_UNSIGNED ? TOK___floatunsitf : TOK___floatsitf);
		vpush_global_sym(&func_old_type, func);
		vrott(2);
		gfunc_call(1);
		vpushi(0);
		vtop->type.t = t;
		vtop->r = REG_FRET;
		return;
	}
	else
	{
		int d, n = intr(gv(RC_INT));
		int s = !(vtop->type.t & VT_UNSIGNED);
		uint32_t l = ((vtop->type.t & VT_BTYPE) == VT_LLONG);
		--vtop;
		d = get_reg(RC_FLOAT);
		++vtop;
		vtop[0].r = d;
		o(0x1e220000 | (uint32_t)!s << 16 |
		  (uint32_t)(t != VT_FLOAT) << 22 | fltr(d) |
		  l << 31 | n << 5); // [us]cvtf [sd](d),[wx](n)
	}
}

ST_FUNC void gen_cvt_ftoi(int t)
{
	if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE)
	{
		int func = (t & VT_BTYPE) == VT_LLONG ?
		           (t & VT_UNSIGNED ? TOK___fixunstfdi : TOK___fixtfdi) :
		           (t & VT_UNSIGNED ? TOK___fixunstfsi : TOK___fixtfsi);
		vpush_global_sym(&func_old_type, func);
		vrott(2);
		gfunc_call(1);
		vpushi(0);
		vtop->type.t = t;
		vtop->r = REG_IRET;
		return;
	}
	else
	{
		int d, n = fltr(gv(RC_FLOAT));
		uint32_t l = ((vtop->type.t & VT_BTYPE) != VT_FLOAT);
		--vtop;
		d = get_reg(RC_INT);
		++vtop;
		vtop[0].r = d;
		o(0x1e380000 |
		  (uint32_t)!!(t & VT_UNSIGNED) << 16 |
		  (uint32_t)((t & VT_BTYPE) == VT_LLONG) << 31 | intr(d) |
		  l << 22 | n << 5); // fcvtz[su] [wx](d),[sd](n)
	}
}

ST_FUNC void gen_cvt_ftof(int t)
{
	int f = vtop[0].type.t & VT_BTYPE;
	assert(t == VT_FLOAT || t == VT_DOUBLE || t == VT_LDOUBLE);
	assert(f == VT_FLOAT || f == VT_DOUBLE || f == VT_LDOUBLE);
	if (t == f)
		return;

	if (t == VT_LDOUBLE || f == VT_LDOUBLE)
	{
		int func = (t == VT_LDOUBLE) ?
		           (f == VT_FLOAT ? TOK___extendsftf2 : TOK___extenddftf2) :
		           (t == VT_FLOAT ? TOK___trunctfsf2 : TOK___trunctfdf2);
		vpush_global_sym(&func_old_type, func);
		vrott(2);
		gfunc_call(1);
		vpushi(0);
		vtop->type.t = t;
		vtop->r = REG_FRET;
	}
	else
	{
		int x, a;
		gv(RC_FLOAT);
		assert(vtop[0].r < VT_CONST);
		a = fltr(vtop[0].r);
		--vtop;
		x = get_reg(RC_FLOAT);
		++vtop;
		vtop[0].r = x;
		x = fltr(x);

		if (f == VT_FLOAT)
			o(0x1e22c000 | x | a << 5); // fcvt d(x),s(a)
		else
			o(0x1e624000 | x | a << 5); // fcvt s(x),d(a)
	}
}

ST_FUNC void ggoto(void)
{
	arm64_gen_bl_or_b(1);
	--vtop;
}

ST_FUNC void gen_clear_cache(void)
{
	uint32_t beg, end, dsz, isz, p, lab1, b1;
	gv2(RC_INT, RC_INT);
	vpushi(0);
	vtop->r = get_reg(RC_INT);
	vpushi(0);
	vtop->r = get_reg(RC_INT);
	vpushi(0);
	vtop->r = get_reg(RC_INT);
	beg = intr(vtop[-4].r); // x0
	end = intr(vtop[-3].r); // x1
	dsz = intr(vtop[-2].r); // x2
	isz = intr(vtop[-1].r); // x3
	p = intr(vtop[0].r);    // x4
	vtop -= 5;

	o(0xd53b0020 | isz); // mrs x(isz),ctr_el0
	o(0x52800080 | p); // mov w(p),#4
	o(0x53104c00 | dsz | isz << 5); // ubfx w(dsz),w(isz),#16,#4
	o(0x1ac02000 | dsz | p << 5 | dsz << 16); // lsl w(dsz),w(p),w(dsz)
	o(0x12000c00 | isz | isz << 5); // and w(isz),w(isz),#15
	o(0x1ac02000 | isz | p << 5 | isz << 16); // lsl w(isz),w(p),w(isz)
	o(0x51000400 | p | dsz << 5); // sub w(p),w(dsz),#1
	o(0x8a240004 | p | beg << 5 | p << 16); // bic x(p),x(beg),x(p)
	b1 = ind;
	o(0x14000000); // b
	lab1 = ind;
	o(0xd50b7b20 | p); // dc cvau,x(p)
	o(0x8b000000 | p | p << 5 | dsz << 16); // add x(p),x(p),x(dsz)
	write32le(cur_text_section->data + b1, 0x14000000 | (ind - b1) >> 2);
	o(0xeb00001f | p << 5 | end << 16); // cmp x(p),x(end)
	o(0x54ffffa3 | ((lab1 - ind) << 3 & 0xffffe0)); // b.cc lab1
	o(0xd5033b9f); // dsb ish
	o(0x51000400 | p | isz << 5); // sub w(p),w(isz),#1
	o(0x8a240004 | p | beg << 5 | p << 16); // bic x(p),x(beg),x(p)
	b1 = ind;
	o(0x14000000); // b
	lab1 = ind;
	o(0xd50b7520 | p); // ic ivau,x(p)
	o(0x8b000000 | p | p << 5 | isz << 16); // add x(p),x(p),x(isz)
	write32le(cur_text_section->data + b1, 0x14000000 | (ind - b1) >> 2);
	o(0xeb00001f | p << 5 | end << 16); // cmp x(p),x(end)
	o(0x54ffffa3 | ((lab1 - ind) << 3 & 0xffffe0)); // b.cc lab1
	o(0xd5033b9f); // dsb ish
	o(0xd5033fdf); // isb
}

ST_FUNC void gen_vla_sp_save(int addr)
{
	uint32_t r = intr(get_reg(RC_INT));
	o(0x910003e0 | r); // mov x(r),sp
	arm64_strx(3, r, 29, addr);
}

ST_FUNC void gen_vla_sp_restore(int addr)
{
	// Use x30 because this function can be called when there
	// is a live return value in x0 but there is nothing on
	// the value stack to prevent get_reg from returning x0.
	uint32_t r = 30;
	arm64_ldrx(0, 3, r, 29, addr);
	o(0x9100001f | r << 5); // mov sp,x(r)
}

ST_FUNC void gen_vla_alloc(CType *type, int align)
{
	uint32_t r = intr(gv(RC_INT));
	o(0x91003c00 | r | r << 5); // add x(r),x(r),#15
	o(0x927cec00 | r | r << 5); // bic x(r),x(r),#15
	o(0xcb2063ff | r << 16); // sub sp,sp,x(r)
	vpop();
}

/* end of A64 code generator */
//END arm64-gen.c

//START arm64-link.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE
# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

/* Returns 1 for a code relocation, 0 for a data relocation. For unknown
   relocations, returns -1. */
int code_reloc (int reloc_type)
{
	switch (reloc_type)
	{
	case R_AARCH64_ABS32:
	case R_AARCH64_ABS64:
	case R_AARCH64_PREL32:
	case R_AARCH64_MOVW_UABS_G0_NC:
	case R_AARCH64_MOVW_UABS_G1_NC:
	case R_AARCH64_MOVW_UABS_G2_NC:
	case R_AARCH64_MOVW_UABS_G3:
	case R_AARCH64_ADR_PREL_PG_HI21:
	case R_AARCH64_ADD_ABS_LO12_NC:
	case R_AARCH64_ADR_GOT_PAGE:
	case R_AARCH64_LD64_GOT_LO12_NC:
	case R_AARCH64_GLOB_DAT:
	case R_AARCH64_COPY:
		return 0;

	case R_AARCH64_JUMP26:
	case R_AARCH64_CALL26:
	case R_AARCH64_JUMP_SLOT:
		return 1;
	}
	return -1;
}

/* Returns an enumerator to describe whether and when the relocation needs a
   GOT and/or PLT entry to be created. See tcc.h for a description of the
   different values. */
int gotplt_entry_type (int reloc_type)
{
	switch (reloc_type)
	{
	case R_AARCH64_PREL32:
	case R_AARCH64_MOVW_UABS_G0_NC:
	case R_AARCH64_MOVW_UABS_G1_NC:
	case R_AARCH64_MOVW_UABS_G2_NC:
	case R_AARCH64_MOVW_UABS_G3:
	case R_AARCH64_ADR_PREL_PG_HI21:
	case R_AARCH64_ADD_ABS_LO12_NC:
	case R_AARCH64_GLOB_DAT:
	case R_AARCH64_JUMP_SLOT:
	case R_AARCH64_COPY:
		return NO_GOTPLT_ENTRY;

	case R_AARCH64_ABS32:
	case R_AARCH64_ABS64:
	case R_AARCH64_JUMP26:
	case R_AARCH64_CALL26:
		return AUTO_GOTPLT_ENTRY;

	case R_AARCH64_ADR_GOT_PAGE:
	case R_AARCH64_LD64_GOT_LO12_NC:
		return ALWAYS_GOTPLT_ENTRY;
	}
	return -1;
}

ST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)
{
	Section *plt = s1->plt;
	uint8_t *p;
	unsigned plt_offset;

	if (s1->output_type == TCC_OUTPUT_DLL)
		tcc_error("DLLs unimplemented!");

	if (plt->data_offset == 0)
	{
		section_ptr_add(plt, 32);
	}
	plt_offset = plt->data_offset;

	p = section_ptr_add(plt, 16);
	write32le(p, got_offset);
	write32le(p + 4, (uint64_t) got_offset >> 32);
	return plt_offset;
}

/* relocate the PLT: compute addresses and offsets in the PLT now that final
   address for PLT and GOT are known (see fill_program_header) */
ST_FUNC void relocate_plt(TCCState *s1)
{
	uint8_t *p, *p_end;

	if (!s1->plt)
		return;

	p = s1->plt->data;
	p_end = p + s1->plt->data_offset;

	if (p < p_end)
	{
		uint64_t plt = s1->plt->sh_addr;
		uint64_t got = s1->got->sh_addr;
		uint64_t off = (got >> 12) - (plt >> 12);
		if ((off + ((uint32_t)1 << 20)) >> 21)
			tcc_error("Failed relocating PLT (off=0x%lx, got=0x%lx, plt=0x%lx)", off, got, plt);
		write32le(p, 0xa9bf7bf0); // stp x16,x30,[sp,#-16]!
		write32le(p + 4, (0x90000010 | // adrp x16,...
		                  (off & 0x1ffffc) << 3 | (off & 3) << 29));
		write32le(p + 8, (0xf9400211 | // ldr x17,[x16,#...]
		                  (got & 0xff8) << 7));
		write32le(p + 12, (0x91000210 | // add x16,x16,#...
		                   (got & 0xfff) << 10));
		write32le(p + 16, 0xd61f0220); // br x17
		write32le(p + 20, 0xd503201f); // nop
		write32le(p + 24, 0xd503201f); // nop
		write32le(p + 28, 0xd503201f); // nop
		p += 32;
		while (p < p_end)
		{
			uint64_t pc = plt + (p - s1->plt->data);
			uint64_t addr = got + read64le(p);
			uint64_t off = (addr >> 12) - (pc >> 12);
			if ((off + ((uint32_t)1 << 20)) >> 21)
				tcc_error("Failed relocating PLT (off=0x%lx, addr=0x%lx, pc=0x%lx)", off, addr, pc);
			write32le(p, (0x90000010 | // adrp x16,...
			              (off & 0x1ffffc) << 3 | (off & 3) << 29));
			write32le(p + 4, (0xf9400211 | // ldr x17,[x16,#...]
			                  (addr & 0xff8) << 7));
			write32le(p + 8, (0x91000210 | // add x16,x16,#...
			                  (addr & 0xfff) << 10));
			write32le(p + 12, 0xd61f0220); // br x17
			p += 16;
		}
	}
}

void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)
{
	int sym_index = ELFW(R_SYM)(rel->r_info);
#ifdef DEBUG_RELOC
	ElfW(Sym) *sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];
#endif

	switch(type)
	{
	case R_AARCH64_ABS64:
		write64le(ptr, val);
		return;
	case R_AARCH64_ABS32:
		write32le(ptr, val);
		return;
	case R_AARCH64_PREL32:
		write32le(ptr, val - addr);
		return;
	case R_AARCH64_MOVW_UABS_G0_NC:
		write32le(ptr, ((read32le(ptr) & 0xffe0001f) |
		                (val & 0xffff) << 5));
		return;
	case R_AARCH64_MOVW_UABS_G1_NC:
		write32le(ptr, ((read32le(ptr) & 0xffe0001f) |
		                (val >> 16 & 0xffff) << 5));
		return;
	case R_AARCH64_MOVW_UABS_G2_NC:
		write32le(ptr, ((read32le(ptr) & 0xffe0001f) |
		                (val >> 32 & 0xffff) << 5));
		return;
	case R_AARCH64_MOVW_UABS_G3:
		write32le(ptr, ((read32le(ptr) & 0xffe0001f) |
		                (val >> 48 & 0xffff) << 5));
		return;
	case R_AARCH64_ADR_PREL_PG_HI21:
	{
		uint64_t off = (val >> 12) - (addr >> 12);
		if ((off + ((uint64_t)1 << 20)) >> 21)
			tcc_error("R_AARCH64_ADR_PREL_PG_HI21 relocation failed");
		write32le(ptr, ((read32le(ptr) & 0x9f00001f) |
		                (off & 0x1ffffc) << 3 | (off & 3) << 29));
		return;
	}
	case R_AARCH64_ADD_ABS_LO12_NC:
		write32le(ptr, ((read32le(ptr) & 0xffc003ff) |
		                (val & 0xfff) << 10));
		return;
	case R_AARCH64_JUMP26:
	case R_AARCH64_CALL26:
#ifdef DEBUG_RELOC
		printf ("reloc %d @ 0x%lx: val=0x%lx name=%s\n", type, addr, val,
		        (char *) symtab_section->link->data + sym->st_name);
#endif
		if (((val - addr) + ((uint64_t)1 << 27)) & ~(uint64_t)0xffffffc)
			tcc_error("R_AARCH64_(JUMP|CALL)26 relocation failed"
			          " (val=%lx, addr=%lx)", val, addr);
		write32le(ptr, (0x14000000 |
		                (uint32_t)(type == R_AARCH64_CALL26) << 31 |
		                ((val - addr) >> 2 & 0x3ffffff)));
		return;
	case R_AARCH64_ADR_GOT_PAGE:
	{
		uint64_t off =
		    (((s1->got->sh_addr +
		       get_sym_attr(s1, sym_index, 0)->got_offset) >> 12) - (addr >> 12));
		if ((off + ((uint64_t)1 << 20)) >> 21)
			tcc_error("R_AARCH64_ADR_GOT_PAGE relocation failed");
		write32le(ptr, ((read32le(ptr) & 0x9f00001f) |
		                (off & 0x1ffffc) << 3 | (off & 3) << 29));
		return;
	}
	case R_AARCH64_LD64_GOT_LO12_NC:
		write32le(ptr,
		          ((read32le(ptr) & 0xfff803ff) |
		           ((s1->got->sh_addr +
		             get_sym_attr(s1, sym_index, 0)->got_offset) & 0xff8) << 7));
		return;
	case R_AARCH64_COPY:
		return;
	case R_AARCH64_GLOB_DAT:
	case R_AARCH64_JUMP_SLOT:
		/* They don't need addend */
#ifdef DEBUG_RELOC
		printf ("reloc %d @ 0x%lx: val=0x%lx name=%s\n", type, addr,
		        val - rel->r_addend,
		        (char *) symtab_section->link->data + sym->st_name);
#endif
		write64le(ptr, val - rel->r_addend);
		return;
	case R_AARCH64_RELATIVE:
#ifdef TCC_TARGET_PE
		add32le(ptr, val - s1->pe_imagebase);
#endif
		/* do nothing */
		return;
	default:
		fprintf(stderr, "FIXME: handle reloc type %x at %x [%p] to %x\n",
		        type, (unsigned)addr, ptr, (unsigned)val);
		return;
	}
}
//END arm64-link.c

#elif defined TCC_TARGET_C67
# define TCC_TARGET_COFF

//START c67-gen.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

ST_DATA const int reg_classes[NB_REGS] =
{
	/* eax */ RC_INT | RC_FLOAT | RC_EAX,
	// only allow even regs for floats (allow for doubles)
	/* ecx */ RC_INT | RC_ECX,
	/* edx */ RC_INT | RC_INT_BSIDE | RC_FLOAT | RC_EDX,
	// only allow even regs for floats (allow for doubles)
	/* st0 */ RC_INT | RC_INT_BSIDE | RC_ST0,
	/* A4  */ RC_C67_A4,
	/* A5  */ RC_C67_A5,
	/* B4  */ RC_C67_B4,
	/* B5  */ RC_C67_B5,
	/* A6  */ RC_C67_A6,
	/* A7  */ RC_C67_A7,
	/* B6  */ RC_C67_B6,
	/* B7  */ RC_C67_B7,
	/* A8  */ RC_C67_A8,
	/* A9  */ RC_C67_A9,
	/* B8  */ RC_C67_B8,
	/* B9  */ RC_C67_B9,
	/* A10  */ RC_C67_A10,
	/* A11  */ RC_C67_A11,
	/* B10  */ RC_C67_B10,
	/* B11  */ RC_C67_B11,
	/* A12  */ RC_C67_A10,
	/* A13  */ RC_C67_A11,
	/* B12  */ RC_C67_B10,
	/* B13  */ RC_C67_B11
};

// although tcc thinks it is passing parameters on the stack,
// the C67 really passes up to the first 10 params in special
// regs or regs pairs (for 64 bit params).  So keep track of
// the stack offsets so we can translate to the appropriate
// reg (pair)

#define NoCallArgsPassedOnStack 10
int NoOfCurFuncArgs;
int TranslateStackToReg[NoCallArgsPassedOnStack];
int ParamLocOnStack[NoCallArgsPassedOnStack];
int TotalBytesPushedOnStack;

#ifndef FALSE
# define FALSE 0
# define TRUE 1
#endif

#undef BOOL
#define BOOL int

#define ALWAYS_ASSERT(x) \
do {\
   if (!(x))\
       tcc_error("internal compiler error file at %s:%d", __FILE__, __LINE__);\
} while (0)

/******************************************************/
static unsigned long func_sub_sp_offset;
static int func_ret_sub;

static BOOL C67_invert_test;
static int C67_compare_reg;

#ifdef ASSEMBLY_LISTING_C67
FILE *f = NULL;
#endif

void C67_g(int c)
{
	int ind1;
	if (nocode_wanted)
		return;
#ifdef ASSEMBLY_LISTING_C67
	fprintf(f, " %08X", c);
#endif
	ind1 = ind + 4;
	if (ind1 > (int) cur_text_section->data_allocated)
		section_realloc(cur_text_section, ind1);
	cur_text_section->data[ind] = c & 0xff;
	cur_text_section->data[ind + 1] = (c >> 8) & 0xff;
	cur_text_section->data[ind + 2] = (c >> 16) & 0xff;
	cur_text_section->data[ind + 3] = (c >> 24) & 0xff;
	ind = ind1;
}


/* output a symbol and patch all calls to it */
void gsym_addr(int t, int a)
{
	int n, *ptr;
	while (t)
	{
		ptr = (int *) (cur_text_section->data + t);
		{
			Sym *sym;

			// extract 32 bit address from MVKH/MVKL
			n = ((*ptr >> 7) & 0xffff);
			n |= ((*(ptr + 1) >> 7) & 0xffff) << 16;

			// define a label that will be relocated

			sym = get_sym_ref(&char_pointer_type, cur_text_section, a, 0);
			greloc(cur_text_section, sym, t, R_C60LO16);
			greloc(cur_text_section, sym, t + 4, R_C60HI16);

			// clear out where the pointer was

			*ptr &= ~(0xffff << 7);
			*(ptr + 1) &= ~(0xffff << 7);
		}
		t = n;
	}
}

// these are regs that tcc doesn't really know about,
// but assign them unique values so the mapping routines
// can distinguish them

#define C67_A0 105
#define C67_SP 106
#define C67_B3 107
#define C67_FP 108
#define C67_B2 109
#define C67_CREG_ZERO -1	/* Special code for no condition reg test */


int ConvertRegToRegClass(int r)
{
	// only works for A4-B13

	return RC_C67_A4 << (r - TREG_C67_A4);
}


// map TCC reg to C67 reg number

int C67_map_regn(int r)
{
	if (r == 0)			// normal tcc regs
		return 0x2;		// A2
	else if (r == 1)		// normal tcc regs
		return 3;		// A3
	else if (r == 2)		// normal tcc regs
		return 0;		// B0
	else if (r == 3)		// normal tcc regs
		return 1;		// B1
	else if (r >= TREG_C67_A4 && r <= TREG_C67_B13)	// these form a pattern of alt pairs
		return (((r & 0xfffffffc) >> 1) | (r & 1)) + 2;
	else if (r == C67_A0)
		return 0;		// set to A0 (offset reg)
	else if (r == C67_B2)
		return 2;		// set to B2 (offset reg)
	else if (r == C67_B3)
		return 3;		// set to B3 (return address reg)
	else if (r == C67_SP)
		return 15;		// set to SP (B15) (offset reg)
	else if (r == C67_FP)
		return 15;		// set to FP (A15) (offset reg)
	else if (r == C67_CREG_ZERO)
		return 0;		// Special code for no condition reg test
	else
		ALWAYS_ASSERT(FALSE);

	return 0;
}

// mapping from tcc reg number to
// C67 register to condition code field
//
// valid condition code regs are:
//
// tcc reg 2 ->B0 -> 1
// tcc reg 3 ->B1 -> 2
// tcc reg 0 -> A2 -> 5
// tcc reg 1 -> A3 -> X
// tcc reg      B2 -> 3

int C67_map_regc(int r)
{
	if (r == 0)			// normal tcc regs
		return 0x5;
	else if (r == 2)		// normal tcc regs
		return 0x1;
	else if (r == 3)		// normal tcc regs
		return 0x2;
	else if (r == C67_B2)	// normal tcc regs
		return 0x3;
	else if (r == C67_CREG_ZERO)
		return 0;		// Special code for no condition reg test
	else
		ALWAYS_ASSERT(FALSE);

	return 0;
}


// map TCC reg to C67 reg side A or B

int C67_map_regs(int r)
{
	if (r == 0)			// normal tcc regs
		return 0x0;
	else if (r == 1)		// normal tcc regs
		return 0x0;
	else if (r == 2)		// normal tcc regs
		return 0x1;
	else if (r == 3)		// normal tcc regs
		return 0x1;
	else if (r >= TREG_C67_A4 && r <= TREG_C67_B13)	// these form a pattern of alt pairs
		return (r & 2) >> 1;
	else if (r == C67_A0)
		return 0;		// set to A side
	else if (r == C67_B2)
		return 1;		// set to B side
	else if (r == C67_B3)
		return 1;		// set to B side
	else if (r == C67_SP)
		return 0x1;		// set to SP (B15) B side
	else if (r == C67_FP)
		return 0x0;		// set to FP (A15) A side
	else
		ALWAYS_ASSERT(FALSE);

	return 0;
}

int C67_map_S12(char *s)
{
	if (strstr(s, ".S1") != NULL)
		return 0;
	else if (strcmp(s, ".S2"))
		return 1;
	else
		ALWAYS_ASSERT(FALSE);

	return 0;
}

int C67_map_D12(char *s)
{
	if (strstr(s, ".D1") != NULL)
		return 0;
	else if (strcmp(s, ".D2"))
		return 1;
	else
		ALWAYS_ASSERT(FALSE);

	return 0;
}



void C67_asm(char *s, int a, int b, int c)
{
	BOOL xpath;

#ifdef ASSEMBLY_LISTING_C67
	if (!f)
	{
		f = fopen("TCC67_out.txt", "wt");
	}
	fprintf(f, "%04X ", ind);
#endif

	if (strstr(s, "MVKL") == s)
	{
		C67_g((C67_map_regn(b) << 23) |
		      ((a & 0xffff) << 7) | (0x0a << 2) | (C67_map_regs(b) << 1));
	}
	else if (strstr(s, "MVKH") == s)
	{
		C67_g((C67_map_regn(b) << 23) |
		      (((a >> 16) & 0xffff) << 7) |
		      (0x1a << 2) | (C67_map_regs(b) << 1));
	}
	else if (strstr(s, "STW.D SP POST DEC") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (15 << 18) |	//SP B15
		      (2 << 13) |	//ucst5 (must keep 8 byte boundary !!)
		      (0xa << 9) |	//mode a = post dec ucst
		      (0 << 8) |	//r (LDDW bit 0)
		      (1 << 7) |	//y D1/D2 use B side
		      (7 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STB.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2 A side
		      (3 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STH.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2 A side
		      (5 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STB.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2 A side
		      (3 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STH.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2 A side
		      (5 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STW.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2 A side
		      (7 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STW.D *") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (C67_map_regn(b) << 18) |	//base reg A0
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(b) << 7) |	//y D1/D2 base reg side
		      (7 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STH.D *") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (C67_map_regn(b) << 18) |	//base reg A0
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(b) << 7) |	//y D1/D2 base reg side
		      (5 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STB.D *") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//src
		      (C67_map_regn(b) << 18) |	//base reg A0
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(b) << 7) |	//y D1/D2 base reg side
		      (3 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "STW.D +*") == s)
	{
		ALWAYS_ASSERT(c < 32);
		C67_g((C67_map_regn(a) << 23) |	//src
		      (C67_map_regn(b) << 18) |	//base reg A0
		      (c << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(b) << 7) |	//y D1/D2 base reg side
		      (7 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of src
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDW.D SP PRE INC") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg B15
		      (2 << 13) |	//ucst5 (must keep 8 byte boundary)
		      (9 << 9) |	//mode 9 = pre inc ucst5
		      (0 << 8) |	//r (LDDW bit 0)
		      (1 << 7) |	//y D1/D2  B side
		      (6 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDDW.D SP PRE INC") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg B15
		      (1 << 13) |	//ucst5 (must keep 8 byte boundary)
		      (9 << 9) |	//mode 9 = pre inc ucst5
		      (1 << 8) |	//r (LDDW bit 1)
		      (1 << 7) |	//y D1/D2  B side
		      (6 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDW.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2  A side
		      (6 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDDW.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (1 << 8) |	//r (LDDW bit 1)
		      (0 << 7) |	//y D1/D2  A side
		      (6 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDH.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2  A side
		      (4 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDB.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2  A side
		      (2 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDHU.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2  A side
		      (0 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDBU.D *+SP[A0]") == s)
	{
		C67_g((C67_map_regn(a) << 23) |	//dst
		      (15 << 18) |	//base reg A15
		      (0 << 13) |	//offset reg A0
		      (5 << 9) |	//mode 5 = pos offset, base reg + off reg
		      (0 << 8) |	//r (LDDW bit 0)
		      (0 << 7) |	//y D1/D2  A side
		      (1 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(a) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDW.D *") == s)
	{
		C67_g((C67_map_regn(b) << 23) |	//dst
		      (C67_map_regn(a) << 18) |	//base reg A15
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(a) << 7) |	//y D1/D2  src side
		      (6 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDDW.D *") == s)
	{
		C67_g((C67_map_regn(b) << 23) |	//dst
		      (C67_map_regn(a) << 18) |	//base reg A15
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (1 << 8) |	//r (LDDW bit 1)
		      (C67_map_regs(a) << 7) |	//y D1/D2  src side
		      (6 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDH.D *") == s)
	{
		C67_g((C67_map_regn(b) << 23) |	//dst
		      (C67_map_regn(a) << 18) |	//base reg A15
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(a) << 7) |	//y D1/D2  src side
		      (4 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDB.D *") == s)
	{
		C67_g((C67_map_regn(b) << 23) |	//dst
		      (C67_map_regn(a) << 18) |	//base reg A15
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(a) << 7) |	//y D1/D2  src side
		      (2 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDHU.D *") == s)
	{
		C67_g((C67_map_regn(b) << 23) |	//dst
		      (C67_map_regn(a) << 18) |	//base reg A15
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(a) << 7) |	//y D1/D2  src side
		      (0 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDBU.D *") == s)
	{
		C67_g((C67_map_regn(b) << 23) |	//dst
		      (C67_map_regn(a) << 18) |	//base reg A15
		      (0 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(a) << 7) |	//y D1/D2  src side
		      (1 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "LDW.D +*") == s)
	{
		C67_g((C67_map_regn(b) << 23) |	//dst
		      (C67_map_regn(a) << 18) |	//base reg A15
		      (1 << 13) |	//cst5
		      (1 << 9) |	//mode 1 = pos cst offset
		      (0 << 8) |	//r (LDDW bit 0)
		      (C67_map_regs(a) << 7) |	//y D1/D2  src side
		      (6 << 4) |	//ldst 3=STB, 5=STH 5, 7=STW, 6=LDW 4=LDH 2=LDB 0=LDHU 1=LDBU
		      (1 << 2) |	//opcode
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPLTSP") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x3a << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPGTSP") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x39 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPEQSP") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x38 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}

	else if (strstr(s, "CMPLTDP") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x2a << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPGTDP") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x29 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPEQDP") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x28 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPLT") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x57 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPGT") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x47 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPEQ") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x53 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPLTU") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x5f << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "CMPGTU") == s)
	{
		xpath = C67_map_regs(a) ^ C67_map_regs(b);
		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x use cross path for src2
		      (0x4f << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side for reg c
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "B DISP") == s)
	{
		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//z
		      (a << 7) |	//cnst
		      (0x4 << 2) |	//opcode fixed
		      (0 << 1) |	//S0/S1
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "B.") == s)
	{
		xpath = C67_map_regs(c) ^ 1;

		C67_g((C67_map_regc(b) << 29) |	//creg
		      (a << 28) |	//inv
		      (0 << 23) |	//dst
		      (C67_map_regn(c) << 18) |	//src2
		      (0 << 13) |	//
		      (xpath << 12) |	//x cross path if !B side
		      (0xd << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (1 << 1) |	//must be S2
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "MV.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (0 << 13) |	//src1 (cst5)
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x2 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SPTRUNC.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (0 << 13) |	//src1 NA
		      (xpath << 12) |	//x cross path if opposite sides
		      (0xb << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "DPTRUNC.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      ((C67_map_regn(b) + 1) << 18) |	//src2   WEIRD CPU must specify odd reg for some reason
		      (0 << 13) |	//src1 NA
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x1 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "INTSP.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (0 << 13) |	//src1 NA
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x4a << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "INTSPU.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (0 << 13) |	//src1 NA
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x49 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "INTDP.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (0 << 13) |	//src1 NA
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x39 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "INTDPU.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      ((C67_map_regn(b) + 1) << 18) |	//src2   WEIRD CPU must specify odd reg for some reason
		      (0 << 13) |	//src1 NA
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x3b << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SPDP.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (0 << 13) |	//src1 NA
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x2 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "DPSP.L") == s)
	{
		ALWAYS_ASSERT(C67_map_regs(b) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      ((C67_map_regn(b) + 1) << 18) |	//src2 WEIRD CPU must specify odd reg for some reason
		      (0 << 13) |	//src1 NA
		      (0 << 12) |	//x cross path if opposite sides
		      (0x9 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "ADD.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x3 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SUB.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x7 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "OR.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x7f << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "AND.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x7b << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "XOR.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x6f << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "ADDSP.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x10 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "ADDDP.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x18 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SUBSP.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x11 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SUBDP.L") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x19 << 5) |	//opcode
		      (0x6 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "MPYSP.M") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x1c << 7) |	//opcode
		      (0x0 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "MPYDP.M") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2 (possible x path)
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x0e << 7) |	//opcode
		      (0x0 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "MPYI.M") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(a) == C67_map_regs(c));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1 (cst5)
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x4 << 7) |	//opcode
		      (0x0 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SHR.S") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x37 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SHRU.S") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x27 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "SHL.S") == s)
	{
		xpath = C67_map_regs(b) ^ C67_map_regs(c);

		ALWAYS_ASSERT(C67_map_regs(c) == C67_map_regs(a));

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(c) << 23) |	//dst
		      (C67_map_regn(b) << 18) |	//src2
		      (C67_map_regn(a) << 13) |	//src1
		      (xpath << 12) |	//x cross path if opposite sides
		      (0x33 << 6) |	//opcode
		      (0x8 << 2) |	//opcode fixed
		      (C67_map_regs(c) << 1) |	//side of dest
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "||ADDK") == s)
	{
		xpath = 0;		// no xpath required just use the side of the src/dst

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(b) << 23) |	//dst
		      (a << 07) |	//scst16
		      (0x14 << 2) |	//opcode fixed
		      (C67_map_regs(b) << 1) |	//side of dst
		      (1 << 0));	//parallel
	}
	else if (strstr(s, "ADDK") == s)
	{
		xpath = 0;		// no xpath required just use the side of the src/dst

		C67_g((0 << 29) |	//creg
		      (0 << 28) |	//inv
		      (C67_map_regn(b) << 23) |	//dst
		      (a << 07) |	//scst16
		      (0x14 << 2) |	//opcode fixed
		      (C67_map_regs(b) << 1) |	//side of dst
		      (0 << 0));	//parallel
	}
	else if (strstr(s, "NOP") == s)
	{
		C67_g(((a - 1) << 13) |	//no of cycles
		      (0 << 0));	//parallel
	}
	else
		ALWAYS_ASSERT(FALSE);

#ifdef ASSEMBLY_LISTING_C67
	fprintf(f, " %s %d %d %d\n", s, a, b, c);
#endif

}

//r=reg to load, fr=from reg, symbol for relocation, constant

void C67_MVKL(int r, int fc)
{
	C67_asm("MVKL.", fc, r, 0);
}

void C67_MVKH(int r, int fc)
{
	C67_asm("MVKH.", fc, r, 0);
}

void C67_STB_SP_A0(int r)
{
	C67_asm("STB.D *+SP[A0]", r, 0, 0);	// STB  r,*+SP[A0]
}

void C67_STH_SP_A0(int r)
{
	C67_asm("STH.D *+SP[A0]", r, 0, 0);	// STH  r,*+SP[A0]
}

void C67_STW_SP_A0(int r)
{
	C67_asm("STW.D *+SP[A0]", r, 0, 0);	// STW  r,*+SP[A0]
}

void C67_STB_PTR(int r, int r2)
{
	C67_asm("STB.D *", r, r2, 0);	// STB  r, *r2
}

void C67_STH_PTR(int r, int r2)
{
	C67_asm("STH.D *", r, r2, 0);	// STH  r, *r2
}

void C67_STW_PTR(int r, int r2)
{
	C67_asm("STW.D *", r, r2, 0);	// STW  r, *r2
}

void C67_STW_PTR_PRE_INC(int r, int r2, int n)
{
	C67_asm("STW.D +*", r, r2, n);	// STW  r, *+r2
}

void C67_PUSH(int r)
{
	C67_asm("STW.D SP POST DEC", r, 0, 0);	// STW  r,*SP--
}

void C67_LDW_SP_A0(int r)
{
	C67_asm("LDW.D *+SP[A0]", r, 0, 0);	// LDW  *+SP[A0],r
}

void C67_LDDW_SP_A0(int r)
{
	C67_asm("LDDW.D *+SP[A0]", r, 0, 0);	// LDDW  *+SP[A0],r
}

void C67_LDH_SP_A0(int r)
{
	C67_asm("LDH.D *+SP[A0]", r, 0, 0);	// LDH  *+SP[A0],r
}

void C67_LDB_SP_A0(int r)
{
	C67_asm("LDB.D *+SP[A0]", r, 0, 0);	// LDB  *+SP[A0],r
}

void C67_LDHU_SP_A0(int r)
{
	C67_asm("LDHU.D *+SP[A0]", r, 0, 0);	// LDHU  *+SP[A0],r
}

void C67_LDBU_SP_A0(int r)
{
	C67_asm("LDBU.D *+SP[A0]", r, 0, 0);	// LDBU  *+SP[A0],r
}

void C67_LDW_PTR(int r, int r2)
{
	C67_asm("LDW.D *", r, r2, 0);	// LDW  *r,r2
}

void C67_LDDW_PTR(int r, int r2)
{
	C67_asm("LDDW.D *", r, r2, 0);	// LDDW  *r,r2
}

void C67_LDH_PTR(int r, int r2)
{
	C67_asm("LDH.D *", r, r2, 0);	// LDH  *r,r2
}

void C67_LDB_PTR(int r, int r2)
{
	C67_asm("LDB.D *", r, r2, 0);	// LDB  *r,r2
}

void C67_LDHU_PTR(int r, int r2)
{
	C67_asm("LDHU.D *", r, r2, 0);	// LDHU  *r,r2
}

void C67_LDBU_PTR(int r, int r2)
{
	C67_asm("LDBU.D *", r, r2, 0);	// LDBU  *r,r2
}

void C67_LDW_PTR_PRE_INC(int r, int r2)
{
	C67_asm("LDW.D +*", r, r2, 0);	// LDW  *+r,r2
}

void C67_POP(int r)
{
	C67_asm("LDW.D SP PRE INC", r, 0, 0);	// LDW  *++SP,r
}

void C67_POP_DW(int r)
{
	C67_asm("LDDW.D SP PRE INC", r, 0, 0);	// LDDW  *++SP,r
}

void C67_CMPLT(int s1, int s2, int dst)
{
	C67_asm("CMPLT.L1", s1, s2, dst);
}

void C67_CMPGT(int s1, int s2, int dst)
{
	C67_asm("CMPGT.L1", s1, s2, dst);
}

void C67_CMPEQ(int s1, int s2, int dst)
{
	C67_asm("CMPEQ.L1", s1, s2, dst);
}

void C67_CMPLTU(int s1, int s2, int dst)
{
	C67_asm("CMPLTU.L1", s1, s2, dst);
}

void C67_CMPGTU(int s1, int s2, int dst)
{
	C67_asm("CMPGTU.L1", s1, s2, dst);
}


void C67_CMPLTSP(int s1, int s2, int dst)
{
	C67_asm("CMPLTSP.S1", s1, s2, dst);
}

void C67_CMPGTSP(int s1, int s2, int dst)
{
	C67_asm("CMPGTSP.S1", s1, s2, dst);
}

void C67_CMPEQSP(int s1, int s2, int dst)
{
	C67_asm("CMPEQSP.S1", s1, s2, dst);
}

void C67_CMPLTDP(int s1, int s2, int dst)
{
	C67_asm("CMPLTDP.S1", s1, s2, dst);
}

void C67_CMPGTDP(int s1, int s2, int dst)
{
	C67_asm("CMPGTDP.S1", s1, s2, dst);
}

void C67_CMPEQDP(int s1, int s2, int dst)
{
	C67_asm("CMPEQDP.S1", s1, s2, dst);
}


void C67_IREG_B_REG(int inv, int r1, int r2)	// [!R] B  r2
{
	C67_asm("B.S2", inv, r1, r2);
}


// call with how many 32 bit words to skip
// (0 would branch to the branch instruction)

void C67_B_DISP(int disp)	//  B  +2  Branch with constant displacement
{
	// Branch point is relative to the 8 word fetch packet
	//
	// we will assume the text section always starts on an 8 word (32 byte boundary)
	//
	// so add in how many words into the fetch packet the branch is


	C67_asm("B DISP", disp + ((ind & 31) >> 2), 0, 0);
}

void C67_NOP(int n)
{
	C67_asm("NOP", n, 0, 0);
}

void C67_ADDK(int n, int r)
{
	ALWAYS_ASSERT(abs(n) < 32767);

	C67_asm("ADDK", n, r, 0);
}

void C67_ADDK_PARALLEL(int n, int r)
{
	ALWAYS_ASSERT(abs(n) < 32767);

	C67_asm("||ADDK", n, r, 0);
}

void C67_Adjust_ADDK(int *inst, int n)
{
	ALWAYS_ASSERT(abs(n) < 32767);

	*inst = (*inst & (~(0xffff << 7))) | ((n & 0xffff) << 7);
}

void C67_MV(int r, int v)
{
	C67_asm("MV.L", 0, r, v);
}


void C67_DPTRUNC(int r, int v)
{
	C67_asm("DPTRUNC.L", 0, r, v);
}

void C67_SPTRUNC(int r, int v)
{
	C67_asm("SPTRUNC.L", 0, r, v);
}

void C67_INTSP(int r, int v)
{
	C67_asm("INTSP.L", 0, r, v);
}

void C67_INTDP(int r, int v)
{
	C67_asm("INTDP.L", 0, r, v);
}

void C67_INTSPU(int r, int v)
{
	C67_asm("INTSPU.L", 0, r, v);
}

void C67_INTDPU(int r, int v)
{
	C67_asm("INTDPU.L", 0, r, v);
}

void C67_SPDP(int r, int v)
{
	C67_asm("SPDP.L", 0, r, v);
}

void C67_DPSP(int r, int v)	// note regs must be on the same side
{
	C67_asm("DPSP.L", 0, r, v);
}

void C67_ADD(int r, int v)
{
	C67_asm("ADD.L", v, r, v);
}

void C67_SUB(int r, int v)
{
	C67_asm("SUB.L", v, r, v);
}

void C67_AND(int r, int v)
{
	C67_asm("AND.L", v, r, v);
}

void C67_OR(int r, int v)
{
	C67_asm("OR.L", v, r, v);
}

void C67_XOR(int r, int v)
{
	C67_asm("XOR.L", v, r, v);
}

void C67_ADDSP(int r, int v)
{
	C67_asm("ADDSP.L", v, r, v);
}

void C67_SUBSP(int r, int v)
{
	C67_asm("SUBSP.L", v, r, v);
}

void C67_MPYSP(int r, int v)
{
	C67_asm("MPYSP.M", v, r, v);
}

void C67_ADDDP(int r, int v)
{
	C67_asm("ADDDP.L", v, r, v);
}

void C67_SUBDP(int r, int v)
{
	C67_asm("SUBDP.L", v, r, v);
}

void C67_MPYDP(int r, int v)
{
	C67_asm("MPYDP.M", v, r, v);
}

void C67_MPYI(int r, int v)
{
	C67_asm("MPYI.M", v, r, v);
}

void C67_SHL(int r, int v)
{
	C67_asm("SHL.S", r, v, v);
}

void C67_SHRU(int r, int v)
{
	C67_asm("SHRU.S", r, v, v);
}

void C67_SHR(int r, int v)
{
	C67_asm("SHR.S", r, v, v);
}



/* load 'r' from value 'sv' */
void load(int r, SValue * sv)
{
	int v, t, ft, fc, fr, size = 0, element;
	BOOL Unsigned = FALSE;
	SValue v1;

	fr = sv->r;
	ft = sv->type.t;
	fc = sv->c.i;

	v = fr & VT_VALMASK;
	if (fr & VT_LVAL)
	{
		if (v == VT_LLOCAL)
		{
			v1.type.t = VT_INT;
			v1.r = VT_LOCAL | VT_LVAL;
			v1.c.i = fc;
			load(r, &v1);
			fr = r;
		}
		else if ((ft & VT_BTYPE) == VT_LDOUBLE)
		{
			tcc_error("long double not supported");
		}
		else if ((ft & VT_TYPE) == VT_BYTE)
		{
			size = 1;
		}
		else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED))
		{
			size = 1;
			Unsigned = TRUE;
		}
		else if ((ft & VT_TYPE) == VT_SHORT)
		{
			size = 2;
		}
		else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED))
		{
			size = 2;
			Unsigned = TRUE;
		}
		else if ((ft & VT_BTYPE) == VT_DOUBLE)
		{
			size = 8;
		}
		else
		{
			size = 4;
		}

		// check if fc is a positive reference on the stack,
		// if it is tcc is referencing what it thinks is a parameter
		// on the stack, so check if it is really in a register.


		if (v == VT_LOCAL && fc > 0)
		{
			int stack_pos = 8;

			for (t = 0; t < NoCallArgsPassedOnStack; t++)
			{
				if (fc == stack_pos)
					break;

				stack_pos += TranslateStackToReg[t];
			}

			// param has been pushed on stack, get it like a local var

			fc = ParamLocOnStack[t] - 8;
		}

		if ((fr & VT_VALMASK) < VT_CONST)	// check for pure indirect
		{
			if (size == 1)
			{
				if (Unsigned)
					C67_LDBU_PTR(v, r);	// LDBU  *v,r
				else
					C67_LDB_PTR(v, r);	// LDB  *v,r
			}
			else if (size == 2)
			{
				if (Unsigned)
					C67_LDHU_PTR(v, r);	// LDHU  *v,r
				else
					C67_LDH_PTR(v, r);	// LDH  *v,r
			}
			else if (size == 4)
			{
				C67_LDW_PTR(v, r);	// LDW  *v,r
			}
			else if (size == 8)
			{
				C67_LDDW_PTR(v, r);	// LDDW  *v,r
			}

			C67_NOP(4);		// NOP 4
			return;
		}
		else if (fr & VT_SYM)
		{
			greloc(cur_text_section, sv->sym, ind, R_C60LO16);	// rem the inst need to be patched
			greloc(cur_text_section, sv->sym, ind + 4, R_C60HI16);


			C67_MVKL(C67_A0, fc);	//r=reg to load,  constant
			C67_MVKH(C67_A0, fc);	//r=reg to load,  constant


			if (size == 1)
			{
				if (Unsigned)
					C67_LDBU_PTR(C67_A0, r);	// LDBU  *A0,r
				else
					C67_LDB_PTR(C67_A0, r);	// LDB  *A0,r
			}
			else if (size == 2)
			{
				if (Unsigned)
					C67_LDHU_PTR(C67_A0, r);	// LDHU  *A0,r
				else
					C67_LDH_PTR(C67_A0, r);	// LDH  *A0,r
			}
			else if (size == 4)
			{
				C67_LDW_PTR(C67_A0, r);	// LDW  *A0,r
			}
			else if (size == 8)
			{
				C67_LDDW_PTR(C67_A0, r);	// LDDW  *A0,r
			}

			C67_NOP(4);		// NOP 4
			return;
		}
		else
		{
			element = size;

			// divide offset in bytes to create element index
			C67_MVKL(C67_A0, (fc / element) + 8 / element);	//r=reg to load,  constant
			C67_MVKH(C67_A0, (fc / element) + 8 / element);	//r=reg to load,  constant

			if (size == 1)
			{
				if (Unsigned)
					C67_LDBU_SP_A0(r);	// LDBU  r, SP[A0]
				else
					C67_LDB_SP_A0(r);	// LDB  r, SP[A0]
			}
			else if (size == 2)
			{
				if (Unsigned)
					C67_LDHU_SP_A0(r);	// LDHU  r, SP[A0]
				else
					C67_LDH_SP_A0(r);	// LDH  r, SP[A0]
			}
			else if (size == 4)
			{
				C67_LDW_SP_A0(r);	// LDW  r, SP[A0]
			}
			else if (size == 8)
			{
				C67_LDDW_SP_A0(r);	// LDDW  r, SP[A0]
			}


			C67_NOP(4);		// NOP 4
			return;
		}
	}
	else
	{
		if (v == VT_CONST)
		{
			if (fr & VT_SYM)
			{
				greloc(cur_text_section, sv->sym, ind, R_C60LO16);	// rem the inst need to be patched
				greloc(cur_text_section, sv->sym, ind + 4, R_C60HI16);
			}
			C67_MVKL(r, fc);	//r=reg to load, constant
			C67_MVKH(r, fc);	//r=reg to load, constant
		}
		else if (v == VT_LOCAL)
		{
			C67_MVKL(r, fc + 8);	//r=reg to load, constant C67 stack points to next free
			C67_MVKH(r, fc + 8);	//r=reg to load, constant
			C67_ADD(C67_FP, r);	// MV v,r   v -> r
		}
		else if (v == VT_CMP)
		{
			C67_MV(C67_compare_reg, r);	// MV v,r   v -> r
		}
		else if (v == VT_JMP || v == VT_JMPI)
		{
			t = v & 1;
			C67_B_DISP(4);	//  Branch with constant displacement, skip over this branch, load, nop, load
			C67_MVKL(r, t);	//  r=reg to load, 0 or 1 (do this while branching)
			C67_NOP(4);		//  NOP 4
			gsym(fc);		//  modifies other branches to branch here
			C67_MVKL(r, t ^ 1);	//  r=reg to load, 0 or 1
		}
		else if (v != r)
		{
			C67_MV(v, r);	// MV v,r   v -> r

			if ((ft & VT_BTYPE) == VT_DOUBLE)
				C67_MV(v + 1, r + 1);	// MV v,r   v -> r
		}
	}
}


/* store register 'r' in lvalue 'v' */
void store(int r, SValue * v)
{
	int fr, bt, ft, fc, size, t, element;

	ft = v->type.t;
	fc = v->c.i;
	fr = v->r & VT_VALMASK;
	bt = ft & VT_BTYPE;
	/* XXX: incorrect if float reg to reg */

	if (bt == VT_LDOUBLE)
	{
		tcc_error("long double not supported");
	}
	else
	{
		if (bt == VT_SHORT)
			size = 2;
		else if (bt == VT_BYTE)
			size = 1;
		else if (bt == VT_DOUBLE)
			size = 8;
		else
			size = 4;

		if ((v->r & VT_VALMASK) == VT_CONST)
		{
			/* constant memory reference */

			if (v->r & VT_SYM)
			{
				greloc(cur_text_section, v->sym, ind, R_C60LO16);	// rem the inst need to be patched
				greloc(cur_text_section, v->sym, ind + 4, R_C60HI16);
			}
			C67_MVKL(C67_A0, fc);	//r=reg to load,  constant
			C67_MVKH(C67_A0, fc);	//r=reg to load,  constant

			if (size == 1)
				C67_STB_PTR(r, C67_A0);	// STB  r, *A0
			else if (size == 2)
				C67_STH_PTR(r, C67_A0);	// STH  r, *A0
			else if (size == 4 || size == 8)
				C67_STW_PTR(r, C67_A0);	// STW  r, *A0

			if (size == 8)
				C67_STW_PTR_PRE_INC(r + 1, C67_A0, 1);	// STW  r, *+A0[1]
		}
		else if ((v->r & VT_VALMASK) == VT_LOCAL)
		{
			// check case of storing to passed argument that
			// tcc thinks is on the stack but for C67 is
			// passed as a reg.  However it may have been
			// saved to the stack, if that reg was required
			// for a call to a child function

			if (fc > 0)		// argument ??
			{
				// walk through sizes and figure which param

				int stack_pos = 8;

				for (t = 0; t < NoCallArgsPassedOnStack; t++)
				{
					if (fc == stack_pos)
						break;

					stack_pos += TranslateStackToReg[t];
				}

				// param has been pushed on stack, get it like a local var
				fc = ParamLocOnStack[t] - 8;
			}

			if (size == 8)
				element = 4;
			else
				element = size;

			// divide offset in bytes to create word index
			C67_MVKL(C67_A0, (fc / element) + 8 / element);	//r=reg to load,  constant
			C67_MVKH(C67_A0, (fc / element) + 8 / element);	//r=reg to load,  constant



			if (size == 1)
				C67_STB_SP_A0(r);	// STB  r, SP[A0]
			else if (size == 2)
				C67_STH_SP_A0(r);	// STH  r, SP[A0]
			else if (size == 4 || size == 8)
				C67_STW_SP_A0(r);	// STW  r, SP[A0]

			if (size == 8)
			{
				C67_ADDK(1, C67_A0);	//  ADDK 1,A0
				C67_STW_SP_A0(r + 1);	//  STW  r, SP[A0]
			}
		}
		else
		{
			if (size == 1)
				C67_STB_PTR(r, fr);	// STB  r, *fr
			else if (size == 2)
				C67_STH_PTR(r, fr);	// STH  r, *fr
			else if (size == 4 || size == 8)
				C67_STW_PTR(r, fr);	// STW  r, *fr

			if (size == 8)
			{
				C67_STW_PTR_PRE_INC(r + 1, fr, 1);	// STW  r, *+fr[1]
			}
		}
	}
}

/* 'is_jmp' is '1' if it is a jump */
static void gcall_or_jmp(int is_jmp)
{
	int r;
	Sym *sym;

	if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
	{
		/* constant case */
		if (vtop->r & VT_SYM)
		{
			/* relocation case */

			// get add into A0, then start the jump B3

			greloc(cur_text_section, vtop->sym, ind, R_C60LO16);	// rem the inst need to be patched
			greloc(cur_text_section, vtop->sym, ind + 4, R_C60HI16);

			C67_MVKL(C67_A0, 0);	//r=reg to load, constant
			C67_MVKH(C67_A0, 0);	//r=reg to load, constant
			C67_IREG_B_REG(0, C67_CREG_ZERO, C67_A0);	//  B.S2x  A0

			if (is_jmp)
			{
				C67_NOP(5);	// simple jump, just put NOP
			}
			else
			{
				// Call, must load return address into B3 during delay slots

				sym = get_sym_ref(&char_pointer_type, cur_text_section, ind + 12, 0);	// symbol for return address
				greloc(cur_text_section, sym, ind, R_C60LO16);	// rem the inst need to be patched
				greloc(cur_text_section, sym, ind + 4, R_C60HI16);
				C67_MVKL(C67_B3, 0);	//r=reg to load, constant
				C67_MVKH(C67_B3, 0);	//r=reg to load, constant
				C67_NOP(3);	// put remaining NOPs
			}
		}
		else
		{
			/* put an empty PC32 relocation */
			ALWAYS_ASSERT(FALSE);
		}
	}
	else
	{
		/* otherwise, indirect call */
		r = gv(RC_INT);
		C67_IREG_B_REG(0, C67_CREG_ZERO, r);	//  B.S2x  r

		if (is_jmp)
		{
			C67_NOP(5);		// simple jump, just put NOP
		}
		else
		{
			// Call, must load return address into B3 during delay slots

			sym = get_sym_ref(&char_pointer_type, cur_text_section, ind + 12, 0);	// symbol for return address
			greloc(cur_text_section, sym, ind, R_C60LO16);	// rem the inst need to be patched
			greloc(cur_text_section, sym, ind + 4, R_C60HI16);
			C67_MVKL(C67_B3, 0);	//r=reg to load, constant
			C67_MVKH(C67_B3, 0);	//r=reg to load, constant
			C67_NOP(3);		// put remaining NOPs
		}
	}
}

/* Return the number of registers needed to return the struct, or 0 if
   returning via struct pointer. */
ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret, int *ret_align, int *regsize)
{
	*ret_align = 1; // Never have to re-align return values for x86-64
	return 0;
}

/* generate function call with address in (vtop->t, vtop->c) and free function
   context. Stack entry is popped */
void gfunc_call(int nb_args)
{
	int i, r, size = 0;
	int args_sizes[NoCallArgsPassedOnStack];

	if (nb_args > NoCallArgsPassedOnStack)
	{
		tcc_error("more than 10 function params not currently supported");
		// handle more than 10, put some on the stack
	}

	for (i = 0; i < nb_args; i++)
	{
		if ((vtop->type.t & VT_BTYPE) == VT_STRUCT)
		{
			ALWAYS_ASSERT(FALSE);
		}
		else
		{
			/* simple type (currently always same size) */
			/* XXX: implicit cast ? */


			if ((vtop->type.t & VT_BTYPE) == VT_LLONG)
			{
				tcc_error("long long not supported");
			}
			else if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE)
			{
				tcc_error("long double not supported");
			}
			else if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)
			{
				size = 8;
			}
			else
			{
				size = 4;
			}

			// put the parameter into the corresponding reg (pair)

			r = gv(RC_C67_A4 << (2 * i));

			// must put on stack because with 1 pass compiler , no way to tell
			// if an up coming nested call might overwrite these regs

			C67_PUSH(r);

			if (size == 8)
			{
				C67_STW_PTR_PRE_INC(r + 1, C67_SP, 3);	// STW  r, *+SP[3] (go back and put the other)
			}
			args_sizes[i] = size;
		}
		vtop--;
	}
	// POP all the params on the stack into registers for the
	// immediate call (in reverse order)

	for (i = nb_args - 1; i >= 0; i--)
	{

		if (args_sizes[i] == 8)
			C67_POP_DW(TREG_C67_A4 + i * 2);
		else
			C67_POP(TREG_C67_A4 + i * 2);
	}
	gcall_or_jmp(0);
	vtop--;
}


// to be compatible with Code Composer for the C67
// the first 10 parameters must be passed in registers
// (pairs for 64 bits) starting wit; A4:A5, then B4:B5 and
// ending with B12:B13.
//
// When a call is made, if the caller has its parameters
// in regs A4-B13 these must be saved before/as the call
// parameters are loaded and restored upon return (or if/when needed).

/* generate function prolog of type 't' */
void gfunc_prolog(Sym *func_sym)
{
	CType *func_type = &func_sym->type;
	int addr, align, size, func_call, i;
	Sym *sym;
	CType *type;

	sym = func_type->ref;
	func_call = sym->f.func_call;
	addr = 8;
	/* if the function returns a structure, then add an
	   implicit pointer parameter */
	func_vt = sym->type;
	func_var = (sym->f.func_type == FUNC_ELLIPSIS);
	if ((func_vt.t & VT_BTYPE) == VT_STRUCT)
	{
		func_vc = addr;
		addr += 4;
	}

	NoOfCurFuncArgs = 0;

	/* define parameters */
	while ((sym = sym->next) != NULL)
	{
		type = &sym->type;
		sym_push(sym->v & ~SYM_FIELD, type, VT_LOCAL | VT_LVAL, addr);
		size = type_size(type, &align);
		size = (size + 3) & ~3;

		// keep track of size of arguments so
		// we can translate where tcc thinks they
		// are on the stack into the appropriate reg

		TranslateStackToReg[NoOfCurFuncArgs] = size;
		NoOfCurFuncArgs++;

#ifdef FUNC_STRUCT_PARAM_AS_PTR
		/* structs are passed as pointer */
		if ((type->t & VT_BTYPE) == VT_STRUCT)
		{
			size = 4;
		}
#endif
		addr += size;
	}
	func_ret_sub = 0;
	/* pascal type call ? */
	if (func_call == FUNC_STDCALL)
		func_ret_sub = addr - 8;

	C67_MV(C67_FP, C67_A0);	//  move FP -> A0
	C67_MV(C67_SP, C67_FP);	//  move SP -> FP

	// place all the args passed in regs onto the stack

	loc = 0;
	for (i = 0; i < NoOfCurFuncArgs; i++)
	{

		ParamLocOnStack[i] = loc;	// remember where the param is
		loc += -8;

		C67_PUSH(TREG_C67_A4 + i * 2);

		if (TranslateStackToReg[i] == 8)
		{
			C67_STW_PTR_PRE_INC(TREG_C67_A4 + i * 2 + 1, C67_SP, 3);	// STW  r, *+SP[1] (go back and put the other)
		}
	}

	TotalBytesPushedOnStack = -loc;

	func_sub_sp_offset = ind;	// remember where we put the stack instruction
	C67_ADDK(0, C67_SP);	//  ADDK.L2 loc,SP  (just put zero temporarily)

	C67_PUSH(C67_A0);
	C67_PUSH(C67_B3);
}

/* generate function epilog */
void gfunc_epilog(void)
{
	{
		int local = (-loc + 7) & -8;	// stack must stay aligned to 8 bytes for LDDW instr
		C67_POP(C67_B3);
		C67_NOP(4);		// NOP wait for load
		C67_IREG_B_REG(0, C67_CREG_ZERO, C67_B3);	//  B.S2  B3
		C67_POP(C67_FP);
		C67_ADDK(local, C67_SP);	//  ADDK.L2 loc,SP
		C67_Adjust_ADDK((int *) (cur_text_section->data +
		                         func_sub_sp_offset),
		                -local + TotalBytesPushedOnStack);
		C67_NOP(3);		// NOP
	}
}

ST_FUNC void gen_fill_nops(int bytes)
{
	if ((bytes & 3))
		tcc_error("alignment of code section not multiple of 4");
	while (bytes > 0)
	{
		C67_NOP(4);
		bytes -= 4;
	}
}

/* generate a jump to a label */
int gjmp(int t)
{
	int ind1 = ind;
	if (nocode_wanted)
		return t;

	C67_MVKL(C67_A0, t);	//r=reg to load,  constant
	C67_MVKH(C67_A0, t);	//r=reg to load,  constant
	C67_IREG_B_REG(0, C67_CREG_ZERO, C67_A0);	// [!R] B.S2x  A0
	C67_NOP(5);
	return ind1;
}

/* generate a jump to a fixed address */
void gjmp_addr(int a)
{
	Sym *sym;
	// I guess this routine is used for relative short
	// local jumps, for now just handle it as the general
	// case

	// define a label that will be relocated

	sym = get_sym_ref(&char_pointer_type, cur_text_section, a, 0);
	greloc(cur_text_section, sym, ind, R_C60LO16);
	greloc(cur_text_section, sym, ind + 4, R_C60HI16);

	gjmp(0);			// place a zero there later the symbol will be added to it
}

/* generate a test. set 'inv' to invert test. Stack entry is popped */
ST_FUNC int gjmp_cond(int op, int t)
{
	int ind1;
	int inv = op & 1;
	if (nocode_wanted)
		return t;

	/* fast case : can jump directly since flags are set */
	// C67 uses B2 sort of as flags register
	ind1 = ind;
	C67_MVKL(C67_A0, t);	//r=reg to load, constant
	C67_MVKH(C67_A0, t);	//r=reg to load, constant

	if (C67_compare_reg != TREG_EAX &&	// check if not already in a conditional test reg
	        C67_compare_reg != TREG_EDX &&
	        C67_compare_reg != TREG_ST0 && C67_compare_reg != C67_B2)
	{
		C67_MV(C67_compare_reg, C67_B2);
		C67_compare_reg = C67_B2;
	}

	C67_IREG_B_REG(C67_invert_test ^ inv, C67_compare_reg, C67_A0);	// [!R] B.S2x  A0
	C67_NOP(5);
	t = ind1;		//return where we need to patch

	return t;
}

ST_FUNC int gjmp_append(int n0, int t)
{
	if (n0)
	{
		int n = n0, *p;
		/* insert vtop->c jump list in t */

		// I guess the idea is to traverse to the
		// null at the end of the list and store t
		// there
		while (n != 0)
		{
			p = (int *) (cur_text_section->data + n);

			// extract 32 bit address from MVKH/MVKL
			n = ((*p >> 7) & 0xffff);
			n |= ((*(p + 1) >> 7) & 0xffff) << 16;
		}
		*p |= (t & 0xffff) << 7;
		*(p + 1) |= ((t >> 16) & 0xffff) << 7;
		t = n0;
	}
	return t;
}

/* generate an integer binary operation */
void gen_opi(int op)
{
	int r, fr, opc, t;

	switch (op)
	{
	case '+':
	case TOK_ADDC1:		/* add with carry generation */
		opc = 0;
gen_op8:


// C67 can't do const compares, must load into a reg
// so just go to gv2 directly - tktk



		if (op >= TOK_ULT && op <= TOK_GT)
			gv2(RC_INT_BSIDE, RC_INT);	// make sure r (src1) is on the B Side of CPU
		else
			gv2(RC_INT, RC_INT);

		r = vtop[-1].r;
		fr = vtop[0].r;

		C67_compare_reg = C67_B2;


		if (op == TOK_LT)
		{
			C67_CMPLT(r, fr, C67_B2);
			C67_invert_test = FALSE;
		}
		else if (op == TOK_GE)
		{
			C67_CMPLT(r, fr, C67_B2);
			C67_invert_test = TRUE;
		}
		else if (op == TOK_GT)
		{
			C67_CMPGT(r, fr, C67_B2);
			C67_invert_test = FALSE;
		}
		else if (op == TOK_LE)
		{
			C67_CMPGT(r, fr, C67_B2);
			C67_invert_test = TRUE;
		}
		else if (op == TOK_EQ)
		{
			C67_CMPEQ(r, fr, C67_B2);
			C67_invert_test = FALSE;
		}
		else if (op == TOK_NE)
		{
			C67_CMPEQ(r, fr, C67_B2);
			C67_invert_test = TRUE;
		}
		else if (op == TOK_ULT)
		{
			C67_CMPLTU(r, fr, C67_B2);
			C67_invert_test = FALSE;
		}
		else if (op == TOK_UGE)
		{
			C67_CMPLTU(r, fr, C67_B2);
			C67_invert_test = TRUE;
		}
		else if (op == TOK_UGT)
		{
			C67_CMPGTU(r, fr, C67_B2);
			C67_invert_test = FALSE;
		}
		else if (op == TOK_ULE)
		{
			C67_CMPGTU(r, fr, C67_B2);
			C67_invert_test = TRUE;
		}
		else if (op == '+')
			C67_ADD(fr, r);	// ADD  r,fr,r
		else if (op == '-')
			C67_SUB(fr, r);	// SUB  r,fr,r
		else if (op == '&')
			C67_AND(fr, r);	// AND  r,fr,r
		else if (op == '|')
			C67_OR(fr, r);	// OR  r,fr,r
		else if (op == '^')
			C67_XOR(fr, r);	// XOR  r,fr,r
		else
			ALWAYS_ASSERT(FALSE);

		vtop--;
		if (op >= TOK_ULT && op <= TOK_GT)
			vset_VT_CMP(0x80);
		break;
	case '-':
	case TOK_SUBC1:		/* sub with carry generation */
		opc = 5;
		goto gen_op8;
	case TOK_ADDC2:		/* add with carry use */
		opc = 2;
		goto gen_op8;
	case TOK_SUBC2:		/* sub with carry use */
		opc = 3;
		goto gen_op8;
	case '&':
		opc = 4;
		goto gen_op8;
	case '^':
		opc = 6;
		goto gen_op8;
	case '|':
		opc = 1;
		goto gen_op8;
	case '*':
	case TOK_UMULL:
		gv2(RC_INT, RC_INT);
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		C67_MPYI(fr, r);	// 32 bit multiply  fr,r,fr
		C67_NOP(8);		// NOP 8 for worst case
		break;
	case TOK_SHL:
		gv2(RC_INT_BSIDE, RC_INT_BSIDE);	// shift amount must be on same side as dst
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		C67_SHL(fr, r);		// arithmetic/logical shift
		break;

	case TOK_SHR:
		gv2(RC_INT_BSIDE, RC_INT_BSIDE);	// shift amount must be on same side as dst
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		C67_SHRU(fr, r);	// logical shift
		break;

	case TOK_SAR:
		gv2(RC_INT_BSIDE, RC_INT_BSIDE);	// shift amount must be on same side as dst
		r = vtop[-1].r;
		fr = vtop[0].r;
		vtop--;
		C67_SHR(fr, r);		// arithmetic shift
		break;

	case '/':
		t = TOK__divi;
call_func:
		vswap();
		/* call generic idiv function */
		vpush_global_sym(&func_old_type, t);
		vrott(3);
		gfunc_call(2);
		vpushi(0);
		vtop->r = REG_IRET;
		vtop->r2 = VT_CONST;
		break;
	case TOK_UDIV:
	case TOK_PDIV:
		t = TOK__divu;
		goto call_func;
	case '%':
		t = TOK__remi;
		goto call_func;
	case TOK_UMOD:
		t = TOK__remu;
		goto call_func;

	default:
		opc = 7;
		goto gen_op8;
	}
}

/* generate a floating point operation 'v = t1 op t2' instruction. The
   two operands are guaranteed to have the same floating point type */
/* XXX: need to use ST1 too */
void gen_opf(int op)
{
	int ft, fc, fr, r;

	if (op >= TOK_ULT && op <= TOK_GT)
		gv2(RC_EDX, RC_EAX);	// make sure src2 is on b side
	else
		gv2(RC_FLOAT, RC_FLOAT);	// make sure src2 is on b side

	ft = vtop->type.t;
	fc = vtop->c.i;
	r = vtop->r;
	fr = vtop[-1].r;


	if ((ft & VT_BTYPE) == VT_LDOUBLE)
		tcc_error("long doubles not supported");

	if (op >= TOK_ULT && op <= TOK_GT)
	{

		r = vtop[-1].r;
		fr = vtop[0].r;

		C67_compare_reg = C67_B2;

		if (op == TOK_LT)
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
				C67_CMPLTDP(r, fr, C67_B2);
			else
				C67_CMPLTSP(r, fr, C67_B2);

			C67_invert_test = FALSE;
		}
		else if (op == TOK_GE)
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
				C67_CMPLTDP(r, fr, C67_B2);
			else
				C67_CMPLTSP(r, fr, C67_B2);

			C67_invert_test = TRUE;
		}
		else if (op == TOK_GT)
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
				C67_CMPGTDP(r, fr, C67_B2);
			else
				C67_CMPGTSP(r, fr, C67_B2);

			C67_invert_test = FALSE;
		}
		else if (op == TOK_LE)
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
				C67_CMPGTDP(r, fr, C67_B2);
			else
				C67_CMPGTSP(r, fr, C67_B2);

			C67_invert_test = TRUE;
		}
		else if (op == TOK_EQ)
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
				C67_CMPEQDP(r, fr, C67_B2);
			else
				C67_CMPEQSP(r, fr, C67_B2);

			C67_invert_test = FALSE;
		}
		else if (op == TOK_NE)
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
				C67_CMPEQDP(r, fr, C67_B2);
			else
				C67_CMPEQSP(r, fr, C67_B2);

			C67_invert_test = TRUE;
		}
		else
		{
			ALWAYS_ASSERT(FALSE);
		}
		vset_VT_CMP(0x80);
	}
	else
	{
		if (op == '+')
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
			{
				C67_ADDDP(r, fr);	// ADD  fr,r,fr
				C67_NOP(6);
			}
			else
			{
				C67_ADDSP(r, fr);	// ADD  fr,r,fr
				C67_NOP(3);
			}
			vtop--;
		}
		else if (op == '-')
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
			{
				C67_SUBDP(r, fr);	// SUB  fr,r,fr
				C67_NOP(6);
			}
			else
			{
				C67_SUBSP(r, fr);	// SUB  fr,r,fr
				C67_NOP(3);
			}
			vtop--;
		}
		else if (op == '*')
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
			{
				C67_MPYDP(r, fr);	// MPY  fr,r,fr
				C67_NOP(9);
			}
			else
			{
				C67_MPYSP(r, fr);	// MPY  fr,r,fr
				C67_NOP(3);
			}
			vtop--;
		}
		else if (op == '/')
		{
			if ((ft & VT_BTYPE) == VT_DOUBLE)
			{
				// must call intrinsic DP floating point divide
				vswap();
				/* call generic idiv function */
				vpush_global_sym(&func_old_type, TOK__divd);
				vrott(3);
				gfunc_call(2);
				vpushi(0);
				vtop->r = REG_FRET;
				vtop->r2 = REG_IRE2;

			}
			else
			{
				// must call intrinsic SP floating point divide
				vswap();
				/* call generic idiv function */
				vpush_global_sym(&func_old_type, TOK__divf);
				vrott(3);
				gfunc_call(2);
				vpushi(0);
				vtop->r = REG_FRET;
				vtop->r2 = VT_CONST;
			}
		}
		else
			ALWAYS_ASSERT(FALSE);


	}
}


/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'
   and 'long long' cases. */
void gen_cvt_itof(int t)
{
	int r;

	gv(RC_INT);
	r = vtop->r;

	if ((t & VT_BTYPE) == VT_DOUBLE)
	{
		if (t & VT_UNSIGNED)
			C67_INTDPU(r, r);
		else
			C67_INTDP(r, r);

		C67_NOP(4);
		vtop->type.t = VT_DOUBLE;
	}
	else
	{
		if (t & VT_UNSIGNED)
			C67_INTSPU(r, r);
		else
			C67_INTSP(r, r);
		C67_NOP(3);
		vtop->type.t = VT_FLOAT;
	}

}

/* convert fp to int 't' type */
/* XXX: handle long long case */
void gen_cvt_ftoi(int t)
{
	int r;

	gv(RC_FLOAT);
	r = vtop->r;

	if (t != VT_INT)
		tcc_error("long long not supported");
	else
	{
		if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)
		{
			C67_DPTRUNC(r, r);
			C67_NOP(3);
		}
		else
		{
			C67_SPTRUNC(r, r);
			C67_NOP(3);
		}

		vtop->type.t = VT_INT;

	}
}

/* convert from one floating point type to another */
void gen_cvt_ftof(int t)
{
	int r, r2;

	if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE &&
	        (t & VT_BTYPE) == VT_FLOAT)
	{
		// convert double to float

		gv(RC_FLOAT);		// get it in a register pair

		r = vtop->r;

		C67_DPSP(r, r);		// convert it to SP same register
		C67_NOP(3);

		vtop->type.t = VT_FLOAT;
		vtop->r2 = VT_CONST;	// set this as unused
	}
	else if ((vtop->type.t & VT_BTYPE) == VT_FLOAT &&
	         (t & VT_BTYPE) == VT_DOUBLE)
	{
		// convert float to double

		gv(RC_FLOAT);		// get it in a register

		r = vtop->r;

		if (r == TREG_EAX)  	// make sure the paired reg is avail
		{
			r2 = get_reg(RC_ECX);
		}
		else if (r == TREG_EDX)
		{
			r2 = get_reg(RC_ST0);
		}
		else
		{
			ALWAYS_ASSERT(FALSE);
			r2 = 0; /* avoid warning */
		}

		C67_SPDP(r, r);		// convert it to DP same register
		C67_NOP(1);

		vtop->type.t = VT_DOUBLE;
		vtop->r2 = r2;		// set this as unused
	}
	else
	{
		ALWAYS_ASSERT(FALSE);
	}
}

/* computed goto support */
void ggoto(void)
{
	gcall_or_jmp(1);
	vtop--;
}

/* Save the stack pointer onto the stack and return the location of its address */
ST_FUNC void gen_vla_sp_save(int addr)
{
	tcc_error("variable length arrays unsupported for this target");
}

/* Restore the SP from a location on the stack */
ST_FUNC void gen_vla_sp_restore(int addr)
{
	tcc_error("variable length arrays unsupported for this target");
}

/* Subtract from the stack pointer, and push the resulting value onto the stack */
ST_FUNC void gen_vla_alloc(CType *type, int align)
{
	tcc_error("variable length arrays unsupported for this target");
}

/* end of C67 code generator */
//END c67-gen.c

//START c67-link.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE
# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

/* Returns 1 for a code relocation, 0 for a data relocation. For unknown
   relocations, returns -1. */
int code_reloc (int reloc_type)
{
	switch (reloc_type)
	{
	case R_C60_32:
	case R_C60LO16:
	case R_C60HI16:
	case R_C60_GOT32:
	case R_C60_GOTOFF:
	case R_C60_GOTPC:
	case R_C60_COPY:
		return 0;

	case R_C60_PLT32:
		return 1;
	}
	return -1;
}

/* Returns an enumerator to describe whether and when the relocation needs a
   GOT and/or PLT entry to be created. See tcc.h for a description of the
   different values. */
int gotplt_entry_type (int reloc_type)
{
	switch (reloc_type)
	{
	case R_C60_32:
	case R_C60LO16:
	case R_C60HI16:
	case R_C60_COPY:
		return NO_GOTPLT_ENTRY;

	case R_C60_GOTOFF:
	case R_C60_GOTPC:
		return BUILD_GOT_ONLY;

	case R_C60_PLT32:
	case R_C60_GOT32:
		return ALWAYS_GOTPLT_ENTRY;
	}
	return -1;
}

ST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)
{
	tcc_error("C67 got not implemented");
	return 0;
}

/* relocate the PLT: compute addresses and offsets in the PLT now that final
   address for PLT and GOT are known (see fill_program_header) */
ST_FUNC void relocate_plt(TCCState *s1)
{
	uint8_t *p, *p_end;

	if (!s1->plt)
		return;

	p = s1->plt->data;
	p_end = p + s1->plt->data_offset;

	if (p < p_end)
	{
		/* XXX: TODO */
		while (p < p_end)
		{
			/* XXX: TODO */
		}
	}
}

void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr, addr_t addr, addr_t val)
{
	switch(type)
	{
	case R_C60_32:
		*(int *)ptr += val;
		break;
	case R_C60LO16:
	{
		uint32_t orig;

		/* put the low 16 bits of the absolute address add to what is
		   already there */
		orig  =   ((*(int *)(ptr  )) >> 7) & 0xffff;
		orig |=  (((*(int *)(ptr+4)) >> 7) & 0xffff) << 16;

		/* patch both at once - assumes always in pairs Low - High */
		*(int *) ptr    = (*(int *) ptr    & (~(0xffff << 7)) ) |
		                  (((val+orig)      & 0xffff) << 7);
		*(int *)(ptr+4) = (*(int *)(ptr+4) & (~(0xffff << 7)) ) |
		                  ((((val+orig)>>16) & 0xffff) << 7);
	}
	break;
	case R_C60HI16:
		break;
	default:
		fprintf(stderr,"FIXME: handle reloc type %x at %x [%p] to %x\n",
		        type, (unsigned) addr, ptr, (unsigned) val);
		break;
	}
}
//END c67-link.c

#elif defined(TCC_TARGET_RISCV64)

//START riscv64-gen.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

#define XLEN 8

#define TREG_RA 17
#define TREG_SP 18

ST_DATA const int reg_classes[NB_REGS] =
{
	RC_INT | RC_R(0),
	RC_INT | RC_R(1),
	RC_INT | RC_R(2),
	RC_INT | RC_R(3),
	RC_INT | RC_R(4),
	RC_INT | RC_R(5),
	RC_INT | RC_R(6),
	RC_INT | RC_R(7),
	RC_FLOAT | RC_F(0),
	RC_FLOAT | RC_F(1),
	RC_FLOAT | RC_F(2),
	RC_FLOAT | RC_F(3),
	RC_FLOAT | RC_F(4),
	RC_FLOAT | RC_F(5),
	RC_FLOAT | RC_F(6),
	RC_FLOAT | RC_F(7),
	0,
	1 << TREG_RA,
	  1 << TREG_SP
};

static int ireg(int r)
{
	if (r == TREG_RA)
		return 1; // ra
	if (r == TREG_SP)
		return 2; // sp
	assert(r >= 0 && r < 8);
	return r + 10;  // tccrX --> aX == x(10+X)
}

static int is_ireg(int r)
{
	return (unsigned)r < 8 || r == TREG_RA || r == TREG_SP;
}

static int freg(int r)
{
	assert(r >= 8 && r < 16);
	return r - 8 + 10;  // tccfX --> faX == f(10+X)
}

static int is_freg(int r)
{
	return r >= 8 && r < 16;
}

ST_FUNC void o(unsigned int c)
{
	int ind1 = ind + 4;
	if (nocode_wanted)
		return;
	if (ind1 > cur_text_section->data_allocated)
		section_realloc(cur_text_section, ind1);
	write32le(cur_text_section->data + ind, c);
	ind = ind1;
}

static void EIu(uint32_t opcode, uint32_t func3,
                uint32_t rd, uint32_t rs1, uint32_t imm)
{
	o(opcode | (func3 << 12) | (rd << 7) | (rs1 << 15) | (imm << 20));
}

static void ER(uint32_t opcode, uint32_t func3,
               uint32_t rd, uint32_t rs1, uint32_t rs2, uint32_t func7)
{
	o(opcode | func3 << 12 | rd << 7 | rs1 << 15 | rs2 << 20 | func7 << 25);
}

static void EI(uint32_t opcode, uint32_t func3,
               uint32_t rd, uint32_t rs1, uint32_t imm)
{
	assert(! ((imm + (1 << 11)) >> 12));
	EIu(opcode, func3, rd, rs1, imm);
}

static void ES(uint32_t opcode, uint32_t func3,
               uint32_t rs1, uint32_t rs2, uint32_t imm)
{
	assert(! ((imm + (1 << 11)) >> 12));
	o(opcode | (func3 << 12) | ((imm & 0x1f) << 7) | (rs1 << 15)
	  | (rs2 << 20) | ((imm >> 5) << 25));
}

// Patch all branches in list pointed to by t to branch to a:
ST_FUNC void gsym_addr(int t_, int a_)
{
	uint32_t t = t_;
	uint32_t a = a_;
	while (t)
	{
		unsigned char *ptr = cur_text_section->data + t;
		uint32_t next = read32le(ptr);
		uint32_t r = a - t, imm;
		if ((r + (1 << 21)) & ~((1U << 22) - 2))
			tcc_error("out-of-range branch chain");
		imm =   (((r >> 12) &  0xff) << 12)
		        | (((r >> 11) &     1) << 20)
		        | (((r >>  1) & 0x3ff) << 21)
		        | (((r >> 20) &     1) << 31);
		write32le(ptr, r == 4 ? 0x33 : 0x6f | imm); // nop || j imm
		t = next;
	}
}

static int load_symofs(int r, SValue *sv, int forstore)
{
	static Sym label;
	int rr, doload = 0;
	int fc = sv->c.i, v = sv->r & VT_VALMASK;
	if (sv->r & VT_SYM)
	{
		assert(v == VT_CONST);
		if (sv->sym->type.t & VT_STATIC)   // XXX do this per linker relax
		{
			greloca(cur_text_section, sv->sym, ind,
			        R_RISCV_PCREL_HI20, sv->c.i);
			sv->c.i = 0;
		}
		else
		{
			if (((unsigned)fc + (1 << 11)) >> 12)
				tcc_error("unimp: large addend for global address (0x%llx)", sv->c.i);
			greloca(cur_text_section, sv->sym, ind,
			        R_RISCV_GOT_HI20, 0);
			doload = 1;
		}
		if (!label.v)
		{
			label.v = tok_alloc(".L0 ", 4)->tok;
			label.type.t = VT_VOID | VT_STATIC;
		}
		label.c = 0; /* force new local ELF symbol */
		put_extern_sym(&label, cur_text_section, ind, 0);
		rr = is_ireg(r) ? ireg(r) : 5;
		o(0x17 | (rr << 7));   // auipc RR, 0 %pcrel_hi(sym)+addend
		greloca(cur_text_section, &label, ind,
		        doload || !forstore
		        ? R_RISCV_PCREL_LO12_I : R_RISCV_PCREL_LO12_S, 0);
		if (doload)
		{
			EI(0x03, 3, rr, rr, 0); // ld RR, 0(RR)
		}
	}
	else if (v == VT_LOCAL || v == VT_LLOCAL)
	{
		rr = 8; // s0
		if (fc != sv->c.i)
			tcc_error("unimp: store(giant local off) (0x%llx)", (long long)sv->c.i);
		if (((unsigned)fc + (1 << 11)) >> 12)
		{
			rr = is_ireg(r) ? ireg(r) : 5; // t0
			o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)); //lui RR, upper(fc)
			ER(0x33, 0, rr, rr, 8, 0); // add RR, RR, s0
			sv->c.i = fc << 20 >> 20;
		}
	}
	else
		tcc_error("uhh");
	return rr;
}

ST_FUNC void load(int r, SValue *sv)
{
	int fr = sv->r;
	int v = fr & VT_VALMASK;
	int rr = is_ireg(r) ? ireg(r) : freg(r);
	int fc = sv->c.i;
	int bt = sv->type.t & VT_BTYPE;
	int align, size = type_size(&sv->type, &align);
	if (fr & VT_LVAL)
	{
		int func3, opcode = is_freg(r) ? 0x07 : 0x03, br;
		assert (!is_freg(r) || bt == VT_FLOAT || bt == VT_DOUBLE);
		if (bt == VT_FUNC) /* XXX should be done in generic code */
			size = PTR_SIZE;
		func3 = size == 1 ? 0 : size == 2 ? 1 : size == 4 ? 2 : 3;
		if (size < 4 && !is_float(sv->type.t) && (sv->type.t & VT_UNSIGNED))
			func3 |= 4;
		if (v == VT_LOCAL || (fr & VT_SYM))
		{
			br = load_symofs(r, sv, 0);
			fc = sv->c.i;
		}
		else if (v < VT_CONST)
		{
			br = ireg(v);
			/*if (((unsigned)fc + (1 << 11)) >> 12)
			  tcc_error("unimp: load(large addend) (0x%x)", fc);*/
			fc = 0; // XXX store ofs in LVAL(reg)
		}
		else if (v == VT_LLOCAL)
		{
			br = load_symofs(r, sv, 0);
			fc = sv->c.i;
			EI(0x03, 3, rr, br, fc); // ld RR, fc(BR)
			br = rr;
			fc = 0;
		}
		else
		{
			tcc_error("unimp: load(non-local lval)");
		}
		EI(opcode, func3, rr, br, fc); // l[bhwd][u] / fl[wd] RR, fc(BR)
	}
	else if (v == VT_CONST)
	{
		int rb = 0, do32bit = 8, zext = 0;
		assert((!is_float(sv->type.t) && is_ireg(r)) || bt == VT_LDOUBLE);
		if (fr & VT_SYM)
		{
			rb = load_symofs(r, sv, 0);
			fc = sv->c.i;
			do32bit = 0;
		}
		if (is_float(sv->type.t) && bt != VT_LDOUBLE)
			tcc_error("unimp: load(float)");
		if (fc != sv->c.i)
		{
			int64_t si = sv->c.i;
			uint32_t pi;
			si >>= 32;
			if (si != 0)
			{
				pi = si;
				if (fc < 0)
					pi++;
				o(0x37 | (rr << 7) | (((pi + 0x800) & 0xfffff000))); // lui RR, up(up(fc))
				EI(0x13, 0, rr, rr, (int)pi << 20 >> 20);   // addi RR, RR, lo(up(fc))
				EI(0x13, 1, rr, rr, 12); // slli RR, RR, 12
				EI(0x13, 0, rr, rr, (fc + (1 << 19)) >> 20);  // addi RR, RR, up(lo(fc))
				EI(0x13, 1, rr, rr, 12); // slli RR, RR, 12
				fc = fc << 12 >> 12;
				EI(0x13, 0, rr, rr, fc >> 8);  // addi RR, RR, lo1(lo(fc))
				EI(0x13, 1, rr, rr, 8); // slli RR, RR, 8
				fc &= 0xff;
				rb = rr;
				do32bit = 0;
			}
			else if (bt == VT_LLONG)
			{
				/* A 32bit unsigned constant for a 64bit type.
				   lui always sign extends, so we need to do an explicit zext.*/
				zext = 1;
			}
		}
		if (((unsigned)fc + (1 << 11)) >> 12)
			o(0x37 | (rr << 7) | ((0x800 + fc) & 0xfffff000)), rb = rr; //lui RR, upper(fc)
		if (fc || (rr != rb) || do32bit || (fr & VT_SYM))
			EI(0x13 | do32bit, 0, rr, rb, fc << 20 >> 20); // addi[w] R, x0|R, FC
		if (zext)
		{
			EI(0x13, 1, rr, rr, 32); // slli RR, RR, 32
			EI(0x13, 5, rr, rr, 32); // srli RR, RR, 32
		}
	}
	else if (v == VT_LOCAL)
	{
		int br = load_symofs(r, sv, 0);
		assert(is_ireg(r));
		fc = sv->c.i;
		EI(0x13, 0, rr, br, fc); // addi R, s0, FC
	}
	else if (v < VT_CONST)     /* reg-reg */
	{
		//assert(!fc); XXX support offseted regs
		if (is_freg(r) && is_freg(v))
			ER(0x53, 0, rr, freg(v), freg(v), bt == VT_DOUBLE ? 0x11 : 0x10); //fsgnj.[sd] RR, V, V == fmv.[sd] RR, V
		else if (is_ireg(r) && is_ireg(v))
			EI(0x13, 0, rr, ireg(v), 0); // addi RR, V, 0 == mv RR, V
		else
		{
			int func7 = is_ireg(r) ? 0x70 : 0x78;
			if (size == 8)
				func7 |= 1;
			assert(size == 4 || size == 8);
			o(0x53 | (rr << 7) | ((is_freg(v) ? freg(v) : ireg(v)) << 15)
			  | (func7 << 25)); // fmv.{w.x, x.w, d.x, x.d} RR, VR
		}
	}
	else if (v == VT_CMP)
	{
		int op = vtop->cmp_op;
		int a = vtop->cmp_r & 0xff;
		int b = (vtop->cmp_r >> 8) & 0xff;
		int inv = 0;
		switch (op)
		{
		case TOK_ULT:
		case TOK_UGE:
		case TOK_ULE:
		case TOK_UGT:
		case TOK_LT:
		case TOK_GE:
		case TOK_LE:
		case TOK_GT:
			if (op & 1)   // remove [U]GE,GT
			{
				inv = 1;
				op--;
			}
			if ((op & 7) == 6)   // [U]LE
			{
				int t = a;
				a = b;
				b = t;
				inv ^= 1;
			}
			ER(0x33, (op > TOK_UGT) ? 2 : 3, rr, a, b, 0); // slt[u] d, a, b
			if (inv)
				EI(0x13, 4, rr, rr, 1); // xori d, d, 1
			break;
		case TOK_NE:
		case TOK_EQ:
			if (rr != a || b)
				ER(0x33, 0, rr, a, b, 0x20); // sub d, a, b
			if (op == TOK_NE)
				ER(0x33, 3, rr, 0, rr, 0); // sltu d, x0, d == snez d,d
			else
				EI(0x13, 3, rr, rr, 1); // sltiu d, d, 1 == seqz d,d
			break;
		}
	}
	else if ((v & ~1) == VT_JMP)
	{
		int t = v & 1;
		assert(is_ireg(r));
		EI(0x13, 0, rr, 0, t);      // addi RR, x0, t
		gjmp_addr(ind + 8);
		gsym(fc);
		EI(0x13, 0, rr, 0, t ^ 1);  // addi RR, x0, !t
	}
	else
		tcc_error("unimp: load(non-const)");
}

ST_FUNC void store(int r, SValue *sv)
{
	int fr = sv->r & VT_VALMASK;
	int rr = is_ireg(r) ? ireg(r) : freg(r), ptrreg;
	int fc = sv->c.i;
	int bt = sv->type.t & VT_BTYPE;
	int align, size = type_size(&sv->type, &align);
	assert(!is_float(bt) || is_freg(r) || bt == VT_LDOUBLE);
	/* long doubles are in two integer registers, but the load/store
	   primitives only deal with one, so do as if it's one reg.  */
	if (bt == VT_LDOUBLE)
		size = align = 8;
	if (bt == VT_STRUCT)
		tcc_error("unimp: store(struct)");
	if (size > 8)
		tcc_error("unimp: large sized store");
	assert(sv->r & VT_LVAL);
	if (fr == VT_LOCAL || (sv->r & VT_SYM))
	{
		ptrreg = load_symofs(-1, sv, 1);
		fc = sv->c.i;
	}
	else if (fr < VT_CONST)
	{
		ptrreg = ireg(fr);
		/*if (((unsigned)fc + (1 << 11)) >> 12)
		  tcc_error("unimp: store(large addend) (0x%x)", fc);*/
		fc = 0; // XXX support offsets regs
	}
	else
		tcc_error("implement me: %s(!local)", __FUNCTION__);
	ES(is_freg(r) ? 0x27 : 0x23,                          // fs... | s...
	   size == 1 ? 0 : size == 2 ? 1 : size == 4 ? 2 : 3, // ... [wd] | [bhwd]
	   ptrreg, rr, fc);                                   // RR, fc(base)
}

static void gcall_or_jmp(int docall)
{
	int tr = docall ? 1 : 5; // ra or t0
	if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&
	        ((vtop->r & VT_SYM) && vtop->c.i == (int)vtop->c.i))
	{
		/* constant symbolic case -> simple relocation */
		greloca(cur_text_section, vtop->sym, ind,
		        R_RISCV_CALL_PLT, (int)vtop->c.i);
		o(0x17 | (tr << 7));   // auipc TR, 0 %call(func)
		EI(0x67, 0, tr, tr, 0);// jalr  TR, r(TR)
	}
	else if (vtop->r < VT_CONST)
	{
		int r = ireg(vtop->r);
		EI(0x67, 0, tr, r, 0);      // jalr TR, 0(R)
	}
	else
	{
		int r = TREG_RA;
		load(r, vtop);
		r = ireg(r);
		EI(0x67, 0, tr, r, 0);      // jalr TR, 0(R)
	}
}

static void reg_pass_rec(CType *type, int *rc, int *fieldofs, int ofs)
{
	if ((type->t & VT_BTYPE) == VT_STRUCT)
	{
		Sym *f;
		if (type->ref->type.t == VT_UNION)
			rc[0] = -1;
		else for (f = type->ref->next; f; f = f->next)
				reg_pass_rec(&f->type, rc, fieldofs, ofs + f->c);
	}
	else if (type->t & VT_ARRAY)
	{
		if (type->ref->c < 0 || type->ref->c > 2)
			rc[0] = -1;
		else
		{
			int a, sz = type_size(&type->ref->type, &a);
			reg_pass_rec(&type->ref->type, rc, fieldofs, ofs);
			if (rc[0] > 2 || (rc[0] == 2 && type->ref->c > 1))
				rc[0] = -1;
			else if (type->ref->c == 2 && rc[0] && rc[1] == RC_FLOAT)
			{
				rc[++rc[0]] = RC_FLOAT;
				fieldofs[rc[0]] = ((ofs + sz) << 4)
				                  | (type->ref->type.t & VT_BTYPE);
			}
			else if (type->ref->c == 2)
				rc[0] = -1;
		}
	}
	else if (rc[0] == 2 || rc[0] < 0 || (type->t & VT_BTYPE) == VT_LDOUBLE)
		rc[0] = -1;
	else if (!rc[0] || rc[1] == RC_FLOAT || is_float(type->t))
	{
		rc[++rc[0]] = is_float(type->t) ? RC_FLOAT : RC_INT;
		fieldofs[rc[0]] = (ofs << 4) | (type->t & VT_BTYPE);
	}
	else
		rc[0] = -1;
}

static void reg_pass(CType *type, int *prc, int *fieldofs, int named)
{
	prc[0] = 0;
	reg_pass_rec(type, prc, fieldofs, 0);
	if (prc[0] <= 0 || !named)
	{
		int align, size = type_size(type, &align);
		prc[0] = (size + 7) >> 3;
		prc[1] = prc[2] = RC_INT;
		fieldofs[1] = (0 << 4) | (size <= 1 ? VT_BYTE : size <= 2 ? VT_SHORT : size <= 4 ? VT_INT : VT_LLONG);
		fieldofs[2] = (8 << 4) | (size <= 9 ? VT_BYTE : size <= 10 ? VT_SHORT : size <= 12 ? VT_INT : VT_LLONG);
	}
}

ST_FUNC void gfunc_call(int nb_args)
{
	int i, align, size, areg[2];
	int info[nb_args ? nb_args : 1];
	int stack_adj = 0, tempspace = 0, ofs, splitofs = 0;
	SValue *sv;
	Sym *sa;
	areg[0] = 0; /* int arg regs */
	areg[1] = 8; /* float arg regs */
	sa = vtop[-nb_args].type.ref->next;
	for (i = 0; i < nb_args; i++)
	{
		int nregs, byref = 0, tempofs;
		int prc[3], fieldofs[3];
		sv = &vtop[1 + i - nb_args];
		sv->type.t &= ~VT_ARRAY; // XXX this should be done in tccgen.c
		size = type_size(&sv->type, &align);
		if (size > 16)
		{
			if (align < XLEN)
				align = XLEN;
			tempspace = (tempspace + align - 1) & -align;
			tempofs = tempspace;
			tempspace += size;
			size = align = 8;
			byref = 64 | (tempofs << 7);
		}
		reg_pass(&sv->type, prc, fieldofs, sa != 0);
		if (!sa && align == 2*XLEN && size <= 2*XLEN)
			areg[0] = (areg[0] + 1) & ~1;
		nregs = prc[0];
		if ((prc[1] == RC_INT && areg[0] >= 8)
		        || (prc[1] == RC_FLOAT && areg[1] >= 16)
		        || (nregs == 2 && prc[1] == RC_FLOAT && prc[2] == RC_FLOAT
		            && areg[1] >= 15)
		        || (nregs == 2 && prc[1] != prc[2]
		            && (areg[1] >= 16 || areg[0] >= 8)))
		{
			info[i] = 32;
			if (align < XLEN)
				align = XLEN;
			stack_adj += (size + align - 1) & -align;
			if (!sa) /* one vararg on stack forces the rest on stack */
				areg[0] = 8, areg[1] = 16;
		}
		else
		{
			info[i] = areg[prc[1] - 1]++;
			if (!byref)
				info[i] |= (fieldofs[1] & VT_BTYPE) << 12;
			assert(!(fieldofs[1] >> 4));
			if (nregs == 2)
			{
				if (prc[2] == RC_FLOAT || areg[0] < 8)
					info[i] |= (1 + areg[prc[2] - 1]++) << 7;
				else
				{
					info[i] |= 16;
					stack_adj += 8;
				}
				if (!byref)
				{
					assert((fieldofs[2] >> 4) < 2048);
					info[i] |= fieldofs[2] << (12 + 4); // includes offset
				}
			}
		}
		info[i] |= byref;
		if (sa)
			sa = sa->next;
	}
	stack_adj = (stack_adj + 15) & -16;
	tempspace = (tempspace + 15) & -16;
	if (stack_adj + tempspace)
	{
		EI(0x13, 0, 2, 2, -(stack_adj + tempspace));   // addi sp, sp, -adj
		for (i = ofs = 0; i < nb_args; i++)
		{
			if (info[i] & (64 | 32))
			{
				vrotb(nb_args - i);
				size = type_size(&vtop->type, &align);
				if (info[i] & 64)
				{
					vset(&char_pointer_type, TREG_SP, 0);
					vpushi(stack_adj + (info[i] >> 7));
					gen_op('+');
					vpushv(vtop); // this replaces the old argument
					vrott(3);
					indir();
					vtop->type = vtop[-1].type;
					vswap();
					vstore();
					vpop();
					size = align = 8;
				}
				if (info[i] & 32)
				{
					if (align < XLEN)
						align = XLEN;
					/* Once we support offseted regs we can do this:
					   vset(&vtop->type, TREG_SP | VT_LVAL, ofs);
					   to construct the lvalue for the outgoing stack slot,
					   until then we have to jump through hoops.  */
					vset(&char_pointer_type, TREG_SP, 0);
					ofs = (ofs + align - 1) & -align;
					vpushi(ofs);
					gen_op('+');
					indir();
					vtop->type = vtop[-1].type;
					vswap();
					vstore();
					vtop->r = vtop->r2 = VT_CONST; // this arg is done
					ofs += size;
				}
				vrott(nb_args - i);
			}
			else if (info[i] & 16)
			{
				assert(!splitofs);
				splitofs = ofs;
				ofs += 8;
			}
		}
	}
	for (i = 0; i < nb_args; i++)
	{
		int ii = info[nb_args - 1 - i], r = ii, r2 = r;
		if (!(r & 32))
		{
			CType origtype;
			int loadt;
			r &= 15;
			r2 = r2 & 64 ? 0 : (r2 >> 7) & 31;
			assert(r2 <= 16);
			vrotb(i+1);
			origtype = vtop->type;
			size = type_size(&vtop->type, &align);
			loadt = vtop->type.t & VT_BTYPE;
			if (loadt == VT_STRUCT)
			{
				loadt = (ii >> 12) & VT_BTYPE;
			}
			if (info[nb_args - 1 - i] & 16)
			{
				assert(!r2);
				r2 = 1 + TREG_RA;
			}
			if (loadt == VT_LDOUBLE)
			{
				assert(r2);
				r2--;
			}
			else if (r2)
			{
				test_lvalue();
				vpushv(vtop);
			}
			vtop->type.t = loadt | (vtop->type.t & VT_UNSIGNED);
			gv(r < 8 ? RC_R(r) : RC_F(r - 8));
			vtop->type = origtype;

			if (r2 && loadt != VT_LDOUBLE)
			{
				r2--;
				assert(r2 < 16 || r2 == TREG_RA);
				vswap();
				gaddrof();
				vtop->type = char_pointer_type;
				vpushi(ii >> 20);
				gen_op('+');
				indir();
				vtop->type = origtype;
				loadt = vtop->type.t & VT_BTYPE;
				if (loadt == VT_STRUCT)
				{
					loadt = (ii >> 16) & VT_BTYPE;
				}
				save_reg_upstack(r2, 1);
				vtop->type.t = loadt | (vtop->type.t & VT_UNSIGNED);
				load(r2, vtop);
				assert(r2 < VT_CONST);
				vtop--;
				vtop->r2 = r2;
			}
			if (info[nb_args - 1 - i] & 16)
			{
				ES(0x23, 3, 2, ireg(vtop->r2), splitofs); // sd t0, ofs(sp)
				vtop->r2 = VT_CONST;
			}
			else if (loadt == VT_LDOUBLE && vtop->r2 != r2)
			{
				assert(vtop->r2 <= 7 && r2 <= 7);
				/* XXX we'd like to have 'gv' move directly into
				   the right class instead of us fixing it up.  */
				EI(0x13, 0, ireg(r2), ireg(vtop->r2), 0); // mv Ra+1, RR2
				vtop->r2 = r2;
			}
			vrott(i+1);
		}
	}
	vrotb(nb_args + 1);
	save_regs(nb_args + 1);
	gcall_or_jmp(1);
	vtop -= nb_args + 1;
	if (stack_adj + tempspace)
		EI(0x13, 0, 2, 2, stack_adj + tempspace);      // addi sp, sp, adj
}

static int func_sub_sp_offset, num_va_regs, func_va_list_ofs;

ST_FUNC void gfunc_prolog(Sym *func_sym)
{
	CType *func_type = &func_sym->type;
	int i, addr, align, size;
	int param_addr = 0;
	int areg[2];
	Sym *sym;
	CType *type;

	sym = func_type->ref;
	func_vt = sym->type;
	loc = -16; // for ra and s0
	func_sub_sp_offset = ind;
	ind += 5 * 4;

	areg[0] = 0, areg[1] = 0;
	addr = 0;
	/* if the function returns by reference, then add an
	   implicit pointer parameter */
	size = type_size(&func_vt, &align);
	if (size > 2 * XLEN)
	{
		loc -= 8;
		func_vc = loc;
		ES(0x23, 3, 8, 10 + areg[0]++, loc); // sd a0, loc(s0)
	}
	/* define parameters */
	while ((sym = sym->next) != NULL)
	{
		int byref = 0;
		int regcount;
		int prc[3], fieldofs[3];
		type = &sym->type;
		size = type_size(type, &align);
		if (size > 2 * XLEN)
		{
			type = &char_pointer_type;
			size = align = byref = 8;
		}
		reg_pass(type, prc, fieldofs, 1);
		regcount = prc[0];
		if (areg[prc[1] - 1] >= 8
		        || (regcount == 2
		            && ((prc[1] == RC_FLOAT && prc[2] == RC_FLOAT && areg[1] >= 7)
		                || (prc[1] != prc[2] && (areg[1] >= 8 || areg[0] >= 8)))))
		{
			if (align < XLEN)
				align = XLEN;
			addr = (addr + align - 1) & -align;
			param_addr = addr;
			addr += size;
		}
		else
		{
			loc -= regcount * 8; // XXX could reserve only 'size' bytes
			param_addr = loc;
			for (i = 0; i < regcount; i++)
			{
				if (areg[prc[1+i] - 1] >= 8)
				{
					assert(i == 1 && regcount == 2 && !(addr & 7));
					EI(0x03, 3, 5, 8, addr); // ld t0, addr(s0)
					addr += 8;
					ES(0x23, 3, 8, 5, loc + i*8); // sd t0, loc(s0)
				}
				else if (prc[1+i] == RC_FLOAT)
				{
					ES(0x27, (size / regcount) == 4 ? 2 : 3, 8, 10 + areg[1]++, loc + (fieldofs[i+1] >> 4)); // fs[wd] FAi, loc(s0)
				}
				else
				{
					ES(0x23, 3, 8, 10 + areg[0]++, loc + i*8); // sd aX, loc(s0) // XXX
				}
			}
		}
		sym_push(sym->v & ~SYM_FIELD, &sym->type,
		         (byref ? VT_LLOCAL : VT_LOCAL) | VT_LVAL,
		         param_addr);
	}
	func_va_list_ofs = addr;
	num_va_regs = 0;
	if (func_type->ref->f.func_type == FUNC_ELLIPSIS)
	{
		for (; areg[0] < 8; areg[0]++)
		{
			num_va_regs++;
			ES(0x23, 3, 8, 10 + areg[0], -8 + num_va_regs * 8); // sd aX, loc(s0)
		}
	}
}

ST_FUNC int gfunc_sret(CType *vt, int variadic, CType *ret,
                       int *ret_align, int *regsize)
{
	int align, size = type_size(vt, &align), nregs;
	int prc[3], fieldofs[3];
	*ret_align = 1;
	*regsize = 8;
	if (size > 16)
		return 0;
	reg_pass(vt, prc, fieldofs, 1);
	nregs = prc[0];
	if (nregs == 2 && prc[1] != prc[2])
		return -1;  /* generic code can't deal with this case */
	if (prc[1] == RC_FLOAT)
	{
		*regsize = size / nregs;
	}
	ret->t = fieldofs[1] & VT_BTYPE;
	return nregs;
}

ST_FUNC void arch_transfer_ret_regs(int aftercall)
{
	int prc[3], fieldofs[3];
	reg_pass(&vtop->type, prc, fieldofs, 1);
	assert(prc[0] == 2 && prc[1] != prc[2] && !(fieldofs[1] >> 4));
	assert(vtop->r == (VT_LOCAL | VT_LVAL));
	vpushv(vtop);
	vtop->type.t = fieldofs[1] & VT_BTYPE;
	(aftercall ? store : load)(prc[1] == RC_INT ? REG_IRET : REG_FRET, vtop);
	vtop->c.i += fieldofs[2] >> 4;
	vtop->type.t = fieldofs[2] & VT_BTYPE;
	(aftercall ? store : load)(prc[2] == RC_INT ? REG_IRET : REG_FRET, vtop);
	vtop--;
}

ST_FUNC void gfunc_epilog(void)
{
	int v, saved_ind, d, large_ofs_ind;

	loc = (loc - num_va_regs * 8);
	d = v = (-loc + 15) & -16;

	if (v >= (1 << 11))
	{
		d = 16;
		o(0x37 | (5 << 7) | ((0x800 + (v-16)) & 0xfffff000)); //lui t0, upper(v)
		EI(0x13, 0, 5, 5, (v-16) << 20 >> 20); // addi t0, t0, lo(v)
		ER(0x33, 0, 2, 2, 5, 0); // add sp, sp, t0
	}
	EI(0x03, 3, 1, 2, d - 8 - num_va_regs * 8);  // ld ra, v-8(sp)
	EI(0x03, 3, 8, 2, d - 16 - num_va_regs * 8); // ld s0, v-16(sp)
	EI(0x13, 0, 2, 2, d);      // addi sp, sp, v
	EI(0x67, 0, 0, 1, 0);      // jalr x0, 0(x1), aka ret
	large_ofs_ind = ind;
	if (v >= (1 << 11))
	{
		EI(0x13, 0, 8, 2, d - num_va_regs * 8);      // addi s0, sp, d
		o(0x37 | (5 << 7) | ((0x800 + (v-16)) & 0xfffff000)); //lui t0, upper(v)
		EI(0x13, 0, 5, 5, (v-16) << 20 >> 20); // addi t0, t0, lo(v)
		ER(0x33, 0, 2, 2, 5, 0x20); // sub sp, sp, t0
		gjmp_addr(func_sub_sp_offset + 5*4);
	}
	saved_ind = ind;

	ind = func_sub_sp_offset;
	EI(0x13, 0, 2, 2, -d);     // addi sp, sp, -d
	ES(0x23, 3, 2, 1, d - 8 - num_va_regs * 8);  // sd ra, d-8(sp)
	ES(0x23, 3, 2, 8, d - 16 - num_va_regs * 8); // sd s0, d-16(sp)
	if (v < (1 << 11))
		EI(0x13, 0, 8, 2, d - num_va_regs * 8);      // addi s0, sp, d
	else
		gjmp_addr(large_ofs_ind);
	if ((ind - func_sub_sp_offset) != 5*4)
		EI(0x13, 0, 0, 0, 0);      // addi x0, x0, 0 == nop
	ind = saved_ind;
}

ST_FUNC void gen_va_start(void)
{
	vtop--;
	vset(&char_pointer_type, VT_LOCAL, func_va_list_ofs);
}

ST_FUNC void gen_fill_nops(int bytes)
{
	if ((bytes & 3))
		tcc_error("alignment of code section not multiple of 4");
	while (bytes > 0)
	{
		EI(0x13, 0, 0, 0, 0);      // addi x0, x0, 0 == nop
		bytes -= 4;
	}
}

// Generate forward branch to label:
ST_FUNC int gjmp(int t)
{
	if (nocode_wanted)
		return t;
	o(t);
	return ind - 4;
}

// Generate branch to known address:
ST_FUNC void gjmp_addr(int a)
{
	uint32_t r = a - ind, imm;
	if ((r + (1 << 21)) & ~((1U << 22) - 2))
	{
		o(0x17 | (5 << 7) | (((r + 0x800) & 0xfffff000))); // lui RR, up(r)
		r = (int)r << 20 >> 20;
		EI(0x67, 0, 0, 5, r);      // jalr x0, r(t0)
	}
	else
	{
		imm = (((r >> 12) &  0xff) << 12)
		      | (((r >> 11) &     1) << 20)
		      | (((r >>  1) & 0x3ff) << 21)
		      | (((r >> 20) &     1) << 31);
		o(0x6f | imm); // jal x0, imm ==  j imm
	}
}

ST_FUNC int gjmp_cond(int op, int t)
{
	int tmp;
	int a = vtop->cmp_r & 0xff;
	int b = (vtop->cmp_r >> 8) & 0xff;
	switch (op)
	{
	case TOK_ULT:
		op = 6;
		break;
	case TOK_UGE:
		op = 7;
		break;
	case TOK_ULE:
		op = 7;
		tmp = a;
		a = b;
		b = tmp;
		break;
	case TOK_UGT:
		op = 6;
		tmp = a;
		a = b;
		b = tmp;
		break;
	case TOK_LT:
		op = 4;
		break;
	case TOK_GE:
		op = 5;
		break;
	case TOK_LE:
		op = 5;
		tmp = a;
		a = b;
		b = tmp;
		break;
	case TOK_GT:
		op = 4;
		tmp = a;
		a = b;
		b = tmp;
		break;
	case TOK_NE:
		op = 1;
		break;
	case TOK_EQ:
		op = 0;
		break;
	}
	o(0x63 | (op ^ 1) << 12 | a << 15 | b << 20 | 8 << 7); // bOP a,b,+4
	return gjmp(t);
}

ST_FUNC int gjmp_append(int n, int t)
{
	void *p;
	/* insert jump list n into t */
	if (n)
	{
		uint32_t n1 = n, n2;
		while ((n2 = read32le(p = cur_text_section->data + n1)))
			n1 = n2;
		write32le(p, t);
		t = n;
	}
	return t;
}

static void gen_opil(int op, int ll)
{
	int a, b, d;
	int func3 = 0;
	ll = ll ? 0 : 8;
	if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
	{
		int fc = vtop->c.i;
		if (fc == vtop->c.i && !(((unsigned)fc + (1 << 11)) >> 12))
		{
			int cll = 0;
			vswap();
			gv(RC_INT);
			a = ireg(vtop[0].r);
			--vtop;
			d = get_reg(RC_INT);
			++vtop;
			vswap();
			switch (op)
			{
			case '-':
				if (fc <= -(1 << 11))
					break;
				fc = -fc;
			case '+':
				func3 = 0; // addi d, a, fc
do_cop:
				EI(0x13 | cll, func3, ireg(d), a, fc);
				--vtop;
				if (op >= TOK_ULT && op <= TOK_GT)
				{
					vset_VT_CMP(TOK_NE);
					vtop->cmp_r = ireg(d) | 0 << 8;
				}
				else
					vtop[0].r = d;
				return;
			case TOK_LE:
				if (fc >= (1 << 11) - 1)
					break;
				++fc;
			case TOK_LT:
				func3 = 2;
				goto do_cop; // slti d, a, fc
			case TOK_ULE:
				if (fc >= (1 << 11) - 1)
					break;
				++fc;
			case TOK_ULT:
				func3 = 3;
				goto do_cop; // sltiu d, a, fc
			case '^':
				func3 = 4;
				goto do_cop; // xori d, a, fc
			case '|':
				func3 = 6;
				goto do_cop; // ori  d, a, fc
			case '&':
				func3 = 7;
				goto do_cop; // andi d, a, fc
			case TOK_SHL:
				func3 = 1;
				fc &= 63;
				goto do_cop; // slli d, a, fc
			case TOK_SHR:
				func3 = 5;
				cll = ll;
				fc &= 63;
				goto do_cop; // srli d, a, fc
			case TOK_SAR:
				func3 = 5;
				cll = ll;
				fc = 1024 | (fc & 63);
				goto do_cop;

			case TOK_UGE:
			case TOK_UGT:
			case TOK_GE:
			case TOK_GT:
				gen_opil(op - 1, ll);
				vtop->cmp_op ^= 1;
				return;

			case TOK_NE:
			case TOK_EQ:
				if (fc)
					gen_opil('-', ll), a = ireg(vtop++->r);
				--vtop;
				vset_VT_CMP(op);
				vtop->cmp_r = a | 0 << 8;
				return;
			}
		}
	}
	gv2(RC_INT, RC_INT);
	a = ireg(vtop[-1].r);
	b = ireg(vtop[0].r);
	vtop -= 2;
	d = get_reg(RC_INT);
	vtop++;
	vtop[0].r = d;
	d = ireg(d);
	switch (op)
	{
	default:
		if (op >= TOK_ULT && op <= TOK_GT)
		{
			vset_VT_CMP(op);
			vtop->cmp_r = a | b << 8;
			break;
		}
		tcc_error("implement me: %s(%s)", __FUNCTION__, get_tok_str(op, NULL));
		break;

	case '+':
		ER(0x33, 0, d, a, b, 0); // add d, a, b
		break;
	case '-':
		ER(0x33, 0, d, a, b, 0x20); // sub d, a, b
		break;
	case TOK_SAR:
		ER(0x33 | ll, 5, d, a, b, 0x20); // sra d, a, b
		break;
	case TOK_SHR:
		ER(0x33 | ll, 5, d, a, b, 0); // srl d, a, b
		break;
	case TOK_SHL:
		ER(0x33, 1, d, a, b, 0); // sll d, a, b
		break;
	case '*':
		ER(0x33, 0, d, a, b, 1); // mul d, a, b
		break;
	case '/':
		ER(0x33, 4, d, a, b, 1); // div d, a, b
		break;
	case '&':
		ER(0x33, 7, d, a, b, 0); // and d, a, b
		break;
	case '^':
		ER(0x33, 4, d, a, b, 0); // xor d, a, b
		break;
	case '|':
		ER(0x33, 6, d, a, b, 0); // or d, a, b
		break;
	case '%':
		ER(0x33, 6, d, a, b, 1); // rem d, a, b
		break;
	case TOK_UMOD:
		ER(0x33, 7, d, a, b, 1); // remu d, a, b
		break;
	case TOK_PDIV:
	case TOK_UDIV:
		ER(0x33, 5, d, a, b, 1); // divu d, a, b
		break;
	}
}

ST_FUNC void gen_opi(int op)
{
	gen_opil(op, 0);
}

ST_FUNC void gen_opl(int op)
{
	gen_opil(op, 1);
}

ST_FUNC void gen_opf(int op)
{
	int rs1, rs2, rd, dbl, invert;
	if (vtop[0].type.t == VT_LDOUBLE)
	{
		CType type = vtop[0].type;
		int func = 0;
		int cond = -1;
		switch (op)
		{
		case '*':
			func = TOK___multf3;
			break;
		case '+':
			func = TOK___addtf3;
			break;
		case '-':
			func = TOK___subtf3;
			break;
		case '/':
			func = TOK___divtf3;
			break;
		case TOK_EQ:
			func = TOK___eqtf2;
			cond = 1;
			break;
		case TOK_NE:
			func = TOK___netf2;
			cond = 0;
			break;
		case TOK_LT:
			func = TOK___lttf2;
			cond = 10;
			break;
		case TOK_GE:
			func = TOK___getf2;
			cond = 11;
			break;
		case TOK_LE:
			func = TOK___letf2;
			cond = 12;
			break;
		case TOK_GT:
			func = TOK___gttf2;
			cond = 13;
			break;
		default:
			assert(0);
			break;
		}
		vpush_global_sym(&func_old_type, func);
		vrott(3);
		gfunc_call(2);
		vpushi(0);
		vtop->r = REG_IRET;
		vtop->r2 = cond < 0 ? TREG_R(1) : VT_CONST;
		if (cond < 0)
			vtop->type = type;
		else
		{
			vpushi(0);
			gen_opil(op, 1);
		}
		return;
	}

	gv2(RC_FLOAT, RC_FLOAT);
	assert(vtop->type.t == VT_DOUBLE || vtop->type.t == VT_FLOAT);
	dbl = vtop->type.t == VT_DOUBLE;
	rs1 = freg(vtop[-1].r);
	rs2 = freg(vtop->r);
	vtop--;
	invert = 0;
	switch(op)
	{
	default:
		assert(0);
	case '+':
		op = 0; // fadd
arithop:
		rd = get_reg(RC_FLOAT);
		vtop->r = rd;
		rd = freg(rd);
		ER(0x53, 7, rd, rs1, rs2, dbl | (op << 2)); // fop.[sd] RD, RS1, RS2 (dyn rm)
		break;
	case '-':
		op = 1; // fsub
		goto arithop;
	case '*':
		op = 2; // fmul
		goto arithop;
	case '/':
		op = 3; // fdiv
		goto arithop;
	case TOK_EQ:
		op = 2; // EQ
cmpop:
		rd = get_reg(RC_INT);
		vtop->r = rd;
		rd = ireg(rd);
		ER(0x53, op, rd, rs1, rs2, dbl | 0x50); // fcmp.[sd] RD, RS1, RS2 (op == eq/lt/le)
		if (invert)
			EI(0x13, 4, rd, rd, 1); // xori RD, 1
		break;
	case TOK_NE:
		invert = 1;
		op = 2; // EQ
		goto cmpop;
	case TOK_LT:
		op = 1; // LT
		goto cmpop;
	case TOK_LE:
		op = 0; // LE
		goto cmpop;
	case TOK_GT:
		op = 1; // LT
		rd = rs1, rs1 = rs2, rs2 = rd;
		goto cmpop;
	case TOK_GE:
		op = 0; // LE
		rd = rs1, rs1 = rs2, rs2 = rd;
		goto cmpop;
	}
}

ST_FUNC void gen_cvt_sxtw(void)
{
	/* XXX on risc-v the registers are usually sign-extended already.
	   Let's try to not do anything here.  */
}

ST_FUNC void gen_cvt_itof(int t)
{
	int rr = ireg(gv(RC_INT)), dr;
	int u = vtop->type.t & VT_UNSIGNED;
	int l = (vtop->type.t & VT_BTYPE) == VT_LLONG;
	if (t == VT_LDOUBLE)
	{
		int func = l ?
		           (u ? TOK___floatunditf : TOK___floatditf) :
		           (u ? TOK___floatunsitf : TOK___floatsitf);
		vpush_global_sym(&func_old_type, func);
		vrott(2);
		gfunc_call(1);
		vpushi(0);
		vtop->type.t = t;
		vtop->r = REG_IRET;
		vtop->r2 = TREG_R(1);
	}
	else
	{
		vtop--;
		dr = get_reg(RC_FLOAT);
		vtop++;
		vtop->r = dr;
		dr = freg(dr);
		EIu(0x53, 7, dr, rr, ((0x68 | (t == VT_DOUBLE ? 1 : 0)) << 5) | (u ? 1 : 0) | (l ? 2 : 0)); // fcvt.[sd].[wl][u]
	}
}

ST_FUNC void gen_cvt_ftoi(int t)
{
	int ft = vtop->type.t & VT_BTYPE;
	int l = (t & VT_BTYPE) == VT_LLONG;
	int u = t & VT_UNSIGNED;
	if (ft == VT_LDOUBLE)
	{
		int func = l ?
		           (u ? TOK___fixunstfdi : TOK___fixtfdi) :
		           (u ? TOK___fixunstfsi : TOK___fixtfsi);
		vpush_global_sym(&func_old_type, func);
		vrott(2);
		gfunc_call(1);
		vpushi(0);
		vtop->type.t = t;
		vtop->r = REG_IRET;
	}
	else
	{
		int rr = freg(gv(RC_FLOAT)), dr;
		vtop--;
		dr = get_reg(RC_INT);
		vtop++;
		vtop->r = dr;
		dr = ireg(dr);
		EIu(0x53, 1, dr, rr, ((0x60 | (ft == VT_DOUBLE ? 1 : 0)) << 5) | (u ? 1 : 0) | (l ? 2 : 0)); // fcvt.[wl][u].[sd] rtz
	}
}

ST_FUNC void gen_cvt_ftof(int dt)
{
	int st = vtop->type.t & VT_BTYPE, rs, rd;
	dt &= VT_BTYPE;
	if (st == dt)
		return;
	if (dt == VT_LDOUBLE || st == VT_LDOUBLE)
	{
		int func = (dt == VT_LDOUBLE) ?
		           (st == VT_FLOAT ? TOK___extendsftf2 : TOK___extenddftf2) :
		           (dt == VT_FLOAT ? TOK___trunctfsf2 : TOK___trunctfdf2);
		/* We can't use gfunc_call, as func_old_type works like vararg
		   functions, and on riscv unnamed float args are passed like
		   integers.  But we really need them in the float argument registers
		   for extendsftf2/extenddftf2.  So, do it explicitely.  */
		save_regs(1);
		if (dt == VT_LDOUBLE)
			gv(RC_F(0));
		else
		{
			gv(RC_R(0));
			assert(vtop->r2 < 7);
			if (vtop->r2 != 1 + vtop->r)
			{
				EI(0x13, 0, ireg(vtop->r) + 1, ireg(vtop->r2), 0); // mv Ra+1, RR2
				vtop->r2 = 1 + vtop->r;
			}
		}
		vpush_global_sym(&func_old_type, func);
		gcall_or_jmp(1);
		vtop -= 2;
		vpushi(0);
		vtop->type.t = dt;
		if (dt == VT_LDOUBLE)
			vtop->r = REG_IRET, vtop->r2 = REG_IRET+1;
		else
			vtop->r = REG_FRET;
	}
	else
	{
		assert (dt == VT_FLOAT || dt == VT_DOUBLE);
		assert (st == VT_FLOAT || st == VT_DOUBLE);
		rs = gv(RC_FLOAT);
		rd = get_reg(RC_FLOAT);
		if (dt == VT_DOUBLE)
			EI(0x53, 7, freg(rd), freg(rs), 0x21 << 5); // fcvt.d.s RD, RS (dyn rm)
		else
			EI(0x53, 7, freg(rd), freg(rs), (0x20 << 5) | 1); // fcvt.s.d RD, RS
		vtop->r = rd;
	}
}

ST_FUNC void ggoto(void)
{
	gcall_or_jmp(0);
	vtop--;
}

ST_FUNC void gen_vla_sp_save(int addr)
{
	ES(0x23, 3, 8, 2, addr); // sd sp, fc(s0)
}

ST_FUNC void gen_vla_sp_restore(int addr)
{
	EI(0x03, 3, 2, 8, addr); // ld sp, fc(s0)
}

ST_FUNC void gen_vla_alloc(CType *type, int align)
{
	int rr = ireg(gv(RC_INT));
	EI(0x13, 0, rr, rr, 15);   // addi RR, RR, 15
	EI(0x13, 7, rr, rr, -16);  // andi, RR, RR, -16
	ER(0x33, 0, 2, 2, rr, 0x20); // sub sp, sp, rr
	vpop();
}
//END riscv64-gen.c

//START riscv64-link.c

//#define DEBUG_RELOC
#undef TCC_STATE_VAR
#undef TCC_SET_STATE
# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

/* Returns 1 for a code relocation, 0 for a data relocation. For unknown
   relocations, returns -1. */
int code_reloc (int reloc_type)
{
	switch (reloc_type)
	{

	case R_RISCV_BRANCH:
	case R_RISCV_CALL:
	case R_RISCV_JAL:
		return 1;

	case R_RISCV_GOT_HI20:
	case R_RISCV_PCREL_HI20:
	case R_RISCV_PCREL_LO12_I:
	case R_RISCV_PCREL_LO12_S:
	case R_RISCV_32_PCREL:
	case R_RISCV_SET6:
	case R_RISCV_SUB6:
	case R_RISCV_ADD16:
	case R_RISCV_ADD32:
	case R_RISCV_ADD64:
	case R_RISCV_SUB16:
	case R_RISCV_SUB32:
	case R_RISCV_SUB64:
	case R_RISCV_32:
	case R_RISCV_64:
		return 0;

	case R_RISCV_CALL_PLT:
		return 1;
	}
	return -1;
}

/* Returns an enumerator to describe whether and when the relocation needs a
   GOT and/or PLT entry to be created. See tcc.h for a description of the
   different values. */
int gotplt_entry_type (int reloc_type)
{
	switch (reloc_type)
	{
	case R_RISCV_ALIGN:
	case R_RISCV_RELAX:
	case R_RISCV_RVC_BRANCH:
	case R_RISCV_RVC_JUMP:
	case R_RISCV_JUMP_SLOT:
	case R_RISCV_SET6:
	case R_RISCV_SUB6:
	case R_RISCV_ADD16:
	case R_RISCV_SUB16:
		return NO_GOTPLT_ENTRY;

	case R_RISCV_BRANCH:
	case R_RISCV_CALL:
	case R_RISCV_PCREL_HI20:
	case R_RISCV_PCREL_LO12_I:
	case R_RISCV_PCREL_LO12_S:
	case R_RISCV_32_PCREL:
	case R_RISCV_ADD32:
	case R_RISCV_ADD64:
	case R_RISCV_SUB32:
	case R_RISCV_SUB64:
	case R_RISCV_32:
	case R_RISCV_64:
	case R_RISCV_JAL:
	case R_RISCV_CALL_PLT:
		return AUTO_GOTPLT_ENTRY;

	case R_RISCV_GOT_HI20:
		return ALWAYS_GOTPLT_ENTRY;
	}
	return -1;
}

ST_FUNC unsigned create_plt_entry(TCCState *s1, unsigned got_offset, struct sym_attr *attr)
{
	Section *plt = s1->plt;
	uint8_t *p;
	unsigned plt_offset;

	if (s1->output_type == TCC_OUTPUT_DLL)
		tcc_error("DLLs unimplemented!");

	if (plt->data_offset == 0)
		section_ptr_add(plt, 32);
	plt_offset = plt->data_offset;

	p = section_ptr_add(plt, 16);
	write64le(p, got_offset);
	return plt_offset;
}

/* relocate the PLT: compute addresses and offsets in the PLT now that final
   address for PLT and GOT are known (see fill_program_header) */
ST_FUNC void relocate_plt(TCCState *s1)
{
	uint8_t *p, *p_end;

	if (!s1->plt)
		return;

	p = s1->plt->data;
	p_end = p + s1->plt->data_offset;

	if (p < p_end)
	{
		uint64_t plt = s1->plt->sh_addr;
		uint64_t got = s1->got->sh_addr;
		uint64_t off = (got - plt + 0x800) >> 12;
		if ((off + ((uint32_t)1 << 20)) >> 21)
			tcc_error("Failed relocating PLT (off=0x%lx, got=0x%lx, plt=0x%lx)", off, got, plt);
		write32le(p, 0x397 | (off << 12)); // auipc t2, %pcrel_hi(got)
		write32le(p + 4, 0x41c30333); // sub t1, t1, t3
		write32le(p + 8, 0x0003be03   // ld t3, %pcrel_lo(got)(t2)
		          | (((got - plt) & 0xfff) << 20));
		write32le(p + 12, 0xfd430313); // addi t1, t1, -(32+12)
		write32le(p + 16, 0x00038293   // addi t0, t2, %pcrel_lo(got)
		          | (((got - plt) & 0xfff) << 20));
		write32le(p + 20, 0x00135313); // srli t1, t1, log2(16/PTRSIZE)
		write32le(p + 24, 0x0082b283); // ld t0, PTRSIZE(t0)
		write32le(p + 28, 0x000e0067); // jr t3
		p += 32;
		while (p < p_end)
		{
			uint64_t pc = plt + (p - s1->plt->data);
			uint64_t addr = got + read64le(p);
			uint64_t off = (addr - pc + 0x800) >> 12;
			if ((off + ((uint32_t)1 << 20)) >> 21)
				tcc_error("Failed relocating PLT (off=0x%lx, addr=0x%lx, pc=0x%lx)", off, addr, pc);
			write32le(p, 0xe17 | (off << 12)); // auipc t3, %pcrel_hi(func@got)
			write32le(p + 4, 0x000e3e03 // ld t3, %pcrel_lo(func@got)(t3)
			          | (((addr - pc) & 0xfff) << 20));
			write32le(p + 8, 0x000e0367); // jalr t1, t3
			write32le(p + 12, 0x00000013); // nop
			p += 16;
		}
	}
}

struct pcrel_hi
{
	addr_t addr, val;
};
static struct pcrel_hi last_hi;

void relocate(TCCState *s1, ElfW_Rel *rel, int type, unsigned char *ptr,
              addr_t addr, addr_t val)
{
	uint64_t off64;
	uint32_t off32;
	int sym_index = ELFW(R_SYM)(rel->r_info);
	ElfW(Sym) *sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];

	switch(type)
	{
	case R_RISCV_ALIGN:
	case R_RISCV_RELAX:
		return;

	case R_RISCV_BRANCH:
		off64 = val - addr;
		if ((off64 + (1 << 12)) & ~(uint64_t)0x1ffe)
			tcc_error("R_RISCV_BRANCH relocation failed"
			          " (val=%lx, addr=%lx)", val, addr);
		off32 = off64 >> 1;
		write32le(ptr, (read32le(ptr) & ~0xfe000f80)
		          | ((off32 & 0x800) << 20)
		          | ((off32 & 0x3f0) << 21)
		          | ((off32 & 0x00f) << 8)
		          | ((off32 & 0x400) >> 3));
		return;
	case R_RISCV_JAL:
		off64 = val - addr;
		if ((off64 + (1 << 21)) & ~(((uint64_t)1 << 22) - 2))
			tcc_error("R_RISCV_JAL relocation failed"
			          " (val=%lx, addr=%lx)", val, addr);
		off32 = off64;
		write32le(ptr, (read32le(ptr) & 0xfff)
		          | (((off32 >> 12) &  0xff) << 12)
		          | (((off32 >> 11) &     1) << 20)
		          | (((off32 >>  1) & 0x3ff) << 21)
		          | (((off32 >> 20) &     1) << 31));
		return;
	case R_RISCV_CALL:
	case R_RISCV_CALL_PLT:
		write32le(ptr, (read32le(ptr) & 0xfff)
		          | ((val - addr + 0x800) & ~0xfff));
		write32le(ptr + 4, (read32le(ptr + 4) & 0xfffff)
		          | (((val - addr) & 0xfff) << 20));
		return;
	case R_RISCV_PCREL_HI20:
#ifdef DEBUG_RELOC
		printf("PCREL_HI20: val=%lx addr=%lx\n", val, addr);
#endif
		off64 = (int64_t)(val - addr + 0x800) >> 12;
		if ((off64 + ((uint64_t)1 << 20)) >> 21)
			tcc_error("R_RISCV_PCREL_HI20 relocation failed: off=%lx cond=%lx sym=%s",
			          off64, ((int64_t)(off64 + ((uint64_t)1 << 20)) >> 21),
			          symtab_section->link->data + sym->st_name);
		write32le(ptr, (read32le(ptr) & 0xfff)
		          | ((off64 & 0xfffff) << 12));
		last_hi.addr = addr;
		last_hi.val = val;
		return;
	case R_RISCV_GOT_HI20:
		val = s1->got->sh_addr + get_sym_attr(s1, sym_index, 0)->got_offset;
		off64 = (int64_t)(val - addr + 0x800) >> 12;
		if ((off64 + ((uint64_t)1 << 20)) >> 21)
			tcc_error("R_RISCV_GOT_HI20 relocation failed");
		last_hi.addr = addr;
		last_hi.val = val;
		write32le(ptr, (read32le(ptr) & 0xfff)
		          | ((off64 & 0xfffff) << 12));
		return;
	case R_RISCV_PCREL_LO12_I:
#ifdef DEBUG_RELOC
		printf("PCREL_LO12_I: val=%lx addr=%lx\n", val, addr);
#endif
		if (val != last_hi.addr)
			tcc_error("unsupported hi/lo pcrel reloc scheme");
		val = last_hi.val;
		addr = last_hi.addr;
		write32le(ptr, (read32le(ptr) & 0xfffff)
		          | (((val - addr) & 0xfff) << 20));
		return;
	case R_RISCV_PCREL_LO12_S:
		if (val != last_hi.addr)
			tcc_error("unsupported hi/lo pcrel reloc scheme");
		val = last_hi.val;
		addr = last_hi.addr;
		off32 = val - addr;
		write32le(ptr, (read32le(ptr) & ~0xfe000f80)
		          | ((off32 & 0xfe0) << 20)
		          | ((off32 & 0x01f) << 7));
		return;

	case R_RISCV_RVC_BRANCH:
		off64 = (val - addr);
		if ((off64 + (1 << 8)) & ~(uint64_t)0x1fe)
			tcc_error("R_RISCV_RVC_BRANCH relocation failed"
			          " (val=%lx, addr=%lx)", val, addr);
		off32 = off64;
		write16le(ptr, (read16le(ptr) & 0xe383)
		          | (((off32 >> 5) & 1) << 2)
		          | (((off32 >> 1) & 3) << 3)
		          | (((off32 >> 6) & 3) << 5)
		          | (((off32 >> 3) & 3) << 10)
		          | (((off32 >> 8) & 1) << 12));
		return;
	case R_RISCV_RVC_JUMP:
		off64 = (val - addr);
		if ((off64 + (1 << 11)) & ~(uint64_t)0xffe)
			tcc_error("R_RISCV_RVC_BRANCH relocation failed"
			          " (val=%lx, addr=%lx)", val, addr);
		off32 = off64;
		write16le(ptr, (read16le(ptr) & 0xe003)
		          | (((off32 >>  5) & 1) << 2)
		          | (((off32 >>  1) & 7) << 3)
		          | (((off32 >>  7) & 1) << 6)
		          | (((off32 >>  6) & 1) << 7)
		          | (((off32 >> 10) & 1) << 8)
		          | (((off32 >>  8) & 3) << 9)
		          | (((off32 >>  4) & 1) << 11)
		          | (((off32 >> 11) & 1) << 12));
		return;

	case R_RISCV_32:
		write32le(ptr, val);
		return;
	case R_RISCV_JUMP_SLOT:
	case R_RISCV_64:
		write64le(ptr, val);
		return;
	case R_RISCV_ADD64:
		write64le(ptr, read64le(ptr) + val);
		return;
	case R_RISCV_ADD32:
		write32le(ptr, read32le(ptr) + val);
		return;
	case R_RISCV_SUB64:
		write64le(ptr, read64le(ptr) - val);
		return;
	case R_RISCV_SUB32:
		write32le(ptr, read32le(ptr) - val);
		return;
	case R_RISCV_ADD16:
		write16le(ptr, read16le(ptr) + val);
		return;
	case R_RISCV_SUB16:
		write16le(ptr, read16le(ptr) - val);
		return;
	case R_RISCV_SET6:
		*ptr = (*ptr & ~0x3f) | (val & 0x3f);
		return;
	case R_RISCV_SUB6:
		*ptr = (*ptr & ~0x3f) | ((*ptr - val) & 0x3f);
		return;

	case R_RISCV_32_PCREL:
	case R_RISCV_COPY:
		/* XXX */
		return;

	default:
		fprintf(stderr, "FIXME: handle reloc type %x at %x [%p] to %x\n",
		        type, (unsigned)addr, ptr, (unsigned)val);
		return;
	}
}
//END riscv64-link.c

#else
#error unknown target
#endif

//END PLATFORM IMPL

/********************************************************/


//START libtcc.c

#if !defined ONE_SOURCE || ONE_SOURCE

//START tccpp.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

/********************************************************/
/* global variables */

ST_DATA int tok_flags;
ST_DATA int parse_flags;

ST_DATA struct BufferedFile *file;
ST_DATA int ch, tok;
ST_DATA CValue tokc;
ST_DATA const int *macro_ptr;
ST_DATA CString tokcstr; /* current parsed string, if any */

/* display benchmark infos */
ST_DATA int tok_ident;
ST_DATA TokenSym **table_ident;

/* ------------------------------------------------------------------------- */

static TokenSym *hash_ident[TOK_HASH_SIZE];
static char token_buf[STRING_MAX_SIZE + 1];
static CString cstr_buf;
static CString macro_equal_buf;
static TokenString tokstr_buf;
static unsigned char isidnum_table[256 - CH_EOF];
static int pp_debug_tok, pp_debug_symv;
static int pp_once;
static int pp_expr;
static int pp_counter;
static void tok_print(const char *msg, const int *str);

static struct TinyAlloc *toksym_alloc;
static struct TinyAlloc *tokstr_alloc;

static TokenString *macro_stack;

static const char tcc_keywords[] =
#define DEF(id, str) str "\0"

//START tcctok.h

    /* keywords */
    DEF(TOK_INT, "int")
    DEF(TOK_VOID, "void")
    DEF(TOK_CHAR, "char")
    DEF(TOK_IF, "if")
    DEF(TOK_ELSE, "else")
    DEF(TOK_WHILE, "while")
    DEF(TOK_BREAK, "break")
    DEF(TOK_RETURN, "return")
    DEF(TOK_FOR, "for")
    DEF(TOK_EXTERN, "extern")
    DEF(TOK_STATIC, "static")
    DEF(TOK_UNSIGNED, "unsigned")
    DEF(TOK_GOTO, "goto")
    DEF(TOK_DO, "do")
    DEF(TOK_CONTINUE, "continue")
    DEF(TOK_SWITCH, "switch")
    DEF(TOK_CASE, "case")

    DEF(TOK_CONST1, "const")
    DEF(TOK_CONST2, "__const") /* gcc keyword */
    DEF(TOK_CONST3, "__const__") /* gcc keyword */
    DEF(TOK_VOLATILE1, "volatile")
    DEF(TOK_VOLATILE2, "__volatile") /* gcc keyword */
    DEF(TOK_VOLATILE3, "__volatile__") /* gcc keyword */
    DEF(TOK_LONG, "long")
    DEF(TOK_REGISTER, "register")
    DEF(TOK_SIGNED1, "signed")
    DEF(TOK_SIGNED2, "__signed") /* gcc keyword */
    DEF(TOK_SIGNED3, "__signed__") /* gcc keyword */
    DEF(TOK_AUTO, "auto")
    DEF(TOK_INLINE1, "inline")
    DEF(TOK_INLINE2, "__inline") /* gcc keyword */
    DEF(TOK_INLINE3, "__inline__") /* gcc keyword */
    DEF(TOK_RESTRICT1, "restrict")
    DEF(TOK_RESTRICT2, "__restrict")
    DEF(TOK_RESTRICT3, "__restrict__")
    DEF(TOK_EXTENSION, "__extension__") /* gcc keyword */

    DEF(TOK_GENERIC, "_Generic")
    DEF(TOK_STATIC_ASSERT, "_Static_assert")

    DEF(TOK_FLOAT, "float")
    DEF(TOK_DOUBLE, "double")
    DEF(TOK_BOOL, "_Bool")
    DEF(TOK_SHORT, "short")
    DEF(TOK_STRUCT, "struct")
    DEF(TOK_UNION, "union")
    DEF(TOK_TYPEDEF, "typedef")
    DEF(TOK_DEFAULT, "default")
    DEF(TOK_ENUM, "enum")
    DEF(TOK_SIZEOF, "sizeof")
    DEF(TOK_ATTRIBUTE1, "__attribute")
    DEF(TOK_ATTRIBUTE2, "__attribute__")
    DEF(TOK_ALIGNOF1, "__alignof")
    DEF(TOK_ALIGNOF2, "__alignof__")
    DEF(TOK_ALIGNOF3, "_Alignof")
    DEF(TOK_ALIGNAS, "_Alignas")
    DEF(TOK_TYPEOF1, "typeof")
    DEF(TOK_TYPEOF2, "__typeof")
    DEF(TOK_TYPEOF3, "__typeof__")
    DEF(TOK_LABEL, "__label__")
    DEF(TOK_ASM1, "asm")
    DEF(TOK_ASM2, "__asm")
    DEF(TOK_ASM3, "__asm__")

#ifdef TCC_TARGET_ARM64
    DEF(TOK_UINT128, "__uint128_t")
#endif

    /*********************************************************************/
    /* the following are not keywords. They are included to ease parsing */
    /* preprocessor only */
    DEF(TOK_DEFINE, "define")
    DEF(TOK_INCLUDE, "include")
    DEF(TOK_INCLUDE_NEXT, "include_next")
    DEF(TOK_IFDEF, "ifdef")
    DEF(TOK_IFNDEF, "ifndef")
    DEF(TOK_ELIF, "elif")
    DEF(TOK_ENDIF, "endif")
    DEF(TOK_DEFINED, "defined")
    DEF(TOK_UNDEF, "undef")
    DEF(TOK_ERROR, "error")
    DEF(TOK_WARNING, "warning")
    DEF(TOK_LINE, "line")
    DEF(TOK_PRAGMA, "pragma")
    DEF(TOK___LINE__, "__LINE__")
    DEF(TOK___FILE__, "__FILE__")
    DEF(TOK___DATE__, "__DATE__")
    DEF(TOK___TIME__, "__TIME__")
    DEF(TOK___FUNCTION__, "__FUNCTION__")
    DEF(TOK___VA_ARGS__, "__VA_ARGS__")
    DEF(TOK___COUNTER__, "__COUNTER__")

    /* special identifiers */
    DEF(TOK___FUNC__, "__func__")

    /* special floating point values */
    DEF(TOK___NAN__, "__nan__")
    DEF(TOK___SNAN__, "__snan__")
    DEF(TOK___INF__, "__inf__")

    /* attribute identifiers */
    /* XXX: handle all tokens generically since speed is not critical */
    DEF(TOK_SECTION1, "section")
    DEF(TOK_SECTION2, "__section__")
    DEF(TOK_ALIGNED1, "aligned")
    DEF(TOK_ALIGNED2, "__aligned__")
    DEF(TOK_PACKED1, "packed")
    DEF(TOK_PACKED2, "__packed__")
    DEF(TOK_WEAK1, "weak")
    DEF(TOK_WEAK2, "__weak__")
    DEF(TOK_ALIAS1, "alias")
    DEF(TOK_ALIAS2, "__alias__")
    DEF(TOK_UNUSED1, "unused")
    DEF(TOK_UNUSED2, "__unused__")
    DEF(TOK_CDECL1, "cdecl")
    DEF(TOK_CDECL2, "__cdecl")
    DEF(TOK_CDECL3, "__cdecl__")
    DEF(TOK_STDCALL1, "stdcall")
    DEF(TOK_STDCALL2, "__stdcall")
    DEF(TOK_STDCALL3, "__stdcall__")
    DEF(TOK_FASTCALL1, "fastcall")
    DEF(TOK_FASTCALL2, "__fastcall")
    DEF(TOK_FASTCALL3, "__fastcall__")
    DEF(TOK_REGPARM1, "regparm")
    DEF(TOK_REGPARM2, "__regparm__")
    DEF(TOK_CLEANUP1, "cleanup")
    DEF(TOK_CLEANUP2, "__cleanup__")
    DEF(TOK_CONSTRUCTOR1, "constructor")
    DEF(TOK_CONSTRUCTOR2, "__constructor__")
    DEF(TOK_DESTRUCTOR1, "destructor")
    DEF(TOK_DESTRUCTOR2, "__destructor__")

    DEF(TOK_MODE, "__mode__")
    DEF(TOK_MODE_QI, "__QI__")
    DEF(TOK_MODE_DI, "__DI__")
    DEF(TOK_MODE_HI, "__HI__")
    DEF(TOK_MODE_SI, "__SI__")
    DEF(TOK_MODE_word, "__word__")

    DEF(TOK_DLLEXPORT, "dllexport")
    DEF(TOK_DLLIMPORT, "dllimport")
    DEF(TOK_NODECORATE, "nodecorate")
    DEF(TOK_NORETURN1, "noreturn")
    DEF(TOK_NORETURN2, "__noreturn__")
    DEF(TOK_NORETURN3, "_Noreturn")
    DEF(TOK_VISIBILITY1, "visibility")
    DEF(TOK_VISIBILITY2, "__visibility__")

    DEF(TOK_builtin_types_compatible_p, "__builtin_types_compatible_p")
    DEF(TOK_builtin_choose_expr, "__builtin_choose_expr")
    DEF(TOK_builtin_constant_p, "__builtin_constant_p")
    DEF(TOK_builtin_frame_address, "__builtin_frame_address")
    DEF(TOK_builtin_return_address, "__builtin_return_address")
    DEF(TOK_builtin_expect, "__builtin_expect")
    /*DEF(TOK_builtin_va_list, "__builtin_va_list")*/
#if defined TCC_TARGET_PE && defined TCC_TARGET_X86_64
    DEF(TOK_builtin_va_start, "__builtin_va_start")
#elif defined TCC_TARGET_X86_64
    DEF(TOK_builtin_va_arg_types, "__builtin_va_arg_types")
#elif defined TCC_TARGET_ARM64
    DEF(TOK___va_start, "__va_start")
    DEF(TOK___va_arg, "__va_arg")
#elif defined TCC_TARGET_RISCV64
    DEF(TOK_builtin_va_start, "__builtin_va_start")
#endif

    /* pragma */
    DEF(TOK_pack, "pack")
#if !defined(TCC_TARGET_I386) && !defined(TCC_TARGET_X86_64)
    /* already defined for assembler */
    DEF(TOK_ASM_push, "push")
    DEF(TOK_ASM_pop, "pop")
#endif
    DEF(TOK_comment, "comment")
    DEF(TOK_lib, "lib")
    DEF(TOK_push_macro, "push_macro")
    DEF(TOK_pop_macro, "pop_macro")
    DEF(TOK_once, "once")
    DEF(TOK_option, "option")

    /* builtin functions or variables */
#ifndef TCC_ARM_EABI
    DEF(TOK_memcpy, "memcpy")
    DEF(TOK_memmove, "memmove")
    DEF(TOK_memset, "memset")
    DEF(TOK___divdi3, "__divdi3")
    DEF(TOK___moddi3, "__moddi3")
    DEF(TOK___udivdi3, "__udivdi3")
    DEF(TOK___umoddi3, "__umoddi3")
    DEF(TOK___ashrdi3, "__ashrdi3")
    DEF(TOK___lshrdi3, "__lshrdi3")
    DEF(TOK___ashldi3, "__ashldi3")
    DEF(TOK___floatundisf, "__floatundisf")
    DEF(TOK___floatundidf, "__floatundidf")
# ifndef TCC_ARM_VFP
    DEF(TOK___floatundixf, "__floatundixf")
    DEF(TOK___fixunsxfdi, "__fixunsxfdi")
# endif
    DEF(TOK___fixunssfdi, "__fixunssfdi")
    DEF(TOK___fixunsdfdi, "__fixunsdfdi")
#endif

#if defined TCC_TARGET_ARM
# ifdef TCC_ARM_EABI
    DEF(TOK_memcpy, "__aeabi_memcpy")
    DEF(TOK_memcpy4, "__aeabi_memcpy4")
    DEF(TOK_memcpy8, "__aeabi_memcpy8")
    DEF(TOK_memmove, "__aeabi_memmove")
    DEF(TOK_memset, "__aeabi_memset")
    DEF(TOK___aeabi_ldivmod, "__aeabi_ldivmod")
    DEF(TOK___aeabi_uldivmod, "__aeabi_uldivmod")
    DEF(TOK___aeabi_idivmod, "__aeabi_idivmod")
    DEF(TOK___aeabi_uidivmod, "__aeabi_uidivmod")
    DEF(TOK___divsi3, "__aeabi_idiv")
    DEF(TOK___udivsi3, "__aeabi_uidiv")
    DEF(TOK___floatdisf, "__aeabi_l2f")
    DEF(TOK___floatdidf, "__aeabi_l2d")
    DEF(TOK___fixsfdi, "__aeabi_f2lz")
    DEF(TOK___fixdfdi, "__aeabi_d2lz")
    DEF(TOK___ashrdi3, "__aeabi_lasr")
    DEF(TOK___lshrdi3, "__aeabi_llsr")
    DEF(TOK___ashldi3, "__aeabi_llsl")
    DEF(TOK___floatundisf, "__aeabi_ul2f")
    DEF(TOK___floatundidf, "__aeabi_ul2d")
    DEF(TOK___fixunssfdi, "__aeabi_f2ulz")
    DEF(TOK___fixunsdfdi, "__aeabi_d2ulz")
# else
    DEF(TOK___modsi3, "__modsi3")
    DEF(TOK___umodsi3, "__umodsi3")
    DEF(TOK___divsi3, "__divsi3")
    DEF(TOK___udivsi3, "__udivsi3")
    DEF(TOK___floatdisf, "__floatdisf")
    DEF(TOK___floatdidf, "__floatdidf")
#  ifndef TCC_ARM_VFP
    DEF(TOK___floatdixf, "__floatdixf")
    DEF(TOK___fixunssfsi, "__fixunssfsi")
    DEF(TOK___fixunsdfsi, "__fixunsdfsi")
    DEF(TOK___fixunsxfsi, "__fixunsxfsi")
    DEF(TOK___fixxfdi, "__fixxfdi")
#  endif
    DEF(TOK___fixsfdi, "__fixsfdi")
    DEF(TOK___fixdfdi, "__fixdfdi")
# endif
#endif

#if defined TCC_TARGET_C67
    DEF(TOK__divi, "_divi")
    DEF(TOK__divu, "_divu")
    DEF(TOK__divf, "_divf")
    DEF(TOK__divd, "_divd")
    DEF(TOK__remi, "_remi")
    DEF(TOK__remu, "_remu")
#endif

#if defined TCC_TARGET_I386
    DEF(TOK___fixsfdi, "__fixsfdi")
    DEF(TOK___fixdfdi, "__fixdfdi")
    DEF(TOK___fixxfdi, "__fixxfdi")
#endif

#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
    DEF(TOK_alloca, "alloca")
#endif

#if defined TCC_TARGET_PE
    DEF(TOK___chkstk, "__chkstk")
#endif
#if defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64
    DEF(TOK___arm64_clear_cache, "__arm64_clear_cache")
    DEF(TOK___addtf3, "__addtf3")
    DEF(TOK___subtf3, "__subtf3")
    DEF(TOK___multf3, "__multf3")
    DEF(TOK___divtf3, "__divtf3")
    DEF(TOK___extendsftf2, "__extendsftf2")
    DEF(TOK___extenddftf2, "__extenddftf2")
    DEF(TOK___trunctfsf2, "__trunctfsf2")
    DEF(TOK___trunctfdf2, "__trunctfdf2")
    DEF(TOK___fixtfsi, "__fixtfsi")
    DEF(TOK___fixtfdi, "__fixtfdi")
    DEF(TOK___fixunstfsi, "__fixunstfsi")
    DEF(TOK___fixunstfdi, "__fixunstfdi")
    DEF(TOK___floatsitf, "__floatsitf")
    DEF(TOK___floatditf, "__floatditf")
    DEF(TOK___floatunsitf, "__floatunsitf")
    DEF(TOK___floatunditf, "__floatunditf")
    DEF(TOK___eqtf2, "__eqtf2")
    DEF(TOK___netf2, "__netf2")
    DEF(TOK___lttf2, "__lttf2")
    DEF(TOK___letf2, "__letf2")
    DEF(TOK___gttf2, "__gttf2")
    DEF(TOK___getf2, "__getf2")
#endif

    /* bound checking symbols */
#ifdef CONFIG_TCC_BCHECK
    DEF(TOK___bound_ptr_add, "__bound_ptr_add")
    DEF(TOK___bound_ptr_indir1, "__bound_ptr_indir1")
    DEF(TOK___bound_ptr_indir2, "__bound_ptr_indir2")
    DEF(TOK___bound_ptr_indir4, "__bound_ptr_indir4")
    DEF(TOK___bound_ptr_indir8, "__bound_ptr_indir8")
    DEF(TOK___bound_ptr_indir12, "__bound_ptr_indir12")
    DEF(TOK___bound_ptr_indir16, "__bound_ptr_indir16")
    DEF(TOK___bound_main_arg, "__bound_main_arg")
    DEF(TOK___bound_local_new, "__bound_local_new")
    DEF(TOK___bound_local_delete, "__bound_local_delete")
# ifdef TCC_TARGET_PE
#  ifdef TCC_TARGET_X86_64
    DEF(TOK___bound_alloca_nr, "__bound_alloca_nr")
#  endif
    DEF(TOK_malloc, "malloc")
    DEF(TOK_free, "free")
    DEF(TOK_realloc, "realloc")
    DEF(TOK_memalign, "memalign")
    DEF(TOK_calloc, "calloc")
# endif
    DEF(TOK_mmap, "mmap")
    DEF(TOK_munmap, "munmap")
    DEF(TOK_memcmp, "memcmp")
    DEF(TOK_strlen, "strlen")
    DEF(TOK_strcpy, "strcpy")
    DEF(TOK_strncpy, "strncpy")
    DEF(TOK_strcmp, "strcmp")
    DEF(TOK_strncmp, "strncmp")
    DEF(TOK_strcat, "strcat")
    DEF(TOK_strchr, "strchr")
    DEF(TOK_strdup, "strdup")
#endif

    /* Tiny Assembler */
    DEF_ASMDIR(byte)              /* must be first directive */
    DEF_ASMDIR(word)
    DEF_ASMDIR(align)
    DEF_ASMDIR(balign)
    DEF_ASMDIR(p2align)
    DEF_ASMDIR(set)
    DEF_ASMDIR(skip)
    DEF_ASMDIR(space)
    DEF_ASMDIR(string)
    DEF_ASMDIR(asciz)
    DEF_ASMDIR(ascii)
    DEF_ASMDIR(file)
    DEF_ASMDIR(globl)
    DEF_ASMDIR(global)
    DEF_ASMDIR(weak)
    DEF_ASMDIR(hidden)
    DEF_ASMDIR(ident)
    DEF_ASMDIR(size)
    DEF_ASMDIR(type)
    DEF_ASMDIR(text)
    DEF_ASMDIR(data)
    DEF_ASMDIR(bss)
    DEF_ASMDIR(previous)
    DEF_ASMDIR(pushsection)
    DEF_ASMDIR(popsection)
    DEF_ASMDIR(fill)
    DEF_ASMDIR(rept)
    DEF_ASMDIR(endr)
    DEF_ASMDIR(org)
    DEF_ASMDIR(quad)
#if defined(TCC_TARGET_I386)
    DEF_ASMDIR(code16)
    DEF_ASMDIR(code32)
#elif defined(TCC_TARGET_X86_64)
    DEF_ASMDIR(code64)
#endif
    DEF_ASMDIR(short)
    DEF_ASMDIR(long)
    DEF_ASMDIR(int)
    DEF_ASMDIR(section)            /* must be last directive */

#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64

//START i386-tok.h

    /* ------------------------------------------------------------------ */
    /* WARNING: relative order of tokens is important. */

    /* register */
    DEF_ASM(al)
    DEF_ASM(cl)
    DEF_ASM(dl)
    DEF_ASM(bl)
    DEF_ASM(ah)
    DEF_ASM(ch)
    DEF_ASM(dh)
    DEF_ASM(bh)
    DEF_ASM(ax)
    DEF_ASM(cx)
    DEF_ASM(dx)
    DEF_ASM(bx)
    DEF_ASM(sp)
    DEF_ASM(bp)
    DEF_ASM(si)
    DEF_ASM(di)
    DEF_ASM(eax)
    DEF_ASM(ecx)
    DEF_ASM(edx)
    DEF_ASM(ebx)
    DEF_ASM(esp)
    DEF_ASM(ebp)
    DEF_ASM(esi)
    DEF_ASM(edi)
#ifdef TCC_TARGET_X86_64
    DEF_ASM(rax)
    DEF_ASM(rcx)
    DEF_ASM(rdx)
    DEF_ASM(rbx)
    DEF_ASM(rsp)
    DEF_ASM(rbp)
    DEF_ASM(rsi)
    DEF_ASM(rdi)
#endif
    DEF_ASM(mm0)
    DEF_ASM(mm1)
    DEF_ASM(mm2)
    DEF_ASM(mm3)
    DEF_ASM(mm4)
    DEF_ASM(mm5)
    DEF_ASM(mm6)
    DEF_ASM(mm7)
    DEF_ASM(xmm0)
    DEF_ASM(xmm1)
    DEF_ASM(xmm2)
    DEF_ASM(xmm3)
    DEF_ASM(xmm4)
    DEF_ASM(xmm5)
    DEF_ASM(xmm6)
    DEF_ASM(xmm7)
    DEF_ASM(cr0)
    DEF_ASM(cr1)
    DEF_ASM(cr2)
    DEF_ASM(cr3)
    DEF_ASM(cr4)
    DEF_ASM(cr5)
    DEF_ASM(cr6)
    DEF_ASM(cr7)
    DEF_ASM(tr0)
    DEF_ASM(tr1)
    DEF_ASM(tr2)
    DEF_ASM(tr3)
    DEF_ASM(tr4)
    DEF_ASM(tr5)
    DEF_ASM(tr6)
    DEF_ASM(tr7)
    DEF_ASM(db0)
    DEF_ASM(db1)
    DEF_ASM(db2)
    DEF_ASM(db3)
    DEF_ASM(db4)
    DEF_ASM(db5)
    DEF_ASM(db6)
    DEF_ASM(db7)
    DEF_ASM(dr0)
    DEF_ASM(dr1)
    DEF_ASM(dr2)
    DEF_ASM(dr3)
    DEF_ASM(dr4)
    DEF_ASM(dr5)
    DEF_ASM(dr6)
    DEF_ASM(dr7)
    DEF_ASM(es)
    DEF_ASM(cs)
    DEF_ASM(ss)
    DEF_ASM(ds)
    DEF_ASM(fs)
    DEF_ASM(gs)
    DEF_ASM(st)
    DEF_ASM(rip)

#ifdef TCC_TARGET_X86_64
    /* The four low parts of sp/bp/si/di that exist only on
       x86-64 (encoding aliased to ah,ch,dh,dh when not using REX). */
    DEF_ASM(spl)
    DEF_ASM(bpl)
    DEF_ASM(sil)
    DEF_ASM(dil)
#endif
    /* generic two operands */
    DEF_BWLX(mov)

    DEF_BWLX(add)
    DEF_BWLX(or)
    DEF_BWLX(adc)
    DEF_BWLX(sbb)
    DEF_BWLX(and)
    DEF_BWLX(sub)
    DEF_BWLX(xor)
    DEF_BWLX(cmp)

    /* unary ops */
    DEF_BWLX(inc)
    DEF_BWLX(dec)
    DEF_BWLX(not)
    DEF_BWLX(neg)
    DEF_BWLX(mul)
    DEF_BWLX(imul)
    DEF_BWLX(div)
    DEF_BWLX(idiv)

    DEF_BWLX(xchg)
    DEF_BWLX(test)

    /* shifts */
    DEF_BWLX(rol)
    DEF_BWLX(ror)
    DEF_BWLX(rcl)
    DEF_BWLX(rcr)
    DEF_BWLX(shl)
    DEF_BWLX(shr)
    DEF_BWLX(sar)

    DEF_WLX(shld)
    DEF_WLX(shrd)

    DEF_ASM(pushw)
    DEF_ASM(pushl)
#ifdef TCC_TARGET_X86_64
    DEF_ASM(pushq)
#endif
    DEF_ASM(push)

    DEF_ASM(popw)
    DEF_ASM(popl)
#ifdef TCC_TARGET_X86_64
    DEF_ASM(popq)
#endif
    DEF_ASM(pop)

    DEF_BWL(in)
    DEF_BWL(out)

    DEF_WLX(movzb)
    DEF_ASM(movzwl)
    DEF_ASM(movsbw)
    DEF_ASM(movsbl)
    DEF_ASM(movswl)
#ifdef TCC_TARGET_X86_64
    DEF_ASM(movsbq)
    DEF_ASM(movswq)
    DEF_ASM(movzwq)
    DEF_ASM(movslq)
#endif

    DEF_WLX(lea)

    DEF_ASM(les)
    DEF_ASM(lds)
    DEF_ASM(lss)
    DEF_ASM(lfs)
    DEF_ASM(lgs)

    DEF_ASM(call)
    DEF_ASM(jmp)
    DEF_ASM(lcall)
    DEF_ASM(ljmp)

    DEF_ASMTEST(j,)

    DEF_ASMTEST(set,)
    DEF_ASMTEST(set,b)
    DEF_ASMTEST(cmov,)

    DEF_WLX(bsf)
    DEF_WLX(bsr)
    DEF_WLX(bt)
    DEF_WLX(bts)
    DEF_WLX(btr)
    DEF_WLX(btc)

    DEF_WLX(lar)
    DEF_WLX(lsl)

    /* generic FP ops */
    DEF_FP(add)
    DEF_FP(mul)

    DEF_ASM(fcom)
    DEF_ASM(fcom_1) /* non existent op, just to have a regular table */
    DEF_FP1(com)

    DEF_FP(comp)
    DEF_FP(sub)
    DEF_FP(subr)
    DEF_FP(div)
    DEF_FP(divr)

    DEF_BWLX(xadd)
    DEF_BWLX(cmpxchg)

    /* string ops */
    DEF_BWLX(cmps)
    DEF_BWLX(scmp)
    DEF_BWL(ins)
    DEF_BWL(outs)
    DEF_BWLX(lods)
    DEF_BWLX(slod)
    DEF_BWLX(movs)
    DEF_BWLX(smov)
    DEF_BWLX(scas)
    DEF_BWLX(ssca)
    DEF_BWLX(stos)
    DEF_BWLX(ssto)

    /* generic asm ops */
#define ALT(x)
#define DEF_ASM_OP0(name, opcode) DEF_ASM(name)
#define DEF_ASM_OP0L(name, opcode, group, instr_type)
#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)
#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)
#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)
#ifdef TCC_TARGET_X86_64
//START x86_64-asm.h

#define X86ASMOPCODE
#include "tinycc.h"

//END x86_64-asm.h
#else
#define i386ASMOPCODE
#include "tinycc.h"
#endif

#define ALT(x)
#define DEF_ASM_OP0(name, opcode)
#define DEF_ASM_OP0L(name, opcode, group, instr_type) DEF_ASM(name)
#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) DEF_ASM(name)
#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) DEF_ASM(name)
#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) DEF_ASM(name)
#ifdef TCC_TARGET_X86_64

//START x86_64-asm.h

#define X86ASMOPCODE
#include "tinycc.h"

//END x86_64-asm.h

#else
#define i386ASMOPCODE
#include "tinycc.h"
#endif
//END i386-tok.h


#endif

//END tcctok.h

#undef DEF
    ;

/* WARNING: the content of this string encodes token numbers */
static const unsigned char tok_two_chars[] =
    /* outdated -- gr
        "<=\236>=\235!=\225&&\240||\241++\244--\242==\224<<\1>>\2+=\253"
        "-=\255*=\252/=\257%=\245&=\246^=\336|=\374->\313..\250##\266";
    */
{
	'<','=', TOK_LE,
	'>','=', TOK_GE,
	'!','=', TOK_NE,
	'&','&', TOK_LAND,
	'|','|', TOK_LOR,
	'+','+', TOK_INC,
	'-','-', TOK_DEC,
	'=','=', TOK_EQ,
	'<','<', TOK_SHL,
	'>','>', TOK_SAR,
	'+','=', TOK_A_ADD,
	'-','=', TOK_A_SUB,
	'*','=', TOK_A_MUL,
	'/','=', TOK_A_DIV,
	'%','=', TOK_A_MOD,
	'&','=', TOK_A_AND,
	'^','=', TOK_A_XOR,
	'|','=', TOK_A_OR,
	'-','>', TOK_ARROW,
	'.','.', TOK_TWODOTS,
	'#','#', TOK_TWOSHARPS,
	0
};

static void next_nomacro_spc(void);

ST_FUNC void skip(int c)
{
	if (tok != c)
		tcc_error("'%c' expected (got \"%s\")", c, get_tok_str(tok, &tokc));
	next();
}

ST_FUNC void expect(const char *msg)
{
	tcc_error("%s expected", msg);
}

/* ------------------------------------------------------------------------- */
/* Custom allocator for tiny objects */

#define USE_TAL

#ifndef USE_TAL
#define tal_free(al, p) tcc_free(p)
#define tal_realloc(al, p, size) tcc_realloc(p, size)
#define tal_new(a,b,c)
#define tal_delete(a)
#else
#if !defined(MEM_DEBUG)
#define tal_free(al, p) tal_free_impl(al, p)
#define tal_realloc(al, p, size) tal_realloc_impl(&al, p, size)
#define TAL_DEBUG_PARAMS
#else
#define TAL_DEBUG 1
//#define TAL_INFO 1 /* collect and dump allocators stats */
#define tal_free(al, p) tal_free_impl(al, p, __FILE__, __LINE__)
#define tal_realloc(al, p, size) tal_realloc_impl(&al, p, size, __FILE__, __LINE__)
#define TAL_DEBUG_PARAMS , const char *file, int line
#define TAL_DEBUG_FILE_LEN 40
#endif

#define TOKSYM_TAL_SIZE     (768 * 1024) /* allocator for tiny TokenSym in table_ident */
#define TOKSTR_TAL_SIZE     (768 * 1024) /* allocator for tiny TokenString instances */
#define CSTR_TAL_SIZE       (256 * 1024) /* allocator for tiny CString instances */
#define TOKSYM_TAL_LIMIT    256 /* prefer unique limits to distinguish allocators debug msgs */
#define TOKSTR_TAL_LIMIT    128 /* 32 * sizeof(int) */
#define CSTR_TAL_LIMIT      1024

typedef struct TinyAlloc
{
	unsigned  limit;
	unsigned  size;
	uint8_t *buffer;
	uint8_t *p;
	unsigned  nb_allocs;
	struct TinyAlloc *next, *top;
#ifdef TAL_INFO
	unsigned  nb_peak;
	unsigned  nb_total;
	unsigned  nb_missed;
	uint8_t *peak_p;
#endif
} TinyAlloc;

typedef struct tal_header_t
{
	unsigned  size;
#ifdef TAL_DEBUG
	int     line_num; /* negative line_num used for double free check */
	char    file_name[TAL_DEBUG_FILE_LEN + 1];
#endif
} tal_header_t;

/* ------------------------------------------------------------------------- */

static TinyAlloc *tal_new(TinyAlloc **pal, unsigned limit, unsigned size)
{
	TinyAlloc *al = tcc_mallocz(sizeof(TinyAlloc));
	al->p = al->buffer = tcc_malloc(size);
	al->limit = limit;
	al->size = size;
	if (pal) *pal = al;
	return al;
}

static void tal_delete(TinyAlloc *al)
{
	TinyAlloc *next;

tail_call:
	if (!al)
		return;
#ifdef TAL_INFO
	fprintf(stderr, "limit=%5d, size=%5g MB, nb_peak=%6d, nb_total=%8d, nb_missed=%6d, usage=%5.1f%%\n",
	        al->limit, al->size / 1024.0 / 1024.0, al->nb_peak, al->nb_total, al->nb_missed,
	        (al->peak_p - al->buffer) * 100.0 / al->size);
#endif
#ifdef TAL_DEBUG
	if (al->nb_allocs > 0)
	{
		uint8_t *p;
		fprintf(stderr, "TAL_DEBUG: memory leak %d chunk(s) (limit= %d)\n",
		        al->nb_allocs, al->limit);
		p = al->buffer;
		while (p < al->p)
		{
			tal_header_t *header = (tal_header_t *)p;
			if (header->line_num > 0)
			{
				fprintf(stderr, "%s:%d: chunk of %d bytes leaked\n",
				        header->file_name, header->line_num, header->size);
			}
			p += header->size + sizeof(tal_header_t);
		}
#if MEM_DEBUG-0 == 2
		exit(2);
#endif
	}
#endif
	next = al->next;
	tcc_free(al->buffer);
	tcc_free(al);
	al = next;
	goto tail_call;
}

static void tal_free_impl(TinyAlloc *al, void *p TAL_DEBUG_PARAMS)
{
	if (!p)
		return;
tail_call:
	if (al->buffer <= (uint8_t *)p && (uint8_t *)p < al->buffer + al->size)
	{
#ifdef TAL_DEBUG
		tal_header_t *header = (((tal_header_t *)p) - 1);
		if (header->line_num < 0)
		{
			fprintf(stderr, "%s:%d: TAL_DEBUG: double frees chunk from\n",
			        file, line);
			fprintf(stderr, "%s:%d: %d bytes\n",
			        header->file_name, (int)-header->line_num, (int)header->size);
		}
		else
			header->line_num = -header->line_num;
#endif
		al->nb_allocs--;
		if (!al->nb_allocs)
			al->p = al->buffer;
	}
	else if (al->next)
	{
		al = al->next;
		goto tail_call;
	}
	else
		tcc_free(p);
}

static void *tal_realloc_impl(TinyAlloc **pal, void *p, unsigned size TAL_DEBUG_PARAMS)
{
	tal_header_t *header;
	void *ret;
	int is_own;
	unsigned adj_size = (size + 3) & -4;
	TinyAlloc *al = *pal;

tail_call:
	is_own = (al->buffer <= (uint8_t *)p && (uint8_t *)p < al->buffer + al->size);
	if ((!p || is_own) && size <= al->limit)
	{
		if (al->p - al->buffer + adj_size + sizeof(tal_header_t) < al->size)
		{
			header = (tal_header_t *)al->p;
			header->size = adj_size;
#ifdef TAL_DEBUG
			{
				int ofs = strlen(file) - TAL_DEBUG_FILE_LEN;
				strncpy(header->file_name, file + (ofs > 0 ? ofs : 0), TAL_DEBUG_FILE_LEN);
				header->file_name[TAL_DEBUG_FILE_LEN] = 0;
				header->line_num = line;
			}
#endif
			ret = al->p + sizeof(tal_header_t);
			al->p += adj_size + sizeof(tal_header_t);
			if (is_own)
			{
				header = (((tal_header_t *)p) - 1);
				memcpy(ret, p, header->size);
#ifdef TAL_DEBUG
				header->line_num = -header->line_num;
#endif
			}
			else
			{
				al->nb_allocs++;
			}
#ifdef TAL_INFO
			if (al->nb_peak < al->nb_allocs)
				al->nb_peak = al->nb_allocs;
			if (al->peak_p < al->p)
				al->peak_p = al->p;
			al->nb_total++;
#endif
			return ret;
		}
		else if (is_own)
		{
			al->nb_allocs--;
			ret = tal_realloc(*pal, 0, size);
			header = (((tal_header_t *)p) - 1);
			memcpy(ret, p, header->size);
#ifdef TAL_DEBUG
			header->line_num = -header->line_num;
#endif
			return ret;
		}
		if (al->next)
		{
			al = al->next;
		}
		else
		{
			TinyAlloc *bottom = al, *next = al->top ? al->top : al;

			al = tal_new(pal, next->limit, next->size * 2);
			al->next = next;
			bottom->top = al;
		}
		goto tail_call;
	}
	if (is_own)
	{
		al->nb_allocs--;
		ret = tcc_malloc(size);
		header = (((tal_header_t *)p) - 1);
		memcpy(ret, p, header->size);
#ifdef TAL_DEBUG
		header->line_num = -header->line_num;
#endif
	}
	else if (al->next)
	{
		al = al->next;
		goto tail_call;
	}
	else
		ret = tcc_realloc(p, size);
#ifdef TAL_INFO
	al->nb_missed++;
#endif
	return ret;
}

#endif /* USE_TAL */

/* ------------------------------------------------------------------------- */
/* CString handling */
static void cstr_realloc(CString *cstr, int new_size)
{
	int size;

	size = cstr->size_allocated;
	if (size < 8)
		size = 8; /* no need to allocate a too small first string */
	while (size < new_size)
		size = size * 2;
	cstr->data = tcc_realloc(cstr->data, size);
	cstr->size_allocated = size;
}

/* add a byte */
ST_INLN void cstr_ccat(CString *cstr, int ch)
{
	int size;
	size = cstr->size + 1;
	if (size > cstr->size_allocated)
		cstr_realloc(cstr, size);
	((unsigned char *)cstr->data)[size - 1] = ch;
	cstr->size = size;
}

ST_FUNC void cstr_cat(CString *cstr, const char *str, int len)
{
	int size;
	if (len <= 0)
		len = strlen(str) + 1 + len;
	size = cstr->size + len;
	if (size > cstr->size_allocated)
		cstr_realloc(cstr, size);
	memmove(((unsigned char *)cstr->data) + cstr->size, str, len);
	cstr->size = size;
}

/* add a wide char */
ST_FUNC void cstr_wccat(CString *cstr, int ch)
{
	int size;
	size = cstr->size + sizeof(nwchar_t);
	if (size > cstr->size_allocated)
		cstr_realloc(cstr, size);
	*(nwchar_t *)(((unsigned char *)cstr->data) + size - sizeof(nwchar_t)) = ch;
	cstr->size = size;
}

ST_FUNC void cstr_new(CString *cstr)
{
	memset(cstr, 0, sizeof(CString));
}

/* free string and reset it to NULL */
ST_FUNC void cstr_free(CString *cstr)
{
	tcc_free(cstr->data);
	cstr_new(cstr);
}

/* reset string to empty */
ST_FUNC void cstr_reset(CString *cstr)
{
	cstr->size = 0;
}

ST_FUNC int cstr_printf(CString *cstr, const char *fmt, ...)
{
	va_list v;
	int len, size;

	va_start(v, fmt);
	len = vsnprintf(NULL, 0, fmt, v);
	va_end(v);
	size = cstr->size + len + 1;
	if (size > cstr->size_allocated)
		cstr_realloc(cstr, size);
	va_start(v, fmt);
	vsnprintf((char*)cstr->data + cstr->size, size, fmt, v);
	va_end(v);
	cstr->size += len;
	return len;
}

/* XXX: unicode ? */
static void add_char(CString *cstr, int c)
{
	if (c == '\'' || c == '\"' || c == '\\')
	{
		/* XXX: could be more precise if char or string */
		cstr_ccat(cstr, '\\');
	}
	if (c >= 32 && c <= 126)
	{
		cstr_ccat(cstr, c);
	}
	else
	{
		cstr_ccat(cstr, '\\');
		if (c == '\n')
		{
			cstr_ccat(cstr, 'n');
		}
		else
		{
			cstr_ccat(cstr, '0' + ((c >> 6) & 7));
			cstr_ccat(cstr, '0' + ((c >> 3) & 7));
			cstr_ccat(cstr, '0' + (c & 7));
		}
	}
}

/* ------------------------------------------------------------------------- */
/* allocate a new token */
static TokenSym *tok_alloc_new(TokenSym **pts, const char *str, int len)
{
	TokenSym *ts, **ptable;
	int i;

	if (tok_ident >= SYM_FIRST_ANOM)
		tcc_error("memory full (symbols)");

	/* expand token table if needed */
	i = tok_ident - TOK_IDENT;
	if ((i % TOK_ALLOC_INCR) == 0)
	{
		ptable = tcc_realloc(table_ident, (i + TOK_ALLOC_INCR) * sizeof(TokenSym *));
		table_ident = ptable;
	}

	ts = tal_realloc(toksym_alloc, 0, sizeof(TokenSym) + len);
	table_ident[i] = ts;
	ts->tok = tok_ident++;
	ts->sym_define = NULL;
	ts->sym_label = NULL;
	ts->sym_struct = NULL;
	ts->sym_identifier = NULL;
	ts->len = len;
	ts->hash_next = NULL;
	memcpy(ts->str, str, len);
	ts->str[len] = '\0';
	*pts = ts;
	return ts;
}

#define TOK_HASH_INIT 1
#define TOK_HASH_FUNC(h, c) ((h) + ((h) << 5) + ((h) >> 27) + (c))


/* find a token and add it if not found */
ST_FUNC TokenSym *tok_alloc(const char *str, int len)
{
	TokenSym *ts, **pts;
	int i;
	unsigned int h;

	h = TOK_HASH_INIT;
	for(i=0; i<len; i++)
		h = TOK_HASH_FUNC(h, ((unsigned char *)str)[i]);
	h &= (TOK_HASH_SIZE - 1);

	pts = &hash_ident[h];
	for(;;)
	{
		ts = *pts;
		if (!ts)
			break;
		if (ts->len == len && !memcmp(ts->str, str, len))
			return ts;
		pts = &(ts->hash_next);
	}
	return tok_alloc_new(pts, str, len);
}

/* XXX: buffer overflow */
/* XXX: float tokens */
ST_FUNC const char *get_tok_str(int v, CValue *cv)
{
	char *p;
	int i, len;

	cstr_reset(&cstr_buf);
	p = cstr_buf.data;

	switch(v)
	{
	case TOK_CINT:
	case TOK_CUINT:
	case TOK_CLONG:
	case TOK_CULONG:
	case TOK_CLLONG:
	case TOK_CULLONG:
		/* XXX: not quite exact, but only useful for testing  */
#ifdef _WIN32
		sprintf(p, "%u", (unsigned)cv->i);
#else
		sprintf(p, "%llu", (unsigned long long)cv->i);
#endif
		break;
	case TOK_LCHAR:
		cstr_ccat(&cstr_buf, 'L');
	case TOK_CCHAR:
		cstr_ccat(&cstr_buf, '\'');
		add_char(&cstr_buf, cv->i);
		cstr_ccat(&cstr_buf, '\'');
		cstr_ccat(&cstr_buf, '\0');
		break;
	case TOK_PPNUM:
	case TOK_PPSTR:
		return (char*)cv->str.data;
	case TOK_LSTR:
		cstr_ccat(&cstr_buf, 'L');
	case TOK_STR:
		cstr_ccat(&cstr_buf, '\"');
		if (v == TOK_STR)
		{
			len = cv->str.size - 1;
			for(i=0; i<len; i++)
				add_char(&cstr_buf, ((unsigned char *)cv->str.data)[i]);
		}
		else
		{
			len = (cv->str.size / sizeof(nwchar_t)) - 1;
			for(i=0; i<len; i++)
				add_char(&cstr_buf, ((nwchar_t *)cv->str.data)[i]);
		}
		cstr_ccat(&cstr_buf, '\"');
		cstr_ccat(&cstr_buf, '\0');
		break;

	case TOK_CFLOAT:
		cstr_cat(&cstr_buf, "<float>", 0);
		break;
	case TOK_CDOUBLE:
		cstr_cat(&cstr_buf, "<double>", 0);
		break;
	case TOK_CLDOUBLE:
		cstr_cat(&cstr_buf, "<long double>", 0);
		break;
	case TOK_LINENUM:
		cstr_cat(&cstr_buf, "<linenumber>", 0);
		break;

	/* above tokens have value, the ones below don't */
	case TOK_LT:
		v = '<';
		goto addv;
	case TOK_GT:
		v = '>';
		goto addv;
	case TOK_DOTS:
		return strcpy(p, "...");
	case TOK_A_SHL:
		return strcpy(p, "<<=");
	case TOK_A_SAR:
		return strcpy(p, ">>=");
	case TOK_EOF:
		return strcpy(p, "<eof>");
	default:
		if (v < TOK_IDENT)
		{
			/* search in two bytes table */
			const unsigned char *q = tok_two_chars;
			while (*q)
			{
				if (q[2] == v)
				{
					*p++ = q[0];
					*p++ = q[1];
					*p = '\0';
					return cstr_buf.data;
				}
				q += 3;
			}
			if (v >= 127)
			{
				sprintf(cstr_buf.data, "<%02x>", v);
				return cstr_buf.data;
			}
addv:
			*p++ = v;
			*p = '\0';
		}
		else if (v < tok_ident)
		{
			return table_ident[v - TOK_IDENT]->str;
		}
		else if (v >= SYM_FIRST_ANOM)
		{
			/* special name for anonymous symbol */
			sprintf(p, "L.%u", v - SYM_FIRST_ANOM);
		}
		else
		{
			/* should never happen */
			return NULL;
		}
		break;
	}
	return cstr_buf.data;
}

/* return the current character, handling end of block if necessary
   (but not stray) */
static int handle_eob(void)
{
	BufferedFile *bf = file;
	int len;

	/* only tries to read if really end of buffer */
	if (bf->buf_ptr >= bf->buf_end)
	{
		if (bf->fd >= 0)
		{
#if defined(PARSE_DEBUG)
			len = 1;
#else
			len = IO_BUF_SIZE;
#endif
			len = read(bf->fd, bf->buffer, len);
			if (len < 0)
				len = 0;
		}
		else
		{
			len = 0;
		}
		total_bytes += len;
		bf->buf_ptr = bf->buffer;
		bf->buf_end = bf->buffer + len;
		*bf->buf_end = CH_EOB;
	}
	if (bf->buf_ptr < bf->buf_end)
	{
		return bf->buf_ptr[0];
	}
	else
	{
		bf->buf_ptr = bf->buf_end;
		return CH_EOF;
	}
}

/* read next char from current input file and handle end of input buffer */
static inline void inp(void)
{
	ch = *(++(file->buf_ptr));
	/* end of buffer/file handling */
	if (ch == CH_EOB)
		ch = handle_eob();
}

/* handle '\[\r]\n' */
static int handle_stray_noerror(void)
{
	while (ch == '\\')
	{
		inp();
		if (ch == '\n')
		{
			file->line_num++;
			inp();
		}
		else if (ch == '\r')
		{
			inp();
			if (ch != '\n')
				goto fail;
			file->line_num++;
			inp();
		}
		else
		{
fail:
			return 1;
		}
	}
	return 0;
}

static void handle_stray(void)
{
	if (handle_stray_noerror())
		tcc_error("stray '\\' in program");
}

/* skip the stray and handle the \\n case. Output an error if
   incorrect char after the stray */
static int handle_stray1(uint8_t *p)
{
	int c;

	file->buf_ptr = p;
	if (p >= file->buf_end)
	{
		c = handle_eob();
		if (c != '\\')
			return c;
		p = file->buf_ptr;
	}
	ch = *p;
	if (handle_stray_noerror())
	{
		if (!(parse_flags & PARSE_FLAG_ACCEPT_STRAYS))
			tcc_error("stray '\\' in program");
		*--file->buf_ptr = '\\';
	}
	p = file->buf_ptr;
	c = *p;
	return c;
}

/* handle just the EOB case, but not stray */
#define PEEKC_EOB(c, p)\
{\
    p++;\
    c = *p;\
    if (c == '\\') {\
        file->buf_ptr = p;\
        c = handle_eob();\
        p = file->buf_ptr;\
    }\
}

/* handle the complicated stray case */
#define PEEKC(c, p)\
{\
    p++;\
    c = *p;\
    if (c == '\\') {\
        c = handle_stray1(p);\
        p = file->buf_ptr;\
    }\
}

/* input with '\[\r]\n' handling. Note that this function cannot
   handle other characters after '\', so you cannot call it inside
   strings or comments */
static void minp(void)
{
	inp();
	if (ch == '\\')
		handle_stray();
}

/* single line C++ comments */
static uint8_t *parse_line_comment(uint8_t *p)
{
	int c;

	p++;
	for(;;)
	{
		c = *p;
redo:
		if (c == '\n' || c == CH_EOF)
		{
			break;
		}
		else if (c == '\\')
		{
			file->buf_ptr = p;
			c = handle_eob();
			p = file->buf_ptr;
			if (c == '\\')
			{
				PEEKC_EOB(c, p);
				if (c == '\n')
				{
					file->line_num++;
					PEEKC_EOB(c, p);
				}
				else if (c == '\r')
				{
					PEEKC_EOB(c, p);
					if (c == '\n')
					{
						file->line_num++;
						PEEKC_EOB(c, p);
					}
				}
			}
			else
			{
				goto redo;
			}
		}
		else
		{
			p++;
		}
	}
	return p;
}

/* C comments */
static uint8_t *parse_comment(uint8_t *p)
{
	int c;

	p++;
	for(;;)
	{
		/* fast skip loop */
		for(;;)
		{
			c = *p;
			if (c == '\n' || c == '*' || c == '\\')
				break;
			p++;
			c = *p;
			if (c == '\n' || c == '*' || c == '\\')
				break;
			p++;
		}
		/* now we can handle all the cases */
		if (c == '\n')
		{
			file->line_num++;
			p++;
		}
		else if (c == '*')
		{
			p++;
			for(;;)
			{
				c = *p;
				if (c == '*')
				{
					p++;
				}
				else if (c == '/')
				{
					goto end_of_comment;
				}
				else if (c == '\\')
				{
					file->buf_ptr = p;
					c = handle_eob();
					p = file->buf_ptr;
					if (c == CH_EOF)
						tcc_error("unexpected end of file in comment");
					if (c == '\\')
					{
						/* skip '\[\r]\n', otherwise just skip the stray */
						while (c == '\\')
						{
							PEEKC_EOB(c, p);
							if (c == '\n')
							{
								file->line_num++;
								PEEKC_EOB(c, p);
							}
							else if (c == '\r')
							{
								PEEKC_EOB(c, p);
								if (c == '\n')
								{
									file->line_num++;
									PEEKC_EOB(c, p);
								}
							}
							else
							{
								goto after_star;
							}
						}
					}
				}
				else
				{
					break;
				}
			}
after_star:
			;
		}
		else
		{
			/* stray, eob or eof */
			file->buf_ptr = p;
			c = handle_eob();
			p = file->buf_ptr;
			if (c == CH_EOF)
			{
				tcc_error("unexpected end of file in comment");
			}
			else if (c == '\\')
			{
				p++;
			}
		}
	}
end_of_comment:
	p++;
	return p;
}

ST_FUNC int set_idnum(int c, int val)
{
	int prev = isidnum_table[c - CH_EOF];
	isidnum_table[c - CH_EOF] = val;
	return prev;
}

#define cinp minp

static inline void skip_spaces(void)
{
	while (isidnum_table[ch - CH_EOF] & IS_SPC)
		cinp();
}

static inline int check_space(int t, int *spc)
{
	if (t < 256 && (isidnum_table[t - CH_EOF] & IS_SPC))
	{
		if (*spc)
			return 1;
		*spc = 1;
	}
	else
		*spc = 0;
	return 0;
}

/* parse a string without interpreting escapes */
static uint8_t *parse_pp_string(uint8_t *p,
                                int sep, CString *str)
{
	int c;
	p++;
	for(;;)
	{
		c = *p;
		if (c == sep)
		{
			break;
		}
		else if (c == '\\')
		{
			file->buf_ptr = p;
			c = handle_eob();
			p = file->buf_ptr;
			if (c == CH_EOF)
			{
unterminated_string:
				/* XXX: indicate line number of start of string */
				tcc_error("missing terminating %c character", sep);
			}
			else if (c == '\\')
			{
				/* escape : just skip \[\r]\n */
				PEEKC_EOB(c, p);
				if (c == '\n')
				{
					file->line_num++;
					p++;
				}
				else if (c == '\r')
				{
					PEEKC_EOB(c, p);
					if (c != '\n')
						expect("'\n' after '\r'");
					file->line_num++;
					p++;
				}
				else if (c == CH_EOF)
				{
					goto unterminated_string;
				}
				else
				{
					if (str)
					{
						cstr_ccat(str, '\\');
						cstr_ccat(str, c);
					}
					p++;
				}
			}
		}
		else if (c == '\n')
		{
			file->line_num++;
			goto add_char;
		}
		else if (c == '\r')
		{
			PEEKC_EOB(c, p);
			if (c != '\n')
			{
				if (str)
					cstr_ccat(str, '\r');
			}
			else
			{
				file->line_num++;
				goto add_char;
			}
		}
		else
		{
add_char:
			if (str)
				cstr_ccat(str, c);
			p++;
		}
	}
	p++;
	return p;
}

/* skip block of text until #else, #elif or #endif. skip also pairs of
   #if/#endif */
static void preprocess_skip(void)
{
	int a, start_of_line, c, in_warn_or_error;
	uint8_t *p;

	p = file->buf_ptr;
	a = 0;
redo_start:
	start_of_line = 1;
	in_warn_or_error = 0;
	for(;;)
	{
redo_no_start:
		c = *p;
		switch(c)
		{
		case ' ':
		case '\t':
		case '\f':
		case '\v':
		case '\r':
			p++;
			goto redo_no_start;
		case '\n':
			file->line_num++;
			p++;
			goto redo_start;
		case '\\':
			file->buf_ptr = p;
			c = handle_eob();
			if (c == CH_EOF)
			{
				expect("#endif");
			}
			else if (c == '\\')
			{
				ch = file->buf_ptr[0];
				handle_stray_noerror();
			}
			p = file->buf_ptr;
			goto redo_no_start;
		/* skip strings */
		case '\"':
		case '\'':
			if (in_warn_or_error)
				goto _default;
			p = parse_pp_string(p, c, NULL);
			break;
		/* skip comments */
		case '/':
			if (in_warn_or_error)
				goto _default;
			file->buf_ptr = p;
			ch = *p;
			minp();
			p = file->buf_ptr;
			if (ch == '*')
			{
				p = parse_comment(p);
			}
			else if (ch == '/')
			{
				p = parse_line_comment(p);
			}
			break;
		case '#':
			p++;
			if (start_of_line)
			{
				file->buf_ptr = p;
				next_nomacro();
				p = file->buf_ptr;
				if (a == 0 &&
				        (tok == TOK_ELSE || tok == TOK_ELIF || tok == TOK_ENDIF))
					goto the_end;
				if (tok == TOK_IF || tok == TOK_IFDEF || tok == TOK_IFNDEF)
					a++;
				else if (tok == TOK_ENDIF)
					a--;
				else if( tok == TOK_ERROR || tok == TOK_WARNING)
					in_warn_or_error = 1;
				else if (tok == TOK_LINEFEED)
					goto redo_start;
				else if (parse_flags & PARSE_FLAG_ASM_FILE)
					p = parse_line_comment(p - 1);
			}
			else if (parse_flags & PARSE_FLAG_ASM_FILE)
				p = parse_line_comment(p - 1);
			break;
_default:
		default:
			p++;
			break;
		}
		start_of_line = 0;
	}
the_end:
	;
	file->buf_ptr = p;
}

#if 0
/* return the number of additional 'ints' necessary to store the
   token */
static inline int tok_size(const int *p)
{
	switch(*p)
	{
	/* 4 bytes */
	case TOK_CINT:
	case TOK_CUINT:
	case TOK_CCHAR:
	case TOK_LCHAR:
	case TOK_CFLOAT:
	case TOK_LINENUM:
		return 1 + 1;
	case TOK_STR:
	case TOK_LSTR:
	case TOK_PPNUM:
	case TOK_PPSTR:
		return 1 + ((sizeof(CString) + ((CString *)(p+1))->size + 3) >> 2);
	case TOK_CLONG:
	case TOK_CULONG:
		return 1 + LONG_SIZE / 4;
	case TOK_CDOUBLE:
	case TOK_CLLONG:
	case TOK_CULLONG:
		return 1 + 2;
	case TOK_CLDOUBLE:
		return 1 + LDOUBLE_SIZE / 4;
	default:
		return 1 + 0;
	}
}
#endif

/* token string handling */
ST_INLN void tok_str_new(TokenString *s)
{
	s->str = NULL;
	s->len = s->lastlen = 0;
	s->allocated_len = 0;
	s->last_line_num = -1;
}

ST_FUNC TokenString *tok_str_alloc(void)
{
	TokenString *str = tal_realloc(tokstr_alloc, 0, sizeof *str);
	tok_str_new(str);
	return str;
}

ST_FUNC int *tok_str_dup(TokenString *s)
{
	int *str;

	str = tal_realloc(tokstr_alloc, 0, s->len * sizeof(int));
	memcpy(str, s->str, s->len * sizeof(int));
	return str;
}

ST_FUNC void tok_str_free_str(int *str)
{
	tal_free(tokstr_alloc, str);
}

ST_FUNC void tok_str_free(TokenString *str)
{
	tok_str_free_str(str->str);
	tal_free(tokstr_alloc, str);
}

ST_FUNC int *tok_str_realloc(TokenString *s, int new_size)
{
	int *str, size;

	size = s->allocated_len;
	if (size < 16)
		size = 16;
	while (size < new_size)
		size = size * 2;
	if (size > s->allocated_len)
	{
		str = tal_realloc(tokstr_alloc, s->str, size * sizeof(int));
		s->allocated_len = size;
		s->str = str;
	}
	return s->str;
}

ST_FUNC void tok_str_add(TokenString *s, int t)
{
	int len, *str;

	len = s->len;
	str = s->str;
	if (len >= s->allocated_len)
		str = tok_str_realloc(s, len + 1);
	str[len++] = t;
	s->len = len;
}

ST_FUNC void begin_macro(TokenString *str, int alloc)
{
	str->alloc = alloc;
	str->prev = macro_stack;
	str->prev_ptr = macro_ptr;
	str->save_line_num = file->line_num;
	macro_ptr = str->str;
	macro_stack = str;
}

ST_FUNC void end_macro(void)
{
	TokenString *str = macro_stack;
	macro_stack = str->prev;
	macro_ptr = str->prev_ptr;
	file->line_num = str->save_line_num;
	if (str->alloc != 0)
	{
		if (str->alloc == 2)
			str->str = NULL; /* don't free */
		tok_str_free(str);
	}
}

static void tok_str_add2(TokenString *s, int t, CValue *cv)
{
	int len, *str;

	len = s->lastlen = s->len;
	str = s->str;

	/* allocate space for worst case */
	if (len + TOK_MAX_SIZE >= s->allocated_len)
		str = tok_str_realloc(s, len + TOK_MAX_SIZE + 1);
	str[len++] = t;
	switch(t)
	{
	case TOK_CINT:
	case TOK_CUINT:
	case TOK_CCHAR:
	case TOK_LCHAR:
	case TOK_CFLOAT:
	case TOK_LINENUM:
#if LONG_SIZE == 4
	case TOK_CLONG:
	case TOK_CULONG:
#endif
		str[len++] = cv->tab[0];
		break;
	case TOK_PPNUM:
	case TOK_PPSTR:
	case TOK_STR:
	case TOK_LSTR:
	{
		/* Insert the string into the int array. */
		size_t nb_words =
		    1 + (cv->str.size + sizeof(int) - 1) / sizeof(int);
		if (len + nb_words >= s->allocated_len)
			str = tok_str_realloc(s, len + nb_words + 1);
		str[len] = cv->str.size;
		memcpy(&str[len + 1], cv->str.data, cv->str.size);
		len += nb_words;
	}
	break;
	case TOK_CDOUBLE:
	case TOK_CLLONG:
	case TOK_CULLONG:
#if LONG_SIZE == 8
	case TOK_CLONG:
	case TOK_CULONG:
#endif
#if LDOUBLE_SIZE == 8
	case TOK_CLDOUBLE:
#endif
		str[len++] = cv->tab[0];
		str[len++] = cv->tab[1];
		break;
#if LDOUBLE_SIZE == 12
	case TOK_CLDOUBLE:
		str[len++] = cv->tab[0];
		str[len++] = cv->tab[1];
		str[len++] = cv->tab[2];
#elif LDOUBLE_SIZE == 16
	case TOK_CLDOUBLE:
		str[len++] = cv->tab[0];
		str[len++] = cv->tab[1];
		str[len++] = cv->tab[2];
		str[len++] = cv->tab[3];
#elif LDOUBLE_SIZE != 8
#error add long double size support
#endif
		break;
	default:
		break;
	}
	s->len = len;
}

/* add the current parse token in token string 's' */
ST_FUNC void tok_str_add_tok(TokenString *s)
{
	CValue cval;

	/* save line number info */
	if (file->line_num != s->last_line_num)
	{
		s->last_line_num = file->line_num;
		cval.i = s->last_line_num;
		tok_str_add2(s, TOK_LINENUM, &cval);
	}
	tok_str_add2(s, tok, &tokc);
}

/* get a token from an integer array and increment pointer. */
static inline void TOK_GET(int *t, const int **pp, CValue *cv)
{
	const int *p = *pp;
	int n, *tab;

	tab = cv->tab;
	switch(*t = *p++)
	{
#if LONG_SIZE == 4
	case TOK_CLONG:
#endif
	case TOK_CINT:
	case TOK_CCHAR:
	case TOK_LCHAR:
	case TOK_LINENUM:
		cv->i = *p++;
		break;
#if LONG_SIZE == 4
	case TOK_CULONG:
#endif
	case TOK_CUINT:
		cv->i = (unsigned)*p++;
		break;
	case TOK_CFLOAT:
		tab[0] = *p++;
		break;
	case TOK_STR:
	case TOK_LSTR:
	case TOK_PPNUM:
	case TOK_PPSTR:
		cv->str.size = *p++;
		cv->str.data = p;
		p += (cv->str.size + sizeof(int) - 1) / sizeof(int);
		break;
	case TOK_CDOUBLE:
	case TOK_CLLONG:
	case TOK_CULLONG:
#if LONG_SIZE == 8
	case TOK_CLONG:
	case TOK_CULONG:
#endif
		n = 2;
		goto copy;
	case TOK_CLDOUBLE:
#if LDOUBLE_SIZE == 16
		n = 4;
#elif LDOUBLE_SIZE == 12
		n = 3;
#elif LDOUBLE_SIZE == 8
		n = 2;
#else
# error add long double size support
#endif
copy:
		do
			*tab++ = *p++;
		while (--n);
		break;
	default:
		break;
	}
	*pp = p;
}

static int macro_is_equal(const int *a, const int *b)
{
	CValue cv;
	int t;

	if (!a || !b)
		return 1;

	while (*a && *b)
	{
		/* first time preallocate macro_equal_buf, next time only reset position to start */
		cstr_reset(&macro_equal_buf);
		TOK_GET(&t, &a, &cv);
		cstr_cat(&macro_equal_buf, get_tok_str(t, &cv), 0);
		TOK_GET(&t, &b, &cv);
		if (strcmp(macro_equal_buf.data, get_tok_str(t, &cv)))
			return 0;
	}
	return !(*a || *b);
}

/* defines handling */
ST_INLN void define_push(int v, int macro_type, int *str, Sym *first_arg)
{
	Sym *s, *o;

	o = define_find(v);
	s = sym_push2(&define_stack, v, macro_type, 0);
	s->d = str;
	s->next = first_arg;
	table_ident[v - TOK_IDENT]->sym_define = s;

	if (o && !macro_is_equal(o->d, s->d))
		tcc_warning("%s redefined", get_tok_str(v, NULL));
}

/* undefined a define symbol. Its name is just set to zero */
ST_FUNC void define_undef(Sym *s)
{
	int v = s->v;
	if (v >= TOK_IDENT && v < tok_ident)
		table_ident[v - TOK_IDENT]->sym_define = NULL;
}

ST_INLN Sym *define_find(int v)
{
	v -= TOK_IDENT;
	if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))
		return NULL;
	return table_ident[v]->sym_define;
}

/* free define stack until top reaches 'b' */
ST_FUNC void free_defines(Sym *b)
{
	while (define_stack != b)
	{
		Sym *top = define_stack;
		define_stack = top->prev;
		tok_str_free_str(top->d);
		define_undef(top);
		sym_free(top);
	}
}

/* label lookup */
ST_FUNC Sym *label_find(int v)
{
	v -= TOK_IDENT;
	if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))
		return NULL;
	return table_ident[v]->sym_label;
}

ST_FUNC Sym *label_push(Sym **ptop, int v, int flags)
{
	Sym *s, **ps;
	s = sym_push2(ptop, v, 0, 0);
	s->r = flags;
	ps = &table_ident[v - TOK_IDENT]->sym_label;
	if (ptop == &global_label_stack)
	{
		/* modify the top most local identifier, so that
		   sym_identifier will point to 's' when popped */
		while (*ps != NULL)
			ps = &(*ps)->prev_tok;
	}
	s->prev_tok = *ps;
	*ps = s;
	return s;
}

/* pop labels until element last is reached. Look if any labels are
   undefined. Define symbols if '&&label' was used. */
ST_FUNC void label_pop(Sym **ptop, Sym *slast, int keep)
{
	Sym *s, *s1;
	for(s = *ptop; s != slast; s = s1)
	{
		s1 = s->prev;
		if (s->r == LABEL_DECLARED)
		{
			tcc_warning("label '%s' declared but not used", get_tok_str(s->v, NULL));
		}
		else if (s->r == LABEL_FORWARD)
		{
			tcc_error("label '%s' used but not defined",
			          get_tok_str(s->v, NULL));
		}
		else
		{
			if (s->c)
			{
				/* define corresponding symbol. A size of
				   1 is put. */
				put_extern_sym(s, cur_text_section, s->jnext, 1);
			}
		}
		/* remove label */
		table_ident[s->v - TOK_IDENT]->sym_label = s->prev_tok;
		if (!keep)
			sym_free(s);
	}
	if (!keep)
		*ptop = slast;
}

/* fake the nth "#if defined test_..." for tcc -dt -run */
static void maybe_run_test(TCCState *s)
{
	const char *p;
	if (s->include_stack_ptr != s->include_stack)
		return;
	p = get_tok_str(tok, NULL);
	if (0 != memcmp(p, "test_", 5))
		return;
	if (0 != --s->run_test)
		return;
	fprintf(s->ppfp, "\n[%s]\n" + !(s->dflag & 32), p), fflush(s->ppfp);
	define_push(tok, MACRO_OBJ, NULL, NULL);
}

/* eval an expression for #if/#elif */
static int expr_preprocess(void)
{
	int c, t;
	TokenString *str;

	str = tok_str_alloc();
	pp_expr = 1;
	while (tok != TOK_LINEFEED && tok != TOK_EOF)
	{
		next(); /* do macro subst */
		if (tok == TOK_DEFINED)
		{
			next_nomacro();
			t = tok;
			if (t == '(')
				next_nomacro();
			if (tok < TOK_IDENT)
				expect("identifier");
			if (tcc_state->run_test)
				maybe_run_test(tcc_state);
			c = define_find(tok) != 0;
			if (t == '(')
			{
				next_nomacro();
				if (tok != ')')
					expect("')'");
			}
			tok = TOK_CINT;
			tokc.i = c;
		}
		else if (tok >= TOK_IDENT)
		{
			/* if undefined macro */
			tok = TOK_CINT;
			tokc.i = 0;
		}
		tok_str_add_tok(str);
	}
	pp_expr = 0;
	tok_str_add(str, -1); /* simulate end of file */
	tok_str_add(str, 0);
	/* now evaluate C constant expression */
	begin_macro(str, 1);
	next();
	c = expr_const();
	end_macro();
	return c != 0;
}


/* parse after #define */
ST_FUNC void parse_define(void)
{
	Sym *s, *first, **ps;
	int v, t, varg, is_vaargs, spc;
	int saved_parse_flags = parse_flags;

	v = tok;
	if (v < TOK_IDENT || v == TOK_DEFINED)
		tcc_error("invalid macro name '%s'", get_tok_str(tok, &tokc));
	/* XXX: should check if same macro (ANSI) */
	first = NULL;
	t = MACRO_OBJ;
	/* We have to parse the whole define as if not in asm mode, in particular
	   no line comment with '#' must be ignored.  Also for function
	   macros the argument list must be parsed without '.' being an ID
	   character.  */
	parse_flags = ((parse_flags & ~PARSE_FLAG_ASM_FILE) | PARSE_FLAG_SPACES);
	/* '(' must be just after macro definition for MACRO_FUNC */
	next_nomacro_spc();
	if (tok == '(')
	{
		int dotid = set_idnum('.', 0);
		next_nomacro();
		ps = &first;
		if (tok != ')') for (;;)
			{
				varg = tok;
				next_nomacro();
				is_vaargs = 0;
				if (varg == TOK_DOTS)
				{
					varg = TOK___VA_ARGS__;
					is_vaargs = 1;
				}
				else if (tok == TOK_DOTS && gnu_ext)
				{
					is_vaargs = 1;
					next_nomacro();
				}
				if (varg < TOK_IDENT)
bad_list:
					tcc_error("bad macro parameter list");
				s = sym_push2(&define_stack, varg | SYM_FIELD, is_vaargs, 0);
				*ps = s;
				ps = &s->next;
				if (tok == ')')
					break;
				if (tok != ',' || is_vaargs)
					goto bad_list;
				next_nomacro();
			}
		next_nomacro_spc();
		t = MACRO_FUNC;
		set_idnum('.', dotid);
	}

	tokstr_buf.len = 0;
	spc = 2;
	parse_flags |= PARSE_FLAG_ACCEPT_STRAYS | PARSE_FLAG_SPACES | PARSE_FLAG_LINEFEED;
	/* The body of a macro definition should be parsed such that identifiers
	   are parsed like the file mode determines (i.e. with '.' being an
	   ID character in asm mode).  But '#' should be retained instead of
	   regarded as line comment leader, so still don't set ASM_FILE
	   in parse_flags. */
	while (tok != TOK_LINEFEED && tok != TOK_EOF)
	{
		/* remove spaces around ## and after '#' */
		if (TOK_TWOSHARPS == tok)
		{
			if (2 == spc)
				goto bad_twosharp;
			if (1 == spc)
				--tokstr_buf.len;
			spc = 3;
			tok = TOK_PPJOIN;
		}
		else if ('#' == tok)
		{
			spc = 4;
		}
		else if (check_space(tok, &spc))
		{
			goto skip;
		}
		tok_str_add2(&tokstr_buf, tok, &tokc);
skip:
		next_nomacro_spc();
	}

	parse_flags = saved_parse_flags;
	if (spc == 1)
		--tokstr_buf.len; /* remove trailing space */
	tok_str_add(&tokstr_buf, 0);
	if (3 == spc)
bad_twosharp:
		tcc_error("'##' cannot appear at either end of macro");
	define_push(v, t, tok_str_dup(&tokstr_buf), first);
}

static CachedInclude *search_cached_include(TCCState *s1, const char *filename, int add)
{
	const unsigned char *s;
	unsigned int h;
	CachedInclude *e;
	int i;

	h = TOK_HASH_INIT;
	s = (unsigned char *) filename;
	while (*s)
	{
#ifdef _WIN32
		h = TOK_HASH_FUNC(h, toup(*s));
#else
		h = TOK_HASH_FUNC(h, *s);
#endif
		s++;
	}
	h &= (CACHED_INCLUDES_HASH_SIZE - 1);

	i = s1->cached_includes_hash[h];
	for(;;)
	{
		if (i == 0)
			break;
		e = s1->cached_includes[i - 1];
		if (0 == PATHCMP(e->filename, filename))
			return e;
		i = e->hash_next;
	}
	if (!add)
		return NULL;

	e = tcc_malloc(sizeof(CachedInclude) + strlen(filename));
	strcpy(e->filename, filename);
	e->ifndef_macro = e->once = 0;
	dynarray_add(&s1->cached_includes, &s1->nb_cached_includes, e);
	/* add in hash table */
	e->hash_next = s1->cached_includes_hash[h];
	s1->cached_includes_hash[h] = s1->nb_cached_includes;
#ifdef INC_DEBUG
	printf("adding cached '%s'\n", filename);
#endif
	return e;
}

static void pragma_parse(TCCState *s1)
{
	next_nomacro();
	if (tok == TOK_push_macro || tok == TOK_pop_macro)
	{
		int t = tok, v;
		Sym *s;

		if (next(), tok != '(')
			goto pragma_err;
		if (next(), tok != TOK_STR)
			goto pragma_err;
		v = tok_alloc(tokc.str.data, tokc.str.size - 1)->tok;
		if (next(), tok != ')')
			goto pragma_err;
		if (t == TOK_push_macro)
		{
			while (NULL == (s = define_find(v)))
				define_push(v, 0, NULL, NULL);
			s->type.ref = s; /* set push boundary */
		}
		else
		{
			for (s = define_stack; s; s = s->prev)
				if (s->v == v && s->type.ref == s)
				{
					s->type.ref = NULL;
					break;
				}
		}
		if (s)
			table_ident[v - TOK_IDENT]->sym_define = s->d ? s : NULL;
		else
			tcc_warning("unbalanced #pragma pop_macro");
		pp_debug_tok = t, pp_debug_symv = v;

	}
	else if (tok == TOK_once)
	{
		search_cached_include(s1, file->filename, 1)->once = pp_once;

	}
	else if (s1->output_type == TCC_OUTPUT_PREPROCESS)
	{
		/* tcc -E: keep pragmas below unchanged */
		unget_tok(' ');
		unget_tok(TOK_PRAGMA);
		unget_tok('#');
		unget_tok(TOK_LINEFEED);

	}
	else if (tok == TOK_pack)
	{
		/* This may be:
		   #pragma pack(1) // set
		   #pragma pack() // reset to default
		   #pragma pack(push,1) // push & set
		   #pragma pack(pop) // restore previous */
		next();
		skip('(');
		if (tok == TOK_ASM_pop)
		{
			next();
			if (s1->pack_stack_ptr <= s1->pack_stack)
			{
stk_error:
				tcc_error("out of pack stack");
			}
			s1->pack_stack_ptr--;
		}
		else
		{
			int val = 0;
			if (tok != ')')
			{
				if (tok == TOK_ASM_push)
				{
					next();
					if (s1->pack_stack_ptr >= s1->pack_stack + PACK_STACK_SIZE - 1)
						goto stk_error;
					s1->pack_stack_ptr++;
					skip(',');
				}
				if (tok != TOK_CINT)
					goto pragma_err;
				val = tokc.i;
				if (val < 1 || val > 16 || (val & (val - 1)) != 0)
					goto pragma_err;
				next();
			}
			*s1->pack_stack_ptr = val;
		}
		if (tok != ')')
			goto pragma_err;

	}
	else if (tok == TOK_comment)
	{
		char *p;
		int t;
		next();
		skip('(');
		t = tok;
		next();
		skip(',');
		if (tok != TOK_STR)
			goto pragma_err;
		p = tcc_strdup((char *)tokc.str.data);
		next();
		if (tok != ')')
			goto pragma_err;
		if (t == TOK_lib)
		{
			dynarray_add(&s1->pragma_libs, &s1->nb_pragma_libs, p);
		}
		else
		{
			if (t == TOK_option)
				tcc_set_options(s1, p);
			tcc_free(p);
		}

	}
	else if (s1->warn_unsupported)
	{
		tcc_warning("#pragma %s is ignored", get_tok_str(tok, &tokc));
	}
	return;

pragma_err:
	tcc_error("malformed #pragma directive");
	return;
}

/* is_bof is true if first non space token at beginning of file */
ST_FUNC void preprocess(int is_bof)
{
	TCCState *s1 = tcc_state;
	int i, c, n, saved_parse_flags;
	char buf[1024], *q;
	Sym *s;

	saved_parse_flags = parse_flags;
	parse_flags = PARSE_FLAG_PREPROCESS
	              | PARSE_FLAG_TOK_NUM
	              | PARSE_FLAG_TOK_STR
	              | PARSE_FLAG_LINEFEED
	              | (parse_flags & PARSE_FLAG_ASM_FILE)
	              ;

	next_nomacro();
redo:
	switch(tok)
	{
	case TOK_DEFINE:
		pp_debug_tok = tok;
		next_nomacro();
		pp_debug_symv = tok;
		parse_define();
		break;
	case TOK_UNDEF:
		pp_debug_tok = tok;
		next_nomacro();
		pp_debug_symv = tok;
		s = define_find(tok);
		/* undefine symbol by putting an invalid name */
		if (s)
			define_undef(s);
		break;
	case TOK_INCLUDE:
	case TOK_INCLUDE_NEXT:
		ch = file->buf_ptr[0];
		/* XXX: incorrect if comments : use next_nomacro with a special mode */
		skip_spaces();
		if (ch == '<')
		{
			c = '>';
			goto read_name;
		}
		else if (ch == '\"')
		{
			c = ch;
read_name:
			inp();
			q = buf;
			while (ch != c && ch != '\n' && ch != CH_EOF)
			{
				if ((q - buf) < sizeof(buf) - 1)
					*q++ = ch;
				if (ch == '\\')
				{
					if (handle_stray_noerror() == 0)
						--q;
				}
				else
					inp();
			}
			*q = '\0';
			minp();
#if 0
			/* eat all spaces and comments after include */
			/* XXX: slightly incorrect */
			while (ch1 != '\n' && ch1 != CH_EOF)
				inp();
#endif
		}
		else
		{
			int len;
			/* computed #include : concatenate everything up to linefeed,
			the result must be one of the two accepted forms.
			Don't convert pp-tokens to tokens here.  */
			parse_flags = (PARSE_FLAG_PREPROCESS
			               | PARSE_FLAG_LINEFEED
			               | (parse_flags & PARSE_FLAG_ASM_FILE));
			next();
			buf[0] = '\0';
			while (tok != TOK_LINEFEED)
			{
				pstrcat(buf, sizeof(buf), get_tok_str(tok, &tokc));
				next();
			}
			len = strlen(buf);
			/* check syntax and remove '<>|""' */
			if ((len < 2 || ((buf[0] != '"' || buf[len-1] != '"') &&
			                 (buf[0] != '<' || buf[len-1] != '>'))))
				tcc_error("'#include' expects \"FILENAME\" or <FILENAME>");
			c = buf[len-1];
			memmove(buf, buf + 1, len - 2);
			buf[len - 2] = '\0';
		}

		if (s1->include_stack_ptr >= s1->include_stack + INCLUDE_STACK_SIZE)
			tcc_error("#include recursion too deep");
		/* push current file on stack */
		*s1->include_stack_ptr++ = file;
		i = tok == TOK_INCLUDE_NEXT ? file->include_next_index: 0;
		n = 2 + s1->nb_include_paths + s1->nb_sysinclude_paths;
		for (; i < n; ++i)
		{
			char buf1[sizeof file->filename];
			CachedInclude *e;
			const char *path;

			if (i == 0)
			{
				/* check absolute include path */
				if (!IS_ABSPATH(buf))
					continue;
				buf1[0] = 0;

			}
			else if (i == 1)
			{
				/* search in file's dir if "header.h" */
				if (c != '\"')
					continue;
				/* https://savannah.nongnu.org/bugs/index.php?50847 */
				path = file->true_filename;
				pstrncpy(buf1, path, tcc_basename(path) - path);

			}
			else
			{
				/* search in all the include paths */
				int j = i - 2, k = j - s1->nb_include_paths;
				path = k < 0 ? s1->include_paths[j] : s1->sysinclude_paths[k];
				pstrcpy(buf1, sizeof(buf1), path);
				pstrcat(buf1, sizeof(buf1), "/");
			}

			pstrcat(buf1, sizeof(buf1), buf);
			e = search_cached_include(s1, buf1, 0);
			if (e && (define_find(e->ifndef_macro) || e->once == pp_once))
			{
				/* no need to parse the include because the 'ifndef macro'
				   is defined (or had #pragma once) */
#ifdef INC_DEBUG
				printf("%s: skipping cached %s\n", file->filename, buf1);
#endif
				goto include_done;
			}

			if (tcc_open(s1, buf1) < 0)
				continue;

			file->include_next_index = i + 1;
#ifdef INC_DEBUG
			printf("%s: including %s\n", file->prev->filename, file->filename);
#endif
			/* update target deps */
			if (s1->gen_deps)
			{
				dynarray_add(&s1->target_deps, &s1->nb_target_deps,
				             tcc_strdup(buf1));
			}
			/* add include file debug info */
			tcc_debug_bincl(tcc_state);
			tok_flags |= TOK_FLAG_BOF | TOK_FLAG_BOL;
			ch = file->buf_ptr[0];
			goto the_end;
		}
		tcc_error("include file '%s' not found", buf);
include_done:
		--s1->include_stack_ptr;
		break;
	case TOK_IFNDEF:
		c = 1;
		goto do_ifdef;
	case TOK_IF:
		c = expr_preprocess();
		goto do_if;
	case TOK_IFDEF:
		c = 0;
do_ifdef:
		next_nomacro();
		if (tok < TOK_IDENT)
			tcc_error("invalid argument for '#if%sdef'", c ? "n" : "");
		if (is_bof)
		{
			if (c)
			{
#ifdef INC_DEBUG
				printf("#ifndef %s\n", get_tok_str(tok, NULL));
#endif
				file->ifndef_macro = tok;
			}
		}
		c = (define_find(tok) != 0) ^ c;
do_if:
		if (s1->ifdef_stack_ptr >= s1->ifdef_stack + IFDEF_STACK_SIZE)
			tcc_error("memory full (ifdef)");
		*s1->ifdef_stack_ptr++ = c;
		goto test_skip;
	case TOK_ELSE:
		if (s1->ifdef_stack_ptr == s1->ifdef_stack)
			tcc_error("#else without matching #if");
		if (s1->ifdef_stack_ptr[-1] & 2)
			tcc_error("#else after #else");
		c = (s1->ifdef_stack_ptr[-1] ^= 3);
		goto test_else;
	case TOK_ELIF:
		if (s1->ifdef_stack_ptr == s1->ifdef_stack)
			tcc_error("#elif without matching #if");
		c = s1->ifdef_stack_ptr[-1];
		if (c > 1)
			tcc_error("#elif after #else");
		/* last #if/#elif expression was true: we skip */
		if (c == 1)
		{
			c = 0;
		}
		else
		{
			c = expr_preprocess();
			s1->ifdef_stack_ptr[-1] = c;
		}
test_else:
		if (s1->ifdef_stack_ptr == file->ifdef_stack_ptr + 1)
			file->ifndef_macro = 0;
test_skip:
		if (!(c & 1))
		{
			preprocess_skip();
			is_bof = 0;
			goto redo;
		}
		break;
	case TOK_ENDIF:
		if (s1->ifdef_stack_ptr <= file->ifdef_stack_ptr)
			tcc_error("#endif without matching #if");
		s1->ifdef_stack_ptr--;
		/* '#ifndef macro' was at the start of file. Now we check if
		   an '#endif' is exactly at the end of file */
		if (file->ifndef_macro &&
		        s1->ifdef_stack_ptr == file->ifdef_stack_ptr)
		{
			file->ifndef_macro_saved = file->ifndef_macro;
			/* need to set to zero to avoid false matches if another
			   #ifndef at middle of file */
			file->ifndef_macro = 0;
			while (tok != TOK_LINEFEED)
				next_nomacro();
			tok_flags |= TOK_FLAG_ENDIF;
			goto the_end;
		}
		break;
	case TOK_PPNUM:
		n = strtoul((char*)tokc.str.data, &q, 10);
		goto _line_num;
	case TOK_LINE:
		next();
		if (tok != TOK_CINT)
_line_err:
			tcc_error("wrong #line format");
		n = tokc.i;
_line_num:
		next();
		if (tok != TOK_LINEFEED)
		{
			if (tok == TOK_STR)
			{
				if (file->true_filename == file->filename)
					file->true_filename = tcc_strdup(file->filename);
				/* prepend directory from real file */
				pstrcpy(buf, sizeof buf, file->true_filename);
				*tcc_basename(buf) = 0;
				pstrcat(buf, sizeof buf, (char *)tokc.str.data);
				tcc_debug_putfile(s1, buf);
			}
			else if (parse_flags & PARSE_FLAG_ASM_FILE)
				break;
			else
				goto _line_err;
			--n;
		}
		if (file->fd > 0)
			total_lines += file->line_num - n;
		file->line_num = n;
		break;
	case TOK_ERROR:
	case TOK_WARNING:
		c = tok;
		ch = file->buf_ptr[0];
		skip_spaces();
		q = buf;
		while (ch != '\n' && ch != CH_EOF)
		{
			if ((q - buf) < sizeof(buf) - 1)
				*q++ = ch;
			if (ch == '\\')
			{
				if (handle_stray_noerror() == 0)
					--q;
			}
			else
				inp();
		}
		*q = '\0';
		if (c == TOK_ERROR)
			tcc_error("#error %s", buf);
		else
			tcc_warning("#warning %s", buf);
		break;
	case TOK_PRAGMA:
		pragma_parse(s1);
		break;
	case TOK_LINEFEED:
		goto the_end;
	default:
		/* ignore gas line comment in an 'S' file. */
		if (saved_parse_flags & PARSE_FLAG_ASM_FILE)
			goto ignore;
		if (tok == '!' && is_bof)
			/* '!' is ignored at beginning to allow C scripts. */
			goto ignore;
		tcc_warning("Ignoring unknown preprocessing directive #%s", get_tok_str(tok, &tokc));
ignore:
		file->buf_ptr = parse_line_comment(file->buf_ptr - 1);
		goto the_end;
	}
	/* ignore other preprocess commands or #! for C scripts */
	while (tok != TOK_LINEFEED)
		next_nomacro();
the_end:
	parse_flags = saved_parse_flags;
}

/* evaluate escape codes in a string. */
static void parse_escape_string(CString *outstr, const uint8_t *buf, int is_long)
{
	int c, n;
	const uint8_t *p;

	p = buf;
	for(;;)
	{
		c = *p;
		if (c == '\0')
			break;
		if (c == '\\')
		{
			p++;
			/* escape */
			c = *p;
			switch(c)
			{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
				/* at most three octal digits */
				n = c - '0';
				p++;
				c = *p;
				if (isoct(c))
				{
					n = n * 8 + c - '0';
					p++;
					c = *p;
					if (isoct(c))
					{
						n = n * 8 + c - '0';
						p++;
					}
				}
				c = n;
				goto add_char_nonext;
			case 'x':
			case 'u':
			case 'U':
				p++;
				n = 0;
				for(;;)
				{
					c = *p;
					if (c >= 'a' && c <= 'f')
						c = c - 'a' + 10;
					else if (c >= 'A' && c <= 'F')
						c = c - 'A' + 10;
					else if (isnum(c))
						c = c - '0';
					else
						break;
					n = n * 16 + c;
					p++;
				}
				c = n;
				goto add_char_nonext;
			case 'a':
				c = '\a';
				break;
			case 'b':
				c = '\b';
				break;
			case 'f':
				c = '\f';
				break;
			case 'n':
				c = '\n';
				break;
			case 'r':
				c = '\r';
				break;
			case 't':
				c = '\t';
				break;
			case 'v':
				c = '\v';
				break;
			case 'e':
				if (!gnu_ext)
					goto invalid_escape;
				c = 27;
				break;
			case '\'':
			case '\"':
			case '\\':
			case '?':
				break;
			default:
invalid_escape:
				if (c >= '!' && c <= '~')
					tcc_warning("unknown escape sequence: \'\\%c\'", c);
				else
					tcc_warning("unknown escape sequence: \'\\x%x\'", c);
				break;
			}
		}
		else if (is_long && c >= 0x80)
		{
			/* assume we are processing UTF-8 sequence */
			/* reference: The Unicode Standard, Version 10.0, ch3.9 */

			int cont; /* count of continuation bytes */
			int skip; /* how many bytes should skip when error occurred */
			int i;

			/* decode leading byte */
			if (c < 0xC2)
			{
				skip = 1;
				goto invalid_utf8_sequence;
			}
			else if (c <= 0xDF)
			{
				cont = 1;
				n = c & 0x1f;
			}
			else if (c <= 0xEF)
			{
				cont = 2;
				n = c & 0xf;
			}
			else if (c <= 0xF4)
			{
				cont = 3;
				n = c & 0x7;
			}
			else
			{
				skip = 1;
				goto invalid_utf8_sequence;
			}

			/* decode continuation bytes */
			for (i = 1; i <= cont; i++)
			{
				int l = 0x80, h = 0xBF;

				/* adjust limit for second byte */
				if (i == 1)
				{
					switch (c)
					{
					case 0xE0:
						l = 0xA0;
						break;
					case 0xED:
						h = 0x9F;
						break;
					case 0xF0:
						l = 0x90;
						break;
					case 0xF4:
						h = 0x8F;
						break;
					}
				}

				if (p[i] < l || p[i] > h)
				{
					skip = i;
					goto invalid_utf8_sequence;
				}

				n = (n << 6) | (p[i] & 0x3f);
			}

			/* advance pointer */
			p += 1 + cont;
			c = n;
			goto add_char_nonext;

			/* error handling */
invalid_utf8_sequence:
			tcc_warning("ill-formed UTF-8 subsequence starting with: \'\\x%x\'", c);
			c = 0xFFFD;
			p += skip;
			goto add_char_nonext;

		}
		p++;
add_char_nonext:
		if (!is_long)
			cstr_ccat(outstr, c);
		else
		{
#ifdef TCC_TARGET_PE
			/* store as UTF-16 */
			if (c < 0x10000)
			{
				cstr_wccat(outstr, c);
			}
			else
			{
				c -= 0x10000;
				cstr_wccat(outstr, (c >> 10) + 0xD800);
				cstr_wccat(outstr, (c & 0x3FF) + 0xDC00);
			}
#else
			cstr_wccat(outstr, c);
#endif
		}
	}
	/* add a trailing '\0' */
	if (!is_long)
		cstr_ccat(outstr, '\0');
	else
		cstr_wccat(outstr, '\0');
}

static void parse_string(const char *s, int len)
{
	uint8_t buf[1000], *p = buf;
	int is_long, sep;

	if ((is_long = *s == 'L'))
		++s, --len;
	sep = *s++;
	len -= 2;
	if (len >= sizeof buf)
		p = tcc_malloc(len + 1);
	memcpy(p, s, len);
	p[len] = 0;

	cstr_reset(&tokcstr);
	parse_escape_string(&tokcstr, p, is_long);
	if (p != buf)
		tcc_free(p);

	if (sep == '\'')
	{
		int char_size, i, n, c;
		/* XXX: make it portable */
		if (!is_long)
			tok = TOK_CCHAR, char_size = 1;
		else
			tok = TOK_LCHAR, char_size = sizeof(nwchar_t);
		n = tokcstr.size / char_size - 1;
		if (n < 1)
			tcc_error("empty character constant");
		if (n > 1)
			tcc_warning("multi-character character constant");
		for (c = i = 0; i < n; ++i)
		{
			if (is_long)
				c = ((nwchar_t *)tokcstr.data)[i];
			else
				c = (c << 8) | ((char *)tokcstr.data)[i];
		}
		tokc.i = c;
	}
	else
	{
		tokc.str.size = tokcstr.size;
		tokc.str.data = tokcstr.data;
		if (!is_long)
			tok = TOK_STR;
		else
			tok = TOK_LSTR;
	}
}

/* we use 64 bit numbers */
#define BN_SIZE 2

/* bn = (bn << shift) | or_val */
static void bn_lshift(unsigned int *bn, int shift, int or_val)
{
	int i;
	unsigned int v;
	for(i=0; i<BN_SIZE; i++)
	{
		v = bn[i];
		bn[i] = (v << shift) | or_val;
		or_val = v >> (32 - shift);
	}
}

static void bn_zero(unsigned int *bn)
{
	int i;
	for(i=0; i<BN_SIZE; i++)
	{
		bn[i] = 0;
	}
}

/* parse number in null terminated string 'p' and return it in the
   current token */
static void parse_number(const char *p)
{
	int b, t, shift, frac_bits, s, exp_val, ch;
	char *q;
	unsigned int bn[BN_SIZE];
	double d;

	/* number */
	q = token_buf;
	ch = *p++;
	t = ch;
	ch = *p++;
	*q++ = t;
	b = 10;
	if (t == '.')
	{
		goto float_frac_parse;
	}
	else if (t == '0')
	{
		if (ch == 'x' || ch == 'X')
		{
			q--;
			ch = *p++;
			b = 16;
		}
		else if (tcc_state->tcc_ext && (ch == 'b' || ch == 'B'))
		{
			q--;
			ch = *p++;
			b = 2;
		}
	}
	/* parse all digits. cannot check octal numbers at this stage
	   because of floating point constants */
	while (1)
	{
		if (ch >= 'a' && ch <= 'f')
			t = ch - 'a' + 10;
		else if (ch >= 'A' && ch <= 'F')
			t = ch - 'A' + 10;
		else if (isnum(ch))
			t = ch - '0';
		else
			break;
		if (t >= b)
			break;
		if (q >= token_buf + STRING_MAX_SIZE)
		{
num_too_long:
			tcc_error("number too long");
		}
		*q++ = ch;
		ch = *p++;
	}
	if (ch == '.' ||
	        ((ch == 'e' || ch == 'E') && b == 10) ||
	        ((ch == 'p' || ch == 'P') && (b == 16 || b == 2)))
	{
		if (b != 10)
		{
			/* NOTE: strtox should support that for hexa numbers, but
			   non ISOC99 libcs do not support it, so we prefer to do
			   it by hand */
			/* hexadecimal or binary floats */
			/* XXX: handle overflows */
			*q = '\0';
			if (b == 16)
				shift = 4;
			else
				shift = 1;
			bn_zero(bn);
			q = token_buf;
			while (1)
			{
				t = *q++;
				if (t == '\0')
				{
					break;
				}
				else if (t >= 'a')
				{
					t = t - 'a' + 10;
				}
				else if (t >= 'A')
				{
					t = t - 'A' + 10;
				}
				else
				{
					t = t - '0';
				}
				bn_lshift(bn, shift, t);
			}
			frac_bits = 0;
			if (ch == '.')
			{
				ch = *p++;
				while (1)
				{
					t = ch;
					if (t >= 'a' && t <= 'f')
					{
						t = t - 'a' + 10;
					}
					else if (t >= 'A' && t <= 'F')
					{
						t = t - 'A' + 10;
					}
					else if (t >= '0' && t <= '9')
					{
						t = t - '0';
					}
					else
					{
						break;
					}
					if (t >= b)
						tcc_error("invalid digit");
					bn_lshift(bn, shift, t);
					frac_bits += shift;
					ch = *p++;
				}
			}
			if (ch != 'p' && ch != 'P')
				expect("exponent");
			ch = *p++;
			s = 1;
			exp_val = 0;
			if (ch == '+')
			{
				ch = *p++;
			}
			else if (ch == '-')
			{
				s = -1;
				ch = *p++;
			}
			if (ch < '0' || ch > '9')
				expect("exponent digits");
			while (ch >= '0' && ch <= '9')
			{
				exp_val = exp_val * 10 + ch - '0';
				ch = *p++;
			}
			exp_val = exp_val * s;

			/* now we can generate the number */
			/* XXX: should patch directly float number */
			d = (double)bn[1] * 4294967296.0 + (double)bn[0];
			d = ldexp(d, exp_val - frac_bits);
			t = toup(ch);
			if (t == 'F')
			{
				ch = *p++;
				tok = TOK_CFLOAT;
				/* float : should handle overflow */
				tokc.f = (float)d;
			}
			else if (t == 'L')
			{
				ch = *p++;
#ifdef TCC_TARGET_PE
				tok = TOK_CDOUBLE;
				tokc.d = d;
#else
				tok = TOK_CLDOUBLE;
				/* XXX: not large enough */
				tokc.ld = (long double)d;
#endif
			}
			else
			{
				tok = TOK_CDOUBLE;
				tokc.d = d;
			}
		}
		else
		{
			/* decimal floats */
			if (ch == '.')
			{
				if (q >= token_buf + STRING_MAX_SIZE)
					goto num_too_long;
				*q++ = ch;
				ch = *p++;
float_frac_parse:
				while (ch >= '0' && ch <= '9')
				{
					if (q >= token_buf + STRING_MAX_SIZE)
						goto num_too_long;
					*q++ = ch;
					ch = *p++;
				}
			}
			if (ch == 'e' || ch == 'E')
			{
				if (q >= token_buf + STRING_MAX_SIZE)
					goto num_too_long;
				*q++ = ch;
				ch = *p++;
				if (ch == '-' || ch == '+')
				{
					if (q >= token_buf + STRING_MAX_SIZE)
						goto num_too_long;
					*q++ = ch;
					ch = *p++;
				}
				if (ch < '0' || ch > '9')
					expect("exponent digits");
				while (ch >= '0' && ch <= '9')
				{
					if (q >= token_buf + STRING_MAX_SIZE)
						goto num_too_long;
					*q++ = ch;
					ch = *p++;
				}
			}
			*q = '\0';
			t = toup(ch);
			errno = 0;
			if (t == 'F')
			{
				ch = *p++;
				tok = TOK_CFLOAT;
				tokc.f = strtof(token_buf, NULL);
			}
			else if (t == 'L')
			{
				ch = *p++;
#ifdef TCC_TARGET_PE
				tok = TOK_CDOUBLE;
				tokc.d = strtod(token_buf, NULL);
#else
				tok = TOK_CLDOUBLE;
				tokc.ld = strtold(token_buf, NULL);
#endif
			}
			else
			{
				tok = TOK_CDOUBLE;
				tokc.d = strtod(token_buf, NULL);
			}
		}
	}
	else
	{
		unsigned long long n, n1;
		int lcount, ucount, ov = 0;
		const char *p1;

		/* integer number */
		*q = '\0';
		q = token_buf;
		if (b == 10 && *q == '0')
		{
			b = 8;
			q++;
		}
		n = 0;
		while(1)
		{
			t = *q++;
			/* no need for checks except for base 10 / 8 errors */
			if (t == '\0')
				break;
			else if (t >= 'a')
				t = t - 'a' + 10;
			else if (t >= 'A')
				t = t - 'A' + 10;
			else
				t = t - '0';
			if (t >= b)
				tcc_error("invalid digit");
			n1 = n;
			n = n * b + t;
			/* detect overflow */
			if (n1 >= 0x1000000000000000ULL && n / b != n1)
				ov = 1;
		}

		/* Determine the characteristics (unsigned and/or 64bit) the type of
		   the constant must have according to the constant suffix(es) */
		lcount = ucount = 0;
		p1 = p;
		for(;;)
		{
			t = toup(ch);
			if (t == 'L')
			{
				if (lcount >= 2)
					tcc_error("three 'l's in integer constant");
				if (lcount && *(p - 1) != ch)
					tcc_error("incorrect integer suffix: %s", p1);
				lcount++;
				ch = *p++;
			}
			else if (t == 'U')
			{
				if (ucount >= 1)
					tcc_error("two 'u's in integer constant");
				ucount++;
				ch = *p++;
			}
			else
			{
				break;
			}
		}

		/* Determine if it needs 64 bits and/or unsigned in order to fit */
		if (ucount == 0 && b == 10)
		{
			if (lcount <= (LONG_SIZE == 4))
			{
				if (n >= 0x80000000U)
					lcount = (LONG_SIZE == 4) + 1;
			}
			if (n >= 0x8000000000000000ULL)
				ov = 1, ucount = 1;
		}
		else
		{
			if (lcount <= (LONG_SIZE == 4))
			{
				if (n >= 0x100000000ULL)
					lcount = (LONG_SIZE == 4) + 1;
				else if (n >= 0x80000000U)
					ucount = 1;
			}
			if (n >= 0x8000000000000000ULL)
				ucount = 1;
		}

		if (ov)
			tcc_warning("integer constant overflow");

		tok = TOK_CINT;
		if (lcount)
		{
			tok = TOK_CLONG;
			if (lcount == 2)
				tok = TOK_CLLONG;
		}
		if (ucount)
			++tok; /* TOK_CU... */
		tokc.i = n;
	}
	if (ch)
		tcc_error("invalid number\n");
}


#define PARSE2(c1, tok1, c2, tok2)              \
    case c1:                                    \
        PEEKC(c, p);                            \
        if (c == c2) {                          \
            p++;                                \
            tok = tok2;                         \
        } else {                                \
            tok = tok1;                         \
        }                                       \
        break;

/* return next token without macro substitution */
static inline void next_nomacro1(void)
{
	int t, c, is_long, len;
	TokenSym *ts;
	uint8_t *p, *p1;
	unsigned int h;

	p = file->buf_ptr;
redo_no_start:
	c = *p;
	switch(c)
	{
	case ' ':
	case '\t':
		tok = c;
		p++;
		if (parse_flags & PARSE_FLAG_SPACES)
			goto keep_tok_flags;
		while (isidnum_table[*p - CH_EOF] & IS_SPC)
			++p;
		goto redo_no_start;
	case '\f':
	case '\v':
	case '\r':
		p++;
		goto redo_no_start;
	case '\\':
		/* first look if it is in fact an end of buffer */
		c = handle_stray1(p);
		p = file->buf_ptr;
		if (c == '\\')
			goto parse_simple;
		if (c != CH_EOF)
			goto redo_no_start;
		{
			TCCState *s1 = tcc_state;
			if ((parse_flags & PARSE_FLAG_LINEFEED)
			        && !(tok_flags & TOK_FLAG_EOF))
			{
				tok_flags |= TOK_FLAG_EOF;
				tok = TOK_LINEFEED;
				goto keep_tok_flags;
			}
			else if (!(parse_flags & PARSE_FLAG_PREPROCESS))
			{
				tok = TOK_EOF;
			}
			else if (s1->ifdef_stack_ptr != file->ifdef_stack_ptr)
			{
				tcc_error("missing #endif");
			}
			else if (s1->include_stack_ptr == s1->include_stack)
			{
				/* no include left : end of file. */
				tok = TOK_EOF;
			}
			else
			{
				tok_flags &= ~TOK_FLAG_EOF;
				/* pop include file */

				/* test if previous '#endif' was after a #ifdef at
				   start of file */
				if (tok_flags & TOK_FLAG_ENDIF)
				{
#ifdef INC_DEBUG
					printf("#endif %s\n", get_tok_str(file->ifndef_macro_saved, NULL));
#endif
					search_cached_include(s1, file->filename, 1)
					->ifndef_macro = file->ifndef_macro_saved;
					tok_flags &= ~TOK_FLAG_ENDIF;
				}

				/* add end of include file debug info */
				tcc_debug_eincl(tcc_state);
				/* pop include stack */
				tcc_close();
				s1->include_stack_ptr--;
				p = file->buf_ptr;
				if (p == file->buffer)
					tok_flags = TOK_FLAG_BOF|TOK_FLAG_BOL;
				goto redo_no_start;
			}
		}
		break;

	case '\n':
		file->line_num++;
		tok_flags |= TOK_FLAG_BOL;
		p++;
maybe_newline:
		if (0 == (parse_flags & PARSE_FLAG_LINEFEED))
			goto redo_no_start;
		tok = TOK_LINEFEED;
		goto keep_tok_flags;

	case '#':
		/* XXX: simplify */
		PEEKC(c, p);
		if ((tok_flags & TOK_FLAG_BOL) &&
		        (parse_flags & PARSE_FLAG_PREPROCESS))
		{
			file->buf_ptr = p;
			preprocess(tok_flags & TOK_FLAG_BOF);
			p = file->buf_ptr;
			goto maybe_newline;
		}
		else
		{
			if (c == '#')
			{
				p++;
				tok = TOK_TWOSHARPS;
			}
			else
			{
				if (parse_flags & PARSE_FLAG_ASM_FILE)
				{
					p = parse_line_comment(p - 1);
					goto redo_no_start;
				}
				else
				{
					tok = '#';
				}
			}
		}
		break;

	/* dollar is allowed to start identifiers when not parsing asm */
	case '$':
		if (!(isidnum_table[c - CH_EOF] & IS_ID)
		        || (parse_flags & PARSE_FLAG_ASM_FILE))
			goto parse_simple;

	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
parse_ident_fast:
		p1 = p;
		h = TOK_HASH_INIT;
		h = TOK_HASH_FUNC(h, c);
		while (c = *++p, isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM))
			h = TOK_HASH_FUNC(h, c);
		len = p - p1;
		if (c != '\\')
		{
			TokenSym **pts;

			/* fast case : no stray found, so we have the full token
			   and we have already hashed it */
			h &= (TOK_HASH_SIZE - 1);
			pts = &hash_ident[h];
			for(;;)
			{
				ts = *pts;
				if (!ts)
					break;
				if (ts->len == len && !memcmp(ts->str, p1, len))
					goto token_found;
				pts = &(ts->hash_next);
			}
			ts = tok_alloc_new(pts, (char *) p1, len);
token_found:
			;
		}
		else
		{
			/* slower case */
			cstr_reset(&tokcstr);
			cstr_cat(&tokcstr, (char *) p1, len);
			p--;
			PEEKC(c, p);
parse_ident_slow:
			while (isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM))
			{
				cstr_ccat(&tokcstr, c);
				PEEKC(c, p);
			}
			ts = tok_alloc(tokcstr.data, tokcstr.size);
		}
		tok = ts->tok;
		break;
	case 'L':
		t = p[1];
		if (t != '\\' && t != '\'' && t != '\"')
		{
			/* fast case */
			goto parse_ident_fast;
		}
		else
		{
			PEEKC(c, p);
			if (c == '\'' || c == '\"')
			{
				is_long = 1;
				goto str_const;
			}
			else
			{
				cstr_reset(&tokcstr);
				cstr_ccat(&tokcstr, 'L');
				goto parse_ident_slow;
			}
		}
		break;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		t = c;
		PEEKC(c, p);
		/* after the first digit, accept digits, alpha, '.' or sign if
		   prefixed by 'eEpP' */
parse_num:
		cstr_reset(&tokcstr);
		for(;;)
		{
			cstr_ccat(&tokcstr, t);
			if (!((isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM))
			        || c == '.'
			        || ((c == '+' || c == '-')
			            && (((t == 'e' || t == 'E')
			                 && !(parse_flags & PARSE_FLAG_ASM_FILE
			                      /* 0xe+1 is 3 tokens in asm */
			                      && ((char*)tokcstr.data)[0] == '0'
			                      && toup(((char*)tokcstr.data)[1]) == 'X'))
			                || t == 'p' || t == 'P'))))
				break;
			t = c;
			PEEKC(c, p);
		}
		/* We add a trailing '\0' to ease parsing */
		cstr_ccat(&tokcstr, '\0');
		tokc.str.size = tokcstr.size;
		tokc.str.data = tokcstr.data;
		tok = TOK_PPNUM;
		break;

	case '.':
		/* special dot handling because it can also start a number */
		PEEKC(c, p);
		if (isnum(c))
		{
			t = '.';
			goto parse_num;
		}
		else if ((isidnum_table['.' - CH_EOF] & IS_ID)
		         && (isidnum_table[c - CH_EOF] & (IS_ID|IS_NUM)))
		{
			*--p = c = '.';
			goto parse_ident_fast;
		}
		else if (c == '.')
		{
			PEEKC(c, p);
			if (c == '.')
			{
				p++;
				tok = TOK_DOTS;
			}
			else
			{
				*--p = '.'; /* may underflow into file->unget[] */
				tok = '.';
			}
		}
		else
		{
			tok = '.';
		}
		break;
	case '\'':
	case '\"':
		is_long = 0;
str_const:
		cstr_reset(&tokcstr);
		if (is_long)
			cstr_ccat(&tokcstr, 'L');
		cstr_ccat(&tokcstr, c);
		p = parse_pp_string(p, c, &tokcstr);
		cstr_ccat(&tokcstr, c);
		cstr_ccat(&tokcstr, '\0');
		tokc.str.size = tokcstr.size;
		tokc.str.data = tokcstr.data;
		tok = TOK_PPSTR;
		break;

	case '<':
		PEEKC(c, p);
		if (c == '=')
		{
			p++;
			tok = TOK_LE;
		}
		else if (c == '<')
		{
			PEEKC(c, p);
			if (c == '=')
			{
				p++;
				tok = TOK_A_SHL;
			}
			else
			{
				tok = TOK_SHL;
			}
		}
		else
		{
			tok = TOK_LT;
		}
		break;
	case '>':
		PEEKC(c, p);
		if (c == '=')
		{
			p++;
			tok = TOK_GE;
		}
		else if (c == '>')
		{
			PEEKC(c, p);
			if (c == '=')
			{
				p++;
				tok = TOK_A_SAR;
			}
			else
			{
				tok = TOK_SAR;
			}
		}
		else
		{
			tok = TOK_GT;
		}
		break;

	case '&':
		PEEKC(c, p);
		if (c == '&')
		{
			p++;
			tok = TOK_LAND;
		}
		else if (c == '=')
		{
			p++;
			tok = TOK_A_AND;
		}
		else
		{
			tok = '&';
		}
		break;

	case '|':
		PEEKC(c, p);
		if (c == '|')
		{
			p++;
			tok = TOK_LOR;
		}
		else if (c == '=')
		{
			p++;
			tok = TOK_A_OR;
		}
		else
		{
			tok = '|';
		}
		break;

	case '+':
		PEEKC(c, p);
		if (c == '+')
		{
			p++;
			tok = TOK_INC;
		}
		else if (c == '=')
		{
			p++;
			tok = TOK_A_ADD;
		}
		else
		{
			tok = '+';
		}
		break;

	case '-':
		PEEKC(c, p);
		if (c == '-')
		{
			p++;
			tok = TOK_DEC;
		}
		else if (c == '=')
		{
			p++;
			tok = TOK_A_SUB;
		}
		else if (c == '>')
		{
			p++;
			tok = TOK_ARROW;
		}
		else
		{
			tok = '-';
		}
		break;

		PARSE2('!', '!', '=', TOK_NE)
		PARSE2('=', '=', '=', TOK_EQ)
		PARSE2('*', '*', '=', TOK_A_MUL)
		PARSE2('%', '%', '=', TOK_A_MOD)
		PARSE2('^', '^', '=', TOK_A_XOR)

	/* comments or operator */
	case '/':
		PEEKC(c, p);
		if (c == '*')
		{
			p = parse_comment(p);
			/* comments replaced by a blank */
			tok = ' ';
			goto keep_tok_flags;
		}
		else if (c == '/')
		{
			p = parse_line_comment(p);
			tok = ' ';
			goto keep_tok_flags;
		}
		else if (c == '=')
		{
			p++;
			tok = TOK_A_DIV;
		}
		else
		{
			tok = '/';
		}
		break;

	/* simple tokens */
	case '(':
	case ')':
	case '[':
	case ']':
	case '{':
	case '}':
	case ',':
	case ';':
	case ':':
	case '?':
	case '~':
	case '@': /* only used in assembler */
parse_simple:
		tok = c;
		p++;
		break;
	default:
		if (c >= 0x80 && c <= 0xFF) /* utf8 identifiers */
			goto parse_ident_fast;
		if (parse_flags & PARSE_FLAG_ASM_FILE)
			goto parse_simple;
		tcc_error("unrecognized character \\x%02x", c);
		break;
	}
	tok_flags = 0;
keep_tok_flags:
	file->buf_ptr = p;
#if defined(PARSE_DEBUG)
	printf("token = %d %s\n", tok, get_tok_str(tok, &tokc));
#endif
}

/* return next token without macro substitution. Can read input from
   macro_ptr buffer */
static void next_nomacro_spc(void)
{
	if (macro_ptr)
	{
redo:
		tok = *macro_ptr;
		if (tok)
		{
			TOK_GET(&tok, &macro_ptr, &tokc);
			if (tok == TOK_LINENUM)
			{
				file->line_num = tokc.i;
				goto redo;
			}
		}
	}
	else
	{
		next_nomacro1();
	}
	//printf("token = %s\n", get_tok_str(tok, &tokc));
}

ST_FUNC void next_nomacro(void)
{
	do
	{
		next_nomacro_spc();
	}
	while (tok < 256 && (isidnum_table[tok - CH_EOF] & IS_SPC));
}


static void macro_subst(
    TokenString *tok_str,
    Sym **nested_list,
    const int *macro_str
);

/* substitute arguments in replacement lists in macro_str by the values in
   args (field d) and return allocated string */
static int *macro_arg_subst(Sym **nested_list, const int *macro_str, Sym *args)
{
	int t, t0, t1, spc;
	const int *st;
	Sym *s;
	CValue cval;
	TokenString str;
	CString cstr;

	tok_str_new(&str);
	t0 = t1 = 0;
	while(1)
	{
		TOK_GET(&t, &macro_str, &cval);
		if (!t)
			break;
		if (t == '#')
		{
			/* stringize */
			TOK_GET(&t, &macro_str, &cval);
			if (!t)
				goto bad_stringy;
			s = sym_find2(args, t);
			if (s)
			{
				cstr_new(&cstr);
				cstr_ccat(&cstr, '\"');
				st = s->d;
				spc = 0;
				while (*st >= 0)
				{
					TOK_GET(&t, &st, &cval);
					if (t != TOK_PLCHLDR
					        && t != TOK_NOSUBST
					        && 0 == check_space(t, &spc))
					{
						const char *s = get_tok_str(t, &cval);
						while (*s)
						{
							if (t == TOK_PPSTR && *s != '\'')
								add_char(&cstr, *s);
							else
								cstr_ccat(&cstr, *s);
							++s;
						}
					}
				}
				cstr.size -= spc;
				cstr_ccat(&cstr, '\"');
				cstr_ccat(&cstr, '\0');
#ifdef PP_DEBUG
				printf("\nstringize: <%s>\n", (char *)cstr.data);
#endif
				/* add string */
				cval.str.size = cstr.size;
				cval.str.data = cstr.data;
				tok_str_add2(&str, TOK_PPSTR, &cval);
				cstr_free(&cstr);
			}
			else
			{
bad_stringy:
				expect("macro parameter after '#'");
			}
		}
		else if (t >= TOK_IDENT)
		{
			s = sym_find2(args, t);
			if (s)
			{
				int l0 = str.len;
				st = s->d;
				/* if '##' is present before or after, no arg substitution */
				if (*macro_str == TOK_PPJOIN || t1 == TOK_PPJOIN)
				{
					/* special case for var arg macros : ## eats the ','
					   if empty VA_ARGS variable. */
					if (t1 == TOK_PPJOIN && t0 == ',' && gnu_ext && s->type.t)
					{
						if (*st <= 0)
						{
							/* suppress ',' '##' */
							str.len -= 2;
						}
						else
						{
							/* suppress '##' and add variable */
							str.len--;
							goto add_var;
						}
					}
				}
				else
				{
add_var:
					if (!s->next)
					{
						/* Expand arguments tokens and store them.  In most
						   cases we could also re-expand each argument if
						   used multiple times, but not if the argument
						   contains the __COUNTER__ macro.  */
						TokenString str2;
						sym_push2(&s->next, s->v, s->type.t, 0);
						tok_str_new(&str2);
						macro_subst(&str2, nested_list, st);
						tok_str_add(&str2, 0);
						s->next->d = str2.str;
					}
					st = s->next->d;
				}
				for(;;)
				{
					int t2;
					TOK_GET(&t2, &st, &cval);
					if (t2 <= 0)
						break;
					tok_str_add2(&str, t2, &cval);
				}
				if (str.len == l0) /* expanded to empty string */
					tok_str_add(&str, TOK_PLCHLDR);
			}
			else
			{
				tok_str_add(&str, t);
			}
		}
		else
		{
			tok_str_add2(&str, t, &cval);
		}
		t0 = t1, t1 = t;
	}
	tok_str_add(&str, 0);
	return str.str;
}

static char const ab_month_name[12][4] =
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

static int paste_tokens(int t1, CValue *v1, int t2, CValue *v2)
{
	CString cstr;
	int n, ret = 1;

	cstr_new(&cstr);
	if (t1 != TOK_PLCHLDR)
		cstr_cat(&cstr, get_tok_str(t1, v1), -1);
	n = cstr.size;
	if (t2 != TOK_PLCHLDR)
		cstr_cat(&cstr, get_tok_str(t2, v2), -1);
	cstr_ccat(&cstr, '\0');

	tcc_open_bf(tcc_state, ":paste:", cstr.size);
	memcpy(file->buffer, cstr.data, cstr.size);
	tok_flags = 0;
	for (;;)
	{
		next_nomacro1();
		if (0 == *file->buf_ptr)
			break;
		if (is_space(tok))
			continue;
		tcc_warning("pasting \"%.*s\" and \"%s\" does not give a valid"
		            " preprocessing token", n, cstr.data, (char*)cstr.data + n);
		ret = 0;
		break;
	}
	tcc_close();
	//printf("paste <%s>\n", (char*)cstr.data);
	cstr_free(&cstr);
	return ret;
}

/* handle the '##' operator. Return NULL if no '##' seen. Otherwise
   return the resulting string (which must be freed). */
static inline int *macro_twosharps(const int *ptr0)
{
	int t;
	CValue cval;
	TokenString macro_str1;
	int start_of_nosubsts = -1;
	const int *ptr;

	/* we search the first '##' */
	for (ptr = ptr0;;)
	{
		TOK_GET(&t, &ptr, &cval);
		if (t == TOK_PPJOIN)
			break;
		if (t == 0)
			return NULL;
	}

	tok_str_new(&macro_str1);

	//tok_print(" $$$", ptr0);
	for (ptr = ptr0;;)
	{
		TOK_GET(&t, &ptr, &cval);
		if (t == 0)
			break;
		if (t == TOK_PPJOIN)
			continue;
		while (*ptr == TOK_PPJOIN)
		{
			int t1;
			CValue cv1;
			/* given 'a##b', remove nosubsts preceding 'a' */
			if (start_of_nosubsts >= 0)
				macro_str1.len = start_of_nosubsts;
			/* given 'a##b', remove nosubsts preceding 'b' */
			while ((t1 = *++ptr) == TOK_NOSUBST)
				;
			if (t1 && t1 != TOK_PPJOIN)
			{
				TOK_GET(&t1, &ptr, &cv1);
				if (t != TOK_PLCHLDR || t1 != TOK_PLCHLDR)
				{
					if (paste_tokens(t, &cval, t1, &cv1))
					{
						t = tok, cval = tokc;
					}
					else
					{
						tok_str_add2(&macro_str1, t, &cval);
						t = t1, cval = cv1;
					}
				}
			}
		}
		if (t == TOK_NOSUBST)
		{
			if (start_of_nosubsts < 0)
				start_of_nosubsts = macro_str1.len;
		}
		else
		{
			start_of_nosubsts = -1;
		}
		tok_str_add2(&macro_str1, t, &cval);
	}
	tok_str_add(&macro_str1, 0);
	//tok_print(" ###", macro_str1.str);
	return macro_str1.str;
}

/* peek or read [ws_str == NULL] next token from function macro call,
   walking up macro levels up to the file if necessary */
static int next_argstream(Sym **nested_list, TokenString *ws_str)
{
	int t;
	const int *p;
	Sym *sa;

	for (;;)
	{
		if (macro_ptr)
		{
			p = macro_ptr, t = *p;
			if (ws_str)
			{
				while (is_space(t) || TOK_LINEFEED == t || TOK_PLCHLDR == t)
					tok_str_add(ws_str, t), t = *++p;
			}
			if (t == 0)
			{
				end_macro();
				/* also, end of scope for nested defined symbol */
				sa = *nested_list;
				while (sa && sa->v == 0)
					sa = sa->prev;
				if (sa)
					sa->v = 0;
				continue;
			}
		}
		else
		{
			ch = handle_eob();
			if (ws_str)
			{
				while (is_space(ch) || ch == '\n' || ch == '/')
				{
					if (ch == '/')
					{
						int c;
						uint8_t *p = file->buf_ptr;
						PEEKC(c, p);
						if (c == '*')
						{
							p = parse_comment(p);
							file->buf_ptr = p - 1;
						}
						else if (c == '/')
						{
							p = parse_line_comment(p);
							file->buf_ptr = p - 1;
						}
						else
							break;
						ch = ' ';
					}
					if (ch == '\n')
						file->line_num++;
					if (!(ch == '\f' || ch == '\v' || ch == '\r'))
						tok_str_add(ws_str, ch);
					cinp();
				}
			}
			t = ch;
		}

		if (ws_str)
			return t;
		next_nomacro_spc();
		return tok;
	}
}

/* do macro substitution of current token with macro 's' and add
   result to (tok_str,tok_len). 'nested_list' is the list of all
   macros we got inside to avoid recursing. Return non zero if no
   substitution needs to be done */
static int macro_subst_tok(
    TokenString *tok_str,
    Sym **nested_list,
    Sym *s)
{
	Sym *args, *sa, *sa1;
	int parlevel, t, t1, spc;
	TokenString str;
	char *cstrval;
	CValue cval;
	CString cstr;
	char buf[32];

	/* if symbol is a macro, prepare substitution */
	/* special macros */
	if (tok == TOK___LINE__ || tok == TOK___COUNTER__)
	{
		t = tok == TOK___LINE__ ? file->line_num : pp_counter++;
		snprintf(buf, sizeof(buf), "%d", t);
		cstrval = buf;
		t1 = TOK_PPNUM;
		goto add_cstr1;
	}
	else if (tok == TOK___FILE__)
	{
		cstrval = file->filename;
		goto add_cstr;
	}
	else if (tok == TOK___DATE__ || tok == TOK___TIME__)
	{
		time_t ti;
		struct tm *tm;

		time(&ti);
		tm = localtime(&ti);
		if (tok == TOK___DATE__)
		{
			snprintf(buf, sizeof(buf), "%s %2d %d",
			         ab_month_name[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);
		}
		else
		{
			snprintf(buf, sizeof(buf), "%02d:%02d:%02d",
			         tm->tm_hour, tm->tm_min, tm->tm_sec);
		}
		cstrval = buf;
add_cstr:
		t1 = TOK_STR;
add_cstr1:
		cstr_new(&cstr);
		cstr_cat(&cstr, cstrval, 0);
		cval.str.size = cstr.size;
		cval.str.data = cstr.data;
		tok_str_add2(tok_str, t1, &cval);
		cstr_free(&cstr);
	}
	else if (s->d)
	{
		int saved_parse_flags = parse_flags;
		int *joined_str = NULL;
		int *mstr = s->d;

		if (s->type.t == MACRO_FUNC)
		{
			/* whitespace between macro name and argument list */
			TokenString ws_str;
			tok_str_new(&ws_str);

			spc = 0;
			parse_flags |= PARSE_FLAG_SPACES | PARSE_FLAG_LINEFEED
			               | PARSE_FLAG_ACCEPT_STRAYS;

			/* get next token from argument stream */
			t = next_argstream(nested_list, &ws_str);
			if (t != '(')
			{
				/* not a macro substitution after all, restore the
				 * macro token plus all whitespace we've read.
				 * whitespace is intentionally not merged to preserve
				 * newlines. */
				parse_flags = saved_parse_flags;
				tok_str_add(tok_str, tok);
				if (parse_flags & PARSE_FLAG_SPACES)
				{
					int i;
					for (i = 0; i < ws_str.len; i++)
						tok_str_add(tok_str, ws_str.str[i]);
				}
				tok_str_free_str(ws_str.str);
				return 0;
			}
			else
			{
				tok_str_free_str(ws_str.str);
			}
			do
			{
				next_nomacro(); /* eat '(' */
			}
			while (tok == TOK_PLCHLDR);

			/* argument macro */
			args = NULL;
			sa = s->next;
			/* NOTE: empty args are allowed, except if no args */
			for(;;)
			{
				do
				{
					next_argstream(nested_list, NULL);
				}
				while (is_space(tok) || TOK_LINEFEED == tok);
empty_arg:
				/* handle '()' case */
				if (!args && !sa && tok == ')')
					break;
				if (!sa)
					tcc_error("macro '%s' used with too many args",
					          get_tok_str(s->v, 0));
				tok_str_new(&str);
				parlevel = spc = 0;
				/* NOTE: non zero sa->t indicates VA_ARGS */
				while ((parlevel > 0 ||
				        (tok != ')' &&
				         (tok != ',' || sa->type.t))))
				{
					if (tok == TOK_EOF || tok == 0)
						break;
					if (tok == '(')
						parlevel++;
					else if (tok == ')')
						parlevel--;
					if (tok == TOK_LINEFEED)
						tok = ' ';
					if (!check_space(tok, &spc))
						tok_str_add2(&str, tok, &tokc);
					next_argstream(nested_list, NULL);
				}
				if (parlevel)
					expect(")");
				str.len -= spc;
				tok_str_add(&str, -1);
				tok_str_add(&str, 0);
				sa1 = sym_push2(&args, sa->v & ~SYM_FIELD, sa->type.t, 0);
				sa1->d = str.str;
				sa = sa->next;
				if (tok == ')')
				{
					/* special case for gcc var args: add an empty
					   var arg argument if it is omitted */
					if (sa && sa->type.t && gnu_ext)
						goto empty_arg;
					break;
				}
				if (tok != ',')
					expect(",");
			}
			if (sa)
			{
				tcc_error("macro '%s' used with too few args",
				          get_tok_str(s->v, 0));
			}

			parse_flags = saved_parse_flags;

			/* now subst each arg */
			mstr = macro_arg_subst(nested_list, mstr, args);
			/* free memory */
			sa = args;
			while (sa)
			{
				sa1 = sa->prev;
				tok_str_free_str(sa->d);
				if (sa->next)
				{
					tok_str_free_str(sa->next->d);
					sym_free(sa->next);
				}
				sym_free(sa);
				sa = sa1;
			}
		}

		sym_push2(nested_list, s->v, 0, 0);
		parse_flags = saved_parse_flags;
		joined_str = macro_twosharps(mstr);
		macro_subst(tok_str, nested_list, joined_str ? joined_str : mstr);

		/* pop nested defined symbol */
		sa1 = *nested_list;
		*nested_list = sa1->prev;
		sym_free(sa1);
		if (joined_str)
			tok_str_free_str(joined_str);
		if (mstr != s->d)
			tok_str_free_str(mstr);
	}
	return 0;
}

/* do macro substitution of macro_str and add result to
   (tok_str,tok_len). 'nested_list' is the list of all macros we got
   inside to avoid recursing. */
static void macro_subst(
    TokenString *tok_str,
    Sym **nested_list,
    const int *macro_str
)
{
	Sym *s;
	int t, spc, nosubst;
	CValue cval;

	spc = nosubst = 0;

	while (1)
	{
		TOK_GET(&t, &macro_str, &cval);
		if (t <= 0)
			break;

		if (t >= TOK_IDENT && 0 == nosubst)
		{
			s = define_find(t);
			if (s == NULL)
				goto no_subst;

			/* if nested substitution, do nothing */
			if (sym_find2(*nested_list, t))
			{
				/* and mark it as TOK_NOSUBST, so it doesn't get subst'd again */
				tok_str_add2(tok_str, TOK_NOSUBST, NULL);
				goto no_subst;
			}

			{
				TokenString *str = tok_str_alloc();
				str->str = (int*)macro_str;
				begin_macro(str, 2);

				tok = t;
				macro_subst_tok(tok_str, nested_list, s);

				if (macro_stack != str)
				{
					/* already finished by reading function macro arguments */
					break;
				}

				macro_str = macro_ptr;
				end_macro ();
			}
			if (tok_str->len)
				spc = is_space(t = tok_str->str[tok_str->lastlen]);
		}
		else
		{
			if (t == '\\' && !(parse_flags & PARSE_FLAG_ACCEPT_STRAYS))
				tcc_error("stray '\\' in program");
no_subst:
			if (!check_space(t, &spc))
				tok_str_add2(tok_str, t, &cval);

			if (nosubst)
			{
				if (nosubst > 1 && (spc || (++nosubst == 3 && t == '(')))
					continue;
				nosubst = 0;
			}
			if (t == TOK_NOSUBST)
				nosubst = 1;
		}
		/* GCC supports 'defined' as result of a macro substitution */
		if (t == TOK_DEFINED && pp_expr)
			nosubst = 2;
	}
}

/* return next token with macro substitution */
ST_FUNC void next(void)
{
redo:
	if (parse_flags & PARSE_FLAG_SPACES)
		next_nomacro_spc();
	else
		next_nomacro();

	if (macro_ptr)
	{
		if (tok == TOK_NOSUBST || tok == TOK_PLCHLDR)
		{
			/* discard preprocessor markers */
			goto redo;
		}
		else if (tok == 0)
		{
			/* end of macro or unget token string */
			end_macro();
			goto redo;
		}
	}
	else if (tok >= TOK_IDENT && (parse_flags & PARSE_FLAG_PREPROCESS))
	{
		Sym *s;
		/* if reading from file, try to substitute macros */
		s = define_find(tok);
		if (s)
		{
			Sym *nested_list = NULL;
			tokstr_buf.len = 0;
			macro_subst_tok(&tokstr_buf, &nested_list, s);
			tok_str_add(&tokstr_buf, 0);
			begin_macro(&tokstr_buf, 0);
			goto redo;
		}
	}
	/* convert preprocessor tokens into C tokens */
	if (tok == TOK_PPNUM)
	{
		if  (parse_flags & PARSE_FLAG_TOK_NUM)
			parse_number((char *)tokc.str.data);
	}
	else if (tok == TOK_PPSTR)
	{
		if (parse_flags & PARSE_FLAG_TOK_STR)
			parse_string((char *)tokc.str.data, tokc.str.size - 1);
	}
}

/* push back current token and set current token to 'last_tok'. Only
   identifier case handled for labels. */
ST_INLN void unget_tok(int last_tok)
{

	TokenString *str = tok_str_alloc();
	tok_str_add2(str, tok, &tokc);
	tok_str_add(str, 0);
	begin_macro(str, 1);
	tok = last_tok;
}

ST_FUNC void preprocess_start(TCCState *s1, int is_asm)
{
	CString cstr;

	tccpp_new(s1);

	s1->include_stack_ptr = s1->include_stack;
	s1->ifdef_stack_ptr = s1->ifdef_stack;
	file->ifdef_stack_ptr = s1->ifdef_stack_ptr;
	pp_expr = 0;
	pp_counter = 0;
	pp_debug_tok = pp_debug_symv = 0;
	pp_once++;
	s1->pack_stack[0] = 0;
	s1->pack_stack_ptr = s1->pack_stack;

	set_idnum('$', s1->dollars_in_identifiers ? IS_ID : 0);
	set_idnum('.', is_asm ? IS_ID : 0);

	cstr_new(&cstr);
	if (s1->cmdline_defs.size)
		cstr_cat(&cstr, s1->cmdline_defs.data, s1->cmdline_defs.size);
	cstr_printf(&cstr, "#define __BASE_FILE__ \"%s\"\n", file->filename);
	if (is_asm)
		cstr_printf(&cstr, "#define __ASSEMBLER__ 1\n");
	if (s1->output_type == TCC_OUTPUT_MEMORY)
		cstr_printf(&cstr, "#define __TCC_RUN__ 1\n");
	if (s1->cmdline_incl.size)
		cstr_cat(&cstr, s1->cmdline_incl.data, s1->cmdline_incl.size);
	//printf("%s\n", (char*)cstr.data);
	*s1->include_stack_ptr++ = file;
	tcc_open_bf(s1, "<command line>", cstr.size);
	memcpy(file->buffer, cstr.data, cstr.size);
	cstr_free(&cstr);

	parse_flags = is_asm ? PARSE_FLAG_ASM_FILE : 0;
	tok_flags = TOK_FLAG_BOL | TOK_FLAG_BOF;
}

/* cleanup from error/setjmp */
ST_FUNC void preprocess_end(TCCState *s1)
{
	while (macro_stack)
		end_macro();
	macro_ptr = NULL;
	while (file)
		tcc_close();
	tccpp_delete(s1);
}

ST_FUNC void tccpp_new(TCCState *s)
{
	int i, c;
	const char *p, *r;

	/* init isid table */
	for(i = CH_EOF; i<128; i++)
		set_idnum(i,
		          is_space(i) ? IS_SPC
		          : isid(i) ? IS_ID
		          : isnum(i) ? IS_NUM
		          : 0);

	for(i = 128; i<256; i++)
		set_idnum(i, IS_ID);

	/* init allocators */
	tal_new(&toksym_alloc, TOKSYM_TAL_LIMIT, TOKSYM_TAL_SIZE);
	tal_new(&tokstr_alloc, TOKSTR_TAL_LIMIT, TOKSTR_TAL_SIZE);

	memset(hash_ident, 0, TOK_HASH_SIZE * sizeof(TokenSym *));
	memset(s->cached_includes_hash, 0, sizeof s->cached_includes_hash);

	cstr_new(&cstr_buf);
	cstr_realloc(&cstr_buf, STRING_MAX_SIZE);
	tok_str_new(&tokstr_buf);
	tok_str_realloc(&tokstr_buf, TOKSTR_MAX_SIZE);

	tok_ident = TOK_IDENT;
	p = tcc_keywords;
	while (*p)
	{
		r = p;
		for(;;)
		{
			c = *r++;
			if (c == '\0')
				break;
		}
		tok_alloc(p, r - p - 1);
		p = r;
	}

	/* we add dummy defines for some special macros to speed up tests
	   and to have working defined() */
	define_push(TOK___LINE__, MACRO_OBJ, NULL, NULL);
	define_push(TOK___FILE__, MACRO_OBJ, NULL, NULL);
	define_push(TOK___DATE__, MACRO_OBJ, NULL, NULL);
	define_push(TOK___TIME__, MACRO_OBJ, NULL, NULL);
	define_push(TOK___COUNTER__, MACRO_OBJ, NULL, NULL);
}

ST_FUNC void tccpp_delete(TCCState *s)
{
	int i, n;

	dynarray_reset(&s->cached_includes, &s->nb_cached_includes);

	/* free tokens */
	n = tok_ident - TOK_IDENT;
	if (n > total_idents)
		total_idents = n;
	for(i = 0; i < n; i++)
		tal_free(toksym_alloc, table_ident[i]);
	tcc_free(table_ident);
	table_ident = NULL;

	/* free static buffers */
	cstr_free(&tokcstr);
	cstr_free(&cstr_buf);
	cstr_free(&macro_equal_buf);
	tok_str_free_str(tokstr_buf.str);

	/* free allocators */
	tal_delete(toksym_alloc);
	toksym_alloc = NULL;
	tal_delete(tokstr_alloc);
	tokstr_alloc = NULL;
}

/* ------------------------------------------------------------------------- */
/* tcc -E [-P[1]] [-dD} support */

static void tok_print(const char *msg, const int *str)
{
	FILE *fp;
	int t, s = 0;
	CValue cval;

	fp = tcc_state->ppfp;
	fprintf(fp, "%s", msg);
	while (str)
	{
		TOK_GET(&t, &str, &cval);
		if (!t)
			break;
		fprintf(fp, " %s" + s, get_tok_str(t, &cval)), s = 1;
	}
	fprintf(fp, "\n");
}

static void pp_line(TCCState *s1, BufferedFile *f, int level)
{
	int d = f->line_num - f->line_ref;

	if (s1->dflag & 4)
		return;

	if (s1->Pflag == LINE_MACRO_OUTPUT_FORMAT_NONE)
	{
		;
	}
	else if (level == 0 && f->line_ref && d < 8)
	{
		while (d > 0)
			fputs("\n", s1->ppfp), --d;
	}
	else if (s1->Pflag == LINE_MACRO_OUTPUT_FORMAT_STD)
	{
		fprintf(s1->ppfp, "#line %d \"%s\"\n", f->line_num, f->filename);
	}
	else
	{
		fprintf(s1->ppfp, "# %d \"%s\"%s\n", f->line_num, f->filename,
		        level > 0 ? " 1" : level < 0 ? " 2" : "");
	}
	f->line_ref = f->line_num;
}

static void define_print(TCCState *s1, int v)
{
	FILE *fp;
	Sym *s;

	s = define_find(v);
	if (NULL == s || NULL == s->d)
		return;

	fp = s1->ppfp;
	fprintf(fp, "#define %s", get_tok_str(v, NULL));
	if (s->type.t == MACRO_FUNC)
	{
		Sym *a = s->next;
		fprintf(fp,"(");
		if (a)
			for (;;)
			{
				fprintf(fp,"%s", get_tok_str(a->v & ~SYM_FIELD, NULL));
				if (!(a = a->next))
					break;
				fprintf(fp,",");
			}
		fprintf(fp,")");
	}
	tok_print("", s->d);
}

static void pp_debug_defines(TCCState *s1)
{
	int v, t;
	const char *vs;
	FILE *fp;

	t = pp_debug_tok;
	if (t == 0)
		return;

	file->line_num--;
	pp_line(s1, file, 0);
	file->line_ref = ++file->line_num;

	fp = s1->ppfp;
	v = pp_debug_symv;
	vs = get_tok_str(v, NULL);
	if (t == TOK_DEFINE)
	{
		define_print(s1, v);
	}
	else if (t == TOK_UNDEF)
	{
		fprintf(fp, "#undef %s\n", vs);
	}
	else if (t == TOK_push_macro)
	{
		fprintf(fp, "#pragma push_macro(\"%s\")\n", vs);
	}
	else if (t == TOK_pop_macro)
	{
		fprintf(fp, "#pragma pop_macro(\"%s\")\n", vs);
	}
	pp_debug_tok = 0;
}

static void pp_debug_builtins(TCCState *s1)
{
	int v;
	for (v = TOK_IDENT; v < tok_ident; ++v)
		define_print(s1, v);
}

/* Add a space between tokens a and b to avoid unwanted textual pasting */
static int pp_need_space(int a, int b)
{
	return 'E' == a ? '+' == b || '-' == b
	       : '+' == a ? TOK_INC == b || '+' == b
	       : '-' == a ? TOK_DEC == b || '-' == b
	       : a >= TOK_IDENT ? b >= TOK_IDENT
	       : a == TOK_PPNUM ? b >= TOK_IDENT
	       : 0;
}

/* maybe hex like 0x1e */
static int pp_check_he0xE(int t, const char *p)
{
	if (t == TOK_PPNUM && toup(strchr(p, 0)[-1]) == 'E')
		return 'E';
	return t;
}

/* Preprocess the current file */
ST_FUNC int tcc_preprocess(TCCState *s1)
{
	BufferedFile **iptr;
	int token_seen, spcs, level;
	const char *p;
	char white[400];

	parse_flags = PARSE_FLAG_PREPROCESS
	              | (parse_flags & PARSE_FLAG_ASM_FILE)
	              | PARSE_FLAG_LINEFEED
	              | PARSE_FLAG_SPACES
	              | PARSE_FLAG_ACCEPT_STRAYS
	              ;
	/* Credits to Fabrice Bellard's initial revision to demonstrate its
	   capability to compile and run itself, provided all numbers are
	   given as decimals. tcc -E -P10 will do. */
	if (s1->Pflag == LINE_MACRO_OUTPUT_FORMAT_P10)
		parse_flags |= PARSE_FLAG_TOK_NUM, s1->Pflag = 1;

#ifdef PP_BENCH
	/* for PP benchmarks */
	do next();
	while (tok != TOK_EOF);
	return 0;
#endif

	if (s1->dflag & 1)
	{
		pp_debug_builtins(s1);
		s1->dflag &= ~1;
	}

	token_seen = TOK_LINEFEED, spcs = 0;
	pp_line(s1, file, 0);
	for (;;)
	{
		iptr = s1->include_stack_ptr;
		next();
		if (tok == TOK_EOF)
			break;

		level = s1->include_stack_ptr - iptr;
		if (level)
		{
			if (level > 0)
				pp_line(s1, *iptr, 0);
			pp_line(s1, file, level);
		}
		if (s1->dflag & 7)
		{
			pp_debug_defines(s1);
			if (s1->dflag & 4)
				continue;
		}

		if (is_space(tok))
		{
			if (spcs < sizeof white - 1)
				white[spcs++] = tok;
			continue;
		}
		else if (tok == TOK_LINEFEED)
		{
			spcs = 0;
			if (token_seen == TOK_LINEFEED)
				continue;
			++file->line_ref;
		}
		else if (token_seen == TOK_LINEFEED)
		{
			pp_line(s1, file, 0);
		}
		else if (spcs == 0 && pp_need_space(token_seen, tok))
		{
			white[spcs++] = ' ';
		}

		white[spcs] = 0, fputs(white, s1->ppfp), spcs = 0;
		fputs(p = get_tok_str(tok, &tokc), s1->ppfp);
		token_seen = pp_check_he0xE(tok, p);
	}
	return 0;
}

/* ------------------------------------------------------------------------- */

//END tccpp.c

//START tccgen.c


#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

/********************************************************/
/* global variables */

/* loc : local variable index
   ind : output code index
   rsym: return symbol
   anon_sym: anonymous symbol index
*/
ST_DATA int rsym, anon_sym, ind, loc;

ST_DATA Sym *global_stack;
ST_DATA Sym *local_stack;
ST_DATA Sym *define_stack;
ST_DATA Sym *global_label_stack;
ST_DATA Sym *local_label_stack;

static Sym *sym_free_first;
static void **sym_pools;
static int nb_sym_pools;

static Sym *all_cleanups, *pending_gotos;
static int local_scope;
static int in_sizeof;
static int in_generic;
static int section_sym;

ST_DATA SValue *vtop;
static SValue _vstack[1 + VSTACK_SIZE];
#define vstack (_vstack + 1)

ST_DATA int const_wanted; /* true if constant wanted */
ST_DATA int nocode_wanted; /* no code generation wanted */
#define unevalmask 0xffff /* unevaluated subexpression */
#define NODATA_WANTED (nocode_wanted > 0) /* no static data output wanted either */
#define STATIC_DATA_WANTED (nocode_wanted & 0xC0000000) /* only static data output */

/* Automagical code suppression ----> */
#define CODE_OFF() (nocode_wanted |= 0x20000000)
#define CODE_ON() (nocode_wanted &= ~0x20000000)

/* Clear 'nocode_wanted' at label if it was used */
ST_FUNC void gsym(int t)
{
	if (t)
	{
		gsym_addr(t, ind);
		CODE_ON();
	}
}
static int gind(void)
{
	CODE_ON();
	return ind;
}

/* Set 'nocode_wanted' after unconditional jumps */
static void gjmp_addr_acs(int t)
{
	gjmp_addr(t);
	CODE_OFF();
}
static int gjmp_acs(int t)
{
	t = gjmp(t);
	CODE_OFF();
	return t;
}

/* These are #undef'd at the end of this file */
#define gjmp_addr gjmp_addr_acs
#define gjmp gjmp_acs
/* <---- */

ST_DATA int global_expr;  /* true if compound literals must be allocated globally (used during initializers parsing */
ST_DATA CType func_vt; /* current function return type (used by return instruction) */
ST_DATA int func_var; /* true if current function is variadic (used by return instruction) */
ST_DATA int func_vc;
static int last_line_num, new_file, func_ind; /* debug info control */
ST_DATA const char *funcname;
ST_DATA CType int_type, func_old_type, char_pointer_type;

#if PTR_SIZE == 4
#define VT_SIZE_T (VT_INT | VT_UNSIGNED)
#define VT_PTRDIFF_T VT_INT
#elif LONG_SIZE == 4
#define VT_SIZE_T (VT_LLONG | VT_UNSIGNED)
#define VT_PTRDIFF_T VT_LLONG
#else
#define VT_SIZE_T (VT_LONG | VT_LLONG | VT_UNSIGNED)
#define VT_PTRDIFF_T (VT_LONG | VT_LLONG)
#endif

ST_DATA struct switch_t
{
	struct case_t
	{
		int64_t v1, v2;
		int sym;
	} **p;
	int n; /* list of case ranges */
	int def_sym; /* default symbol */
	int *bsym;
	struct scope *scope;
	struct switch_t *prev;
	SValue sv;
} *cur_switch; /* current switch */

#define MAX_TEMP_LOCAL_VARIABLE_NUMBER 8
/*list of temporary local variables on the stack in current function. */
ST_DATA struct temp_local_variable
{
	int location; //offset on stack. Svalue.c.i
	short size;
	short align;
} arr_temp_local_vars[MAX_TEMP_LOCAL_VARIABLE_NUMBER];
short nb_temp_local_vars;

static struct scope
{
	struct scope *prev;
	struct
	{
		int loc, num;
	} vla;
	struct
	{
		Sym *s;
		int n;
	} cl;
	int *bsym, *csym;
	Sym *lstk, *llstk;
} *cur_scope, *loop_scope, *root_scope;

/********************************************************/
#if 1
#define precedence_parser
static void init_prec(void);
#endif
/********************************************************/
#ifndef CONFIG_TCC_ASM
ST_FUNC void asm_instr(void)
{
	tcc_error("inline asm() not supported");
}
ST_FUNC void asm_global_instr(void)
{
	tcc_error("inline asm() not supported");
}
#endif

/* ------------------------------------------------------------------------- */
static void gen_cast(CType *type);
static void gen_cast_s(int t);
static inline CType *pointed_type(CType *type);
static int is_compatible_types(CType *type1, CType *type2);
static int parse_btype(CType *type, AttributeDef *ad);
static CType *type_decl(CType *type, AttributeDef *ad, int *v, int td);
static void parse_expr_type(CType *type);
static void init_putv(CType *type, Section *sec, unsigned long c);
static void decl_initializer(CType *type, Section *sec, unsigned long c, int flags);
static void block(int is_expr);
static void decl_initializer_alloc(CType *type, AttributeDef *ad, int r, int has_init, int v, int scope);
static void decl(int l);
static int decl0(int l, int is_for_loop_init, Sym *);
static void expr_eq(void);
static void vla_runtime_type_size(CType *type, int *a);
static int is_compatible_unqualified_types(CType *type1, CType *type2);
static inline int64_t expr_const64(void);
static void vpush64(int ty, unsigned long long v);
static void vpush(CType *type);
static int gvtst(int inv, int t);
static void gen_inline_functions(TCCState *s);
static void free_inline_functions(TCCState *s);
static void skip_or_save_block(TokenString **str);
static void gv_dup(void);
static int get_temp_local_var(int size,int align);
static void clear_temp_local_var_list();
static void cast_error(CType *st, CType *dt);

ST_INLN int is_float(int t)
{
	int bt = t & VT_BTYPE;
	return bt == VT_LDOUBLE
	       || bt == VT_DOUBLE
	       || bt == VT_FLOAT
	       || bt == VT_QFLOAT;
}

static inline int is_integer_btype(int bt)
{
	return bt == VT_BYTE
	       || bt == VT_BOOL
	       || bt == VT_SHORT
	       || bt == VT_INT
	       || bt == VT_LLONG;
}

static int btype_size(int bt)
{
	return bt == VT_BYTE || bt == VT_BOOL ? 1 :
	       bt == VT_SHORT ? 2 :
	       bt == VT_INT ? 4 :
	       bt == VT_LLONG ? 8 :
	       bt == VT_PTR ? PTR_SIZE : 0;
}

/* returns function return register from type */
static int R_RET(int t)
{
	if (!is_float(t))
		return REG_IRET;
#ifdef TCC_TARGET_X86_64
	if ((t & VT_BTYPE) == VT_LDOUBLE)
		return TREG_ST0;
#elif defined TCC_TARGET_RISCV64
	if ((t & VT_BTYPE) == VT_LDOUBLE)
		return REG_IRET;
#endif
	return REG_FRET;
}

/* returns 2nd function return register, if any */
static int R2_RET(int t)
{
	t &= VT_BTYPE;
#if PTR_SIZE == 4
	if (t == VT_LLONG)
		return REG_IRE2;
#elif defined TCC_TARGET_X86_64
	if (t == VT_QLONG)
		return REG_IRE2;
	if (t == VT_QFLOAT)
		return REG_FRE2;
#elif defined TCC_TARGET_RISCV64
	if (t == VT_LDOUBLE)
		return REG_IRE2;
#endif
	return VT_CONST;
}

/* returns true for two-word types */
#define USING_TWO_WORDS(t) (R2_RET(t) != VT_CONST)

/* put function return registers to stack value */
static void PUT_R_RET(SValue *sv, int t)
{
	sv->r = R_RET(t), sv->r2 = R2_RET(t);
}

/* returns function return register class for type t */
static int RC_RET(int t)
{
	return reg_classes[R_RET(t)] & ~(RC_FLOAT | RC_INT);
}

/* returns generic register class for type t */
static int RC_TYPE(int t)
{
	if (!is_float(t))
		return RC_INT;
#ifdef TCC_TARGET_X86_64
	if ((t & VT_BTYPE) == VT_LDOUBLE)
		return RC_ST0;
	if ((t & VT_BTYPE) == VT_QFLOAT)
		return RC_FRET;
#elif defined TCC_TARGET_RISCV64
	if ((t & VT_BTYPE) == VT_LDOUBLE)
		return RC_INT;
#endif
	return RC_FLOAT;
}

/* returns 2nd register class corresponding to t and rc */
static int RC2_TYPE(int t, int rc)
{
	if (!USING_TWO_WORDS(t))
		return 0;
#ifdef RC_IRE2
	if (rc == RC_IRET)
		return RC_IRE2;
#endif
#ifdef RC_FRE2
	if (rc == RC_FRET)
		return RC_FRE2;
#endif
	if (rc & RC_FLOAT)
		return RC_FLOAT;
	return RC_INT;
}

/* we use our own 'finite' function to avoid potential problems with
   non standard math libs */
/* XXX: endianness dependent */
ST_FUNC int ieee_finite(double d)
{
	int p[4];
	memcpy(p, &d, sizeof(double));
	return ((unsigned)((p[1] | 0x800fffff) + 1)) >> 31;
}

/* compiling intel long double natively */
#if (defined __i386__ || defined __x86_64__) \
    && (defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64)
# define TCC_IS_NATIVE_387
#endif

ST_FUNC void test_lvalue(void)
{
	if (!(vtop->r & VT_LVAL))
		expect("lvalue");
}

ST_FUNC void check_vstack(void)
{
	if (vtop != vstack - 1)
		tcc_error("internal compiler error: vstack leak (%d)", vtop - vstack + 1);
}

/* ------------------------------------------------------------------------- */
/* vstack debugging aid */

#if 0
void pv (const char *lbl, int a, int b)
{
	int i;
	for (i = a; i < a + b; ++i)
	{
		SValue *p = &vtop[-i];
		printf("%s vtop[-%d] : type.t:%04x  r:%04x  r2:%04x  c.i:%d\n",
		       lbl, i, p->type.t, p->r, p->r2, (int)p->c.i);
	}
}
#endif

/* ------------------------------------------------------------------------- */
/* start of translation unit info */
ST_FUNC void tcc_debug_start(TCCState *s1)
{
	if (s1->do_debug)
	{
		char buf[512];

		/* file info: full path + filename */
		section_sym = put_elf_sym(symtab_section, 0, 0,
		                          ELFW(ST_INFO)(STB_LOCAL, STT_SECTION), 0,
		                          text_section->sh_num, NULL);
		getcwd(buf, sizeof(buf));
#ifdef _WIN32
		normalize_slashes(buf);
#endif
		pstrcat(buf, sizeof(buf), "/");
		put_stabs_r(s1, buf, N_SO, 0, 0,
		            text_section->data_offset, text_section, section_sym);
		put_stabs_r(s1, file->prev->filename, N_SO, 0, 0,
		            text_section->data_offset, text_section, section_sym);
		new_file = last_line_num = 0;
		func_ind = -1;
		/* we're currently 'including' the <command line> */
		tcc_debug_bincl(s1);
	}

	/* an elf symbol of type STT_FILE must be put so that STB_LOCAL
	   symbols can be safely used */
	put_elf_sym(symtab_section, 0, 0,
	            ELFW(ST_INFO)(STB_LOCAL, STT_FILE), 0,
	            SHN_ABS, file->filename);
}

/* put end of translation unit info */
ST_FUNC void tcc_debug_end(TCCState *s1)
{
	if (!s1->do_debug)
		return;
	put_stabs_r(s1, NULL, N_SO, 0, 0,
	            text_section->data_offset, text_section, section_sym);
}

static BufferedFile* put_new_file(TCCState *s1)
{
	BufferedFile *f = file;
	/* use upper file if from inline ":asm:" */
	if (f->filename[0] == ':')
		f = f->prev;
	if (f && new_file)
	{
		put_stabs_r(s1, f->filename, N_SOL, 0, 0, ind, text_section, section_sym);
		new_file = last_line_num = 0;
	}
	return f;
}

/* generate line number info */
ST_FUNC void tcc_debug_line(TCCState *s1)
{
	BufferedFile *f;
	if (!s1->do_debug
	        || cur_text_section != text_section
	        || !(f = put_new_file(s1))
	        || last_line_num == f->line_num)
		return;
	if (func_ind != -1)
	{
		put_stabn(s1, N_SLINE, 0, f->line_num, ind - func_ind);
	}
	else
	{
		/* from tcc_assemble */
		put_stabs_r(s1, NULL, N_SLINE, 0, f->line_num, ind, text_section, section_sym);
	}
	last_line_num = f->line_num;
}

/* put function symbol */
ST_FUNC void tcc_debug_funcstart(TCCState *s1, Sym *sym)
{
	char buf[512];
	BufferedFile *f;
	if (!s1->do_debug || !(f = put_new_file(s1)))
		return;
	/* XXX: we put here a dummy type */
	snprintf(buf, sizeof(buf), "%s:%c1",
	         funcname, sym->type.t & VT_STATIC ? 'f' : 'F');
	put_stabs_r(s1, buf, N_FUN, 0, f->line_num, 0, cur_text_section, sym->c);
	tcc_debug_line(s1);
}

/* put function size */
ST_FUNC void tcc_debug_funcend(TCCState *s1, int size)
{
	if (!s1->do_debug)
		return;
	put_stabn(s1, N_FUN, 0, 0, size);
}

/* put alternative filename */
ST_FUNC void tcc_debug_putfile(TCCState *s1, const char *filename)
{
	if (0 == strcmp(file->filename, filename))
		return;
	pstrcpy(file->filename, sizeof(file->filename), filename);
	new_file = 1;
}

/* begin of #include */
ST_FUNC void tcc_debug_bincl(TCCState *s1)
{
	if (!s1->do_debug)
		return;
	put_stabs(s1, file->filename, N_BINCL, 0, 0, 0);
	new_file = 1;
}

/* end of #include */
ST_FUNC void tcc_debug_eincl(TCCState *s1)
{
	if (!s1->do_debug)
		return;
	put_stabn(s1, N_EINCL, 0, 0, 0);
	new_file = 1;
}

/* ------------------------------------------------------------------------- */
/* initialize vstack and types.  This must be done also for tcc -E */
ST_FUNC void tccgen_init(TCCState *s1)
{
	vtop = vstack - 1;
	memset(vtop, 0, sizeof *vtop);

	/* define some often used types */
	int_type.t = VT_INT;
	char_pointer_type.t = VT_BYTE;
	mk_pointer(&char_pointer_type);
	func_old_type.t = VT_FUNC;
	func_old_type.ref = sym_push(SYM_FIELD, &int_type, 0, 0);
	func_old_type.ref->f.func_call = FUNC_CDECL;
	func_old_type.ref->f.func_type = FUNC_OLD;
#ifdef precedence_parser
	init_prec();
#endif
}

ST_FUNC int tccgen_compile(TCCState *s1)
{
	cur_text_section = NULL;
	funcname = "";
	anon_sym = SYM_FIRST_ANOM;
	section_sym = 0;
	const_wanted = 0;
	nocode_wanted = 0x80000000;
	local_scope = 0;

	tcc_debug_start(s1);
#ifdef TCC_TARGET_ARM
	arm_init(s1);
#endif
#ifdef INC_DEBUG
	printf("%s: **** new file\n", file->filename);
#endif
	parse_flags = PARSE_FLAG_PREPROCESS | PARSE_FLAG_TOK_NUM | PARSE_FLAG_TOK_STR;
	next();
	decl(VT_CONST);
	gen_inline_functions(s1);
	check_vstack();
	/* end of translation unit info */
	tcc_debug_end(s1);
	return 0;
}

ST_FUNC void tccgen_finish(TCCState *s1)
{
	free_inline_functions(s1);
	sym_pop(&global_stack, NULL, 0);
	sym_pop(&local_stack, NULL, 0);
	/* free preprocessor macros */
	free_defines(NULL);
	/* free sym_pools */
	dynarray_reset(&sym_pools, &nb_sym_pools);
	sym_free_first = NULL;
}

/* ------------------------------------------------------------------------- */
ST_FUNC ElfSym *elfsym(Sym *s)
{
	if (!s || !s->c)
		return NULL;
	return &((ElfSym *)symtab_section->data)[s->c];
}

/* apply storage attributes to Elf symbol */
ST_FUNC void update_storage(Sym *sym)
{
	ElfSym *esym;
	int sym_bind, old_sym_bind;

	esym = elfsym(sym);
	if (!esym)
		return;

	if (sym->a.visibility)
		esym->st_other = (esym->st_other & ~ELFW(ST_VISIBILITY)(-1))
		                 | sym->a.visibility;

	if (sym->type.t & (VT_STATIC | VT_INLINE))
		sym_bind = STB_LOCAL;
	else if (sym->a.weak)
		sym_bind = STB_WEAK;
	else
		sym_bind = STB_GLOBAL;
	old_sym_bind = ELFW(ST_BIND)(esym->st_info);
	if (sym_bind != old_sym_bind)
	{
		esym->st_info = ELFW(ST_INFO)(sym_bind, ELFW(ST_TYPE)(esym->st_info));
	}

#ifdef TCC_TARGET_PE
	if (sym->a.dllimport)
		esym->st_other |= ST_PE_IMPORT;
	if (sym->a.dllexport)
		esym->st_other |= ST_PE_EXPORT;
#endif

#if 0
	printf("storage %s: bind=%c vis=%d exp=%d imp=%d\n",
	       get_tok_str(sym->v, NULL),
	       sym_bind == STB_WEAK ? 'w' : sym_bind == STB_LOCAL ? 'l' : 'g',
	       sym->a.visibility,
	       sym->a.dllexport,
	       sym->a.dllimport
	      );
#endif
}

/* ------------------------------------------------------------------------- */
/* update sym->c so that it points to an external symbol in section
   'section' with value 'value' */

ST_FUNC void put_extern_sym2(Sym *sym, int sh_num,
                             addr_t value, unsigned long size,
                             int can_add_underscore)
{
	int sym_type, sym_bind, info, other, t;
	ElfSym *esym;
	const char *name;
	char buf1[256];
#ifdef CONFIG_TCC_BCHECK
	char buf[32];
#endif

	if (!sym->c)
	{
		name = get_tok_str(sym->v, NULL);
#ifdef CONFIG_TCC_BCHECK
		if (tcc_state->do_bounds_check)
		{
			/* XXX: avoid doing that for statics ? */
			/* if bound checking is activated, we change some function
			   names by adding the "__bound" prefix */
			switch(sym->v)
			{
#ifdef TCC_TARGET_PE
			/* XXX: we rely only on malloc hooks */
			case TOK_malloc:
			case TOK_free:
			case TOK_realloc:
			case TOK_memalign:
			case TOK_calloc:
#endif
			case TOK_memcpy:
			case TOK_memmove:
			case TOK_memset:
			case TOK_memcmp:
			case TOK_strlen:
			case TOK_strcpy:
			case TOK_strncpy:
			case TOK_strcmp:
			case TOK_strncmp:
			case TOK_strcat:
			case TOK_strchr:
			case TOK_strdup:
			case TOK_alloca:
			case TOK_mmap:
			case TOK_munmap:
				strcpy(buf, "__bound_");
				strcat(buf, name);
				name = buf;
				break;
			}
		}
#endif
		t = sym->type.t;
		if ((t & VT_BTYPE) == VT_FUNC)
		{
			sym_type = STT_FUNC;
		}
		else if ((t & VT_BTYPE) == VT_VOID)
		{
			sym_type = STT_NOTYPE;
		}
		else
		{
			sym_type = STT_OBJECT;
		}
		if (t & (VT_STATIC | VT_INLINE))
			sym_bind = STB_LOCAL;
		else
			sym_bind = STB_GLOBAL;
		other = 0;
#ifdef TCC_TARGET_PE
		if (sym_type == STT_FUNC && sym->type.ref)
		{
			Sym *ref = sym->type.ref;
			if (ref->a.nodecorate)
			{
				can_add_underscore = 0;
			}
			if (ref->f.func_call == FUNC_STDCALL && can_add_underscore)
			{
				sprintf(buf1, "_%s@%d", name, ref->f.func_args * PTR_SIZE);
				name = buf1;
				other |= ST_PE_STDCALL;
				can_add_underscore = 0;
			}
		}
#endif
		if (tcc_state->leading_underscore && can_add_underscore)
		{
			buf1[0] = '_';
			pstrcpy(buf1 + 1, sizeof(buf1) - 1, name);
			name = buf1;
		}
		if (sym->asm_label)
			name = get_tok_str(sym->asm_label, NULL);
		info = ELFW(ST_INFO)(sym_bind, sym_type);
		sym->c = put_elf_sym(symtab_section, value, size, info, other, sh_num, name);
	}
	else
	{
		esym = elfsym(sym);
		esym->st_value = value;
		esym->st_size = size;
		esym->st_shndx = sh_num;
	}
	update_storage(sym);
}

ST_FUNC void put_extern_sym(Sym *sym, Section *section,
                            addr_t value, unsigned long size)
{
	int sh_num = section ? section->sh_num : SHN_UNDEF;
	put_extern_sym2(sym, sh_num, value, size, 1);
}

/* add a new relocation entry to symbol 'sym' in section 's' */
ST_FUNC void greloca(Section *s, Sym *sym, unsigned long offset, int type,
                     addr_t addend)
{
	int c = 0;

	if (nocode_wanted && s == cur_text_section)
		return;

	if (sym)
	{
		if (0 == sym->c)
			put_extern_sym(sym, NULL, 0, 0);
		c = sym->c;
	}

	/* now we can add ELF relocation info */
	put_elf_reloca(symtab_section, s, offset, type, c, addend);
}

#if PTR_SIZE == 4
ST_FUNC void greloc(Section *s, Sym *sym, unsigned long offset, int type)
{
	greloca(s, sym, offset, type, 0);
}
#endif

/* ------------------------------------------------------------------------- */
/* symbol allocator */
static Sym *__sym_malloc(void)
{
	Sym *sym_pool, *sym, *last_sym;
	int i;

	sym_pool = tcc_malloc(SYM_POOL_NB * sizeof(Sym));
	dynarray_add(&sym_pools, &nb_sym_pools, sym_pool);

	last_sym = sym_free_first;
	sym = sym_pool;
	for(i = 0; i < SYM_POOL_NB; i++)
	{
		sym->next = last_sym;
		last_sym = sym;
		sym++;
	}
	sym_free_first = last_sym;
	return last_sym;
}

static inline Sym *sym_malloc(void)
{
	Sym *sym;
#ifndef SYM_DEBUG
	sym = sym_free_first;
	if (!sym)
		sym = __sym_malloc();
	sym_free_first = sym->next;
	return sym;
#else
	sym = tcc_malloc(sizeof(Sym));
	return sym;
#endif
}

ST_INLN void sym_free(Sym *sym)
{
#ifndef SYM_DEBUG
	sym->next = sym_free_first;
	sym_free_first = sym;
#else
	tcc_free(sym);
#endif
}

/* push, without hashing */
ST_FUNC Sym *sym_push2(Sym **ps, int v, int t, int c)
{
	Sym *s;

	s = sym_malloc();
	memset(s, 0, sizeof *s);
	s->v = v;
	s->type.t = t;
	s->c = c;
	/* add in stack */
	s->prev = *ps;
	*ps = s;
	return s;
}

/* find a symbol and return its associated structure. 's' is the top
   of the symbol stack */
ST_FUNC Sym *sym_find2(Sym *s, int v)
{
	while (s)
	{
		if (s->v == v)
			return s;
		else if (s->v == -1)
			return NULL;
		s = s->prev;
	}
	return NULL;
}

/* structure lookup */
ST_INLN Sym *struct_find(int v)
{
	v -= TOK_IDENT;
	if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))
		return NULL;
	return table_ident[v]->sym_struct;
}

/* find an identifier */
ST_INLN Sym *sym_find(int v)
{
	v -= TOK_IDENT;
	if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))
		return NULL;
	return table_ident[v]->sym_identifier;
}

static int sym_scope(Sym *s)
{
	if (IS_ENUM_VAL (s->type.t))
		return s->type.ref->sym_scope;
	else
		return s->sym_scope;
}

/* push a given symbol on the symbol stack */
ST_FUNC Sym *sym_push(int v, CType *type, int r, int c)
{
	Sym *s, **ps;
	TokenSym *ts;

	if (local_stack)
		ps = &local_stack;
	else
		ps = &global_stack;
	s = sym_push2(ps, v, type->t, c);
	s->type.ref = type->ref;
	s->r = r;
	/* don't record fields or anonymous symbols */
	/* XXX: simplify */
	if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM)
	{
		/* record symbol in token array */
		ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];
		if (v & SYM_STRUCT)
			ps = &ts->sym_struct;
		else
			ps = &ts->sym_identifier;
		s->prev_tok = *ps;
		*ps = s;
		s->sym_scope = local_scope;
		if (s->prev_tok && sym_scope(s->prev_tok) == s->sym_scope)
			tcc_error("redeclaration of '%s'",
			          get_tok_str(v & ~SYM_STRUCT, NULL));
	}
	return s;
}

/* push a global identifier */
ST_FUNC Sym *global_identifier_push(int v, int t, int c)
{
	Sym *s, **ps;
	s = sym_push2(&global_stack, v, t, c);
	s->r = VT_CONST | VT_SYM;
	/* don't record anonymous symbol */
	if (v < SYM_FIRST_ANOM)
	{
		ps = &table_ident[v - TOK_IDENT]->sym_identifier;
		/* modify the top most local identifier, so that sym_identifier will
		   point to 's' when popped; happens when called from inline asm */
		while (*ps != NULL && (*ps)->sym_scope)
			ps = &(*ps)->prev_tok;
		s->prev_tok = *ps;
		*ps = s;
	}
	return s;
}

/* pop symbols until top reaches 'b'.  If KEEP is non-zero don't really
   pop them yet from the list, but do remove them from the token array.  */
ST_FUNC void sym_pop(Sym **ptop, Sym *b, int keep)
{
	Sym *s, *ss, **ps;
	TokenSym *ts;
	int v;

	s = *ptop;
	while(s != b)
	{
		ss = s->prev;
		v = s->v;
		/* remove symbol in token array */
		/* XXX: simplify */
		if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM)
		{
			ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];
			if (v & SYM_STRUCT)
				ps = &ts->sym_struct;
			else
				ps = &ts->sym_identifier;
			*ps = s->prev_tok;
		}
		if (!keep)
			sym_free(s);
		s = ss;
	}
	if (!keep)
		*ptop = b;
}

/* ------------------------------------------------------------------------- */
static void vcheck_cmp(void)
{
	/* cannot let cpu flags if other instruction are generated. Also
	   avoid leaving VT_JMP anywhere except on the top of the stack
	   because it would complicate the code generator.

	   Don't do this when nocode_wanted.  vtop might come from
	   !nocode_wanted regions (see 88_codeopt.c) and transforming
	   it to a register without actually generating code is wrong
	   as their value might still be used for real.  All values
	   we push under nocode_wanted will eventually be popped
	   again, so that the VT_CMP/VT_JMP value will be in vtop
	   when code is unsuppressed again. */

	if (vtop->r == VT_CMP && !nocode_wanted)
		gv(RC_INT);
}

static void vsetc(CType *type, int r, CValue *vc)
{
	if (vtop >= vstack + (VSTACK_SIZE - 1))
		tcc_error("memory full (vstack)");
	vcheck_cmp();
	vtop++;
	vtop->type = *type;
	vtop->r = r;
	vtop->r2 = VT_CONST;
	vtop->c = *vc;
	vtop->sym = NULL;
}

ST_FUNC void vswap(void)
{
	SValue tmp;

	vcheck_cmp();
	tmp = vtop[0];
	vtop[0] = vtop[-1];
	vtop[-1] = tmp;
}

/* pop stack value */
ST_FUNC void vpop(void)
{
	int v;
	v = vtop->r & VT_VALMASK;
#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
	/* for x86, we need to pop the FP stack */
	if (v == TREG_ST0)
	{
		o(0xd8dd); /* fstp %st(0) */
	}
	else
#endif
		if (v == VT_CMP)
		{
			/* need to put correct jump if && or || without test */
			gsym(vtop->jtrue);
			gsym(vtop->jfalse);
		}
	vtop--;
}

/* push constant of type "type" with useless value */
static void vpush(CType *type)
{
	vset(type, VT_CONST, 0);
}

/* push arbitrary 64bit constant */
static void vpush64(int ty, unsigned long long v)
{
	CValue cval;
	CType ctype;
	ctype.t = ty;
	ctype.ref = NULL;
	cval.i = v;
	vsetc(&ctype, VT_CONST, &cval);
}

/* push integer constant */
ST_FUNC void vpushi(int v)
{
	vpush64(VT_INT, v);
}

/* push a pointer sized constant */
static void vpushs(addr_t v)
{
	vpush64(VT_SIZE_T, v);
}

/* push long long constant */
static inline void vpushll(long long v)
{
	vpush64(VT_LLONG, v);
}

ST_FUNC void vset(CType *type, int r, int v)
{
	CValue cval;
	cval.i = v;
	vsetc(type, r, &cval);
}

static void vseti(int r, int v)
{
	CType type;
	type.t = VT_INT;
	type.ref = NULL;
	vset(&type, r, v);
}

ST_FUNC void vpushv(SValue *v)
{
	if (vtop >= vstack + (VSTACK_SIZE - 1))
		tcc_error("memory full (vstack)");
	vtop++;
	*vtop = *v;
}

static void vdup(void)
{
	vpushv(vtop);
}

/* rotate n first stack elements to the bottom
   I1 ... In -> I2 ... In I1 [top is right]
*/
ST_FUNC void vrotb(int n)
{
	int i;
	SValue tmp;

	vcheck_cmp();
	tmp = vtop[-n + 1];
	for(i=-n+1; i!=0; i++)
		vtop[i] = vtop[i+1];
	vtop[0] = tmp;
}

/* rotate the n elements before entry e towards the top
   I1 ... In ... -> In I1 ... I(n-1) ... [top is right]
 */
ST_FUNC void vrote(SValue *e, int n)
{
	int i;
	SValue tmp;

	vcheck_cmp();
	tmp = *e;
	for(i = 0; i < n - 1; i++)
		e[-i] = e[-i - 1];
	e[-n + 1] = tmp;
}

/* rotate n first stack elements to the top
   I1 ... In -> In I1 ... I(n-1)  [top is right]
 */
ST_FUNC void vrott(int n)
{
	vrote(vtop, n);
}

/* ------------------------------------------------------------------------- */
/* vtop->r = VT_CMP means CPU-flags have been set from comparison or test. */

/* called from generators to set the result from relational ops  */
ST_FUNC void vset_VT_CMP(int op)
{
	vtop->r = VT_CMP;
	vtop->cmp_op = op;
	vtop->jfalse = 0;
	vtop->jtrue = 0;
}

/* called once before asking generators to load VT_CMP to a register */
static void vset_VT_JMP(void)
{
	int op = vtop->cmp_op;

	if (vtop->jtrue || vtop->jfalse)
	{
		/* we need to jump to 'mov $0,%R' or 'mov $1,%R' */
		int inv = op & (op < 2); /* small optimization */
		vseti(VT_JMP+inv, gvtst(inv, 0));
	}
	else
	{
		/* otherwise convert flags (rsp. 0/1) to register */
		vtop->c.i = op;
		if (op < 2) /* doesn't seem to happen */
			vtop->r = VT_CONST;
	}
}

/* Set CPU Flags, doesn't yet jump */
static void gvtst_set(int inv, int t)
{
	int *p;

	if (vtop->r != VT_CMP)
	{
		vpushi(0);
		gen_op(TOK_NE);
		if (vtop->r != VT_CMP) /* must be VT_CONST then */
			vset_VT_CMP(vtop->c.i != 0);
	}

	p = inv ? &vtop->jfalse : &vtop->jtrue;
	*p = gjmp_append(*p, t);
}

/* Generate value test
 *
 * Generate a test for any value (jump, comparison and integers) */
static int gvtst(int inv, int t)
{
	int op, x, u;

	gvtst_set(inv, t);
	t = vtop->jtrue, u = vtop->jfalse;
	if (inv)
		x = u, u = t, t = x;
	op = vtop->cmp_op;

	/* jump to the wanted target */
	if (op > 1)
		t = gjmp_cond(op ^ inv, t);
	else if (op != inv)
		t = gjmp(t);
	/* resolve complementary jumps to here */
	gsym(u);

	vtop--;
	return t;
}

/* generate a zero or nozero test */
static void gen_test_zero(int op)
{
	if (vtop->r == VT_CMP)
	{
		int j;
		if (op == TOK_EQ)
		{
			j = vtop->jfalse;
			vtop->jfalse = vtop->jtrue;
			vtop->jtrue = j;
			vtop->cmp_op ^= 1;
		}
	}
	else
	{
		vpushi(0);
		gen_op(op);
	}
}

/* ------------------------------------------------------------------------- */
/* push a symbol value of TYPE */
static inline void vpushsym(CType *type, Sym *sym)
{
	CValue cval;
	cval.i = 0;
	vsetc(type, VT_CONST | VT_SYM, &cval);
	vtop->sym = sym;
}

/* Return a static symbol pointing to a section */
ST_FUNC Sym *get_sym_ref(CType *type, Section *sec, unsigned long offset, unsigned long size)
{
	int v;
	Sym *sym;

	v = anon_sym++;
	sym = sym_push(v, type, VT_CONST | VT_SYM, 0);
	sym->type.t |= VT_STATIC;
	put_extern_sym(sym, sec, offset, size);
	return sym;
}

/* push a reference to a section offset by adding a dummy symbol */
static void vpush_ref(CType *type, Section *sec, unsigned long offset, unsigned long size)
{
	vpushsym(type, get_sym_ref(type, sec, offset, size));
}

/* define a new external reference to a symbol 'v' of type 'u' */
ST_FUNC Sym *external_global_sym(int v, CType *type)
{
	Sym *s;

	s = sym_find(v);
	if (!s)
	{
		/* push forward reference */
		s = global_identifier_push(v, type->t | VT_EXTERN, 0);
		s->type.ref = type->ref;
	}
	else if (IS_ASM_SYM(s))
	{
		s->type.t = type->t | (s->type.t & VT_EXTERN);
		s->type.ref = type->ref;
		update_storage(s);
	}
	return s;
}

/* Merge symbol attributes.  */
static void merge_symattr(struct SymAttr *sa, struct SymAttr *sa1)
{
	if (sa1->aligned && !sa->aligned)
		sa->aligned = sa1->aligned;
	sa->packed |= sa1->packed;
	sa->weak |= sa1->weak;
	if (sa1->visibility != STV_DEFAULT)
	{
		int vis = sa->visibility;
		if (vis == STV_DEFAULT
		        || vis > sa1->visibility)
			vis = sa1->visibility;
		sa->visibility = vis;
	}
	sa->dllexport |= sa1->dllexport;
	sa->nodecorate |= sa1->nodecorate;
	sa->dllimport |= sa1->dllimport;
}

/* Merge function attributes.  */
static void merge_funcattr(struct FuncAttr *fa, struct FuncAttr *fa1)
{
	if (fa1->func_call && !fa->func_call)
		fa->func_call = fa1->func_call;
	if (fa1->func_type && !fa->func_type)
		fa->func_type = fa1->func_type;
	if (fa1->func_args && !fa->func_args)
		fa->func_args = fa1->func_args;
}

/* Merge attributes.  */
static void merge_attr(AttributeDef *ad, AttributeDef *ad1)
{
	merge_symattr(&ad->a, &ad1->a);
	merge_funcattr(&ad->f, &ad1->f);

	if (ad1->section)
		ad->section = ad1->section;
	if (ad1->alias_target)
		ad->alias_target = ad1->alias_target;
	if (ad1->asm_label)
		ad->asm_label = ad1->asm_label;
	if (ad1->attr_mode)
		ad->attr_mode = ad1->attr_mode;
}

/* Merge some type attributes.  */
static void patch_type(Sym *sym, CType *type)
{
	if (!(type->t & VT_EXTERN) || IS_ENUM_VAL(sym->type.t))
	{
		if (!(sym->type.t & VT_EXTERN))
			tcc_error("redefinition of '%s'", get_tok_str(sym->v, NULL));
		sym->type.t &= ~VT_EXTERN;
	}

	if (IS_ASM_SYM(sym))
	{
		/* stay static if both are static */
		sym->type.t = type->t & (sym->type.t | ~VT_STATIC);
		sym->type.ref = type->ref;
	}

	if (!is_compatible_types(&sym->type, type))
	{
		tcc_error("incompatible types for redefinition of '%s'",
		          get_tok_str(sym->v, NULL));

	}
	else if ((sym->type.t & VT_BTYPE) == VT_FUNC)
	{
		int static_proto = sym->type.t & VT_STATIC;
		/* warn if static follows non-static function declaration */
		if ((type->t & VT_STATIC) && !static_proto
		        /* XXX this test for inline shouldn't be here.  Until we
		           implement gnu-inline mode again it silences a warning for
		           mingw caused by our workarounds.  */
		        && !((type->t | sym->type.t) & VT_INLINE))
			tcc_warning("static storage ignored for redefinition of '%s'",
			            get_tok_str(sym->v, NULL));

		/* set 'inline' if both agree or if one has static */
		if ((type->t | sym->type.t) & VT_INLINE)
		{
			if (!((type->t ^ sym->type.t) & VT_INLINE)
			        || ((type->t | sym->type.t) & VT_STATIC))
				static_proto |= VT_INLINE;
		}

		if (0 == (type->t & VT_EXTERN))
		{
			/* put complete type, use static from prototype */
			sym->type.t = (type->t & ~(VT_STATIC|VT_INLINE)) | static_proto;
			sym->type.ref = type->ref;
		}
		else
		{
			sym->type.t &= ~VT_INLINE | static_proto;
		}

		if (sym->type.ref->f.func_type == FUNC_OLD
		        && type->ref->f.func_type != FUNC_OLD)
		{
			sym->type.ref = type->ref;
		}

	}
	else
	{
		if ((sym->type.t & VT_ARRAY) && type->ref->c >= 0)
		{
			/* set array size if it was omitted in extern declaration */
			sym->type.ref->c = type->ref->c;
		}
		if ((type->t ^ sym->type.t) & VT_STATIC)
			tcc_warning("storage mismatch for redefinition of '%s'",
			            get_tok_str(sym->v, NULL));
	}
}

/* Merge some storage attributes.  */
static void patch_storage(Sym *sym, AttributeDef *ad, CType *type)
{
	if (type)
		patch_type(sym, type);

#ifdef TCC_TARGET_PE
	if (sym->a.dllimport != ad->a.dllimport)
		tcc_error("incompatible dll linkage for redefinition of '%s'",
		          get_tok_str(sym->v, NULL));
#endif
	merge_symattr(&sym->a, &ad->a);
	if (ad->asm_label)
		sym->asm_label = ad->asm_label;
	update_storage(sym);
}

/* copy sym to other stack */
static Sym *sym_copy(Sym *s0, Sym **ps)
{
	Sym *s;
	s = sym_malloc(), *s = *s0;
	s->prev = *ps, *ps = s;
	if (s->v < SYM_FIRST_ANOM)
	{
		ps = &table_ident[s->v - TOK_IDENT]->sym_identifier;
		s->prev_tok = *ps, *ps = s;
	}
	return s;
}

/* copy s->type.ref to stack 'ps' for VT_FUNC and VT_PTR */
static void sym_copy_ref(Sym *s, Sym **ps)
{
	int bt = s->type.t & VT_BTYPE;
	if (bt == VT_FUNC || bt == VT_PTR)
	{
		Sym **sp = &s->type.ref;
		for (s = *sp, *sp = NULL; s; s = s->next)
		{
			Sym *s2 = sym_copy(s, ps);
			sp = &(*sp = s2)->next;
			sym_copy_ref(s2, ps);
		}
	}
}

/* define a new external reference to a symbol 'v' */
static Sym *external_sym(int v, CType *type, int r, AttributeDef *ad)
{
	Sym *s;

	/* look for global symbol */
	s = sym_find(v);
	while (s && s->sym_scope)
		s = s->prev_tok;

	if (!s)
	{
		/* push forward reference */
		s = global_identifier_push(v, type->t, 0);
		s->r |= r;
		s->a = ad->a;
		s->asm_label = ad->asm_label;
		s->type.ref = type->ref;
		/* copy type to the global stack */
		if (local_stack)
			sym_copy_ref(s, &global_stack);
	}
	else
	{
		patch_storage(s, ad, type);
	}
	/* push variables on local_stack if any */
	if (local_stack && (s->type.t & VT_BTYPE) != VT_FUNC)
		s = sym_copy(s, &local_stack);
	return s;
}

/* push a reference to global symbol v */
ST_FUNC void vpush_global_sym(CType *type, int v)
{
	vpushsym(type, external_global_sym(v, type));
}

/* save registers up to (vtop - n) stack entry */
ST_FUNC void save_regs(int n)
{
	SValue *p, *p1;
	for(p = vstack, p1 = vtop - n; p <= p1; p++)
		save_reg(p->r);
}

/* save r to the memory stack, and mark it as being free */
ST_FUNC void save_reg(int r)
{
	save_reg_upstack(r, 0);
}

/* save r to the memory stack, and mark it as being free,
   if seen up to (vtop - n) stack entry */
ST_FUNC void save_reg_upstack(int r, int n)
{
	int l, size, align, bt;
	SValue *p, *p1, sv;

	if ((r &= VT_VALMASK) >= VT_CONST)
		return;
	if (nocode_wanted)
		return;
	l = 0;
	for(p = vstack, p1 = vtop - n; p <= p1; p++)
	{
		if ((p->r & VT_VALMASK) == r || p->r2 == r)
		{
			/* must save value on stack if not already done */
			if (!l)
			{
				bt = p->type.t & VT_BTYPE;
				if (bt == VT_VOID)
					continue;
				if ((p->r & VT_LVAL) || bt == VT_FUNC)
					bt = VT_PTR;
				sv.type.t = bt;
				size = type_size(&sv.type, &align);
				l = get_temp_local_var(size,align);
				sv.r = VT_LOCAL | VT_LVAL;
				sv.c.i = l;
				store(p->r & VT_VALMASK, &sv);
#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
				/* x86 specific: need to pop fp register ST0 if saved */
				if (r == TREG_ST0)
				{
					o(0xd8dd); /* fstp %st(0) */
				}
#endif
				/* special long long case */
				if (p->r2 < VT_CONST && USING_TWO_WORDS(bt))
				{
					sv.c.i += PTR_SIZE;
					store(p->r2, &sv);
				}
			}
			/* mark that stack entry as being saved on the stack */
			if (p->r & VT_LVAL)
			{
				/* also clear the bounded flag because the
				   relocation address of the function was stored in
				   p->c.i */
				p->r = (p->r & ~(VT_VALMASK | VT_BOUNDED)) | VT_LLOCAL;
			}
			else
			{
				p->r = VT_LVAL | VT_LOCAL;
			}
			p->r2 = VT_CONST;
			p->c.i = l;
		}
	}
}

#ifdef TCC_TARGET_ARM
/* find a register of class 'rc2' with at most one reference on stack.
 * If none, call get_reg(rc) */
ST_FUNC int get_reg_ex(int rc, int rc2)
{
	int r;
	SValue *p;

	for(r=0; r<NB_REGS; r++)
	{
		if (reg_classes[r] & rc2)
		{
			int n;
			n=0;
			for(p = vstack; p <= vtop; p++)
			{
				if ((p->r & VT_VALMASK) == r ||
				        p->r2 == r)
					n++;
			}
			if (n <= 1)
				return r;
		}
	}
	return get_reg(rc);
}
#endif

/* find a free register of class 'rc'. If none, save one register */
ST_FUNC int get_reg(int rc)
{
	int r;
	SValue *p;

	/* find a free register */
	for(r=0; r<NB_REGS; r++)
	{
		if (reg_classes[r] & rc)
		{
			if (nocode_wanted)
				return r;
			for(p=vstack; p<=vtop; p++)
			{
				if ((p->r & VT_VALMASK) == r ||
				        p->r2 == r)
					goto notfound;
			}
			return r;
		}
notfound:
		;
	}

	/* no register left : free the first one on the stack (VERY
	   IMPORTANT to start from the bottom to ensure that we don't
	   spill registers used in gen_opi()) */
	for(p=vstack; p<=vtop; p++)
	{
		/* look at second register (if long long) */
		r = p->r2;
		if (r < VT_CONST && (reg_classes[r] & rc))
			goto save_found;
		r = p->r & VT_VALMASK;
		if (r < VT_CONST && (reg_classes[r] & rc))
		{
save_found:
			save_reg(r);
			return r;
		}
	}
	/* Should never comes here */
	return -1;
}

/* find a free temporary local variable (return the offset on stack) match the size and align. If none, add new temporary stack variable*/
static int get_temp_local_var(int size,int align)
{
	int i;
	struct temp_local_variable *temp_var;
	int found_var;
	SValue *p;
	int r;
	char free;
	char found;
	found=0;
	for(i=0; i<nb_temp_local_vars; i++)
	{
		temp_var=&arr_temp_local_vars[i];
		if(temp_var->size<size||align!=temp_var->align)
		{
			continue;
		}
		/*check if temp_var is free*/
		free=1;
		for(p=vstack; p<=vtop; p++)
		{
			r=p->r&VT_VALMASK;
			if(r==VT_LOCAL||r==VT_LLOCAL)
			{
				if(p->c.i==temp_var->location)
				{
					free=0;
					break;
				}
			}
		}
		if(free)
		{
			found_var=temp_var->location;
			found=1;
			break;
		}
	}
	if(!found)
	{
		loc = (loc - size) & -align;
		if(nb_temp_local_vars<MAX_TEMP_LOCAL_VARIABLE_NUMBER)
		{
			temp_var=&arr_temp_local_vars[i];
			temp_var->location=loc;
			temp_var->size=size;
			temp_var->align=align;
			nb_temp_local_vars++;
		}
		found_var=loc;
	}
	return found_var;
}

static void clear_temp_local_var_list()
{
	nb_temp_local_vars=0;
}

/* move register 's' (of type 't') to 'r', and flush previous value of r to memory
   if needed */
static void move_reg(int r, int s, int t)
{
	SValue sv;

	if (r != s)
	{
		save_reg(r);
		sv.type.t = t;
		sv.type.ref = NULL;
		sv.r = s;
		sv.c.i = 0;
		load(r, &sv);
	}
}

/* get address of vtop (vtop MUST BE an lvalue) */
ST_FUNC void gaddrof(void)
{
	vtop->r &= ~VT_LVAL;
	/* tricky: if saved lvalue, then we can go back to lvalue */
	if ((vtop->r & VT_VALMASK) == VT_LLOCAL)
		vtop->r = (vtop->r & ~VT_VALMASK) | VT_LOCAL | VT_LVAL;
}

#ifdef CONFIG_TCC_BCHECK
/* generate lvalue bound code */
static void gbound(void)
{
	CType type1;

	vtop->r &= ~VT_MUSTBOUND;
	/* if lvalue, then use checking code before dereferencing */
	if (vtop->r & VT_LVAL)
	{
		/* if not VT_BOUNDED value, then make one */
		if (!(vtop->r & VT_BOUNDED))
		{
			/* must save type because we must set it to int to get pointer */
			type1 = vtop->type;
			vtop->type.t = VT_PTR;
			gaddrof();
			vpushi(0);
			gen_bounded_ptr_add();
			vtop->r |= VT_LVAL;
			vtop->type = type1;
		}
		/* then check for dereferencing */
		gen_bounded_ptr_deref();
	}
}

/* we need to call __bound_ptr_add before we start to load function
   args into registers */
ST_FUNC void gbound_args(int nb_args)
{
	int i;
	for (i = 1; i <= nb_args; ++i)
		if (vtop[1 - i].r & VT_MUSTBOUND)
		{
			vrotb(i);
			gbound();
			vrott(i);
		}
}

/* Add bounds for local symbols from S to E (via ->prev) */
static void add_local_bounds(Sym *s, Sym *e)
{
	for (; s != e; s = s->prev)
	{
		if (!s->v || (s->r & VT_VALMASK) != VT_LOCAL)
			continue;
		/* Add arrays/structs/unions because we always take address */
		if ((s->type.t & VT_ARRAY)
		        || (s->type.t & VT_BTYPE) == VT_STRUCT
		        || s->a.addrtaken)
		{
			/* add local bound info */
			int align, size = type_size(&s->type, &align);
			addr_t *bounds_ptr = section_ptr_add(lbounds_section,
			                                     2 * sizeof(addr_t));
			bounds_ptr[0] = s->c;
			bounds_ptr[1] = size;
		}
	}
}
#endif

/* Wrapper around sym_pop, that potentially also registers local bounds.  */
static void pop_local_syms(Sym **ptop, Sym *b, int keep, int ellipsis)
{
#ifdef CONFIG_TCC_BCHECK
	if (!ellipsis && !keep && tcc_state->do_bounds_check)
		add_local_bounds(*ptop, b);
#endif
	sym_pop(ptop, b, keep);
}

static void incr_bf_adr(int o)
{
	vtop->type = char_pointer_type;
	gaddrof();
	vpushs(o);
	gen_op('+');
	vtop->type.t = VT_BYTE | VT_UNSIGNED;
	vtop->r |= VT_LVAL;
}

/* single-byte load mode for packed or otherwise unaligned bitfields */
static void load_packed_bf(CType *type, int bit_pos, int bit_size)
{
	int n, o, bits;
	save_reg_upstack(vtop->r, 1);
	vpush64(type->t & VT_BTYPE, 0); // B X
	bits = 0, o = bit_pos >> 3, bit_pos &= 7;
	do
	{
		vswap(); // X B
		incr_bf_adr(o);
		vdup(); // X B B
		n = 8 - bit_pos;
		if (n > bit_size)
			n = bit_size;
		if (bit_pos)
			vpushi(bit_pos), gen_op(TOK_SHR), bit_pos = 0; // X B Y
		if (n < 8)
			vpushi((1 << n) - 1), gen_op('&');
		gen_cast(type);
		if (bits)
			vpushi(bits), gen_op(TOK_SHL);
		vrotb(3); // B Y X
		gen_op('|'); // B X
		bits += n, bit_size -= n, o = 1;
	}
	while (bit_size);
	vswap(), vpop();
	if (!(type->t & VT_UNSIGNED))
	{
		n = ((type->t & VT_BTYPE) == VT_LLONG ? 64 : 32) - bits;
		vpushi(n), gen_op(TOK_SHL);
		vpushi(n), gen_op(TOK_SAR);
	}
}

/* single-byte store mode for packed or otherwise unaligned bitfields */
static void store_packed_bf(int bit_pos, int bit_size)
{
	int bits, n, o, m, c;

	c = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
	vswap(); // X B
	save_reg_upstack(vtop->r, 1);
	bits = 0, o = bit_pos >> 3, bit_pos &= 7;
	do
	{
		incr_bf_adr(o); // X B
		vswap(); //B X
		c ? vdup() : gv_dup(); // B V X
		vrott(3); // X B V
		if (bits)
			vpushi(bits), gen_op(TOK_SHR);
		if (bit_pos)
			vpushi(bit_pos), gen_op(TOK_SHL);
		n = 8 - bit_pos;
		if (n > bit_size)
			n = bit_size;
		if (n < 8)
		{
			m = ((1 << n) - 1) << bit_pos;
			vpushi(m), gen_op('&'); // X B V1
			vpushv(vtop-1); // X B V1 B
			vpushi(m & 0x80 ? ~m & 0x7f : ~m);
			gen_op('&'); // X B V1 B1
			gen_op('|'); // X B V2
		}
		vdup(), vtop[-1] = vtop[-2]; // X B B V2
		vstore(), vpop(); // X B
		bits += n, bit_size -= n, bit_pos = 0, o = 1;
	}
	while (bit_size);
	vpop(), vpop();
}

static int adjust_bf(SValue *sv, int bit_pos, int bit_size)
{
	int t;
	if (0 == sv->type.ref)
		return 0;
	t = sv->type.ref->auxtype;
	if (t != -1 && t != VT_STRUCT)
	{
		sv->type.t = (sv->type.t & ~VT_BTYPE) | t;
		sv->r |= VT_LVAL;
	}
	return t;
}

/* store vtop a register belonging to class 'rc'. lvalues are
   converted to values. Cannot be used if cannot be converted to
   register value (such as structures). */
ST_FUNC int gv(int rc)
{
	int r, r2, r_ok, r2_ok, rc2, bt;
	int bit_pos, bit_size, size, align;

	/* NOTE: get_reg can modify vstack[] */
	if (vtop->type.t & VT_BITFIELD)
	{
		CType type;

		bit_pos = BIT_POS(vtop->type.t);
		bit_size = BIT_SIZE(vtop->type.t);
		/* remove bit field info to avoid loops */
		vtop->type.t &= ~VT_STRUCT_MASK;

		type.ref = NULL;
		type.t = vtop->type.t & VT_UNSIGNED;
		if ((vtop->type.t & VT_BTYPE) == VT_BOOL)
			type.t |= VT_UNSIGNED;

		r = adjust_bf(vtop, bit_pos, bit_size);

		if ((vtop->type.t & VT_BTYPE) == VT_LLONG)
			type.t |= VT_LLONG;
		else
			type.t |= VT_INT;

		if (r == VT_STRUCT)
		{
			load_packed_bf(&type, bit_pos, bit_size);
		}
		else
		{
			int bits = (type.t & VT_BTYPE) == VT_LLONG ? 64 : 32;
			/* cast to int to propagate signedness in following ops */
			gen_cast(&type);
			/* generate shifts */
			vpushi(bits - (bit_pos + bit_size));
			gen_op(TOK_SHL);
			vpushi(bits - bit_size);
			/* NOTE: transformed to SHR if unsigned */
			gen_op(TOK_SAR);
		}
		r = gv(rc);
	}
	else
	{
		if (is_float(vtop->type.t) &&
		        (vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
		{
			unsigned long offset;
			/* CPUs usually cannot use float constants, so we store them
			   generically in data segment */
			size = type_size(&vtop->type, &align);
			if (NODATA_WANTED)
				size = 0, align = 1;
			offset = section_add(data_section, size, align);
			vpush_ref(&vtop->type, data_section, offset, size);
			vswap();
			init_putv(&vtop->type, data_section, offset);
			vtop->r |= VT_LVAL;
		}
#ifdef CONFIG_TCC_BCHECK
		if (vtop->r & VT_MUSTBOUND)
			gbound();
#endif

		bt = vtop->type.t & VT_BTYPE;

#ifdef TCC_TARGET_RISCV64
		/* XXX mega hack */
		if (bt == VT_LDOUBLE && rc == RC_FLOAT)
			rc = RC_INT;
#endif
		rc2 = RC2_TYPE(bt, rc);

		/* need to reload if:
		   - constant
		   - lvalue (need to dereference pointer)
		   - already a register, but not in the right class */
		r = vtop->r & VT_VALMASK;
		r_ok = !(vtop->r & VT_LVAL) && (r < VT_CONST) && (reg_classes[r] & rc);
		r2_ok = !rc2 || ((vtop->r2 < VT_CONST) && (reg_classes[vtop->r2] & rc2));

		if (!r_ok || !r2_ok)
		{
			if (!r_ok)
				r = get_reg(rc);
			if (rc2)
			{
				int load_type = (bt == VT_QFLOAT) ? VT_DOUBLE : VT_PTRDIFF_T;
				int original_type = vtop->type.t;

				/* two register type load :
				   expand to two words temporarily */
				if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST)
				{
					/* load constant */
					unsigned long long ll = vtop->c.i;
					vtop->c.i = ll; /* first word */
					load(r, vtop);
					vtop->r = r; /* save register value */
					vpushi(ll >> 32); /* second word */
				}
				else if (vtop->r & VT_LVAL)
				{
					/* We do not want to modifier the long long pointer here.
					   So we save any other instances down the stack */
					save_reg_upstack(vtop->r, 1);
					/* load from memory */
					vtop->type.t = load_type;
					load(r, vtop);
					vdup();
					vtop[-1].r = r; /* save register value */
					/* increment pointer to get second word */
					vtop->type.t = VT_PTRDIFF_T;
					gaddrof();
					vpushs(PTR_SIZE);
					gen_op('+');
					vtop->r |= VT_LVAL;
					vtop->type.t = load_type;
				}
				else
				{
					/* move registers */
					if (!r_ok)
						load(r, vtop);
					if (r2_ok && vtop->r2 < VT_CONST)
						goto done;
					vdup();
					vtop[-1].r = r; /* save register value */
					vtop->r = vtop[-1].r2;
				}
				/* Allocate second register. Here we rely on the fact that
				   get_reg() tries first to free r2 of an SValue. */
				r2 = get_reg(rc2);
				load(r2, vtop);
				vpop();
				/* write second register */
				vtop->r2 = r2;
done:
				vtop->type.t = original_type;
			}
			else
			{
				if (vtop->r == VT_CMP)
					vset_VT_JMP();
				/* one register type load */
				load(r, vtop);
			}
		}
		vtop->r = r;
#ifdef TCC_TARGET_C67
		/* uses register pairs for doubles */
		if (bt == VT_DOUBLE)
			vtop->r2 = r+1;
#endif
	}
	return r;
}

/* generate vtop[-1] and vtop[0] in resp. classes rc1 and rc2 */
ST_FUNC void gv2(int rc1, int rc2)
{
	/* generate more generic register first. But VT_JMP or VT_CMP
	   values must be generated first in all cases to avoid possible
	   reload errors */
	if (vtop->r != VT_CMP && rc1 <= rc2)
	{
		vswap();
		gv(rc1);
		vswap();
		gv(rc2);
		/* test if reload is needed for first register */
		if ((vtop[-1].r & VT_VALMASK) >= VT_CONST)
		{
			vswap();
			gv(rc1);
			vswap();
		}
	}
	else
	{
		gv(rc2);
		vswap();
		gv(rc1);
		vswap();
		/* test if reload is needed for first register */
		if ((vtop[0].r & VT_VALMASK) >= VT_CONST)
		{
			gv(rc2);
		}
	}
}

#if PTR_SIZE == 4
/* expand 64bit on stack in two ints */
ST_FUNC void lexpand(void)
{
	int u, v;
	u = vtop->type.t & (VT_DEFSIGN | VT_UNSIGNED);
	v = vtop->r & (VT_VALMASK | VT_LVAL);
	if (v == VT_CONST)
	{
		vdup();
		vtop[0].c.i >>= 32;
	}
	else if (v == (VT_LVAL|VT_CONST) || v == (VT_LVAL|VT_LOCAL))
	{
		vdup();
		vtop[0].c.i += 4;
	}
	else
	{
		gv(RC_INT);
		vdup();
		vtop[0].r = vtop[-1].r2;
		vtop[0].r2 = vtop[-1].r2 = VT_CONST;
	}
	vtop[0].type.t = vtop[-1].type.t = VT_INT | u;
}
#endif

#if PTR_SIZE == 4
/* build a long long from two ints */
static void lbuild(int t)
{
	gv2(RC_INT, RC_INT);
	vtop[-1].r2 = vtop[0].r;
	vtop[-1].type.t = t;
	vpop();
}
#endif

/* convert stack entry to register and duplicate its value in another
   register */
static void gv_dup(void)
{
	int t, rc, r;

	t = vtop->type.t;
#if PTR_SIZE == 4
	if ((t & VT_BTYPE) == VT_LLONG)
	{
		if (t & VT_BITFIELD)
		{
			gv(RC_INT);
			t = vtop->type.t;
		}
		lexpand();
		gv_dup();
		vswap();
		vrotb(3);
		gv_dup();
		vrotb(4);
		/* stack: H L L1 H1 */
		lbuild(t);
		vrotb(3);
		vrotb(3);
		vswap();
		lbuild(t);
		vswap();
		return;
	}
#endif
	/* duplicate value */
	rc = RC_TYPE(t);
	gv(rc);
	r = get_reg(rc);
	vdup();
	load(r, vtop);
	vtop->r = r;
}

#if PTR_SIZE == 4
/* generate CPU independent (unsigned) long long operations */
static void gen_opl(int op)
{
	int t, a, b, op1, c, i;
	int func;
	unsigned short reg_iret = REG_IRET;
	unsigned short reg_lret = REG_IRE2;
	SValue tmp;

	switch(op)
	{
	case '/':
	case TOK_PDIV:
		func = TOK___divdi3;
		goto gen_func;
	case TOK_UDIV:
		func = TOK___udivdi3;
		goto gen_func;
	case '%':
		func = TOK___moddi3;
		goto gen_mod_func;
	case TOK_UMOD:
		func = TOK___umoddi3;
gen_mod_func:
#ifdef TCC_ARM_EABI
		reg_iret = TREG_R2;
		reg_lret = TREG_R3;
#endif
gen_func:
		/* call generic long long function */
		vpush_global_sym(&func_old_type, func);
		vrott(3);
		gfunc_call(2);
		vpushi(0);
		vtop->r = reg_iret;
		vtop->r2 = reg_lret;
		break;
	case '^':
	case '&':
	case '|':
	case '*':
	case '+':
	case '-':
		//pv("gen_opl A",0,2);
		t = vtop->type.t;
		vswap();
		lexpand();
		vrotb(3);
		lexpand();
		/* stack: L1 H1 L2 H2 */
		tmp = vtop[0];
		vtop[0] = vtop[-3];
		vtop[-3] = tmp;
		tmp = vtop[-2];
		vtop[-2] = vtop[-3];
		vtop[-3] = tmp;
		vswap();
		/* stack: H1 H2 L1 L2 */
		//pv("gen_opl B",0,4);
		if (op == '*')
		{
			vpushv(vtop - 1);
			vpushv(vtop - 1);
			gen_op(TOK_UMULL);
			lexpand();
			/* stack: H1 H2 L1 L2 ML MH */
			for(i=0; i<4; i++)
				vrotb(6);
			/* stack: ML MH H1 H2 L1 L2 */
			tmp = vtop[0];
			vtop[0] = vtop[-2];
			vtop[-2] = tmp;
			/* stack: ML MH H1 L2 H2 L1 */
			gen_op('*');
			vrotb(3);
			vrotb(3);
			gen_op('*');
			/* stack: ML MH M1 M2 */
			gen_op('+');
			gen_op('+');
		}
		else if (op == '+' || op == '-')
		{
			/* XXX: add non carry method too (for MIPS or alpha) */
			if (op == '+')
				op1 = TOK_ADDC1;
			else
				op1 = TOK_SUBC1;
			gen_op(op1);
			/* stack: H1 H2 (L1 op L2) */
			vrotb(3);
			vrotb(3);
			gen_op(op1 + 1); /* TOK_xxxC2 */
		}
		else
		{
			gen_op(op);
			/* stack: H1 H2 (L1 op L2) */
			vrotb(3);
			vrotb(3);
			/* stack: (L1 op L2) H1 H2 */
			gen_op(op);
			/* stack: (L1 op L2) (H1 op H2) */
		}
		/* stack: L H */
		lbuild(t);
		break;
	case TOK_SAR:
	case TOK_SHR:
	case TOK_SHL:
		if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
		{
			t = vtop[-1].type.t;
			vswap();
			lexpand();
			vrotb(3);
			/* stack: L H shift */
			c = (int)vtop->c.i;
			/* constant: simpler */
			/* NOTE: all comments are for SHL. the other cases are
			   done by swapping words */
			vpop();
			if (op != TOK_SHL)
				vswap();
			if (c >= 32)
			{
				/* stack: L H */
				vpop();
				if (c > 32)
				{
					vpushi(c - 32);
					gen_op(op);
				}
				if (op != TOK_SAR)
				{
					vpushi(0);
				}
				else
				{
					gv_dup();
					vpushi(31);
					gen_op(TOK_SAR);
				}
				vswap();
			}
			else
			{
				vswap();
				gv_dup();
				/* stack: H L L */
				vpushi(c);
				gen_op(op);
				vswap();
				vpushi(32 - c);
				if (op == TOK_SHL)
					gen_op(TOK_SHR);
				else
					gen_op(TOK_SHL);
				vrotb(3);
				/* stack: L L H */
				vpushi(c);
				if (op == TOK_SHL)
					gen_op(TOK_SHL);
				else
					gen_op(TOK_SHR);
				gen_op('|');
			}
			if (op != TOK_SHL)
				vswap();
			lbuild(t);
		}
		else
		{
			/* XXX: should provide a faster fallback on x86 ? */
			switch(op)
			{
			case TOK_SAR:
				func = TOK___ashrdi3;
				goto gen_func;
			case TOK_SHR:
				func = TOK___lshrdi3;
				goto gen_func;
			case TOK_SHL:
				func = TOK___ashldi3;
				goto gen_func;
			}
		}
		break;
	default:
		/* compare operations */
		t = vtop->type.t;
		vswap();
		lexpand();
		vrotb(3);
		lexpand();
		/* stack: L1 H1 L2 H2 */
		tmp = vtop[-1];
		vtop[-1] = vtop[-2];
		vtop[-2] = tmp;
		/* stack: L1 L2 H1 H2 */
		save_regs(4);
		/* compare high */
		op1 = op;
		/* when values are equal, we need to compare low words. since
		   the jump is inverted, we invert the test too. */
		if (op1 == TOK_LT)
			op1 = TOK_LE;
		else if (op1 == TOK_GT)
			op1 = TOK_GE;
		else if (op1 == TOK_ULT)
			op1 = TOK_ULE;
		else if (op1 == TOK_UGT)
			op1 = TOK_UGE;
		a = 0;
		b = 0;
		gen_op(op1);
		if (op == TOK_NE)
		{
			b = gvtst(0, 0);
		}
		else
		{
			a = gvtst(1, 0);
			if (op != TOK_EQ)
			{
				/* generate non equal test */
				vpushi(0);
				vset_VT_CMP(TOK_NE);
				b = gvtst(0, 0);
			}
		}
		/* compare low. Always unsigned */
		op1 = op;
		if (op1 == TOK_LT)
			op1 = TOK_ULT;
		else if (op1 == TOK_LE)
			op1 = TOK_ULE;
		else if (op1 == TOK_GT)
			op1 = TOK_UGT;
		else if (op1 == TOK_GE)
			op1 = TOK_UGE;
		gen_op(op1);
#if 0//def TCC_TARGET_I386
		if (op == TOK_NE)
		{
			gsym(b);
			break;
		}
		if (op == TOK_EQ)
		{
			gsym(a);
			break;
		}
#endif
		gvtst_set(1, a);
		gvtst_set(0, b);
		break;
	}
}
#endif

static uint64_t gen_opic_sdiv(uint64_t a, uint64_t b)
{
	uint64_t x = (a >> 63 ? -a : a) / (b >> 63 ? -b : b);
	return (a ^ b) >> 63 ? -x : x;
}

static int gen_opic_lt(uint64_t a, uint64_t b)
{
	return (a ^ (uint64_t)1 << 63) < (b ^ (uint64_t)1 << 63);
}

/* handle integer constant optimizations and various machine
   independent opt */
static void gen_opic(int op)
{
	SValue *v1 = vtop - 1;
	SValue *v2 = vtop;
	int t1 = v1->type.t & VT_BTYPE;
	int t2 = v2->type.t & VT_BTYPE;
	int c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
	int c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
	uint64_t l1 = c1 ? v1->c.i : 0;
	uint64_t l2 = c2 ? v2->c.i : 0;
	int shm = (t1 == VT_LLONG) ? 63 : 31;

	if (t1 != VT_LLONG && (PTR_SIZE != 8 || t1 != VT_PTR))
		l1 = ((uint32_t)l1 |
		      (v1->type.t & VT_UNSIGNED ? 0 : -(l1 & 0x80000000)));
	if (t2 != VT_LLONG && (PTR_SIZE != 8 || t2 != VT_PTR))
		l2 = ((uint32_t)l2 |
		      (v2->type.t & VT_UNSIGNED ? 0 : -(l2 & 0x80000000)));

	if (c1 && c2)
	{
		switch(op)
		{
		case '+':
			l1 += l2;
			break;
		case '-':
			l1 -= l2;
			break;
		case '&':
			l1 &= l2;
			break;
		case '^':
			l1 ^= l2;
			break;
		case '|':
			l1 |= l2;
			break;
		case '*':
			l1 *= l2;
			break;

		case TOK_PDIV:
		case '/':
		case '%':
		case TOK_UDIV:
		case TOK_UMOD:
			/* if division by zero, generate explicit division */
			if (l2 == 0)
			{
				if (const_wanted && !(nocode_wanted & unevalmask))
					tcc_error("division by zero in constant");
				goto general_case;
			}
			switch(op)
			{
			default:
				l1 = gen_opic_sdiv(l1, l2);
				break;
			case '%':
				l1 = l1 - l2 * gen_opic_sdiv(l1, l2);
				break;
			case TOK_UDIV:
				l1 = l1 / l2;
				break;
			case TOK_UMOD:
				l1 = l1 % l2;
				break;
			}
			break;
		case TOK_SHL:
			l1 <<= (l2 & shm);
			break;
		case TOK_SHR:
			l1 >>= (l2 & shm);
			break;
		case TOK_SAR:
			l1 = (l1 >> 63) ? ~(~l1 >> (l2 & shm)) : l1 >> (l2 & shm);
			break;
		/* tests */
		case TOK_ULT:
			l1 = l1 < l2;
			break;
		case TOK_UGE:
			l1 = l1 >= l2;
			break;
		case TOK_EQ:
			l1 = l1 == l2;
			break;
		case TOK_NE:
			l1 = l1 != l2;
			break;
		case TOK_ULE:
			l1 = l1 <= l2;
			break;
		case TOK_UGT:
			l1 = l1 > l2;
			break;
		case TOK_LT:
			l1 = gen_opic_lt(l1, l2);
			break;
		case TOK_GE:
			l1 = !gen_opic_lt(l1, l2);
			break;
		case TOK_LE:
			l1 = !gen_opic_lt(l2, l1);
			break;
		case TOK_GT:
			l1 = gen_opic_lt(l2, l1);
			break;
		/* logical */
		case TOK_LAND:
			l1 = l1 && l2;
			break;
		case TOK_LOR:
			l1 = l1 || l2;
			break;
		default:
			goto general_case;
		}
		if (t1 != VT_LLONG && (PTR_SIZE != 8 || t1 != VT_PTR))
			l1 = ((uint32_t)l1 |
			      (v1->type.t & VT_UNSIGNED ? 0 : -(l1 & 0x80000000)));
		v1->c.i = l1;
		vtop--;
	}
	else
	{
		/* if commutative ops, put c2 as constant */
		if (c1 && (op == '+' || op == '&' || op == '^' ||
		           op == '|' || op == '*' || op == TOK_EQ || op == TOK_NE))
		{
			vswap();
			c2 = c1; //c = c1, c1 = c2, c2 = c;
			l2 = l1; //l = l1, l1 = l2, l2 = l;
		}
		if (!const_wanted &&
		        c1 && ((l1 == 0 &&
		                (op == TOK_SHL || op == TOK_SHR || op == TOK_SAR)) ||
		               (l1 == -1 && op == TOK_SAR)))
		{
			/* treat (0 << x), (0 >> x) and (-1 >> x) as constant */
			vtop--;
		}
		else if (!const_wanted &&
		         c2 && ((l2 == 0 && (op == '&' || op == '*')) ||
		                (op == '|' &&
		                 (l2 == -1 || (l2 == 0xFFFFFFFF && t2 != VT_LLONG))) ||
		                (l2 == 1 && (op == '%' || op == TOK_UMOD))))
		{
			/* treat (x & 0), (x * 0), (x | -1) and (x % 1) as constant */
			if (l2 == 1)
				vtop->c.i = 0;
			vswap();
			vtop--;
		}
		else if (c2 && (((op == '*' || op == '/' || op == TOK_UDIV ||
		                  op == TOK_PDIV) &&
		                 l2 == 1) ||
		                ((op == '+' || op == '-' || op == '|' || op == '^' ||
		                  op == TOK_SHL || op == TOK_SHR || op == TOK_SAR) &&
		                 l2 == 0) ||
		                (op == '&' &&
		                 (l2 == -1 || (l2 == 0xFFFFFFFF && t2 != VT_LLONG)))))
		{
			/* filter out NOP operations like x*1, x-0, x&-1... */
			vtop--;
		}
		else if (c2 && (op == '*' || op == TOK_PDIV || op == TOK_UDIV))
		{
			/* try to use shifts instead of muls or divs */
			if (l2 > 0 && (l2 & (l2 - 1)) == 0)
			{
				int n = -1;
				while (l2)
				{
					l2 >>= 1;
					n++;
				}
				vtop->c.i = n;
				if (op == '*')
					op = TOK_SHL;
				else if (op == TOK_PDIV)
					op = TOK_SAR;
				else
					op = TOK_SHR;
			}
			goto general_case;
		}
		else if (c2 && (op == '+' || op == '-') &&
		         (((vtop[-1].r & (VT_VALMASK | VT_LVAL | VT_SYM)) == (VT_CONST | VT_SYM))
		          || (vtop[-1].r & (VT_VALMASK | VT_LVAL)) == VT_LOCAL))
		{
			/* symbol + constant case */
			if (op == '-')
				l2 = -l2;
			l2 += vtop[-1].c.i;
			/* The backends can't always deal with addends to symbols
			   larger than +-1<<31.  Don't construct such.  */
			if ((int)l2 != l2)
				goto general_case;
			vtop--;
			vtop->c.i = l2;
		}
		else
		{
general_case:
			/* call low level op generator */
			if (t1 == VT_LLONG || t2 == VT_LLONG ||
			        (PTR_SIZE == 8 && (t1 == VT_PTR || t2 == VT_PTR)))
				gen_opl(op);
			else
				gen_opi(op);
		}
	}
}

/* generate a floating point operation with constant propagation */
static void gen_opif(int op)
{
	int c1, c2;
	SValue *v1, *v2;
#if defined _MSC_VER && defined __x86_64__
	/* avoid bad optimization with f1 -= f2 for f1:-0.0, f2:0.0 */
	volatile
#endif
	long double f1, f2;

	v1 = vtop - 1;
	v2 = vtop;
	/* currently, we cannot do computations with forward symbols */
	c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
	c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
	if (c1 && c2)
	{
		if (v1->type.t == VT_FLOAT)
		{
			f1 = v1->c.f;
			f2 = v2->c.f;
		}
		else if (v1->type.t == VT_DOUBLE)
		{
			f1 = v1->c.d;
			f2 = v2->c.d;
		}
		else
		{
			f1 = v1->c.ld;
			f2 = v2->c.ld;
		}

		/* NOTE: we only do constant propagation if finite number (not
		   NaN or infinity) (ANSI spec) */
		if (!ieee_finite(f1) || !ieee_finite(f2))
			goto general_case;

		switch(op)
		{
		case '+':
			f1 += f2;
			break;
		case '-':
			f1 -= f2;
			break;
		case '*':
			f1 *= f2;
			break;
		case '/':
			if (f2 == 0.0)
			{
				/* If not in initializer we need to potentially generate
				   FP exceptions at runtime, otherwise we want to fold.  */
				if (!const_wanted)
					goto general_case;
			}
			f1 /= f2;
			break;
		/* XXX: also handles tests ? */
		default:
			goto general_case;
		}
		/* XXX: overflow test ? */
		if (v1->type.t == VT_FLOAT)
		{
			v1->c.f = f1;
		}
		else if (v1->type.t == VT_DOUBLE)
		{
			v1->c.d = f1;
		}
		else
		{
			v1->c.ld = f1;
		}
		vtop--;
	}
	else
	{
general_case:
		gen_opf(op);
	}
}

static int pointed_size(CType *type)
{
	int align;
	return type_size(pointed_type(type), &align);
}

static void vla_runtime_pointed_size(CType *type)
{
	int align;
	vla_runtime_type_size(pointed_type(type), &align);
}

static inline int is_null_pointer(SValue *p)
{
	if ((p->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
		return 0;
	return ((p->type.t & VT_BTYPE) == VT_INT && (uint32_t)p->c.i == 0) ||
	       ((p->type.t & VT_BTYPE) == VT_LLONG && p->c.i == 0) ||
	       ((p->type.t & VT_BTYPE) == VT_PTR &&
	        (PTR_SIZE == 4 ? (uint32_t)p->c.i == 0 : p->c.i == 0) &&
	        ((pointed_type(&p->type)->t & VT_BTYPE) == VT_VOID) &&
	        0 == (pointed_type(&p->type)->t & (VT_CONSTANT | VT_VOLATILE))
	       );
}

/* check types for comparison or subtraction of pointers */
static void check_comparison_pointer_types(SValue *p1, SValue *p2, int op)
{
	CType *type1, *type2, tmp_type1, tmp_type2;
	int bt1, bt2;

	/* null pointers are accepted for all comparisons as gcc */
	if (is_null_pointer(p1) || is_null_pointer(p2))
		return;
	type1 = &p1->type;
	type2 = &p2->type;
	bt1 = type1->t & VT_BTYPE;
	bt2 = type2->t & VT_BTYPE;
	/* accept comparison between pointer and integer with a warning */
	if ((is_integer_btype(bt1) || is_integer_btype(bt2)) && op != '-')
	{
		if (op != TOK_LOR && op != TOK_LAND )
			tcc_warning("comparison between pointer and integer");
		return;
	}

	/* both must be pointers or implicit function pointers */
	if (bt1 == VT_PTR)
	{
		type1 = pointed_type(type1);
	}
	else if (bt1 != VT_FUNC)
		goto invalid_operands;

	if (bt2 == VT_PTR)
	{
		type2 = pointed_type(type2);
	}
	else if (bt2 != VT_FUNC)
	{
invalid_operands:
		tcc_error("invalid operands to binary %s", get_tok_str(op, NULL));
	}
	if ((type1->t & VT_BTYPE) == VT_VOID ||
	        (type2->t & VT_BTYPE) == VT_VOID)
		return;
	tmp_type1 = *type1;
	tmp_type2 = *type2;
	tmp_type1.t &= ~(VT_DEFSIGN | VT_UNSIGNED | VT_CONSTANT | VT_VOLATILE);
	tmp_type2.t &= ~(VT_DEFSIGN | VT_UNSIGNED | VT_CONSTANT | VT_VOLATILE);
	if (!is_compatible_types(&tmp_type1, &tmp_type2))
	{
		/* gcc-like error if '-' is used */
		if (op == '-')
			goto invalid_operands;
		else
			tcc_warning("comparison of distinct pointer types lacks a cast");
	}
}

/* generic gen_op: handles types problems */
ST_FUNC void gen_op(int op)
{
	int u, t1, t2, bt1, bt2, t;
	CType type1;

redo:
	t1 = vtop[-1].type.t;
	t2 = vtop[0].type.t;
	bt1 = t1 & VT_BTYPE;
	bt2 = t2 & VT_BTYPE;

	if (bt1 == VT_STRUCT || bt2 == VT_STRUCT)
	{
		tcc_error("operation on a struct");
	}
	else if (bt1 == VT_FUNC || bt2 == VT_FUNC)
	{
		if (bt2 == VT_FUNC)
		{
			mk_pointer(&vtop->type);
			gaddrof();
		}
		if (bt1 == VT_FUNC)
		{
			vswap();
			mk_pointer(&vtop->type);
			gaddrof();
			vswap();
		}
		goto redo;
	}
	else if (bt1 == VT_PTR || bt2 == VT_PTR)
	{
		/* at least one operand is a pointer */
		/* relational op: must be both pointers */
		if (op >= TOK_ULT && op <= TOK_LOR)
		{
			check_comparison_pointer_types(vtop - 1, vtop, op);
			/* pointers are handled are unsigned */
#if PTR_SIZE == 8
			t = VT_LLONG | VT_UNSIGNED;
#else
			t = VT_INT | VT_UNSIGNED;
#endif
			goto std_op;
		}
		/* if both pointers, then it must be the '-' op */
		if (bt1 == VT_PTR && bt2 == VT_PTR)
		{
			if (op != '-')
				tcc_error("cannot use pointers here");
			check_comparison_pointer_types(vtop - 1, vtop, op);
			/* XXX: check that types are compatible */
			if (vtop[-1].type.t & VT_VLA)
			{
				vla_runtime_pointed_size(&vtop[-1].type);
			}
			else
			{
				vpushi(pointed_size(&vtop[-1].type));
			}
			vrott(3);
			gen_opic(op);
			vtop->type.t = VT_PTRDIFF_T;
			vswap();
			gen_op(TOK_PDIV);
		}
		else
		{
			/* exactly one pointer : must be '+' or '-'. */
			if (op != '-' && op != '+')
				tcc_error("cannot use pointers here");
			/* Put pointer as first operand */
			if (bt2 == VT_PTR)
			{
				vswap();
				t = t1, t1 = t2, t2 = t;
			}
#if PTR_SIZE == 4
			if ((vtop[0].type.t & VT_BTYPE) == VT_LLONG)
				/* XXX: truncate here because gen_opl can't handle ptr + long long */
				gen_cast_s(VT_INT);
#endif
			type1 = vtop[-1].type;
			type1.t &= ~VT_ARRAY;
			if (vtop[-1].type.t & VT_VLA)
				vla_runtime_pointed_size(&vtop[-1].type);
			else
			{
				u = pointed_size(&vtop[-1].type);
				if (u < 0)
					tcc_error("unknown array element size");
#if PTR_SIZE == 8
				vpushll(u);
#else
				/* XXX: cast to int ? (long long case) */
				vpushi(u);
#endif
			}
			gen_op('*');
#ifdef CONFIG_TCC_BCHECK
			if (tcc_state->do_bounds_check && !const_wanted)
			{
				/* if bounded pointers, we generate a special code to
				   test bounds */
				if (op == '-')
				{
					vpushi(0);
					vswap();
					gen_op('-');
				}
				gen_bounded_ptr_add();
			}
			else
#endif
			{
				gen_opic(op);
			}
			/* put again type if gen_opic() swaped operands */
			vtop->type = type1;
		}
	}
	else if (is_float(bt1) || is_float(bt2))
	{
		/* compute bigger type and do implicit casts */
		if (bt1 == VT_LDOUBLE || bt2 == VT_LDOUBLE)
		{
			t = VT_LDOUBLE;
		}
		else if (bt1 == VT_DOUBLE || bt2 == VT_DOUBLE)
		{
			t = VT_DOUBLE;
		}
		else
		{
			t = VT_FLOAT;
		}
		/* floats can only be used for a few operations */
		if (op != '+' && op != '-' && op != '*' && op != '/' &&
		        (op < TOK_ULT || op > TOK_GT))
			tcc_error("invalid operands for binary operation");
		goto std_op;
	}
	else if (op == TOK_SHR || op == TOK_SAR || op == TOK_SHL)
	{
		t = bt1 == VT_LLONG ? VT_LLONG : VT_INT;
		if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (t | VT_UNSIGNED))
			t |= VT_UNSIGNED;
		t |= (VT_LONG & t1);
		goto std_op;
	}
	else if (bt1 == VT_LLONG || bt2 == VT_LLONG)
	{
		/* cast to biggest op */
		t = VT_LLONG | VT_LONG;
		if (bt1 == VT_LLONG)
			t &= t1;
		if (bt2 == VT_LLONG)
			t &= t2;
		/* convert to unsigned if it does not fit in a long long */
		if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED) ||
		        (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED))
			t |= VT_UNSIGNED;
		goto std_op;
	}
	else
	{
		/* integer operations */
		t = VT_INT | (VT_LONG & (t1 | t2));
		/* convert to unsigned if it does not fit in an integer */
		if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED) ||
		        (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED))
			t |= VT_UNSIGNED;
std_op:
		/* XXX: currently, some unsigned operations are explicit, so
		   we modify them here */
		if (t & VT_UNSIGNED)
		{
			if (op == TOK_SAR)
				op = TOK_SHR;
			else if (op == '/')
				op = TOK_UDIV;
			else if (op == '%')
				op = TOK_UMOD;
			else if (op == TOK_LT)
				op = TOK_ULT;
			else if (op == TOK_GT)
				op = TOK_UGT;
			else if (op == TOK_LE)
				op = TOK_ULE;
			else if (op == TOK_GE)
				op = TOK_UGE;
		}
		vswap();
		type1.t = t;
		type1.ref = NULL;
		gen_cast(&type1);
		vswap();
		/* special case for shifts and long long: we keep the shift as
		   an integer */
		if (op == TOK_SHR || op == TOK_SAR || op == TOK_SHL)
			type1.t = VT_INT;
		gen_cast(&type1);
		if (is_float(t))
			gen_opif(op);
		else
			gen_opic(op);
		if (op >= TOK_ULT && op <= TOK_GT)
		{
			/* relational op: the result is an int */
			vtop->type.t = VT_INT;
		}
		else
		{
			vtop->type.t = t;
		}
	}
	// Make sure that we have converted to an rvalue:
	if (vtop->r & VT_LVAL)
		gv(is_float(vtop->type.t & VT_BTYPE) ? RC_FLOAT : RC_INT);
}

#if defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64 || defined TCC_TARGET_ARM
#define gen_cvt_itof1 gen_cvt_itof
#else
/* generic itof for unsigned long long case */
static void gen_cvt_itof1(int t)
{
	if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) ==
	        (VT_LLONG | VT_UNSIGNED))
	{

		if (t == VT_FLOAT)
			vpush_global_sym(&func_old_type, TOK___floatundisf);
#if LDOUBLE_SIZE != 8
		else if (t == VT_LDOUBLE)
			vpush_global_sym(&func_old_type, TOK___floatundixf);
#endif
		else
			vpush_global_sym(&func_old_type, TOK___floatundidf);
		vrott(2);
		gfunc_call(1);
		vpushi(0);
		PUT_R_RET(vtop, t);
	}
	else
	{
		gen_cvt_itof(t);
	}
}
#endif

#if defined TCC_TARGET_ARM64 || defined TCC_TARGET_RISCV64
#define gen_cvt_ftoi1 gen_cvt_ftoi
#else
/* generic ftoi for unsigned long long case */
static void gen_cvt_ftoi1(int t)
{
	int st;
	if (t == (VT_LLONG | VT_UNSIGNED))
	{
		/* not handled natively */
		st = vtop->type.t & VT_BTYPE;
		if (st == VT_FLOAT)
			vpush_global_sym(&func_old_type, TOK___fixunssfdi);
#if LDOUBLE_SIZE != 8
		else if (st == VT_LDOUBLE)
			vpush_global_sym(&func_old_type, TOK___fixunsxfdi);
#endif
		else
			vpush_global_sym(&func_old_type, TOK___fixunsdfdi);
		vrott(2);
		gfunc_call(1);
		vpushi(0);
		PUT_R_RET(vtop, t);
	}
	else
	{
		gen_cvt_ftoi(t);
	}
}
#endif

/* special delayed cast for char/short */
static void force_charshort_cast(void)
{
	int sbt = BFGET(vtop->r, VT_MUSTCAST) == 2 ? VT_LLONG : VT_INT;
	int dbt = vtop->type.t;
	vtop->r &= ~VT_MUSTCAST;
	vtop->type.t = sbt;
	gen_cast_s(dbt == VT_BOOL ? VT_BYTE|VT_UNSIGNED : dbt);
	vtop->type.t = dbt;
}

static void gen_cast_s(int t)
{
	CType type;
	type.t = t;
	type.ref = NULL;
	gen_cast(&type);
}

/* cast 'vtop' to 'type'. Casting to bitfields is forbidden. */
static void gen_cast(CType *type)
{
	int sbt, dbt, sf, df, c;
	int dbt_bt, sbt_bt, ds, ss, bits, trunc;

	/* special delayed cast for char/short */
	if (vtop->r & VT_MUSTCAST)
		force_charshort_cast();

	/* bitfields first get cast to ints */
	if (vtop->type.t & VT_BITFIELD)
		gv(RC_INT);

	dbt = type->t & (VT_BTYPE | VT_UNSIGNED);
	sbt = vtop->type.t & (VT_BTYPE | VT_UNSIGNED);
	if (sbt == VT_FUNC)
		sbt = VT_PTR;

again:
	if (sbt != dbt)
	{
		sf = is_float(sbt);
		df = is_float(dbt);
		dbt_bt = dbt & VT_BTYPE;
		sbt_bt = sbt & VT_BTYPE;

		c = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
#if !defined TCC_IS_NATIVE && !defined TCC_IS_NATIVE_387
		c &= (dbt != VT_LDOUBLE) | !!nocode_wanted;
#endif
		if (c)
		{
			/* constant case: we can do it now */
			/* XXX: in ISOC, cannot do it if error in convert */
			if (sbt == VT_FLOAT)
				vtop->c.ld = vtop->c.f;
			else if (sbt == VT_DOUBLE)
				vtop->c.ld = vtop->c.d;

			if (df)
			{
				if (sbt_bt == VT_LLONG)
				{
					if ((sbt & VT_UNSIGNED) || !(vtop->c.i >> 63))
						vtop->c.ld = vtop->c.i;
					else
						vtop->c.ld = -(long double)-vtop->c.i;
				}
				else if(!sf)
				{
					if ((sbt & VT_UNSIGNED) || !(vtop->c.i >> 31))
						vtop->c.ld = (uint32_t)vtop->c.i;
					else
						vtop->c.ld = -(long double)-(uint32_t)vtop->c.i;
				}

				if (dbt == VT_FLOAT)
					vtop->c.f = (float)vtop->c.ld;
				else if (dbt == VT_DOUBLE)
					vtop->c.d = (double)vtop->c.ld;
			}
			else if (sf && dbt == VT_BOOL)
			{
				vtop->c.i = (vtop->c.ld != 0);
			}
			else
			{
				if(sf)
					vtop->c.i = vtop->c.ld;
				else if (sbt_bt == VT_LLONG || (PTR_SIZE == 8 && sbt == VT_PTR))
					;
				else if (sbt & VT_UNSIGNED)
					vtop->c.i = (uint32_t)vtop->c.i;
				else
					vtop->c.i = ((uint32_t)vtop->c.i | -(vtop->c.i & 0x80000000));

				if (dbt_bt == VT_LLONG || (PTR_SIZE == 8 && dbt == VT_PTR))
					;
				else if (dbt == VT_BOOL)
					vtop->c.i = (vtop->c.i != 0);
				else
				{
					uint32_t m = dbt_bt == VT_BYTE ? 0xff :
					             dbt_bt == VT_SHORT ? 0xffff :
					             0xffffffff;
					vtop->c.i &= m;
					if (!(dbt & VT_UNSIGNED))
						vtop->c.i |= -(vtop->c.i & ((m >> 1) + 1));
				}
			}
			goto done;

		}
		else if (dbt == VT_BOOL
		         && (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM))
		         == (VT_CONST | VT_SYM))
		{
			/* addresses are considered non-zero (see tcctest.c:sinit23) */
			vtop->r = VT_CONST;
			vtop->c.i = 1;
			goto done;
		}

		/* cannot generate code for global or static initializers */
		if (STATIC_DATA_WANTED)
			goto done;

		/* non constant case: generate code */
		if (dbt == VT_BOOL)
		{
			gen_test_zero(TOK_NE);
			goto done;
		}

		if (sf || df)
		{
			if (sf && df)
			{
				/* convert from fp to fp */
				gen_cvt_ftof(dbt);
			}
			else if (df)
			{
				/* convert int to fp */
				gen_cvt_itof1(dbt);
			}
			else
			{
				/* convert fp to int */
				sbt = dbt;
				if (dbt_bt != VT_LLONG && dbt_bt != VT_INT)
					sbt = VT_INT;
				gen_cvt_ftoi1(sbt);
				goto again; /* may need char/short cast */
			}
			goto done;
		}

		ds = btype_size(dbt_bt);
		ss = btype_size(sbt_bt);
		if (ds == 0 || ss == 0)
		{
			if (dbt_bt == VT_VOID)
				goto done;
			cast_error(&vtop->type, type);
		}
		if (IS_ENUM(type->t) && type->ref->c < 0)
			tcc_error("cast to incomplete type");

		/* same size and no sign conversion needed */
		if (ds == ss && ds >= 4)
			goto done;
		if (dbt_bt == VT_PTR || sbt_bt == VT_PTR)
		{
			tcc_warning("cast between pointer and integer of different size");
			if (sbt_bt == VT_PTR)
			{
				/* put integer type to allow logical operations below */
				vtop->type.t = (PTR_SIZE == 8 ? VT_LLONG : VT_INT);
			}
		}

		/* processor allows { int a = 0, b = *(char*)&a; }
		   That means that if we cast to less width, we can just
		   change the type and read it still later. */
#define ALLOW_SUBTYPE_ACCESS 1

		if (ALLOW_SUBTYPE_ACCESS && (vtop->r & VT_LVAL))
		{
			/* value still in memory */
			if (ds <= ss)
				goto done;
			/* ss <= 4 here */
			if (ds <= 4)
			{
				gv(RC_INT);
				goto done; /* no 64bit envolved */
			}
		}
		gv(RC_INT);

		trunc = 0;
#if PTR_SIZE == 4
		if (ds == 8)
		{
			/* generate high word */
			if (sbt & VT_UNSIGNED)
			{
				vpushi(0);
				gv(RC_INT);
			}
			else
			{
				gv_dup();
				vpushi(31);
				gen_op(TOK_SAR);
			}
			lbuild(dbt);
		}
		else if (ss == 8)
		{
			/* from long long: just take low order word */
			lexpand();
			vpop();
		}
		ss = 4;

#elif PTR_SIZE == 8
		if (ds == 8)
		{
			/* need to convert from 32bit to 64bit */
			if (sbt & VT_UNSIGNED)
			{
#if defined(TCC_TARGET_RISCV64)
				/* RISC-V keeps 32bit vals in registers sign-extended.
				   So here we need a zero-extension.  */
				trunc = 32;
#else
				goto done;
#endif
			}
			else
			{
				gen_cvt_sxtw();
				goto done;
			}
			ss = ds, ds = 4, dbt = sbt;
		}
		else if (ss == 8)
		{
			/* XXX some architectures (e.g. risc-v) would like it
			   better for this merely being a 32-to-64 sign or zero-
			   extension.  */
			trunc = 32; /* zero upper 32 bits */
		}
		else
		{
			ss = 4;
		}
#endif

		if (ds >= ss)
			goto done;
#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 || defined TCC_TARGET_ARM64
		if (ss == 4)
		{
			gen_cvt_csti(dbt);
			goto done;
		}
#endif
		bits = (ss - ds) * 8;
		/* for unsigned, gen_op will convert SAR to SHR */
		vtop->type.t = (ss == 8 ? VT_LLONG : VT_INT) | (dbt & VT_UNSIGNED);
		vpushi(bits);
		gen_op(TOK_SHL);
		vpushi(bits - trunc);
		gen_op(TOK_SAR);
		vpushi(trunc);
		gen_op(TOK_SHR);
	}
done:
	vtop->type = *type;
	vtop->type.t &= ~ ( VT_CONSTANT | VT_VOLATILE | VT_ARRAY );
}

/* return type size as known at compile time. Put alignment at 'a' */
ST_FUNC int type_size(CType *type, int *a)
{
	Sym *s;
	int bt;

	bt = type->t & VT_BTYPE;
	if (bt == VT_STRUCT)
	{
		/* struct/union */
		s = type->ref;
		*a = s->r;
		return s->c;
	}
	else if (bt == VT_PTR)
	{
		if (type->t & VT_ARRAY)
		{
			int ts;

			s = type->ref;
			ts = type_size(&s->type, a);

			if (ts < 0 && s->c < 0)
				ts = -ts;

			return ts * s->c;
		}
		else
		{
			*a = PTR_SIZE;
			return PTR_SIZE;
		}
	}
	else if (IS_ENUM(type->t) && type->ref->c < 0)
	{
		return -1; /* incomplete enum */
	}
	else if (bt == VT_LDOUBLE)
	{
		*a = LDOUBLE_ALIGN;
		return LDOUBLE_SIZE;
	}
	else if (bt == VT_DOUBLE || bt == VT_LLONG)
	{
#ifdef TCC_TARGET_I386
#ifdef TCC_TARGET_PE
		*a = 8;
#else
		*a = 4;
#endif
#elif defined(TCC_TARGET_ARM)
#ifdef TCC_ARM_EABI
		*a = 8;
#else
		*a = 4;
#endif
#else
		*a = 8;
#endif
		return 8;
	}
	else if (bt == VT_INT || bt == VT_FLOAT)
	{
		*a = 4;
		return 4;
	}
	else if (bt == VT_SHORT)
	{
		*a = 2;
		return 2;
	}
	else if (bt == VT_QLONG || bt == VT_QFLOAT)
	{
		*a = 8;
		return 16;
	}
	else
	{
		/* char, void, function, _Bool */
		*a = 1;
		return 1;
	}
}

/* push type size as known at runtime time on top of value stack. Put
   alignment at 'a' */
ST_FUNC void vla_runtime_type_size(CType *type, int *a)
{
	if (type->t & VT_VLA)
	{
		type_size(&type->ref->type, a);
		vset(&int_type, VT_LOCAL|VT_LVAL, type->ref->c);
	}
	else
	{
		vpushi(type_size(type, a));
	}
}

/* return the pointed type of t */
static inline CType *pointed_type(CType *type)
{
	return &type->ref->type;
}

/* modify type so that its it is a pointer to type. */
ST_FUNC void mk_pointer(CType *type)
{
	Sym *s;
	s = sym_push(SYM_FIELD, type, 0, -1);
	type->t = VT_PTR | (type->t & VT_STORAGE);
	type->ref = s;
}

/* compare function types. OLD functions match any new functions */
static int is_compatible_func(CType *type1, CType *type2)
{
	Sym *s1, *s2;

	s1 = type1->ref;
	s2 = type2->ref;
	if (s1->f.func_call != s2->f.func_call)
		return 0;
	if (s1->f.func_type != s2->f.func_type
	        && s1->f.func_type != FUNC_OLD
	        && s2->f.func_type != FUNC_OLD)
		return 0;
	/* we should check the function return type for FUNC_OLD too
	   but that causes problems with the internally used support
	   functions such as TOK_memmove */
	if (s1->f.func_type == FUNC_OLD && !s1->next)
		return 1;
	if (s2->f.func_type == FUNC_OLD && !s2->next)
		return 1;
	for (;;)
	{
		if (!is_compatible_unqualified_types(&s1->type, &s2->type))
			return 0;
		s1 = s1->next;
		s2 = s2->next;
		if (!s1)
			return !s2;
		if (!s2)
			return 0;
	}
}

/* return true if type1 and type2 are the same.  If unqualified is
   true, qualifiers on the types are ignored.
 */
static int compare_types(CType *type1, CType *type2, int unqualified)
{
	int bt1, t1, t2;

	t1 = type1->t & VT_TYPE;
	t2 = type2->t & VT_TYPE;
	if (unqualified)
	{
		/* strip qualifiers before comparing */
		t1 &= ~(VT_CONSTANT | VT_VOLATILE);
		t2 &= ~(VT_CONSTANT | VT_VOLATILE);
	}

	/* Default Vs explicit signedness only matters for char */
	if ((t1 & VT_BTYPE) != VT_BYTE)
	{
		t1 &= ~VT_DEFSIGN;
		t2 &= ~VT_DEFSIGN;
	}
	/* XXX: bitfields ? */
	if (t1 != t2)
		return 0;

	if ((t1 & VT_ARRAY)
	        && !(type1->ref->c < 0
	             || type2->ref->c < 0
	             || type1->ref->c == type2->ref->c))
		return 0;

	/* test more complicated cases */
	bt1 = t1 & VT_BTYPE;
	if (bt1 == VT_PTR)
	{
		type1 = pointed_type(type1);
		type2 = pointed_type(type2);
		return is_compatible_types(type1, type2);
	}
	else if (bt1 == VT_STRUCT)
	{
		return (type1->ref == type2->ref);
	}
	else if (bt1 == VT_FUNC)
	{
		return is_compatible_func(type1, type2);
	}
	else if (IS_ENUM(type1->t) || IS_ENUM(type2->t))
	{
		return type1->ref == type2->ref;
	}
	else
	{
		return 1;
	}
}

/* return true if type1 and type2 are exactly the same (including
   qualifiers).
*/
static int is_compatible_types(CType *type1, CType *type2)
{
	return compare_types(type1,type2,0);
}

/* return true if type1 and type2 are the same (ignoring qualifiers).
*/
static int is_compatible_unqualified_types(CType *type1, CType *type2)
{
	return compare_types(type1,type2,1);
}

/* print a type. If 'varstr' is not NULL, then the variable is also
   printed in the type */
/* XXX: union */
/* XXX: add array and function pointers */
static void type_to_str(char *buf, int buf_size,
                        CType *type, const char *varstr)
{
	int bt, v, t;
	Sym *s, *sa;
	char buf1[256];
	const char *tstr;

	t = type->t;
	bt = t & VT_BTYPE;
	buf[0] = '\0';

	if (t & VT_EXTERN)
		pstrcat(buf, buf_size, "extern ");
	if (t & VT_STATIC)
		pstrcat(buf, buf_size, "static ");
	if (t & VT_TYPEDEF)
		pstrcat(buf, buf_size, "typedef ");
	if (t & VT_INLINE)
		pstrcat(buf, buf_size, "inline ");
	if (t & VT_VOLATILE)
		pstrcat(buf, buf_size, "volatile ");
	if (t & VT_CONSTANT)
		pstrcat(buf, buf_size, "const ");

	if (((t & VT_DEFSIGN) && bt == VT_BYTE)
	        || ((t & VT_UNSIGNED)
	            && (bt == VT_SHORT || bt == VT_INT || bt == VT_LLONG)
	            && !IS_ENUM(t)
	           ))
		pstrcat(buf, buf_size, (t & VT_UNSIGNED) ? "unsigned " : "signed ");

	buf_size -= strlen(buf);
	buf += strlen(buf);

	switch(bt)
	{
	case VT_VOID:
		tstr = "void";
		goto add_tstr;
	case VT_BOOL:
		tstr = "_Bool";
		goto add_tstr;
	case VT_BYTE:
		tstr = "char";
		goto add_tstr;
	case VT_SHORT:
		tstr = "short";
		goto add_tstr;
	case VT_INT:
		tstr = "int";
		goto maybe_long;
	case VT_LLONG:
		tstr = "long long";
maybe_long:
		if (t & VT_LONG)
			tstr = "long";
		if (!IS_ENUM(t))
			goto add_tstr;
		tstr = "enum ";
		goto tstruct;
	case VT_FLOAT:
		tstr = "float";
		goto add_tstr;
	case VT_DOUBLE:
		tstr = "double";
		goto add_tstr;
	case VT_LDOUBLE:
		tstr = "long double";
add_tstr:
		pstrcat(buf, buf_size, tstr);
		break;
	case VT_STRUCT:
		tstr = "struct ";
		if (IS_UNION(t))
			tstr = "union ";
tstruct:
		pstrcat(buf, buf_size, tstr);
		v = type->ref->v & ~SYM_STRUCT;
		if (v >= SYM_FIRST_ANOM)
			pstrcat(buf, buf_size, "<anonymous>");
		else
			pstrcat(buf, buf_size, get_tok_str(v, NULL));
		break;
	case VT_FUNC:
		s = type->ref;
		buf1[0]=0;
		if (varstr && '*' == *varstr)
		{
			pstrcat(buf1, sizeof(buf1), "(");
			pstrcat(buf1, sizeof(buf1), varstr);
			pstrcat(buf1, sizeof(buf1), ")");
		}
		pstrcat(buf1, buf_size, "(");
		sa = s->next;
		while (sa != NULL)
		{
			char buf2[256];
			type_to_str(buf2, sizeof(buf2), &sa->type, NULL);
			pstrcat(buf1, sizeof(buf1), buf2);
			sa = sa->next;
			if (sa)
				pstrcat(buf1, sizeof(buf1), ", ");
		}
		if (s->f.func_type == FUNC_ELLIPSIS)
			pstrcat(buf1, sizeof(buf1), ", ...");
		pstrcat(buf1, sizeof(buf1), ")");
		type_to_str(buf, buf_size, &s->type, buf1);
		goto no_var;
	case VT_PTR:
		s = type->ref;
		if (t & VT_ARRAY)
		{
			if (varstr && '*' == *varstr)
				snprintf(buf1, sizeof(buf1), "(%s)[%d]", varstr, s->c);
			else
				snprintf(buf1, sizeof(buf1), "%s[%d]", varstr ? varstr : "", s->c);
			type_to_str(buf, buf_size, &s->type, buf1);
			goto no_var;
		}
		pstrcpy(buf1, sizeof(buf1), "*");
		if (t & VT_CONSTANT)
			pstrcat(buf1, buf_size, "const ");
		if (t & VT_VOLATILE)
			pstrcat(buf1, buf_size, "volatile ");
		if (varstr)
			pstrcat(buf1, sizeof(buf1), varstr);
		type_to_str(buf, buf_size, &s->type, buf1);
		goto no_var;
	}
	if (varstr)
	{
		pstrcat(buf, buf_size, " ");
		pstrcat(buf, buf_size, varstr);
	}
no_var:
	;
}

static void type_incompatibility_error(CType* st, CType* dt, const char* fmt)
{
	char buf1[256], buf2[256];
	type_to_str(buf1, sizeof(buf1), st, NULL);
	type_to_str(buf2, sizeof(buf2), dt, NULL);
	tcc_error(fmt, buf1, buf2);
}

static void type_incompatibility_warning(CType* st, CType* dt, const char* fmt)
{
	char buf1[256], buf2[256];
	type_to_str(buf1, sizeof(buf1), st, NULL);
	type_to_str(buf2, sizeof(buf2), dt, NULL);
	tcc_warning(fmt, buf1, buf2);
}

static void cast_error(CType *st, CType *dt)
{
	type_incompatibility_error(st, dt, "cannot convert '%s' to '%s'");
}

/* verify type compatibility to store vtop in 'dt' type */
static void verify_assign_cast(CType *dt)
{
	CType *st, *type1, *type2;
	int dbt, sbt, qualwarn, lvl;

	st = &vtop->type; /* source type */
	dbt = dt->t & VT_BTYPE;
	sbt = st->t & VT_BTYPE;
	if (dt->t & VT_CONSTANT)
		tcc_warning("assignment of read-only location");
	switch(dbt)
	{
	case VT_VOID:
		if (sbt != dbt)
			tcc_error("assignment to void expression");
		break;
	case VT_PTR:
		/* special cases for pointers */
		/* '0' can also be a pointer */
		if (is_null_pointer(vtop))
			break;
		/* accept implicit pointer to integer cast with warning */
		if (is_integer_btype(sbt))
		{
			tcc_warning("assignment makes pointer from integer without a cast");
			break;
		}
		type1 = pointed_type(dt);
		if (sbt == VT_PTR)
			type2 = pointed_type(st);
		else if (sbt == VT_FUNC)
			type2 = st; /* a function is implicitly a function pointer */
		else
			goto error;
		if (is_compatible_types(type1, type2))
			break;
		for (qualwarn = lvl = 0;; ++lvl)
		{
			if (((type2->t & VT_CONSTANT) && !(type1->t & VT_CONSTANT)) ||
			        ((type2->t & VT_VOLATILE) && !(type1->t & VT_VOLATILE)))
				qualwarn = 1;
			dbt = type1->t & (VT_BTYPE|VT_LONG);
			sbt = type2->t & (VT_BTYPE|VT_LONG);
			if (dbt != VT_PTR || sbt != VT_PTR)
				break;
			type1 = pointed_type(type1);
			type2 = pointed_type(type2);
		}
		if (!is_compatible_unqualified_types(type1, type2))
		{
			if ((dbt == VT_VOID || sbt == VT_VOID) && lvl == 0)
			{
				/* void * can match anything */
			}
			else if (dbt == sbt
			         && is_integer_btype(sbt & VT_BTYPE)
			         && IS_ENUM(type1->t) + IS_ENUM(type2->t)
			         + !!((type1->t ^ type2->t) & VT_UNSIGNED) < 2)
			{
				/* Like GCC don't warn by default for merely changes
				   in pointer target signedness.  Do warn for different
				   base types, though, in particular for unsigned enums
				   and signed int targets.  */
			}
			else
			{
				tcc_warning("assignment from incompatible pointer type");
				break;
			}
		}
		if (qualwarn)
			tcc_warning("assignment discards qualifiers from pointer target type");
		break;
	case VT_BYTE:
	case VT_SHORT:
	case VT_INT:
	case VT_LLONG:
		if (sbt == VT_PTR || sbt == VT_FUNC)
		{
			tcc_warning("assignment makes integer from pointer without a cast");
		}
		else if (sbt == VT_STRUCT)
		{
			goto case_VT_STRUCT;
		}
		/* XXX: more tests */
		break;
	case VT_STRUCT:
case_VT_STRUCT:
		if (!is_compatible_unqualified_types(dt, st))
		{
error:
			cast_error(st, dt);
		}
		break;
	}
}

static void gen_assign_cast(CType *dt)
{
	verify_assign_cast(dt);
	gen_cast(dt);
}

/* store vtop in lvalue pushed on stack */
ST_FUNC void vstore(void)
{
	int sbt, dbt, ft, r, size, align, bit_size, bit_pos, delayed_cast;

	ft = vtop[-1].type.t;
	sbt = vtop->type.t & VT_BTYPE;
	dbt = ft & VT_BTYPE;

	verify_assign_cast(&vtop[-1].type);

	if (sbt == VT_STRUCT)
	{
		/* if structure, only generate pointer */
		/* structure assignment : generate memcpy */
		/* XXX: optimize if small size */
		size = type_size(&vtop->type, &align);

		/* destination */
		vswap();
#ifdef CONFIG_TCC_BCHECK
		if (vtop->r & VT_MUSTBOUND)
			gbound(); /* check would be wrong after gaddrof() */
#endif
		vtop->type.t = VT_PTR;
		gaddrof();

		/* address of memcpy() */
#ifdef TCC_ARM_EABI
		if(!(align & 7))
			vpush_global_sym(&func_old_type, TOK_memcpy8);
		else if(!(align & 3))
			vpush_global_sym(&func_old_type, TOK_memcpy4);
		else
#endif
			/* Use memmove, rather than memcpy, as dest and src may be same: */
			vpush_global_sym(&func_old_type, TOK_memmove);

		vswap();
		/* source */
		vpushv(vtop - 2);
#ifdef CONFIG_TCC_BCHECK
		if (vtop->r & VT_MUSTBOUND)
			gbound();
#endif
		vtop->type.t = VT_PTR;
		gaddrof();
		/* type size */
		vpushi(size);
		gfunc_call(3);
		/* leave source on stack */

	}
	else if (ft & VT_BITFIELD)
	{
		/* bitfield store handling */

		/* save lvalue as expression result (example: s.b = s.a = n;) */
		vdup(), vtop[-1] = vtop[-2];

		bit_pos = BIT_POS(ft);
		bit_size = BIT_SIZE(ft);
		/* remove bit field info to avoid loops */
		vtop[-1].type.t = ft & ~VT_STRUCT_MASK;

		if (dbt == VT_BOOL)
		{
			gen_cast(&vtop[-1].type);
			vtop[-1].type.t = (vtop[-1].type.t & ~VT_BTYPE) | (VT_BYTE | VT_UNSIGNED);
		}
		r = adjust_bf(vtop - 1, bit_pos, bit_size);
		if (dbt != VT_BOOL)
		{
			gen_cast(&vtop[-1].type);
			dbt = vtop[-1].type.t & VT_BTYPE;
		}
		if (r == VT_STRUCT)
		{
			store_packed_bf(bit_pos, bit_size);
		}
		else
		{
			unsigned long long mask = (1ULL << bit_size) - 1;
			if (dbt != VT_BOOL)
			{
				/* mask source */
				if (dbt == VT_LLONG)
					vpushll(mask);
				else
					vpushi((unsigned)mask);
				gen_op('&');
			}
			/* shift source */
			vpushi(bit_pos);
			gen_op(TOK_SHL);
			vswap();
			/* duplicate destination */
			vdup();
			vrott(3);
			/* load destination, mask and or with source */
			if (dbt == VT_LLONG)
				vpushll(~(mask << bit_pos));
			else
				vpushi(~((unsigned)mask << bit_pos));
			gen_op('&');
			gen_op('|');
			/* store result */
			vstore();
			/* ... and discard */
			vpop();
		}
	}
	else if (dbt == VT_VOID)
	{
		--vtop;
	}
	else
	{
		/* optimize char/short casts */
		delayed_cast = 0;
		if ((dbt == VT_BYTE || dbt == VT_SHORT)
		        && is_integer_btype(sbt)
		   )
		{
			if ((vtop->r & VT_MUSTCAST)
			        && btype_size(dbt) > btype_size(sbt)
			   )
				force_charshort_cast();
			delayed_cast = 1;
		}
		else
		{
			gen_cast(&vtop[-1].type);
		}

#ifdef CONFIG_TCC_BCHECK
		/* bound check case */
		if (vtop[-1].r & VT_MUSTBOUND)
		{
			vswap();
			gbound();
			vswap();
		}
#endif
		gv(RC_TYPE(dbt)); /* generate value */

		if (delayed_cast)
		{
			vtop->r |= BFVAL(VT_MUSTCAST, (sbt == VT_LLONG) + 1);
			//tcc_warning("deley cast %x -> %x", sbt, dbt);
			vtop->type.t = ft & VT_TYPE;
		}

		/* if lvalue was saved on stack, must read it */
		if ((vtop[-1].r & VT_VALMASK) == VT_LLOCAL)
		{
			SValue sv;
			r = get_reg(RC_INT);
			sv.type.t = VT_PTRDIFF_T;
			sv.r = VT_LOCAL | VT_LVAL;
			sv.c.i = vtop[-1].c.i;
			load(r, &sv);
			vtop[-1].r = r | VT_LVAL;
		}

		r = vtop->r & VT_VALMASK;
		/* two word case handling :
		   store second register at word + 4 (or +8 for x86-64)  */
		if (USING_TWO_WORDS(dbt))
		{
			int load_type = (dbt == VT_QFLOAT) ? VT_DOUBLE : VT_PTRDIFF_T;
			vtop[-1].type.t = load_type;
			store(r, vtop - 1);
			vswap();
			/* convert to int to increment easily */
			vtop->type.t = VT_PTRDIFF_T;
			gaddrof();
			vpushs(PTR_SIZE);
			gen_op('+');
			vtop->r |= VT_LVAL;
			vswap();
			vtop[-1].type.t = load_type;
			/* XXX: it works because r2 is spilled last ! */
			store(vtop->r2, vtop - 1);
		}
		else
		{
			/* single word */
			store(r, vtop - 1);
		}
		vswap();
		vtop--; /* NOT vpop() because on x86 it would flush the fp stack */
	}
}

/* post defines POST/PRE add. c is the token ++ or -- */
ST_FUNC void inc(int post, int c)
{
	test_lvalue();
	vdup(); /* save lvalue */
	if (post)
	{
		gv_dup(); /* duplicate value */
		vrotb(3);
		vrotb(3);
	}
	/* add constant */
	vpushi(c - TOK_MID);
	gen_op('+');
	vstore(); /* store value */
	if (post)
		vpop(); /* if post op, return saved value */
}

ST_FUNC void parse_mult_str (CString *astr, const char *msg)
{
	/* read the string */
	if (tok != TOK_STR)
		expect(msg);
	cstr_new(astr);
	while (tok == TOK_STR)
	{
		/* XXX: add \0 handling too ? */
		cstr_cat(astr, tokc.str.data, -1);
		next();
	}
	cstr_ccat(astr, '\0');
}

/* If I is >= 1 and a power of two, returns log2(i)+1.
   If I is 0 returns 0.  */
static int exact_log2p1(int i)
{
	int ret;
	if (!i)
		return 0;
	for (ret = 1; i >= 1 << 8; ret += 8)
		i >>= 8;
	if (i >= 1 << 4)
		ret += 4, i >>= 4;
	if (i >= 1 << 2)
		ret += 2, i >>= 2;
	if (i >= 1 << 1)
		ret++;
	return ret;
}

/* Parse __attribute__((...)) GNUC extension. */
static void parse_attribute(AttributeDef *ad)
{
	int t, n;
	CString astr;

redo:
	if (tok != TOK_ATTRIBUTE1 && tok != TOK_ATTRIBUTE2)
		return;
	next();
	skip('(');
	skip('(');
	while (tok != ')')
	{
		if (tok < TOK_IDENT)
			expect("attribute name");
		t = tok;
		next();
		switch(t)
		{
		case TOK_CLEANUP1:
		case TOK_CLEANUP2:
		{
			Sym *s;

			skip('(');
			s = sym_find(tok);
			if (!s)
			{
				tcc_warning("implicit declaration of function '%s'",
				            get_tok_str(tok, &tokc));
				s = external_global_sym(tok, &func_old_type);
			}
			else if ((s->type.t & VT_BTYPE) == VT_FUNC)
			{
				ad->cleanup_func = s;
			}
			else
			{
				tcc_error("'%s' is not declared as function", get_tok_str(tok, &tokc));
			}
			ad->cleanup_func = s;
			next();
			skip(')');
			break;
		}
		case TOK_CONSTRUCTOR1:
		case TOK_CONSTRUCTOR2:
			ad->f.func_ctor = 1;
			break;
		case TOK_DESTRUCTOR1:
		case TOK_DESTRUCTOR2:
			ad->f.func_dtor = 1;
			break;
		case TOK_SECTION1:
		case TOK_SECTION2:
			skip('(');
			parse_mult_str(&astr, "section name");
			ad->section = find_section(tcc_state, (char *)astr.data);
			skip(')');
			cstr_free(&astr);
			break;
		case TOK_ALIAS1:
		case TOK_ALIAS2:
			skip('(');
			parse_mult_str(&astr, "alias(\"target\")");
			ad->alias_target = /* save string as token, for later */
			    tok_alloc((char*)astr.data, astr.size-1)->tok;
			skip(')');
			cstr_free(&astr);
			break;
		case TOK_VISIBILITY1:
		case TOK_VISIBILITY2:
			skip('(');
			parse_mult_str(&astr,
			               "visibility(\"default|hidden|internal|protected\")");
			if (!strcmp (astr.data, "default"))
				ad->a.visibility = STV_DEFAULT;
			else if (!strcmp (astr.data, "hidden"))
				ad->a.visibility = STV_HIDDEN;
			else if (!strcmp (astr.data, "internal"))
				ad->a.visibility = STV_INTERNAL;
			else if (!strcmp (astr.data, "protected"))
				ad->a.visibility = STV_PROTECTED;
			else
				expect("visibility(\"default|hidden|internal|protected\")");
			skip(')');
			cstr_free(&astr);
			break;
		case TOK_ALIGNED1:
		case TOK_ALIGNED2:
			if (tok == '(')
			{
				next();
				n = expr_const();
				if (n <= 0 || (n & (n - 1)) != 0)
					tcc_error("alignment must be a positive power of two");
				skip(')');
			}
			else
			{
				n = MAX_ALIGN;
			}
			ad->a.aligned = exact_log2p1(n);
			if (n != 1 << (ad->a.aligned - 1))
				tcc_error("alignment of %d is larger than implemented", n);
			break;
		case TOK_PACKED1:
		case TOK_PACKED2:
			ad->a.packed = 1;
			break;
		case TOK_WEAK1:
		case TOK_WEAK2:
			ad->a.weak = 1;
			break;
		case TOK_UNUSED1:
		case TOK_UNUSED2:
			/* currently, no need to handle it because tcc does not
			   track unused objects */
			break;
		case TOK_NORETURN1:
		case TOK_NORETURN2:
			ad->f.func_noreturn = 1;
			break;
		case TOK_CDECL1:
		case TOK_CDECL2:
		case TOK_CDECL3:
			ad->f.func_call = FUNC_CDECL;
			break;
		case TOK_STDCALL1:
		case TOK_STDCALL2:
		case TOK_STDCALL3:
			ad->f.func_call = FUNC_STDCALL;
			break;
#ifdef TCC_TARGET_I386
		case TOK_REGPARM1:
		case TOK_REGPARM2:
			skip('(');
			n = expr_const();
			if (n > 3)
				n = 3;
			else if (n < 0)
				n = 0;
			if (n > 0)
				ad->f.func_call = FUNC_FASTCALL1 + n - 1;
			skip(')');
			break;
		case TOK_FASTCALL1:
		case TOK_FASTCALL2:
		case TOK_FASTCALL3:
			ad->f.func_call = FUNC_FASTCALLW;
			break;
#endif
		case TOK_MODE:
			skip('(');
			switch(tok)
			{
			case TOK_MODE_DI:
				ad->attr_mode = VT_LLONG + 1;
				break;
			case TOK_MODE_QI:
				ad->attr_mode = VT_BYTE + 1;
				break;
			case TOK_MODE_HI:
				ad->attr_mode = VT_SHORT + 1;
				break;
			case TOK_MODE_SI:
			case TOK_MODE_word:
				ad->attr_mode = VT_INT + 1;
				break;
			default:
				tcc_warning("__mode__(%s) not supported\n", get_tok_str(tok, NULL));
				break;
			}
			next();
			skip(')');
			break;
		case TOK_DLLEXPORT:
			ad->a.dllexport = 1;
			break;
		case TOK_NODECORATE:
			ad->a.nodecorate = 1;
			break;
		case TOK_DLLIMPORT:
			ad->a.dllimport = 1;
			break;
		default:
			if (tcc_state->warn_unsupported)
				tcc_warning("'%s' attribute ignored", get_tok_str(t, NULL));
			/* skip parameters */
			if (tok == '(')
			{
				int parenthesis = 0;
				do
				{
					if (tok == '(')
						parenthesis++;
					else if (tok == ')')
						parenthesis--;
					next();
				}
				while (parenthesis && tok != -1);
			}
			break;
		}
		if (tok != ',')
			break;
		next();
	}
	skip(')');
	skip(')');
	goto redo;
}

static Sym * find_field (CType *type, int v, int *cumofs)
{
	Sym *s = type->ref;
	v |= SYM_FIELD;
	while ((s = s->next) != NULL)
	{
		if ((s->v & SYM_FIELD) &&
		        (s->type.t & VT_BTYPE) == VT_STRUCT &&
		        (s->v & ~SYM_FIELD) >= SYM_FIRST_ANOM)
		{
			Sym *ret = find_field (&s->type, v, cumofs);
			if (ret)
			{
				*cumofs += s->c;
				return ret;
			}
		}
		if (s->v == v)
			break;
	}
	return s;
}

static void struct_layout(CType *type, AttributeDef *ad)
{
	int size, align, maxalign, offset, c, bit_pos, bit_size;
	int packed, a, bt, prevbt, prev_bit_size;
	int pcc = !tcc_state->ms_bitfields;
	int pragma_pack = *tcc_state->pack_stack_ptr;
	Sym *f;

	maxalign = 1;
	offset = 0;
	c = 0;
	bit_pos = 0;
	prevbt = VT_STRUCT; /* make it never match */
	prev_bit_size = 0;

//#define BF_DEBUG

	for (f = type->ref->next; f; f = f->next)
	{
		if (f->type.t & VT_BITFIELD)
			bit_size = BIT_SIZE(f->type.t);
		else
			bit_size = -1;
		size = type_size(&f->type, &align);
		a = f->a.aligned ? 1 << (f->a.aligned - 1) : 0;
		packed = 0;

		if (pcc && bit_size == 0)
		{
			/* in pcc mode, packing does not affect zero-width bitfields */

		}
		else
		{
			/* in pcc mode, attribute packed overrides if set. */
			if (pcc && (f->a.packed || ad->a.packed))
				align = packed = 1;

			/* pragma pack overrides align if lesser and packs bitfields always */
			if (pragma_pack)
			{
				packed = 1;
				if (pragma_pack < align)
					align = pragma_pack;
				/* in pcc mode pragma pack also overrides individual align */
				if (pcc && pragma_pack < a)
					a = 0;
			}
		}
		/* some individual align was specified */
		if (a)
			align = a;

		if (type->ref->type.t == VT_UNION)
		{
			if (pcc && bit_size >= 0)
				size = (bit_size + 7) >> 3;
			offset = 0;
			if (size > c)
				c = size;

		}
		else if (bit_size < 0)
		{
			if (pcc)
				c += (bit_pos + 7) >> 3;
			c = (c + align - 1) & -align;
			offset = c;
			if (size > 0)
				c += size;
			bit_pos = 0;
			prevbt = VT_STRUCT;
			prev_bit_size = 0;

		}
		else
		{
			/* A bit-field.  Layout is more complicated.  There are two
			   options: PCC (GCC) compatible and MS compatible */
			if (pcc)
			{
				/* In PCC layout a bit-field is placed adjacent to the
				           preceding bit-fields, except if:
				           - it has zero-width
				           - an individual alignment was given
				           - it would overflow its base type container and
				             there is no packing */
				if (bit_size == 0)
				{
new_field:
					c = (c + ((bit_pos + 7) >> 3) + align - 1) & -align;
					bit_pos = 0;
				}
				else if (f->a.aligned)
				{
					goto new_field;
				}
				else if (!packed)
				{
					int a8 = align * 8;
					int ofs = ((c * 8 + bit_pos) % a8 + bit_size + a8 - 1) / a8;
					if (ofs > size / align)
						goto new_field;
				}

				/* in pcc mode, long long bitfields have type int if they fit */
				if (size == 8 && bit_size <= 32)
					f->type.t = (f->type.t & ~VT_BTYPE) | VT_INT, size = 4;

				while (bit_pos >= align * 8)
					c += align, bit_pos -= align * 8;
				offset = c;

				/* In PCC layout named bit-fields influence the alignment
				   of the containing struct using the base types alignment,
				   except for packed fields (which here have correct align).  */
				if (f->v & SYM_FIRST_ANOM
				        // && bit_size // ??? gcc on ARM/rpi does that
				   )
					align = 1;

			}
			else
			{
				bt = f->type.t & VT_BTYPE;
				if ((bit_pos + bit_size > size * 8)
				        || (bit_size > 0) == (bt != prevbt)
				   )
				{
					c = (c + align - 1) & -align;
					offset = c;
					bit_pos = 0;
					/* In MS bitfield mode a bit-field run always uses
					   at least as many bits as the underlying type.
					   To start a new run it's also required that this
					   or the last bit-field had non-zero width.  */
					if (bit_size || prev_bit_size)
						c += size;
				}
				/* In MS layout the records alignment is normally
				   influenced by the field, except for a zero-width
				   field at the start of a run (but by further zero-width
				   fields it is again).  */
				if (bit_size == 0 && prevbt != bt)
					align = 1;
				prevbt = bt;
				prev_bit_size = bit_size;
			}

			f->type.t = (f->type.t & ~(0x3f << VT_STRUCT_SHIFT))
			            | (bit_pos << VT_STRUCT_SHIFT);
			bit_pos += bit_size;
		}
		if (align > maxalign)
			maxalign = align;

#ifdef BF_DEBUG
		printf("set field %s offset %-2d size %-2d align %-2d",
		       get_tok_str(f->v & ~SYM_FIELD, NULL), offset, size, align);
		if (f->type.t & VT_BITFIELD)
		{
			printf(" pos %-2d bits %-2d",
			       BIT_POS(f->type.t),
			       BIT_SIZE(f->type.t)
			      );
		}
		printf("\n");
#endif

		f->c = offset;
		f->r = 0;
	}

	if (pcc)
		c += (bit_pos + 7) >> 3;

	/* store size and alignment */
	a = bt = ad->a.aligned ? 1 << (ad->a.aligned - 1) : 1;
	if (a < maxalign)
		a = maxalign;
	type->ref->r = a;
	if (pragma_pack && pragma_pack < maxalign && 0 == pcc)
	{
		/* can happen if individual align for some member was given.  In
		   this case MSVC ignores maxalign when aligning the size */
		a = pragma_pack;
		if (a < bt)
			a = bt;
	}
	c = (c + a - 1) & -a;
	type->ref->c = c;

#ifdef BF_DEBUG
	printf("struct size %-2d align %-2d\n\n", c, a), fflush(stdout);
#endif

	/* check whether we can access bitfields by their type */
	for (f = type->ref->next; f; f = f->next)
	{
		int s, px, cx, c0;
		CType t;

		if (0 == (f->type.t & VT_BITFIELD))
			continue;
		f->type.ref = f;
		f->auxtype = -1;
		bit_size = BIT_SIZE(f->type.t);
		if (bit_size == 0)
			continue;
		bit_pos = BIT_POS(f->type.t);
		size = type_size(&f->type, &align);
		if (bit_pos + bit_size <= size * 8 && f->c + size <= c)
			continue;

		/* try to access the field using a different type */
		c0 = -1, s = align = 1;
		for (;;)
		{
			px = f->c * 8 + bit_pos;
			cx = (px >> 3) & -align;
			px = px - (cx << 3);
			if (c0 == cx)
				break;
			s = (px + bit_size + 7) >> 3;
			if (s > 4)
			{
				t.t = VT_LLONG;
			}
			else if (s > 2)
			{
				t.t = VT_INT;
			}
			else if (s > 1)
			{
				t.t = VT_SHORT;
			}
			else
			{
				t.t = VT_BYTE;
			}
			s = type_size(&t, &align);
			c0 = cx;
		}

		if (px + bit_size <= s * 8 && cx + s <= c)
		{
			/* update offset and bit position */
			f->c = cx;
			bit_pos = px;
			f->type.t = (f->type.t & ~(0x3f << VT_STRUCT_SHIFT))
			            | (bit_pos << VT_STRUCT_SHIFT);
			if (s != size)
				f->auxtype = t.t;
#ifdef BF_DEBUG
			printf("FIX field %s offset %-2d size %-2d align %-2d "
			       "pos %-2d bits %-2d\n",
			       get_tok_str(f->v & ~SYM_FIELD, NULL),
			       cx, s, align, px, bit_size);
#endif
		}
		else
		{
			/* fall back to load/store single-byte wise */
			f->auxtype = VT_STRUCT;
#ifdef BF_DEBUG
			printf("FIX field %s : load byte-wise\n",
			       get_tok_str(f->v & ~SYM_FIELD, NULL));
#endif
		}
	}
}

/* enum/struct/union declaration. u is VT_ENUM/VT_STRUCT/VT_UNION */
static void struct_decl(CType *type, int u)
{
	int v, c, size, align, flexible;
	int bit_size, bsize, bt;
	Sym *s, *ss, **ps;
	AttributeDef ad, ad1;
	CType type1, btype;

	memset(&ad, 0, sizeof ad);
	next();
	parse_attribute(&ad);
	if (tok != '{')
	{
		v = tok;
		next();
		/* struct already defined ? return it */
		if (v < TOK_IDENT)
			expect("struct/union/enum name");
		s = struct_find(v);
		if (s && (s->sym_scope == local_scope || tok != '{'))
		{
			if (u == s->type.t)
				goto do_decl;
			if (u == VT_ENUM && IS_ENUM(s->type.t))
				goto do_decl;
			tcc_error("redefinition of '%s'", get_tok_str(v, NULL));
		}
	}
	else
	{
		v = anon_sym++;
	}
	/* Record the original enum/struct/union token.  */
	type1.t = u == VT_ENUM ? u | VT_INT | VT_UNSIGNED : u;
	type1.ref = NULL;
	/* we put an undefined size for struct/union */
	s = sym_push(v | SYM_STRUCT, &type1, 0, -1);
	s->r = 0; /* default alignment is zero as gcc */
do_decl:
	type->t = s->type.t;
	type->ref = s;

	if (tok == '{')
	{
		next();
		if (s->c != -1)
			tcc_error("struct/union/enum already defined");
		s->c = -2;
		/* cannot be empty */
		/* non empty enums are not allowed */
		ps = &s->next;
		if (u == VT_ENUM)
		{
			long long ll = 0, pl = 0, nl = 0;
			CType t;
			t.ref = s;
			/* enum symbols have static storage */
			t.t = VT_INT|VT_STATIC|VT_ENUM_VAL;
			for(;;)
			{
				v = tok;
				if (v < TOK_UIDENT)
					expect("identifier");
				ss = sym_find(v);
				if (ss && !local_stack)
					tcc_error("redefinition of enumerator '%s'",
					          get_tok_str(v, NULL));
				next();
				if (tok == '=')
				{
					next();
					ll = expr_const64();
				}
				ss = sym_push(v, &t, VT_CONST, 0);
				ss->enum_val = ll;
				*ps = ss, ps = &ss->next;
				if (ll < nl)
					nl = ll;
				if (ll > pl)
					pl = ll;
				if (tok != ',')
					break;
				next();
				ll++;
				/* NOTE: we accept a trailing comma */
				if (tok == '}')
					break;
			}
			skip('}');
			/* set integral type of the enum */
			t.t = VT_INT;
			if (nl >= 0)
			{
				if (pl != (unsigned)pl)
					t.t = (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);
				t.t |= VT_UNSIGNED;
			}
			else if (pl != (int)pl || nl != (int)nl)
				t.t = (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);
			s->type.t = type->t = t.t | VT_ENUM;
			s->c = 0;
			/* set type for enum members */
			for (ss = s->next; ss; ss = ss->next)
			{
				ll = ss->enum_val;
				if (ll == (int)ll) /* default is int if it fits */
					continue;
				if (t.t & VT_UNSIGNED)
				{
					ss->type.t |= VT_UNSIGNED;
					if (ll == (unsigned)ll)
						continue;
				}
				ss->type.t = (ss->type.t & ~VT_BTYPE)
				             | (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);
			}
		}
		else
		{
			c = 0;
			flexible = 0;
			while (tok != '}')
			{
				if (!parse_btype(&btype, &ad1))
				{
					skip(';');
					continue;
				}
				while (1)
				{
					if (flexible)
						tcc_error("flexible array member '%s' not at the end of struct",
						          get_tok_str(v, NULL));
					bit_size = -1;
					v = 0;
					type1 = btype;
					if (tok != ':')
					{
						if (tok != ';')
							type_decl(&type1, &ad1, &v, TYPE_DIRECT);
						if (v == 0)
						{
							if ((type1.t & VT_BTYPE) != VT_STRUCT)
								expect("identifier");
							else
							{
								int v = btype.ref->v;
								if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM)
								{
									if (tcc_state->ms_extensions == 0)
										expect("identifier");
								}
							}
						}
						if (type_size(&type1, &align) < 0)
						{
							if ((u == VT_STRUCT) && (type1.t & VT_ARRAY) && c)
								flexible = 1;
							else
								tcc_error("field '%s' has incomplete type",
								          get_tok_str(v, NULL));
						}
						if ((type1.t & VT_BTYPE) == VT_FUNC ||
						        (type1.t & VT_BTYPE) == VT_VOID ||
						        (type1.t & VT_STORAGE))
							tcc_error("invalid type for '%s'",
							          get_tok_str(v, NULL));
					}
					if (tok == ':')
					{
						next();
						bit_size = expr_const();
						/* XXX: handle v = 0 case for messages */
						if (bit_size < 0)
							tcc_error("negative width in bit-field '%s'",
							          get_tok_str(v, NULL));
						if (v && bit_size == 0)
							tcc_error("zero width for bit-field '%s'",
							          get_tok_str(v, NULL));
						parse_attribute(&ad1);
					}
					size = type_size(&type1, &align);
					if (bit_size >= 0)
					{
						bt = type1.t & VT_BTYPE;
						if (bt != VT_INT &&
						        bt != VT_BYTE &&
						        bt != VT_SHORT &&
						        bt != VT_BOOL &&
						        bt != VT_LLONG)
							tcc_error("bitfields must have scalar type");
						bsize = size * 8;
						if (bit_size > bsize)
						{
							tcc_error("width of '%s' exceeds its type",
							          get_tok_str(v, NULL));
						}
						else if (bit_size == bsize
						         && !ad.a.packed && !ad1.a.packed)
						{
							/* no need for bit fields */
							;
						}
						else if (bit_size == 64)
						{
							tcc_error("field width 64 not implemented");
						}
						else
						{
							type1.t = (type1.t & ~VT_STRUCT_MASK)
							          | VT_BITFIELD
							          | (bit_size << (VT_STRUCT_SHIFT + 6));
						}
					}
					if (v != 0 || (type1.t & VT_BTYPE) == VT_STRUCT)
					{
						/* Remember we've seen a real field to check
						for placement of flexible array member. */
						c = 1;
					}
					/* If member is a struct or bit-field, enforce
					   placing into the struct (as anonymous).  */
					if (v == 0 &&
					        ((type1.t & VT_BTYPE) == VT_STRUCT ||
					         bit_size >= 0))
					{
						v = anon_sym++;
					}
					if (v)
					{
						ss = sym_push(v | SYM_FIELD, &type1, 0, 0);
						ss->a = ad1.a;
						*ps = ss;
						ps = &ss->next;
					}
					if (tok == ';' || tok == TOK_EOF)
						break;
					skip(',');
				}
				skip(';');
			}
			skip('}');
			parse_attribute(&ad);
			if (ad.cleanup_func)
			{
				tcc_warning("attribute '__cleanup__' ignored on type");
			}
			struct_layout(type, &ad);
		}
	}
}

static void sym_to_attr(AttributeDef *ad, Sym *s)
{
	merge_symattr(&ad->a, &s->a);
	merge_funcattr(&ad->f, &s->f);
}

/* Add type qualifiers to a type. If the type is an array then the qualifiers
   are added to the element type, copied because it could be a typedef. */
static void parse_btype_qualify(CType *type, int qualifiers)
{
	while (type->t & VT_ARRAY)
	{
		type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->c);
		type = &type->ref->type;
	}
	type->t |= qualifiers;
}

/* return 0 if no type declaration. otherwise, return the basic type
   and skip it.
 */
static int parse_btype(CType *type, AttributeDef *ad)
{
	int t, u, bt, st, type_found, typespec_found, g, n;
	Sym *s;
	CType type1;

	memset(ad, 0, sizeof(AttributeDef));
	type_found = 0;
	typespec_found = 0;
	t = VT_INT;
	bt = st = -1;
	type->ref = NULL;

	while(1)
	{
		switch(tok)
		{
		case TOK_EXTENSION:
			/* currently, we really ignore extension */
			next();
			continue;

		/* basic types */
		case TOK_CHAR:
			u = VT_BYTE;
basic_type:
			next();
basic_type1:
			if (u == VT_SHORT || u == VT_LONG)
			{
				if (st != -1 || (bt != -1 && bt != VT_INT))
tmbt:
					tcc_error("too many basic types");
				st = u;
			}
			else
			{
				if (bt != -1 || (st != -1 && u != VT_INT))
					goto tmbt;
				bt = u;
			}
			if (u != VT_INT)
				t = (t & ~(VT_BTYPE|VT_LONG)) | u;
			typespec_found = 1;
			break;
		case TOK_VOID:
			u = VT_VOID;
			goto basic_type;
		case TOK_SHORT:
			u = VT_SHORT;
			goto basic_type;
		case TOK_INT:
			u = VT_INT;
			goto basic_type;
		case TOK_ALIGNAS:
		{
			int n;
			AttributeDef ad1;
			next();
			skip('(');
			memset(&ad1, 0, sizeof(AttributeDef));
			if (parse_btype(&type1, &ad1))
			{
				type_decl(&type1, &ad1, &n, TYPE_ABSTRACT);
				if (ad1.a.aligned)
					n = 1 << (ad1.a.aligned - 1);
				else
					type_size(&type1, &n);
			}
			else
			{
				n = expr_const();
				if (n <= 0 || (n & (n - 1)) != 0)
					tcc_error("alignment must be a positive power of two");
			}
			skip(')');
			ad->a.aligned = exact_log2p1(n);
		}
		continue;
		case TOK_LONG:
			if ((t & VT_BTYPE) == VT_DOUBLE)
			{
				t = (t & ~(VT_BTYPE|VT_LONG)) | VT_LDOUBLE;
			}
			else if ((t & (VT_BTYPE|VT_LONG)) == VT_LONG)
			{
				t = (t & ~(VT_BTYPE|VT_LONG)) | VT_LLONG;
			}
			else
			{
				u = VT_LONG;
				goto basic_type;
			}
			next();
			break;
#ifdef TCC_TARGET_ARM64
		case TOK_UINT128:
			/* GCC's __uint128_t appears in some Linux header files. Make it a
			   synonym for long double to get the size and alignment right. */
			u = VT_LDOUBLE;
			goto basic_type;
#endif
		case TOK_BOOL:
			u = VT_BOOL;
			goto basic_type;
		case TOK_FLOAT:
			u = VT_FLOAT;
			goto basic_type;
		case TOK_DOUBLE:
			if ((t & (VT_BTYPE|VT_LONG)) == VT_LONG)
			{
				t = (t & ~(VT_BTYPE|VT_LONG)) | VT_LDOUBLE;
			}
			else
			{
				u = VT_DOUBLE;
				goto basic_type;
			}
			next();
			break;
		case TOK_ENUM:
			struct_decl(&type1, VT_ENUM);
basic_type2:
			u = type1.t;
			type->ref = type1.ref;
			goto basic_type1;
		case TOK_STRUCT:
			struct_decl(&type1, VT_STRUCT);
			goto basic_type2;
		case TOK_UNION:
			struct_decl(&type1, VT_UNION);
			goto basic_type2;

		/* type modifiers */
		case TOK_CONST1:
		case TOK_CONST2:
		case TOK_CONST3:
			type->t = t;
			parse_btype_qualify(type, VT_CONSTANT);
			t = type->t;
			next();
			break;
		case TOK_VOLATILE1:
		case TOK_VOLATILE2:
		case TOK_VOLATILE3:
			type->t = t;
			parse_btype_qualify(type, VT_VOLATILE);
			t = type->t;
			next();
			break;
		case TOK_SIGNED1:
		case TOK_SIGNED2:
		case TOK_SIGNED3:
			if ((t & (VT_DEFSIGN|VT_UNSIGNED)) == (VT_DEFSIGN|VT_UNSIGNED))
				tcc_error("signed and unsigned modifier");
			t |= VT_DEFSIGN;
			next();
			typespec_found = 1;
			break;
		case TOK_REGISTER:
		case TOK_AUTO:
		case TOK_RESTRICT1:
		case TOK_RESTRICT2:
		case TOK_RESTRICT3:
			next();
			break;
		case TOK_UNSIGNED:
			if ((t & (VT_DEFSIGN|VT_UNSIGNED)) == VT_DEFSIGN)
				tcc_error("signed and unsigned modifier");
			t |= VT_DEFSIGN | VT_UNSIGNED;
			next();
			typespec_found = 1;
			break;

		/* storage */
		case TOK_EXTERN:
			g = VT_EXTERN;
			goto storage;
		case TOK_STATIC:
			g = VT_STATIC;
			goto storage;
		case TOK_TYPEDEF:
			g = VT_TYPEDEF;
			goto storage;
storage:
			if (t & (VT_EXTERN|VT_STATIC|VT_TYPEDEF) & ~g)
				tcc_error("multiple storage classes");
			t |= g;
			next();
			break;
		case TOK_INLINE1:
		case TOK_INLINE2:
		case TOK_INLINE3:
			t |= VT_INLINE;
			next();
			break;
		case TOK_NORETURN3:
			next();
			ad->f.func_noreturn = 1;
			break;
		/* GNUC attribute */
		case TOK_ATTRIBUTE1:
		case TOK_ATTRIBUTE2:
			parse_attribute(ad);
			if (ad->attr_mode)
			{
				u = ad->attr_mode -1;
				t = (t & ~(VT_BTYPE|VT_LONG)) | u;
			}
			continue;
		/* GNUC typeof */
		case TOK_TYPEOF1:
		case TOK_TYPEOF2:
		case TOK_TYPEOF3:
			next();
			parse_expr_type(&type1);
			/* remove all storage modifiers except typedef */
			type1.t &= ~(VT_STORAGE&~VT_TYPEDEF);
			if (type1.ref)
				sym_to_attr(ad, type1.ref);
			goto basic_type2;
		default:
			if (typespec_found)
				goto the_end;
			s = sym_find(tok);
			if (!s || !(s->type.t & VT_TYPEDEF))
				goto the_end;

			n = tok, next();
			if (tok == ':' && !in_generic)
			{
				/* ignore if it's a label */
				unget_tok(n);
				goto the_end;
			}

			t &= ~(VT_BTYPE|VT_LONG);
			u = t & ~(VT_CONSTANT | VT_VOLATILE), t ^= u;
			type->t = (s->type.t & ~VT_TYPEDEF) | u;
			type->ref = s->type.ref;
			if (t)
				parse_btype_qualify(type, t);
			t = type->t;
			/* get attributes from typedef */
			sym_to_attr(ad, s);
			typespec_found = 1;
			st = bt = -2;
			break;
		}
		type_found = 1;
	}
the_end:
	if (tcc_state->char_is_unsigned)
	{
		if ((t & (VT_DEFSIGN|VT_BTYPE)) == VT_BYTE)
			t |= VT_UNSIGNED;
	}
	/* VT_LONG is used just as a modifier for VT_INT / VT_LLONG */
	bt = t & (VT_BTYPE|VT_LONG);
	if (bt == VT_LONG)
		t |= LONG_SIZE == 8 ? VT_LLONG : VT_INT;
#ifdef TCC_TARGET_PE
	if (bt == VT_LDOUBLE)
		t = (t & ~(VT_BTYPE|VT_LONG)) | VT_DOUBLE;
#endif
	type->t = t;
	return type_found;
}

/* convert a function parameter type (array to pointer and function to
   function pointer) */
static inline void convert_parameter_type(CType *pt)
{
	/* remove const and volatile qualifiers (XXX: const could be used
	   to indicate a const function parameter */
	pt->t &= ~(VT_CONSTANT | VT_VOLATILE);
	/* array must be transformed to pointer according to ANSI C */
	pt->t &= ~VT_ARRAY;
	if ((pt->t & VT_BTYPE) == VT_FUNC)
	{
		mk_pointer(pt);
	}
}

ST_FUNC void parse_asm_str(CString *astr)
{
	skip('(');
	parse_mult_str(astr, "string constant");
}

/* Parse an asm label and return the token */
static int asm_label_instr(void)
{
	int v;
	CString astr;

	next();
	parse_asm_str(&astr);
	skip(')');
#ifdef ASM_DEBUG
	printf("asm_alias: \"%s\"\n", (char *)astr.data);
#endif
	v = tok_alloc(astr.data, astr.size - 1)->tok;
	cstr_free(&astr);
	return v;
}

static int post_type(CType *type, AttributeDef *ad, int storage, int td)
{
	int n, l, t1, arg_size, align, unused_align;
	Sym **plast, *s, *first;
	AttributeDef ad1;
	CType pt;

	if (tok == '(')
	{
		/* function type, or recursive declarator (return if so) */
		next();
		if (td && !(td & TYPE_ABSTRACT))
			return 0;
		if (tok == ')')
			l = 0;
		else if (parse_btype(&pt, &ad1))
			l = FUNC_NEW;
		else if (td)
		{
			merge_attr (ad, &ad1);
			return 0;
		}
		else
			l = FUNC_OLD;
		first = NULL;
		plast = &first;
		arg_size = 0;
		if (l)
		{
			for(;;)
			{
				/* read param name and compute offset */
				if (l != FUNC_OLD)
				{
					if ((pt.t & VT_BTYPE) == VT_VOID && tok == ')')
						break;
					type_decl(&pt, &ad1, &n, TYPE_DIRECT | TYPE_ABSTRACT);
					if ((pt.t & VT_BTYPE) == VT_VOID)
						tcc_error("parameter declared as void");
				}
				else
				{
					n = tok;
					if (n < TOK_UIDENT)
						expect("identifier");
					pt.t = VT_VOID; /* invalid type */
					pt.ref = NULL;
					next();
				}
				convert_parameter_type(&pt);
				arg_size += (type_size(&pt, &align) + PTR_SIZE - 1) / PTR_SIZE;
				s = sym_push(n | SYM_FIELD, &pt, 0, 0);
				*plast = s;
				plast = &s->next;
				if (tok == ')')
					break;
				skip(',');
				if (l == FUNC_NEW && tok == TOK_DOTS)
				{
					l = FUNC_ELLIPSIS;
					next();
					break;
				}
				if (l == FUNC_NEW && !parse_btype(&pt, &ad1))
					tcc_error("invalid type");
			}
		}
		else
			/* if no parameters, then old type prototype */
			l = FUNC_OLD;
		skip(')');
		/* NOTE: const is ignored in returned type as it has a special
		   meaning in gcc / C++ */
		type->t &= ~VT_CONSTANT;
		/* some ancient pre-K&R C allows a function to return an array
		   and the array brackets to be put after the arguments, such
		   that "int c()[]" means something like "int[] c()" */
		if (tok == '[')
		{
			next();
			skip(']'); /* only handle simple "[]" */
			mk_pointer(type);
		}
		/* we push a anonymous symbol which will contain the function prototype */
		ad->f.func_args = arg_size;
		ad->f.func_type = l;
		s = sym_push(SYM_FIELD, type, 0, 0);
		s->a = ad->a;
		s->f = ad->f;
		s->next = first;
		type->t = VT_FUNC;
		type->ref = s;
	}
	else if (tok == '[')
	{
		int saved_nocode_wanted = nocode_wanted;
		/* array definition */
		next();
		while (1)
		{
			/* XXX The optional type-quals and static should only be accepted
			   in parameter decls.  The '*' as well, and then even only
			   in prototypes (not function defs).  */
			switch (tok)
			{
			case TOK_RESTRICT1:
			case TOK_RESTRICT2:
			case TOK_RESTRICT3:
			case TOK_CONST1:
			case TOK_VOLATILE1:
			case TOK_STATIC:
			case '*':
				next();
				continue;
			default:
				break;
			}
			break;
		}
		n = -1;
		t1 = 0;
		if (tok != ']')
		{
			if (!local_stack || (storage & VT_STATIC))
				vpushi(expr_const());
			else
			{
				/* VLAs (which can only happen with local_stack && !VT_STATIC)
				   length must always be evaluated, even under nocode_wanted,
				   so that its size slot is initialized (e.g. under sizeof
				   or typeof).  */
				nocode_wanted = 0;
				gexpr();
			}
			if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)
			{
				n = vtop->c.i;
				if (n < 0)
					tcc_error("invalid array size");
			}
			else
			{
				if (!is_integer_btype(vtop->type.t & VT_BTYPE))
					tcc_error("size of variable length array should be an integer");
				n = 0;
				t1 = VT_VLA;
			}
		}
		skip(']');
		/* parse next post type */
		post_type(type, ad, storage, 0);

		if ((type->t & VT_BTYPE) == VT_FUNC)
			tcc_error("declaration of an array of functions");
		if ((type->t & VT_BTYPE) == VT_VOID
		        || type_size(type, &unused_align) < 0)
			tcc_error("declaration of an array of incomplete type elements");

		t1 |= type->t & VT_VLA;

		if (t1 & VT_VLA)
		{
			if (n < 0)
				tcc_error("need explicit inner array size in VLAs");
			loc -= type_size(&int_type, &align);
			loc &= -align;
			n = loc;

			vla_runtime_type_size(type, &align);
			gen_op('*');
			vset(&int_type, VT_LOCAL|VT_LVAL, n);
			vswap();
			vstore();
		}
		if (n != -1)
			vpop();
		nocode_wanted = saved_nocode_wanted;

		/* we push an anonymous symbol which will contain the array
		   element type */
		s = sym_push(SYM_FIELD, type, 0, n);
		type->t = (t1 ? VT_VLA : VT_ARRAY) | VT_PTR;
		type->ref = s;
	}
	return 1;
}

/* Parse a type declarator (except basic type), and return the type
   in 'type'. 'td' is a bitmask indicating which kind of type decl is
   expected. 'type' should contain the basic type. 'ad' is the
   attribute definition of the basic type. It can be modified by
   type_decl().  If this (possibly abstract) declarator is a pointer chain
   it returns the innermost pointed to type (equals *type, but is a different
   pointer), otherwise returns type itself, that's used for recursive calls.  */
static CType *type_decl(CType *type, AttributeDef *ad, int *v, int td)
{
	CType *post, *ret;
	int qualifiers, storage;

	/* recursive type, remove storage bits first, apply them later again */
	storage = type->t & VT_STORAGE;
	type->t &= ~VT_STORAGE;
	post = ret = type;

	while (tok == '*')
	{
		qualifiers = 0;
redo:
		next();
		switch(tok)
		{
		case TOK_CONST1:
		case TOK_CONST2:
		case TOK_CONST3:
			qualifiers |= VT_CONSTANT;
			goto redo;
		case TOK_VOLATILE1:
		case TOK_VOLATILE2:
		case TOK_VOLATILE3:
			qualifiers |= VT_VOLATILE;
			goto redo;
		case TOK_RESTRICT1:
		case TOK_RESTRICT2:
		case TOK_RESTRICT3:
			goto redo;
		/* XXX: clarify attribute handling */
		case TOK_ATTRIBUTE1:
		case TOK_ATTRIBUTE2:
			parse_attribute(ad);
			break;
		}
		mk_pointer(type);
		type->t |= qualifiers;
		if (ret == type)
			/* innermost pointed to type is the one for the first derivation */
			ret = pointed_type(type);
	}

	if (tok == '(')
	{
		/* This is possibly a parameter type list for abstract declarators
		   ('int ()'), use post_type for testing this.  */
		if (!post_type(type, ad, 0, td))
		{
			/* It's not, so it's a nested declarator, and the post operations
			   apply to the innermost pointed to type (if any).  */
			/* XXX: this is not correct to modify 'ad' at this point, but
			   the syntax is not clear */
			parse_attribute(ad);
			post = type_decl(type, ad, v, td);
			skip(')');
		}
		else
			goto abstract;
	}
	else if (tok >= TOK_IDENT && (td & TYPE_DIRECT))
	{
		/* type identifier */
		*v = tok;
		next();
	}
	else
	{
abstract:
		if (!(td & TYPE_ABSTRACT))
			expect("identifier");
		*v = 0;
	}
	post_type(post, ad, storage, 0);
	parse_attribute(ad);
	type->t |= storage;
	return ret;
}

/* indirection with full error checking and bound check */
ST_FUNC void indir(void)
{
	if ((vtop->type.t & VT_BTYPE) != VT_PTR)
	{
		if ((vtop->type.t & VT_BTYPE) == VT_FUNC)
			return;
		expect("pointer");
	}
	if (vtop->r & VT_LVAL)
		gv(RC_INT);
	vtop->type = *pointed_type(&vtop->type);
	/* Arrays and functions are never lvalues */
	if (!(vtop->type.t & (VT_ARRAY | VT_VLA))
	        && (vtop->type.t & VT_BTYPE) != VT_FUNC)
	{
		vtop->r |= VT_LVAL;
		/* if bound checking, the referenced pointer must be checked */
#ifdef CONFIG_TCC_BCHECK
		if (tcc_state->do_bounds_check)
			vtop->r |= VT_MUSTBOUND;
#endif
	}
}

/* pass a parameter to a function and do type checking and casting */
static void gfunc_param_typed(Sym *func, Sym *arg)
{
	int func_type;
	CType type;

	func_type = func->f.func_type;
	if (func_type == FUNC_OLD ||
	        (func_type == FUNC_ELLIPSIS && arg == NULL))
	{
		/* default casting : only need to convert float to double */
		if ((vtop->type.t & VT_BTYPE) == VT_FLOAT)
		{
			gen_cast_s(VT_DOUBLE);
		}
		else if (vtop->type.t & VT_BITFIELD)
		{
			type.t = vtop->type.t & (VT_BTYPE | VT_UNSIGNED);
			type.ref = vtop->type.ref;
			gen_cast(&type);
		}
		else if (vtop->r & VT_MUSTCAST)
		{
			force_charshort_cast();
		}
	}
	else if (arg == NULL)
	{
		tcc_error("too many arguments to function");
	}
	else
	{
		type = arg->type;
		type.t &= ~VT_CONSTANT; /* need to do that to avoid false warning */
		gen_assign_cast(&type);
	}
}

/* parse an expression and return its type without any side effect. */
static void expr_type(CType *type, void (*expr_fn)(void))
{
	nocode_wanted++;
	expr_fn();
	*type = vtop->type;
	vpop();
	nocode_wanted--;
}

/* parse an expression of the form '(type)' or '(expr)' and return its
   type */
static void parse_expr_type(CType *type)
{
	int n;
	AttributeDef ad;

	skip('(');
	if (parse_btype(type, &ad))
	{
		type_decl(type, &ad, &n, TYPE_ABSTRACT);
	}
	else
	{
		expr_type(type, gexpr);
	}
	skip(')');
}

static void parse_type(CType *type)
{
	AttributeDef ad;
	int n;

	if (!parse_btype(type, &ad))
	{
		expect("type");
	}
	type_decl(type, &ad, &n, TYPE_ABSTRACT);
}

static void parse_builtin_params(int nc, const char *args)
{
	char c, sep = '(';
	CType t;
	if (nc)
		nocode_wanted++;
	next();
	while ((c = *args++))
	{
		skip(sep);
		sep = ',';
		switch (c)
		{
		case 'e':
			expr_eq();
			continue;
		case 't':
			parse_type(&t);
			vpush(&t);
			continue;
		default:
			tcc_error("internal error");
			break;
		}
	}
	skip(')');
	if (nc)
		nocode_wanted--;
}

ST_FUNC void unary(void)
{
	int n, t, align, size, r, sizeof_caller;
	CType type;
	Sym *s;
	AttributeDef ad;

	/* generate line number info */
	if (tcc_state->do_debug)
		tcc_debug_line(tcc_state);

	sizeof_caller = in_sizeof;
	in_sizeof = 0;
	type.ref = NULL;
	/* XXX: GCC 2.95.3 does not generate a table although it should be
	   better here */
tok_next:
	switch(tok)
	{
	case TOK_EXTENSION:
		next();
		goto tok_next;
	case TOK_LCHAR:
#ifdef TCC_TARGET_PE
		t = VT_SHORT|VT_UNSIGNED;
		goto push_tokc;
#endif
	case TOK_CINT:
	case TOK_CCHAR:
		t = VT_INT;
push_tokc:
		type.t = t;
		vsetc(&type, VT_CONST, &tokc);
		next();
		break;
	case TOK_CUINT:
		t = VT_INT | VT_UNSIGNED;
		goto push_tokc;
	case TOK_CLLONG:
		t = VT_LLONG;
		goto push_tokc;
	case TOK_CULLONG:
		t = VT_LLONG | VT_UNSIGNED;
		goto push_tokc;
	case TOK_CFLOAT:
		t = VT_FLOAT;
		goto push_tokc;
	case TOK_CDOUBLE:
		t = VT_DOUBLE;
		goto push_tokc;
	case TOK_CLDOUBLE:
		t = VT_LDOUBLE;
		goto push_tokc;
	case TOK_CLONG:
		t = (LONG_SIZE == 8 ? VT_LLONG : VT_INT) | VT_LONG;
		goto push_tokc;
	case TOK_CULONG:
		t = (LONG_SIZE == 8 ? VT_LLONG : VT_INT) | VT_LONG | VT_UNSIGNED;
		goto push_tokc;
	case TOK___FUNCTION__:
		if (!gnu_ext)
			goto tok_identifier;
	/* fall thru */
	case TOK___FUNC__:
	{
		void *ptr;
		int len;
		/* special function name identifier */
		len = strlen(funcname) + 1;
		/* generate char[len] type */
		type.t = VT_BYTE;
		mk_pointer(&type);
		type.t |= VT_ARRAY;
		type.ref->c = len;
		vpush_ref(&type, data_section, data_section->data_offset, len);
		if (!NODATA_WANTED)
		{
			ptr = section_ptr_add(data_section, len);
			memcpy(ptr, funcname, len);
		}
		next();
	}
	break;
	case TOK_LSTR:
#ifdef TCC_TARGET_PE
		t = VT_SHORT | VT_UNSIGNED;
#else
		t = VT_INT;
#endif
		goto str_init;
	case TOK_STR:
		/* string parsing */
		t = VT_BYTE;
		if (tcc_state->char_is_unsigned)
			t = VT_BYTE | VT_UNSIGNED;
str_init:
		if (tcc_state->warn_write_strings)
			t |= VT_CONSTANT;
		type.t = t;
		mk_pointer(&type);
		type.t |= VT_ARRAY;
		memset(&ad, 0, sizeof(AttributeDef));
		decl_initializer_alloc(&type, &ad, VT_CONST, 2, 0, 0);
		break;
	case '(':
		next();
		/* cast ? */
		if (parse_btype(&type, &ad))
		{
			type_decl(&type, &ad, &n, TYPE_ABSTRACT);
			skip(')');
			/* check ISOC99 compound literal */
			if (tok == '{')
			{
				/* data is allocated locally by default */
				if (global_expr)
					r = VT_CONST;
				else
					r = VT_LOCAL;
				/* all except arrays are lvalues */
				if (!(type.t & VT_ARRAY))
					r |= VT_LVAL;
				memset(&ad, 0, sizeof(AttributeDef));
				decl_initializer_alloc(&type, &ad, r, 1, 0, 0);
			}
			else
			{
				if (sizeof_caller)
				{
					vpush(&type);
					return;
				}
				unary();
				gen_cast(&type);
			}
		}
		else if (tok == '{')
		{
			int saved_nocode_wanted = nocode_wanted;
			if (const_wanted && !(nocode_wanted & unevalmask))
				tcc_error("expected constant");
			/* save all registers */
			save_regs(0);
			/* statement expression : we do not accept break/continue
			   inside as GCC does.  We do retain the nocode_wanted state,
			as statement expressions can't ever be entered from the
			outside, so any reactivation of code emission (from labels
			or loop heads) can be disabled again after the end of it. */
			block(1);
			nocode_wanted = saved_nocode_wanted;
			skip(')');
		}
		else
		{
			gexpr();
			skip(')');
		}
		break;
	case '*':
		next();
		unary();
		indir();
		break;
	case '&':
		next();
		unary();
		/* functions names must be treated as function pointers,
		   except for unary '&' and sizeof. Since we consider that
		   functions are not lvalues, we only have to handle it
		   there and in function calls. */
		/* arrays can also be used although they are not lvalues */
		if ((vtop->type.t & VT_BTYPE) != VT_FUNC &&
		        !(vtop->type.t & VT_ARRAY))
			test_lvalue();
		if (vtop->sym)
			vtop->sym->a.addrtaken = 1;
		mk_pointer(&vtop->type);
		gaddrof();
		break;
	case '!':
		next();
		unary();
		gen_test_zero(TOK_EQ);
		break;
	case '~':
		next();
		unary();
		vpushi(-1);
		gen_op('^');
		break;
	case '+':
		next();
		unary();
		if ((vtop->type.t & VT_BTYPE) == VT_PTR)
			tcc_error("pointer not accepted for unary plus");
		/* In order to force cast, we add zero, except for floating point
		where we really need an noop (otherwise -0.0 will be transformed
		into +0.0).  */
		if (!is_float(vtop->type.t))
		{
			vpushi(0);
			gen_op('+');
		}
		break;
	case TOK_SIZEOF:
	case TOK_ALIGNOF1:
	case TOK_ALIGNOF2:
	case TOK_ALIGNOF3:
		t = tok;
		next();
		in_sizeof++;
		expr_type(&type, unary); /* Perform a in_sizeof = 0; */
		s = NULL;
		if (vtop[1].r & VT_SYM)
			s = vtop[1].sym; /* hack: accessing previous vtop */
		size = type_size(&type, &align);
		if (s && s->a.aligned)
			align = 1 << (s->a.aligned - 1);
		if (t == TOK_SIZEOF)
		{
			if (!(type.t & VT_VLA))
			{
				if (size < 0)
					tcc_error("sizeof applied to an incomplete type");
				vpushs(size);
			}
			else
			{
				vla_runtime_type_size(&type, &align);
			}
		}
		else
		{
			vpushs(align);
		}
		vtop->type.t |= VT_UNSIGNED;
		break;

	case TOK_builtin_expect:
		/* __builtin_expect is a no-op for now */
		parse_builtin_params(0, "ee");
		vpop();
		break;
	case TOK_builtin_types_compatible_p:
		parse_builtin_params(0, "tt");
		vtop[-1].type.t &= ~(VT_CONSTANT | VT_VOLATILE);
		vtop[0].type.t &= ~(VT_CONSTANT | VT_VOLATILE);
		n = is_compatible_types(&vtop[-1].type, &vtop[0].type);
		vtop -= 2;
		vpushi(n);
		break;
	case TOK_builtin_choose_expr:
	{
		int64_t c;
		next();
		skip('(');
		c = expr_const64();
		skip(',');
		if (!c)
		{
			nocode_wanted++;
		}
		expr_eq();
		if (!c)
		{
			vpop();
			nocode_wanted--;
		}
		skip(',');
		if (c)
		{
			nocode_wanted++;
		}
		expr_eq();
		if (c)
		{
			vpop();
			nocode_wanted--;
		}
		skip(')');
	}
	break;
	case TOK_builtin_constant_p:
		parse_builtin_params(1, "e");
		n = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
		vtop--;
		vpushi(n);
		break;
	case TOK_builtin_frame_address:
	case TOK_builtin_return_address:
	{
		int tok1 = tok;
		int level;
		next();
		skip('(');
		if (tok != TOK_CINT)
		{
			tcc_error("%s only takes positive integers",
			          tok1 == TOK_builtin_return_address ?
			          "__builtin_return_address" :
			          "__builtin_frame_address");
		}
		level = (uint32_t)tokc.i;
		next();
		skip(')');
		type.t = VT_VOID;
		mk_pointer(&type);
		vset(&type, VT_LOCAL, 0);       /* local frame */
		while (level--)
		{
			mk_pointer(&vtop->type);
			indir();                    /* -> parent frame */
		}
		if (tok1 == TOK_builtin_return_address)
		{
			// assume return address is just above frame pointer on stack
			vpushi(PTR_SIZE);
			gen_op('+');
			mk_pointer(&vtop->type);
			indir();
		}
	}
	break;
#ifdef TCC_TARGET_RISCV64
	case TOK_builtin_va_start:
		parse_builtin_params(0, "ee");
		r = vtop->r & VT_VALMASK;
		if (r == VT_LLOCAL)
			r = VT_LOCAL;
		if (r != VT_LOCAL)
			tcc_error("__builtin_va_start expects a local variable");
		gen_va_start();
		vstore();
		break;
#endif
#ifdef TCC_TARGET_X86_64
#ifdef TCC_TARGET_PE
	case TOK_builtin_va_start:
		parse_builtin_params(0, "ee");
		r = vtop->r & VT_VALMASK;
		if (r == VT_LLOCAL)
			r = VT_LOCAL;
		if (r != VT_LOCAL)
			tcc_error("__builtin_va_start expects a local variable");
		vtop->r = r;
		vtop->type = char_pointer_type;
		vtop->c.i += 8;
		vstore();
		break;
#else
	case TOK_builtin_va_arg_types:
		parse_builtin_params(0, "t");
		vpushi(classify_x86_64_va_arg(&vtop->type));
		vswap();
		vpop();
		break;
#endif
#endif

#ifdef TCC_TARGET_ARM64
	case TOK___va_start:
	{
		parse_builtin_params(0, "ee");
		//xx check types
		gen_va_start();
		vpushi(0);
		vtop->type.t = VT_VOID;
		break;
	}
	case TOK___va_arg:
	{
		parse_builtin_params(0, "et");
		type = vtop->type;
		vpop();
		//xx check types
		gen_va_arg(&type);
		vtop->type = type;
		break;
	}
	case TOK___arm64_clear_cache:
	{
		parse_builtin_params(0, "ee");
		gen_clear_cache();
		vpushi(0);
		vtop->type.t = VT_VOID;
		break;
	}
#endif
	/* pre operations */
	case TOK_INC:
	case TOK_DEC:
		t = tok;
		next();
		unary();
		inc(0, t);
		break;
	case '-':
		next();
		unary();
		t = vtop->type.t & VT_BTYPE;
		if (is_float(t))
		{
			/* In IEEE negate(x) isn't subtract(0,x), but rather
			subtract(-0, x).  */
			vpush(&vtop->type);
			if (t == VT_FLOAT)
				vtop->c.f = -1.0 * 0.0;
			else if (t == VT_DOUBLE)
				vtop->c.d = -1.0 * 0.0;
			else
				vtop->c.ld = -1.0 * 0.0;
		}
		else
			vpushi(0);
		vswap();
		gen_op('-');
		break;
	case TOK_LAND:
		if (!gnu_ext)
			goto tok_identifier;
		next();
		/* allow to take the address of a label */
		if (tok < TOK_UIDENT)
			expect("label identifier");
		s = label_find(tok);
		if (!s)
		{
			s = label_push(&global_label_stack, tok, LABEL_FORWARD);
		}
		else
		{
			if (s->r == LABEL_DECLARED)
				s->r = LABEL_FORWARD;
		}
		if (!s->type.t)
		{
			s->type.t = VT_VOID;
			mk_pointer(&s->type);
			s->type.t |= VT_STATIC;
		}
		vpushsym(&s->type, s);
		next();
		break;

	case TOK_GENERIC:
	{
		CType controlling_type;
		int has_default = 0;
		int has_match = 0;
		int learn = 0;
		TokenString *str = NULL;
		int saved_const_wanted = const_wanted;

		next();
		skip('(');
		const_wanted = 0;
		expr_type(&controlling_type, expr_eq);
		controlling_type.t &= ~(VT_CONSTANT | VT_VOLATILE | VT_ARRAY);
		if ((controlling_type.t & VT_BTYPE) == VT_FUNC)
			mk_pointer(&controlling_type);
		const_wanted = saved_const_wanted;
		for (;;)
		{
			learn = 0;
			skip(',');
			if (tok == TOK_DEFAULT)
			{
				if (has_default)
					tcc_error("too many 'default'");
				has_default = 1;
				if (!has_match)
					learn = 1;
				next();
			}
			else
			{
				AttributeDef ad_tmp;
				int itmp;
				CType cur_type;

				in_generic++;
				parse_btype(&cur_type, &ad_tmp);
				in_generic--;

				type_decl(&cur_type, &ad_tmp, &itmp, TYPE_ABSTRACT);
				if (compare_types(&controlling_type, &cur_type, 0))
				{
					if (has_match)
					{
						tcc_error("type match twice");
					}
					has_match = 1;
					learn = 1;
				}
			}
			skip(':');
			if (learn)
			{
				if (str)
					tok_str_free(str);
				skip_or_save_block(&str);
			}
			else
			{
				skip_or_save_block(NULL);
			}
			if (tok == ')')
				break;
		}
		if (!str)
		{
			char buf[60];
			type_to_str(buf, sizeof buf, &controlling_type, NULL);
			tcc_error("type '%s' does not match any association", buf);
		}
		begin_macro(str, 1);
		next();
		expr_eq();
		if (tok != TOK_EOF)
			expect(",");
		end_macro();
		next();
		break;
	}
	// special qnan , snan and infinity values
	case TOK___NAN__:
		n = 0x7fc00000;
special_math_val:
		vpushi(n);
		vtop->type.t = VT_FLOAT;
		next();
		break;
	case TOK___SNAN__:
		n = 0x7f800001;
		goto special_math_val;
	case TOK___INF__:
		n = 0x7f800000;
		goto special_math_val;

	default:
tok_identifier:
		t = tok;
		next();
		if (t < TOK_UIDENT)
			expect("identifier");
		s = sym_find(t);
		if (!s || IS_ASM_SYM(s))
		{
			const char *name = get_tok_str(t, NULL);
			if (tok != '(')
				tcc_error("'%s' undeclared", name);
			/* for simple function calls, we tolerate undeclared
			   external reference to int() function */
			if (tcc_state->warn_implicit_function_declaration
#ifdef TCC_TARGET_PE
			        /* people must be warned about using undeclared WINAPI functions
			           (which usually start with uppercase letter) */
			        || (name[0] >= 'A' && name[0] <= 'Z')
#endif
			   )
				tcc_warning("implicit declaration of function '%s'", name);
			s = external_global_sym(t, &func_old_type);
		}

		r = s->r;
		/* A symbol that has a register is a local register variable,
		   which starts out as VT_LOCAL value.  */
		if ((r & VT_VALMASK) < VT_CONST)
			r = (r & ~VT_VALMASK) | VT_LOCAL;

		vset(&s->type, r, s->c);
		/* Point to s as backpointer (even without r&VT_SYM).
		Will be used by at least the x86 inline asm parser for
		regvars.  */
		vtop->sym = s;

		if (r & VT_SYM)
		{
			vtop->c.i = 0;
		}
		else if (r == VT_CONST && IS_ENUM_VAL(s->type.t))
		{
			vtop->c.i = s->enum_val;
		}
		break;
	}

	/* post operations */
	while (1)
	{
		if (tok == TOK_INC || tok == TOK_DEC)
		{
			inc(1, tok);
			next();
		}
		else if (tok == '.' || tok == TOK_ARROW || tok == TOK_CDOUBLE)
		{
			int qualifiers, cumofs = 0;
			/* field */
			if (tok == TOK_ARROW)
				indir();
			qualifiers = vtop->type.t & (VT_CONSTANT | VT_VOLATILE);
			test_lvalue();
			gaddrof();
			/* expect pointer on structure */
			if ((vtop->type.t & VT_BTYPE) != VT_STRUCT)
			{
				char got[256];
				type_to_str(got, sizeof got, &vtop->type, NULL);
				tcc_error("expected struct or union but not '%s'", got);
			}
			if (tok == TOK_CDOUBLE)
				expect("field name");
			next();
			if (tok == TOK_CINT || tok == TOK_CUINT)
				expect("field name");
			s = find_field(&vtop->type, tok, &cumofs);
			if (!s)
				tcc_error("field not found: %s",  get_tok_str(tok & ~SYM_FIELD, &tokc));
			/* add field offset to pointer */
			vtop->type = char_pointer_type; /* change type to 'char *' */
			vpushi(cumofs + s->c);
			gen_op('+');
			/* change type to field type, and set to lvalue */
			vtop->type = s->type;
			vtop->type.t |= qualifiers;
			/* an array is never an lvalue */
			if (!(vtop->type.t & VT_ARRAY))
			{
				vtop->r |= VT_LVAL;
#ifdef CONFIG_TCC_BCHECK
				/* if bound checking, the referenced pointer must be checked */
				if (tcc_state->do_bounds_check)
					vtop->r |= VT_MUSTBOUND;
#endif
			}
			next();
		}
		else if (tok == '[')
		{
			next();
			gexpr();
			gen_op('+');
			indir();
			skip(']');
		}
		else if (tok == '(')
		{
			SValue ret;
			Sym *sa;
			int nb_args, ret_nregs, ret_align, regsize, variadic;

			/* function call  */
			if ((vtop->type.t & VT_BTYPE) != VT_FUNC)
			{
				/* pointer test (no array accepted) */
				if ((vtop->type.t & (VT_BTYPE | VT_ARRAY)) == VT_PTR)
				{
					vtop->type = *pointed_type(&vtop->type);
					if ((vtop->type.t & VT_BTYPE) != VT_FUNC)
						goto error_func;
				}
				else
				{
error_func:
					expect("function pointer");
				}
			}
			else
			{
				vtop->r &= ~VT_LVAL; /* no lvalue */
			}
			/* get return type */
			s = vtop->type.ref;
			next();
			sa = s->next; /* first parameter */
			nb_args = regsize = 0;
			ret.r2 = VT_CONST;
			/* compute first implicit argument if a structure is returned */
			if ((s->type.t & VT_BTYPE) == VT_STRUCT)
			{
				variadic = (s->f.func_type == FUNC_ELLIPSIS);
				ret_nregs = gfunc_sret(&s->type, variadic, &ret.type,
				                       &ret_align, &regsize);
				if (ret_nregs <= 0)
				{
					/* get some space for the returned structure */
					size = type_size(&s->type, &align);
#ifdef TCC_TARGET_ARM64
					/* On arm64, a small struct is return in registers.
					   It is much easier to write it to memory if we know
					   that we are allowed to write some extra bytes, so
					   round the allocated space up to a power of 2: */
					if (size < 16)
						while (size & (size - 1))
							size = (size | (size - 1)) + 1;
#endif
					loc = (loc - size) & -align;
					ret.type = s->type;
					ret.r = VT_LOCAL | VT_LVAL;
					/* pass it as 'int' to avoid structure arg passing
					   problems */
					vseti(VT_LOCAL, loc);
					ret.c = vtop->c;
					if (ret_nregs < 0)
						vtop--;
					else
						nb_args++;
				}
			}
			else
			{
				ret_nregs = 1;
				ret.type = s->type;
			}

			if (ret_nregs > 0)
			{
				/* return in register */
				ret.c.i = 0;
				PUT_R_RET(&ret, ret.type.t);
			}
			if (tok != ')')
			{
				for(;;)
				{
					expr_eq();
					gfunc_param_typed(s, sa);
					nb_args++;
					if (sa)
						sa = sa->next;
					if (tok == ')')
						break;
					skip(',');
				}
			}
			if (sa)
				tcc_error("too few arguments to function");
			skip(')');
			gfunc_call(nb_args);

			if (ret_nregs < 0)
			{
				vsetc(&ret.type, ret.r, &ret.c);
#ifdef TCC_TARGET_RISCV64
				arch_transfer_ret_regs(1);
#endif
			}
			else
			{
				/* return value */
				for (r = ret.r + ret_nregs + !ret_nregs; r-- > ret.r;)
				{
					vsetc(&ret.type, r, &ret.c);
					vtop->r2 = ret.r2; /* Loop only happens when r2 is VT_CONST */
				}

				/* handle packed struct return */
				if (((s->type.t & VT_BTYPE) == VT_STRUCT) && ret_nregs)
				{
					int addr, offset;

					size = type_size(&s->type, &align);
					/* We're writing whole regs often, make sure there's enough
					   space.  Assume register size is power of 2.  */
					if (regsize > align)
						align = regsize;
					loc = (loc - size) & -align;
					addr = loc;
					offset = 0;
					for (;;)
					{
						vset(&ret.type, VT_LOCAL | VT_LVAL, addr + offset);
						vswap();
						vstore();
						vtop--;
						if (--ret_nregs == 0)
							break;
						offset += regsize;
					}
					vset(&s->type, VT_LOCAL | VT_LVAL, addr);
				}

				/* Promote char/short return values. This is matters only
				   for calling function that were not compiled by TCC and
				   only on some architectures.  For those where it doesn't
				   matter we expect things to be already promoted to int,
				   but not larger.  */
				t = s->type.t & VT_BTYPE;
				if (t == VT_BYTE || t == VT_SHORT || t == VT_BOOL)
				{
#ifdef PROMOTE_RET
					vtop->r |= BFVAL(VT_MUSTCAST, 1);
#else
					vtop->type.t = VT_INT;
#endif
				}
			}
			if (s->f.func_noreturn)
				CODE_OFF();
		}
		else
		{
			break;
		}
	}
}

#ifndef precedence_parser /* original top-down parser */

static void expr_prod(void)
{
	int t;

	unary();
	while ((t = tok) == '*' || t == '/' || t == '%')
	{
		next();
		unary();
		gen_op(t);
	}
}

static void expr_sum(void)
{
	int t;

	expr_prod();
	while ((t = tok) == '+' || t == '-')
	{
		next();
		expr_prod();
		gen_op(t);
	}
}

static void expr_shift(void)
{
	int t;

	expr_sum();
	while ((t = tok) == TOK_SHL || t == TOK_SAR)
	{
		next();
		expr_sum();
		gen_op(t);
	}
}

static void expr_cmp(void)
{
	int t;

	expr_shift();
	while (((t = tok) >= TOK_ULE && t <= TOK_GT) ||
	        t == TOK_ULT || t == TOK_UGE)
	{
		next();
		expr_shift();
		gen_op(t);
	}
}

static void expr_cmpeq(void)
{
	int t;

	expr_cmp();
	while ((t = tok) == TOK_EQ || t == TOK_NE)
	{
		next();
		expr_cmp();
		gen_op(t);
	}
}

static void expr_and(void)
{
	expr_cmpeq();
	while (tok == '&')
	{
		next();
		expr_cmpeq();
		gen_op('&');
	}
}

static void expr_xor(void)
{
	expr_and();
	while (tok == '^')
	{
		next();
		expr_and();
		gen_op('^');
	}
}

static void expr_or(void)
{
	expr_xor();
	while (tok == '|')
	{
		next();
		expr_xor();
		gen_op('|');
	}
}

static void expr_landor(int op);

static void expr_land(void)
{
	expr_or();
	if (tok == TOK_LAND)
		expr_landor(tok);
}

static void expr_lor(void)
{
	expr_land();
	if (tok == TOK_LOR)
		expr_landor(tok);
}

# define expr_landor_next(op) op == TOK_LAND ? expr_or() : expr_land()
#else /* defined precedence_parser */
# define expr_landor_next(op) unary(), expr_infix(precedence(op) + 1)
# define expr_lor() unary(), expr_infix(1)

static int precedence(int tok)
{
	switch (tok)
	{
	case TOK_LOR:
		return 1;
	case TOK_LAND:
		return 2;
	case '|':
		return 3;
	case '^':
		return 4;
	case '&':
		return 5;
	case TOK_EQ:
	case TOK_NE:
		return 6;
relat:
	case TOK_ULT:
	case TOK_UGE:
		return 7;
	case TOK_SHL:
	case TOK_SAR:
		return 8;
	case '+':
	case '-':
		return 9;
	case '*':
	case '/':
	case '%':
		return 10;
	default:
		if (tok >= TOK_ULE && tok <= TOK_GT)
			goto relat;
		return 0;
	}
}
static unsigned char prec[256];
static void init_prec(void)
{
	int i;
	for (i = 0; i < 256; i++)
		prec[i] = precedence(i);
}
#define precedence(i) ((unsigned)i < 256 ? prec[i] : 0)

static void expr_landor(int op);

static void expr_infix(int p)
{
	int t = tok, p2;
	while ((p2 = precedence(t)) >= p)
	{
		if (t == TOK_LOR || t == TOK_LAND)
		{
			expr_landor(t);
		}
		else
		{
			next();
			unary();
			if (precedence(tok) > p2)
				expr_infix(p2 + 1);
			gen_op(t);
		}
		t = tok;
	}
}
#endif

/* Assuming vtop is a value used in a conditional context
   (i.e. compared with zero) return 0 if it's false, 1 if
   true and -1 if it can't be statically determined.  */
static int condition_3way(void)
{
	int c = -1;
	if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&
	        (!(vtop->r & VT_SYM) || !vtop->sym->a.weak))
	{
		vdup();
		gen_cast_s(VT_BOOL);
		c = vtop->c.i;
		vpop();
	}
	return c;
}

static void expr_landor(int op)
{
	int t = 0, cc = 1, f = 0, i = op == TOK_LAND, c;
	for(;;)
	{
		c = f ? i : condition_3way();
		if (c < 0)
			save_regs(1), cc = 0;
		else if (c != i)
			nocode_wanted++, f = 1;
		if (tok != op)
			break;
		if (c < 0)
			t = gvtst(i, t);
		else
			vpop();
		next();
		expr_landor_next(op);
	}
	if (cc || f)
	{
		vpop();
		vpushi(i ^ f);
		gsym(t);
		nocode_wanted -= f;
	}
	else
	{
		gvtst_set(i, t);
	}
}

static int is_cond_bool(SValue *sv)
{
	if ((sv->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST
	        && (sv->type.t & VT_BTYPE) == VT_INT)
		return (unsigned)sv->c.i < 2;
	if (sv->r == VT_CMP)
		return 1;
	return 0;
}

static void expr_cond(void)
{
	int tt, u, r1, r2, rc, t1, t2, bt1, bt2, islv, c, g;
	SValue sv;
	CType type, type1, type2;
	int ncw_prev;

	expr_lor();
	if (tok == '?')
	{
		next();
		c = condition_3way();
		ncw_prev = nocode_wanted;
		g = (tok == ':' && gnu_ext);
		tt = 0;
		if (!g)
		{
			if (c < 0)
			{
				save_regs(1);
				tt = gvtst(1, 0);
			}
			else
			{
				vpop();
			}
		}
		else if (c < 0)
		{
			/* needed to avoid having different registers saved in
			   each branch */
			save_regs(1);
			gv_dup();
			tt = gvtst(0, 0);
		}

		if (1)
		{
			if (c == 0)
				nocode_wanted++;
			if (!g)
				gexpr();

			if (c < 0 && vtop->r == VT_CMP)
			{
				t1 = gvtst(0, 0);
				vpushi(0);
				gvtst_set(0, t1);
			}

			if ((vtop->type.t & VT_BTYPE) == VT_FUNC)
				mk_pointer(&vtop->type);
			type1 = vtop->type;
			sv = *vtop; /* save value to handle it later */
			vtop--; /* no vpop so that FP stack is not flushed */

			if (g)
			{
				u = tt;
			}
			else if (c < 0)
			{
				u = gjmp(0);
				gsym(tt);
			}
			else
				u = 0;

			nocode_wanted = ncw_prev;
			if (c == 1)
				nocode_wanted++;
			skip(':');
			expr_cond();

			if (c < 0 && is_cond_bool(vtop) && is_cond_bool(&sv))
			{
				if (sv.r == VT_CMP)
				{
					t1 = sv.jtrue;
					t2 = u;
				}
				else
				{
					t1 = gvtst(0, 0);
					t2 = gjmp(0);
					gsym(u);
					vpushv(&sv);
				}
				gvtst_set(0, t1);
				gvtst_set(1, t2);
				nocode_wanted = ncw_prev;
				//  tcc_warning("two conditions expr_cond");
				return;
			}

			if ((vtop->type.t & VT_BTYPE) == VT_FUNC)
				mk_pointer(&vtop->type);
			type2=vtop->type;
			t1 = type1.t;
			bt1 = t1 & VT_BTYPE;
			t2 = type2.t;
			bt2 = t2 & VT_BTYPE;
			type.ref = NULL;

			/* cast operands to correct type according to ISOC rules */
			if (bt1 == VT_VOID || bt2 == VT_VOID)
			{
				type.t = VT_VOID; /* NOTE: as an extension, we accept void on only one side */
			}
			else if (bt1 == VT_BOOL && bt2 == VT_BOOL)
			{
				type = type1;
			}
			else if (is_float(bt1) && is_integer_btype(bt2))
			{
				type = type1;
			}
			else if (is_integer_btype(bt1) && is_float(bt2))
			{
				type = type2;
			}
			else if (is_float(bt1) && is_float(bt2))
			{
				if (bt1 == VT_LDOUBLE || bt2 == VT_LDOUBLE)
				{
					type.t = VT_LDOUBLE;

				}
				else if (bt1 == VT_DOUBLE || bt2 == VT_DOUBLE)
				{
					type.t = VT_DOUBLE;
				}
				else
				{
					type.t = VT_FLOAT;
				}
			}
			else if ((bt1 == VT_LLONG && is_integer_btype(bt2)) ||
			         (bt2 == VT_LLONG && is_integer_btype(bt1)))
			{
				/* cast to biggest op */
				type.t = VT_LLONG | VT_LONG;
				if (bt1 == VT_LLONG)
					type.t &= t1;
				if (bt2 == VT_LLONG)
					type.t &= t2;
				/* convert to unsigned if it does not fit in a long long */
				if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED) ||
				        (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_LLONG | VT_UNSIGNED))
					type.t |= VT_UNSIGNED;
			}
			/* http://port70.net/~nsz/c/c99/n1256.html#6.5.15p6 */
			/* If one is a null ptr constant the result type
			    is the other.  */
			else if (bt1 == VT_PTR && is_null_pointer(vtop))
			{
				type = type1;
			}
			else if (is_null_pointer(&sv) && bt2 == VT_PTR)
			{
				type = type2;
			}
			else if (bt1 == VT_PTR && is_integer_btype(bt2))
			{
				type = type1;
				tcc_warning("pointer/integer mismatch");
			}
			else if (is_integer_btype(bt1) && bt2 == VT_PTR)
			{
				type = type2;
				tcc_warning("pointer/integer mismatch");
			}
			else if (bt1==VT_PTR && bt2 == VT_PTR)
			{
				CType *pt1 = pointed_type(&type1);
				CType *pt2 = pointed_type(&type2);
				int pbt1 = pt1->t & VT_BTYPE;
				int pbt2 = pt2->t & VT_BTYPE;
				int newquals, copied = 0;
				/* pointers to void get preferred, otherwise the
				   pointed to types minus qualifs should be compatible */
				type = (pbt1 == VT_VOID) ? type1 : type2;
				if (pbt1 != VT_VOID && pbt2 != VT_VOID && ! compare_types(pt1, pt2, 1/*unqualif*/))
				{
					type_incompatibility_warning(&type1, &type2, "incompatible pointer types");
					// result is void*
					type.t = VT_VOID;
					mk_pointer(&type);
				}
				/* combine qualifs */
				newquals = ((pt1->t | pt2->t) & (VT_CONSTANT | VT_VOLATILE));
				if ((~pointed_type(&type)->t & (VT_CONSTANT | VT_VOLATILE))
				        & newquals)
				{
					/* copy the pointer target symbol */
					type.ref = sym_push(SYM_FIELD, &type.ref->type,
					                    0, type.ref->c);
					copied = 1;
					pointed_type(&type)->t |= newquals;
				}
				/* pointers to incomplete arrays get converted to
				pointers to completed ones if possible */
				if (pt1->t & VT_ARRAY
				        && pt2->t & VT_ARRAY
				        && pointed_type(&type)->ref->c < 0
				        && (pt1->ref->c > 0 || pt2->ref->c > 0))
				{
					if (!copied)
						type.ref = sym_push(SYM_FIELD, &type.ref->type,
						                    0, type.ref->c);
					pointed_type(&type)->ref =
					    sym_push(SYM_FIELD, &pointed_type(&type)->ref->type,
					             0, pointed_type(&type)->ref->c);
					pointed_type(&type)->ref->c =
					    0 < pt1->ref->c ? pt1->ref->c : pt2->ref->c;
				}
			}
			else if (bt1 == VT_STRUCT && bt2 == VT_STRUCT)
			{
				/* test structure compatibility */
				if (type1.ref != type2.ref)
				{
					type_incompatibility_error(&type1, &type2,"different struct/union types '%s' vs. '%s'");
				}
				else
				{
					type = bt1 == VT_STRUCT ? type1 : type2;
				}
			}
			else if (is_integer_btype(bt1) && is_integer_btype(bt2))
			{
				/* integer operations */
				type.t = VT_INT | (VT_LONG & (t1 | t2));
				/* convert to unsigned if one of both is unsigned */
				if ((t1 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED) ||
				        (t2 & (VT_BTYPE | VT_UNSIGNED | VT_BITFIELD)) == (VT_INT | VT_UNSIGNED))
					type.t |= VT_UNSIGNED;
			}
			else
			{
				type_incompatibility_error(&type1, &type2, "type '%s' is incompatible to '%s'");
			}

			/* keep structs lvalue by transforming `(expr ? a : b)` to `*(expr ? &a : &b)` so
			   that `(expr ? a : b).mem` does not error  with "lvalue expected" */
			islv = (vtop->r & VT_LVAL) && (sv.r & VT_LVAL) && VT_STRUCT == (type.t & VT_BTYPE);

			/* now we convert second operand */
			if (c != 1)
			{
				gen_cast(&type);
				if (islv)
				{
					mk_pointer(&vtop->type);
					gaddrof();
				}
				else if (VT_STRUCT == (vtop->type.t & VT_BTYPE))
					gaddrof();
			}

			rc = RC_TYPE(type.t);
			/* for long longs, we use fixed registers to avoid having
			   to handle a complicated move */
			if (USING_TWO_WORDS(type.t))
				rc = RC_RET(type.t);

			tt = r2 = 0;
			if (c < 0)
			{
				r2 = gv(rc);
				tt = gjmp(0);
			}
			gsym(u);
			nocode_wanted = ncw_prev;

			/* this is horrible, but we must also convert first
			   operand */
			if (c != 0)
			{
				*vtop = sv;
				gen_cast(&type);
				if (islv)
				{
					mk_pointer(&vtop->type);
					gaddrof();
				}
				else if (VT_STRUCT == (vtop->type.t & VT_BTYPE))
					gaddrof();
			}

			if (c < 0)
			{
				r1 = gv(rc);
				move_reg(r2, r1, islv ? VT_PTR : type.t);
				vtop->r = r2;
				gsym(tt);
			}

			if (islv)
				indir();
		}
	}
}

static void expr_eq(void)
{
	int t;

	expr_cond();
	if ((t = tok) == '='
	        || (t >= TOK_A_MOD && t <= TOK_A_DIV)
	        || t == TOK_A_XOR || t == TOK_A_OR
	        || t == TOK_A_SHL || t == TOK_A_SAR)
	{
		test_lvalue();
		next();
		if (t == '=')
		{
			expr_eq();
		}
		else
		{
			vdup();
			expr_eq();
			gen_op(t & 0x7f);
		}
		vstore();
	}
}

ST_FUNC void gexpr(void)
{
	while (1)
	{
		expr_eq();
		if (tok != ',')
			break;
		vpop();
		next();
	}
}

/* parse a constant expression and return value in vtop.  */
static void expr_const1(void)
{
	const_wanted++;
	nocode_wanted += unevalmask + 1;
	expr_cond();
	nocode_wanted -= unevalmask + 1;
	const_wanted--;
}

/* parse an integer constant and return its value. */
static inline int64_t expr_const64(void)
{
	int64_t c;
	expr_const1();
	if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
		expect("constant expression");
	c = vtop->c.i;
	vpop();
	return c;
}

/* parse an integer constant and return its value.
   Complain if it doesn't fit 32bit (signed or unsigned).  */
ST_FUNC int expr_const(void)
{
	int c;
	int64_t wc = expr_const64();
	c = wc;
	if (c != wc && (unsigned)c != wc)
		tcc_error("constant exceeds 32 bit");
	return c;
}

/* ------------------------------------------------------------------------- */
/* return from function */

#ifndef TCC_TARGET_ARM64
static void gfunc_return(CType *func_type)
{
	if ((func_type->t & VT_BTYPE) == VT_STRUCT)
	{
		CType type, ret_type;
		int ret_align, ret_nregs, regsize;
		ret_nregs = gfunc_sret(func_type, func_var, &ret_type,
		                       &ret_align, &regsize);
		if (ret_nregs < 0)
		{
#ifdef TCC_TARGET_RISCV64
			arch_transfer_ret_regs(0);
#endif
		}
		else if (0 == ret_nregs)
		{
			/* if returning structure, must copy it to implicit
			   first pointer arg location */
			type = *func_type;
			mk_pointer(&type);
			vset(&type, VT_LOCAL | VT_LVAL, func_vc);
			indir();
			vswap();
			/* copy structure value to pointer */
			vstore();
		}
		else
		{
			/* returning structure packed into registers */
			int size, addr, align, rc;
			size = type_size(func_type,&align);
			if ((vtop->r != (VT_LOCAL | VT_LVAL) ||
			        (vtop->c.i & (ret_align-1)))
			        && (align & (ret_align-1)))
			{
				loc = (loc - size) & -ret_align;
				addr = loc;
				type = *func_type;
				vset(&type, VT_LOCAL | VT_LVAL, addr);
				vswap();
				vstore();
				vpop();
				vset(&ret_type, VT_LOCAL | VT_LVAL, addr);
			}
			vtop->type = ret_type;
			rc = RC_RET(ret_type.t);
			if (ret_nregs == 1)
				gv(rc);
			else
			{
				for (;;)
				{
					vdup();
					gv(rc);
					vpop();
					if (--ret_nregs == 0)
						break;
					/* We assume that when a structure is returned in multiple
					   registers, their classes are consecutive values of the
					   suite s(n) = 2^n */
					rc <<= 1;
					vtop->c.i += regsize;
				}
			}
		}
	}
	else
	{
		gv(RC_RET(func_type->t));
	}
	vtop--; /* NOT vpop() because on x86 it would flush the fp stack */
}
#endif

static void check_func_return(void)
{
	if ((func_vt.t & VT_BTYPE) == VT_VOID)
		return;
	if (!strcmp (funcname, "main")
	        && (func_vt.t & VT_BTYPE) == VT_INT)
	{
		/* main returns 0 by default */
		vpushi(0);
		gen_assign_cast(&func_vt);
		gfunc_return(&func_vt);
	}
	else
	{
		tcc_warning("function might return no value: '%s'", funcname);
	}
}

/* ------------------------------------------------------------------------- */
/* switch/case */

static int case_cmp(const void *pa, const void *pb)
{
	int64_t a = (*(struct case_t**) pa)->v1;
	int64_t b = (*(struct case_t**) pb)->v1;
	return a < b ? -1 : a > b;
}

static void gtst_addr(int t, int a)
{
	gsym_addr(gvtst(0, t), a);
}

static void gcase(struct case_t **base, int len, int *bsym)
{
	struct case_t *p;
	int e;
	int ll = (vtop->type.t & VT_BTYPE) == VT_LLONG;
	while (len > 8)
	{
		/* binary search */
		p = base[len/2];
		vdup();
		if (ll)
			vpushll(p->v2);
		else
			vpushi(p->v2);
		gen_op(TOK_LE);
		e = gvtst(1, 0);
		vdup();
		if (ll)
			vpushll(p->v1);
		else
			vpushi(p->v1);
		gen_op(TOK_GE);
		gtst_addr(0, p->sym); /* v1 <= x <= v2 */
		/* x < v1 */
		gcase(base, len/2, bsym);
		/* x > v2 */
		gsym(e);
		e = len/2 + 1;
		base += e;
		len -= e;
	}
	/* linear scan */
	while (len--)
	{
		p = *base++;
		vdup();
		if (ll)
			vpushll(p->v2);
		else
			vpushi(p->v2);
		if (p->v1 == p->v2)
		{
			gen_op(TOK_EQ);
			gtst_addr(0, p->sym);
		}
		else
		{
			gen_op(TOK_LE);
			e = gvtst(1, 0);
			vdup();
			if (ll)
				vpushll(p->v1);
			else
				vpushi(p->v1);
			gen_op(TOK_GE);
			gtst_addr(0, p->sym);
			gsym(e);
		}
	}
	*bsym = gjmp(*bsym);
}

/* ------------------------------------------------------------------------- */
/* __attribute__((cleanup(fn))) */

static void try_call_scope_cleanup(Sym *stop)
{
	Sym *cls = cur_scope->cl.s;

	for (; cls != stop; cls = cls->ncl)
	{
		Sym *fs = cls->next;
		Sym *vs = cls->prev_tok;

		vpushsym(&fs->type, fs);
		vset(&vs->type, vs->r, vs->c);
		vtop->sym = vs;
		mk_pointer(&vtop->type);
		gaddrof();
		gfunc_call(1);
	}
}

static void try_call_cleanup_goto(Sym *cleanupstate)
{
	Sym *oc, *cc;
	int ocd, ccd;

	if (!cur_scope->cl.s)
		return;

	/* search NCA of both cleanup chains given parents and initial depth */
	ocd = cleanupstate ? cleanupstate->v & ~SYM_FIELD : 0;
	for (ccd = cur_scope->cl.n, oc = cleanupstate; ocd > ccd; --ocd, oc = oc->ncl)
		;
	for (cc = cur_scope->cl.s; ccd > ocd; --ccd, cc = cc->ncl)
		;
	for (; cc != oc; cc = cc->ncl, oc = oc->ncl, --ccd)
		;

	try_call_scope_cleanup(cc);
}

/* call 'func' for each __attribute__((cleanup(func))) */
static void block_cleanup(struct scope *o)
{
	int jmp = 0;
	Sym *g, **pg;
	for (pg = &pending_gotos; (g = *pg) && g->c > o->cl.n;)
	{
		if (g->prev_tok->r & LABEL_FORWARD)
		{
			Sym *pcl = g->next;
			if (!jmp)
				jmp = gjmp(0);
			gsym(pcl->jnext);
			try_call_scope_cleanup(o->cl.s);
			pcl->jnext = gjmp(0);
			if (!o->cl.n)
				goto remove_pending;
			g->c = o->cl.n;
			pg = &g->prev;
		}
		else
		{
remove_pending:
			*pg = g->prev;
			sym_free(g);
		}
	}
	gsym(jmp);
	try_call_scope_cleanup(o->cl.s);
}

/* ------------------------------------------------------------------------- */
/* VLA */

static void vla_restore(int loc)
{
	if (loc)
		gen_vla_sp_restore(loc);
}

static void vla_leave(struct scope *o)
{
	if (o->vla.num < cur_scope->vla.num)
		vla_restore(o->vla.loc);
}

/* ------------------------------------------------------------------------- */
/* local scopes */

void new_scope(struct scope *o)
{
	/* copy and link previous scope */
	*o = *cur_scope;
	o->prev = cur_scope;
	cur_scope = o;

	/* record local declaration stack position */
	o->lstk = local_stack;
	o->llstk = local_label_stack;

	++local_scope;
}

void prev_scope(struct scope *o, int is_expr)
{
	vla_leave(o->prev);

	if (o->cl.s != o->prev->cl.s)
		block_cleanup(o->prev);

	/* pop locally defined labels */
	label_pop(&local_label_stack, o->llstk, is_expr);

	/* In the is_expr case (a statement expression is finished here),
	   vtop might refer to symbols on the local_stack.  Either via the
	   type or via vtop->sym.  We can't pop those nor any that in turn
	   might be referred to.  To make it easier we don't roll back
	   any symbols in that case; some upper level call to block() will
	   do that.  We do have to remove such symbols from the lookup
	   tables, though.  sym_pop will do that.  */

	/* pop locally defined symbols */
	pop_local_syms(&local_stack, o->lstk, is_expr, 0);

	cur_scope = o->prev;
	--local_scope;
}

/* leave a scope via break/continue(/goto) */
void leave_scope(struct scope *o)
{
	if (!o)
		return;
	try_call_scope_cleanup(o->cl.s);
	vla_leave(o);
}

/* ------------------------------------------------------------------------- */
/* call block from 'for do while' loops */

static void lblock(int *bsym, int *csym)
{
	struct scope *lo = loop_scope, *co = cur_scope;
	int *b = co->bsym, *c = co->csym;
	if (csym)
	{
		co->csym = csym;
		loop_scope = co;
	}
	co->bsym = bsym;
	block(0);
	co->bsym = b;
	if (csym)
	{
		co->csym = c;
		loop_scope = lo;
	}
}

static void block(int is_expr)
{
	int a, b, c, d, e, t;
	struct scope o;
	Sym *s;

	if (is_expr)
	{
		/* default return value is (void) */
		vpushi(0);
		vtop->type.t = VT_VOID;
	}

again:
	t = tok, next();

	if (t == TOK_IF)
	{
		skip('(');
		gexpr();
		skip(')');
		a = gvtst(1, 0);
		block(0);
		if (tok == TOK_ELSE)
		{
			d = gjmp(0);
			gsym(a);
			next();
			block(0);
			gsym(d); /* patch else jmp */
		}
		else
		{
			gsym(a);
		}

	}
	else if (t == TOK_WHILE)
	{
		d = gind();
		skip('(');
		gexpr();
		skip(')');
		a = gvtst(1, 0);
		b = 0;
		lblock(&a, &b);
		gjmp_addr(d);
		gsym_addr(b, d);
		gsym(a);

	}
	else if (t == '{')
	{
		new_scope(&o);

		/* handle local labels declarations */
		while (tok == TOK_LABEL)
		{
			do
			{
				next();
				if (tok < TOK_UIDENT)
					expect("label identifier");
				label_push(&local_label_stack, tok, LABEL_DECLARED);
				next();
			}
			while (tok == ',');
			skip(';');
		}

		while (tok != '}')
		{
			decl(VT_LOCAL);
			if (tok != '}')
			{
				if (is_expr)
					vpop();
				block(is_expr);
			}
		}

		prev_scope(&o, is_expr);
		if (local_scope)
			next();
		else if (!nocode_wanted)
			check_func_return();

	}
	else if (t == TOK_RETURN)
	{
		b = (func_vt.t & VT_BTYPE) != VT_VOID;
		if (tok != ';')
		{
			gexpr();
			if (b)
			{
				gen_assign_cast(&func_vt);
			}
			else
			{
				if (vtop->type.t != VT_VOID)
					tcc_warning("void function returns a value");
				vtop--;
			}
		}
		else if (b)
		{
			tcc_warning("'return' with no value");
			b = 0;
		}
		leave_scope(root_scope);
		if (b)
			gfunc_return(&func_vt);
		skip(';');
		/* jump unless last stmt in top-level block */
		if (tok != '}' || local_scope != 1)
			rsym = gjmp(rsym);
		CODE_OFF();

	}
	else if (t == TOK_BREAK)
	{
		/* compute jump */
		if (!cur_scope->bsym)
			tcc_error("cannot break");
		if (cur_switch && cur_scope->bsym == cur_switch->bsym)
			leave_scope(cur_switch->scope);
		else
			leave_scope(loop_scope);
		*cur_scope->bsym = gjmp(*cur_scope->bsym);
		skip(';');

	}
	else if (t == TOK_CONTINUE)
	{
		/* compute jump */
		if (!cur_scope->csym)
			tcc_error("cannot continue");
		leave_scope(loop_scope);
		*cur_scope->csym = gjmp(*cur_scope->csym);
		skip(';');

	}
	else if (t == TOK_FOR)
	{
		new_scope(&o);

		skip('(');
		if (tok != ';')
		{
			/* c99 for-loop init decl? */
			if (!decl0(VT_LOCAL, 1, NULL))
			{
				/* no, regular for-loop init expr */
				gexpr();
				vpop();
			}
		}
		skip(';');
		a = b = 0;
		c = d = gind();
		if (tok != ';')
		{
			gexpr();
			a = gvtst(1, 0);
		}
		skip(';');
		if (tok != ')')
		{
			e = gjmp(0);
			d = gind();
			gexpr();
			vpop();
			gjmp_addr(c);
			gsym(e);
		}
		skip(')');
		lblock(&a, &b);
		gjmp_addr(d);
		gsym_addr(b, d);
		gsym(a);
		prev_scope(&o, 0);

	}
	else if (t == TOK_DO)
	{
		a = b = 0;
		d = gind();
		lblock(&a, &b);
		gsym(b);
		skip(TOK_WHILE);
		skip('(');
		gexpr();
		skip(')');
		skip(';');
		c = gvtst(0, 0);
		gsym_addr(c, d);
		gsym(a);

	}
	else if (t == TOK_SWITCH)
	{
		struct switch_t *sw;

		sw = tcc_mallocz(sizeof *sw);
		sw->bsym = &a;
		sw->scope = cur_scope;
		sw->prev = cur_switch;
		cur_switch = sw;

		skip('(');
		gexpr();
		skip(')');
		sw->sv = *vtop--; /* save switch value */

		a = 0;
		b = gjmp(0); /* jump to first case */
		lblock(&a, NULL);
		a = gjmp(a); /* add implicit break */
		/* case lookup */
		gsym(b);

		qsort(sw->p, sw->n, sizeof(void*), case_cmp);
		for (b = 1; b < sw->n; b++)
			if (sw->p[b - 1]->v2 >= sw->p[b]->v1)
				tcc_error("duplicate case value");

		/* Our switch table sorting is signed, so the compared
		   value needs to be as well when it's 64bit.  */
		vpushv(&sw->sv);
		if ((vtop->type.t & VT_BTYPE) == VT_LLONG)
			vtop->type.t &= ~VT_UNSIGNED;
		gv(RC_INT);
		d = 0, gcase(sw->p, sw->n, &d);
		vpop();
		if (sw->def_sym)
			gsym_addr(d, sw->def_sym);
		else
			gsym(d);
		/* break label */
		gsym(a);

		dynarray_reset(&sw->p, &sw->n);
		cur_switch = sw->prev;
		tcc_free(sw);

	}
	else if (t == TOK_CASE)
	{
		struct case_t *cr = tcc_malloc(sizeof(struct case_t));
		if (!cur_switch)
			expect("switch");
		cr->v1 = cr->v2 = expr_const64();
		if (gnu_ext && tok == TOK_DOTS)
		{
			next();
			cr->v2 = expr_const64();
			if (cr->v2 < cr->v1)
				tcc_warning("empty case range");
		}
		cr->sym = gind();
		dynarray_add(&cur_switch->p, &cur_switch->n, cr);
		skip(':');
		is_expr = 0;
		goto block_after_label;

	}
	else if (t == TOK_DEFAULT)
	{
		if (!cur_switch)
			expect("switch");
		if (cur_switch->def_sym)
			tcc_error("too many 'default'");
		cur_switch->def_sym = gind();
		skip(':');
		is_expr = 0;
		goto block_after_label;

	}
	else if (t == TOK_GOTO)
	{
		vla_restore(root_scope->vla.loc);
		if (tok == '*' && gnu_ext)
		{
			/* computed goto */
			next();
			gexpr();
			if ((vtop->type.t & VT_BTYPE) != VT_PTR)
				expect("pointer");
			ggoto();

		}
		else if (tok >= TOK_UIDENT)
		{
			s = label_find(tok);
			/* put forward definition if needed */
			if (!s)
				s = label_push(&global_label_stack, tok, LABEL_FORWARD);
			else if (s->r == LABEL_DECLARED)
				s->r = LABEL_FORWARD;

			if (s->r & LABEL_FORWARD)
			{
				/* start new goto chain for cleanups, linked via label->next */
				if (cur_scope->cl.s && !nocode_wanted)
				{
					sym_push2(&pending_gotos, SYM_FIELD, 0, cur_scope->cl.n);
					pending_gotos->prev_tok = s;
					s = sym_push2(&s->next, SYM_FIELD, 0, 0);
					pending_gotos->next = s;
				}
				s->jnext = gjmp(s->jnext);
			}
			else
			{
				try_call_cleanup_goto(s->cleanupstate);
				gjmp_addr(s->jnext);
			}
			next();

		}
		else
		{
			expect("label identifier");
		}
		skip(';');

	}
	else if (t == TOK_ASM1 || t == TOK_ASM2 || t == TOK_ASM3)
	{
		asm_instr();

	}
	else
	{
		if (tok == ':' && t >= TOK_UIDENT)
		{
			/* label case */
			next();
			s = label_find(t);
			if (s)
			{
				if (s->r == LABEL_DEFINED)
					tcc_error("duplicate label '%s'", get_tok_str(s->v, NULL));
				s->r = LABEL_DEFINED;
				if (s->next)
				{
					Sym *pcl; /* pending cleanup goto */
					for (pcl = s->next; pcl; pcl = pcl->prev)
						gsym(pcl->jnext);
					sym_pop(&s->next, NULL, 0);
				}
				else
					gsym(s->jnext);
			}
			else
			{
				s = label_push(&global_label_stack, t, LABEL_DEFINED);
			}
			s->jnext = gind();
			s->cleanupstate = cur_scope->cl.s;

block_after_label:
			vla_restore(cur_scope->vla.loc);
			/* we accept this, but it is a mistake */
			if (tok == '}')
			{
				tcc_warning("deprecated use of label at end of compound statement");
			}
			else
			{
				goto again;
			}

		}
		else
		{
			/* expression case */
			if (t != ';')
			{
				unget_tok(t);
				if (is_expr)
				{
					vpop();
					gexpr();
				}
				else
				{
					gexpr();
					vpop();
				}
				skip(';');
			}
		}
	}
}

/* This skips over a stream of tokens containing balanced {} and ()
   pairs, stopping at outer ',' ';' and '}' (or matching '}' if we started
   with a '{').  If STR then allocates and stores the skipped tokens
   in *STR.  This doesn't check if () and {} are nested correctly,
   i.e. "({)}" is accepted.  */
static void skip_or_save_block(TokenString **str)
{
	int braces = tok == '{';
	int level = 0;
	if (str)
		*str = tok_str_alloc();

	while ((level > 0 || (tok != '}' && tok != ',' && tok != ';' && tok != ')')))
	{
		int t;
		if (tok == TOK_EOF)
		{
			if (str || level > 0)
				tcc_error("unexpected end of file");
			else
				break;
		}
		if (str)
			tok_str_add_tok(*str);
		t = tok;
		next();
		if (t == '{' || t == '(')
		{
			level++;
		}
		else if (t == '}' || t == ')')
		{
			level--;
			if (level == 0 && braces && t == '}')
				break;
		}
	}
	if (str)
	{
		tok_str_add(*str, -1);
		tok_str_add(*str, 0);
	}
}

#define EXPR_CONST 1
#define EXPR_ANY   2

static void parse_init_elem(int expr_type)
{
	int saved_global_expr;
	switch(expr_type)
	{
	case EXPR_CONST:
		/* compound literals must be allocated globally in this case */
		saved_global_expr = global_expr;
		global_expr = 1;
		expr_const1();
		global_expr = saved_global_expr;
		/* NOTE: symbols are accepted, as well as lvalue for anon symbols
		(compound literals).  */
		if (((vtop->r & (VT_VALMASK | VT_LVAL)) != VT_CONST
		        && ((vtop->r & (VT_SYM|VT_LVAL)) != (VT_SYM|VT_LVAL)
		            || vtop->sym->v < SYM_FIRST_ANOM))
#ifdef TCC_TARGET_PE
		        || ((vtop->r & VT_SYM) && vtop->sym->a.dllimport)
#endif
		   )
			tcc_error("initializer element is not constant");
		break;
	case EXPR_ANY:
		expr_eq();
		break;
	}
}

/* put zeros for variable based init */
static void init_putz(Section *sec, unsigned long c, int size)
{
	if (sec)
	{
		/* nothing to do because globals are already set to zero */
	}
	else
	{
		vpush_global_sym(&func_old_type, TOK_memset);
		vseti(VT_LOCAL, c);
#ifdef TCC_TARGET_ARM
		vpushs(size);
		vpushi(0);
#else
		vpushi(0);
		vpushs(size);
#endif
		gfunc_call(3);
	}
}

#define DIF_FIRST     1
#define DIF_SIZE_ONLY 2
#define DIF_HAVE_ELEM 4

/* t is the array or struct type. c is the array or struct
   address. cur_field is the pointer to the current
   field, for arrays the 'c' member contains the current start
   index.  'flags' is as in decl_initializer.
   'al' contains the already initialized length of the
   current container (starting at c).  This returns the new length of that.  */
static int decl_designator(CType *type, Section *sec, unsigned long c,
                           Sym **cur_field, int flags, int al)
{
	Sym *s, *f;
	int index, index_last, align, l, nb_elems, elem_size;
	unsigned long corig = c;

	elem_size = 0;
	nb_elems = 1;

	if (flags & DIF_HAVE_ELEM)
		goto no_designator;

	if (gnu_ext && tok >= TOK_UIDENT)
	{
		l = tok, next();
		if (tok == ':')
			goto struct_field;
		unget_tok(l);
	}

	/* NOTE: we only support ranges for last designator */
	while (nb_elems == 1 && (tok == '[' || tok == '.'))
	{
		if (tok == '[')
		{
			if (!(type->t & VT_ARRAY))
				expect("array type");
			next();
			index = index_last = expr_const();
			if (tok == TOK_DOTS && gnu_ext)
			{
				next();
				index_last = expr_const();
			}
			skip(']');
			s = type->ref;
			if (index < 0 || (s->c >= 0 && index_last >= s->c) ||
			        index_last < index)
				tcc_error("invalid index");
			if (cur_field)
				(*cur_field)->c = index_last;
			type = pointed_type(type);
			elem_size = type_size(type, &align);
			c += index * elem_size;
			nb_elems = index_last - index + 1;
		}
		else
		{
			int cumofs;
			next();
			l = tok;
struct_field:
			next();
			if ((type->t & VT_BTYPE) != VT_STRUCT)
				expect("struct/union type");
			cumofs = 0;
			f = find_field(type, l, &cumofs);
			if (!f)
				expect("field");
			if (cur_field)
				*cur_field = f;
			type = &f->type;
			c += cumofs + f->c;
		}
		cur_field = NULL;
	}
	if (!cur_field)
	{
		if (tok == '=')
		{
			next();
		}
		else if (!gnu_ext)
		{
			expect("=");
		}
	}
	else
	{
no_designator:
		if (type->t & VT_ARRAY)
		{
			index = (*cur_field)->c;
			if (type->ref->c >= 0 && index >= type->ref->c)
				tcc_error("index too large");
			type = pointed_type(type);
			c += index * type_size(type, &align);
		}
		else
		{
			f = *cur_field;
			while (f && (f->v & SYM_FIRST_ANOM) && (f->type.t & VT_BITFIELD))
				*cur_field = f = f->next;
			if (!f)
				tcc_error("too many field init");
			type = &f->type;
			c += f->c;
		}
	}
	/* must put zero in holes (note that doing it that way
	   ensures that it even works with designators) */
	if (!(flags & DIF_SIZE_ONLY) && c - corig > al)
		init_putz(sec, corig + al, c - corig - al);
	decl_initializer(type, sec, c, flags & ~DIF_FIRST);

	/* XXX: make it more general */
	if (!(flags & DIF_SIZE_ONLY) && nb_elems > 1)
	{
		unsigned long c_end;
		uint8_t *src, *dst;
		int i;

		if (!sec)
		{
			vset(type, VT_LOCAL|VT_LVAL, c);
			for (i = 1; i < nb_elems; i++)
			{
				vset(type, VT_LOCAL|VT_LVAL, c + elem_size * i);
				vswap();
				vstore();
			}
			vpop();
		}
		else if (!NODATA_WANTED)
		{
			c_end = c + nb_elems * elem_size;
			if (c_end > sec->data_allocated)
				section_realloc(sec, c_end);
			src = sec->data + c;
			dst = src;
			for(i = 1; i < nb_elems; i++)
			{
				dst += elem_size;
				memcpy(dst, src, elem_size);
			}
		}
	}
	c += nb_elems * type_size(type, &align);
	if (c - corig > al)
		al = c - corig;
	return al;
}

/* store a value or an expression directly in global data or in local array */
static void init_putv(CType *type, Section *sec, unsigned long c)
{
	int bt;
	void *ptr;
	CType dtype;

	dtype = *type;
	dtype.t &= ~VT_CONSTANT; /* need to do that to avoid false warning */

	if (sec)
	{
		int size, align;
		/* XXX: not portable */
		/* XXX: generate error if incorrect relocation */
		gen_assign_cast(&dtype);
		bt = type->t & VT_BTYPE;

		if ((vtop->r & VT_SYM)
		        && bt != VT_PTR
		        && bt != VT_FUNC
		        && (bt != (PTR_SIZE == 8 ? VT_LLONG : VT_INT)
		            || (type->t & VT_BITFIELD))
		        && !((vtop->r & VT_CONST) && vtop->sym->v >= SYM_FIRST_ANOM)
		   )
			tcc_error("initializer element is not computable at load time");

		if (NODATA_WANTED)
		{
			vtop--;
			return;
		}

		size = type_size(type, &align);
		section_reserve(sec, c + size);
		ptr = sec->data + c;

		/* XXX: make code faster ? */
		if ((vtop->r & (VT_SYM|VT_CONST)) == (VT_SYM|VT_CONST) &&
		        vtop->sym->v >= SYM_FIRST_ANOM &&
		        /* XXX This rejects compound literals like
		           '(void *){ptr}'.  The problem is that '&sym' is
		           represented the same way, which would be ruled out
		           by the SYM_FIRST_ANOM check above, but also '"string"'
		           in 'char *p = "string"' is represented the same
		           with the type being VT_PTR and the symbol being an
		           anonymous one.  That is, there's no difference in vtop
		           between '(void *){x}' and '&(void *){x}'.  Ignore
		           pointer typed entities here.  Hopefully no real code
		           will every use compound literals with scalar type.  */
		        (vtop->type.t & VT_BTYPE) != VT_PTR)
		{
			/* These come from compound literals, memcpy stuff over.  */
			Section *ssec;
			ElfSym *esym;
			ElfW_Rel *rel;
			esym = elfsym(vtop->sym);
			ssec = tcc_state->sections[esym->st_shndx];
			memmove (ptr, ssec->data + esym->st_value, size);
			if (ssec->reloc)
			{
				/* We need to copy over all memory contents, and that
				   includes relocations.  Use the fact that relocs are
				   created it order, so look from the end of relocs
				   until we hit one before the copied region.  */
				int num_relocs = ssec->reloc->data_offset / sizeof(*rel);
				rel = (ElfW_Rel*)(ssec->reloc->data + ssec->reloc->data_offset);
				while (num_relocs--)
				{
					rel--;
					if (rel->r_offset >= esym->st_value + size)
						continue;
					if (rel->r_offset < esym->st_value)
						break;
					/* Note: if the same fields are initialized multiple
					   times (possible with designators) then we possibly
					   add multiple relocations for the same offset here.
					   That would lead to wrong code, the last reloc needs
					   to win.  We clean this up later after the whole
					   initializer is parsed.  */
					put_elf_reloca(symtab_section, sec,
					               c + rel->r_offset - esym->st_value,
					               ELFW(R_TYPE)(rel->r_info),
					               ELFW(R_SYM)(rel->r_info),
#if PTR_SIZE == 8
					               rel->r_addend
#else
					               0
#endif
					              );
				}
			}
		}
		else
		{
			if (type->t & VT_BITFIELD)
			{
				int bit_pos, bit_size, bits, n;
				unsigned char *p, v, m;
				bit_pos = BIT_POS(vtop->type.t);
				bit_size = BIT_SIZE(vtop->type.t);
				p = (unsigned char*)ptr + (bit_pos >> 3);
				bit_pos &= 7, bits = 0;
				while (bit_size)
				{
					n = 8 - bit_pos;
					if (n > bit_size)
						n = bit_size;
					v = vtop->c.i >> bits << bit_pos;
					m = ((1 << n) - 1) << bit_pos;
					*p = (*p & ~m) | (v & m);
					bits += n, bit_size -= n, bit_pos = 0, ++p;
				}
			}
			else
				switch(bt)
				{
				/* XXX: when cross-compiling we assume that each type has the
				   same representation on host and target, which is likely to
				   be wrong in the case of long double */
				case VT_BOOL:
					vtop->c.i = vtop->c.i != 0;
				case VT_BYTE:
					*(char *)ptr |= vtop->c.i;
					break;
				case VT_SHORT:
					*(short *)ptr |= vtop->c.i;
					break;
				case VT_FLOAT:
					*(float*)ptr = vtop->c.f;
					break;
				case VT_DOUBLE:
					*(double *)ptr = vtop->c.d;
					break;
				case VT_LDOUBLE:
#if defined TCC_IS_NATIVE_387
					if (sizeof (long double) >= 10) /* zero pad ten-byte LD */
						memcpy(ptr, &vtop->c.ld, 10);
#ifdef __TINYC__
					else if (sizeof (long double) == sizeof (double))
						__asm__("fldl %1\nfstpt %0\n" : "=m" (*ptr) : "m" (vtop->c.ld));
#endif
					else if (vtop->c.ld == 0.0)
						;
					else
#endif
						if (sizeof(long double) == LDOUBLE_SIZE)
							*(long double*)ptr = vtop->c.ld;
						else if (sizeof(double) == LDOUBLE_SIZE)
							*(double *)ptr = (double)vtop->c.ld;
						else
							tcc_error("can't cross compile long double constants");
					break;
#if PTR_SIZE != 8
				case VT_LLONG:
					*(long long *)ptr |= vtop->c.i;
					break;
#else
				case VT_LLONG:
#endif
				case VT_PTR:
				{
					addr_t val = vtop->c.i;
#if PTR_SIZE == 8
					if (vtop->r & VT_SYM)
						greloca(sec, vtop->sym, c, R_DATA_PTR, val);
					else
						*(addr_t *)ptr |= val;
#else
					if (vtop->r & VT_SYM)
						greloc(sec, vtop->sym, c, R_DATA_PTR);
					*(addr_t *)ptr |= val;
#endif
					break;
				}
				default:
				{
					int val = vtop->c.i;
#if PTR_SIZE == 8
					if (vtop->r & VT_SYM)
						greloca(sec, vtop->sym, c, R_DATA_PTR, val);
					else
						*(int *)ptr |= val;
#else
					if (vtop->r & VT_SYM)
						greloc(sec, vtop->sym, c, R_DATA_PTR);
					*(int *)ptr |= val;
#endif
					break;
				}
				}
		}
		vtop--;
	}
	else
	{
		vset(&dtype, VT_LOCAL|VT_LVAL, c);
		vswap();
		vstore();
		vpop();
	}
}

/* 't' contains the type and storage info. 'c' is the offset of the
   object in section 'sec'. If 'sec' is NULL, it means stack based
   allocation. 'flags & DIF_FIRST' is true if array '{' must be read (multi
   dimension implicit array init handling). 'flags & DIF_SIZE_ONLY' is true if
   size only evaluation is wanted (only for arrays). */
static void decl_initializer(CType *type, Section *sec, unsigned long c,
                             int flags)
{
	int len, n, no_oblock, nb, i;
	int size1, align1;
	Sym *s, *f;
	Sym indexsym;
	CType *t1;

	if (!(flags & DIF_HAVE_ELEM) && tok != '{' &&
	        /* In case of strings we have special handling for arrays, so
	           don't consume them as initializer value (which would commit them
	           to some anonymous symbol).  */
	        tok != TOK_LSTR && tok != TOK_STR &&
	        !(flags & DIF_SIZE_ONLY))
	{
		parse_init_elem(!sec ? EXPR_ANY : EXPR_CONST);
		flags |= DIF_HAVE_ELEM;
	}

	if ((flags & DIF_HAVE_ELEM) &&
	        !(type->t & VT_ARRAY) &&
	        /* Use i_c_parameter_t, to strip toplevel qualifiers.
	           The source type might have VT_CONSTANT set, which is
	           of course assignable to non-const elements.  */
	        is_compatible_unqualified_types(type, &vtop->type))
	{
		init_putv(type, sec, c);
	}
	else if (type->t & VT_ARRAY)
	{
		s = type->ref;
		n = s->c;
		t1 = pointed_type(type);
		size1 = type_size(t1, &align1);

		no_oblock = 1;
		if (((flags & DIF_FIRST) && tok != TOK_LSTR && tok != TOK_STR) ||
		        tok == '{')
		{
			if (tok != '{')
				tcc_error("character array initializer must be a literal,"
				          " optionally enclosed in braces");
			skip('{');
			no_oblock = 0;
		}

		/* only parse strings here if correct type (otherwise: handle
		   them as ((w)char *) expressions */
		if ((tok == TOK_LSTR &&
#ifdef TCC_TARGET_PE
		        (t1->t & VT_BTYPE) == VT_SHORT && (t1->t & VT_UNSIGNED)
#else
		        (t1->t & VT_BTYPE) == VT_INT
#endif
		    ) || (tok == TOK_STR && (t1->t & VT_BTYPE) == VT_BYTE))
		{
			len = 0;
			while (tok == TOK_STR || tok == TOK_LSTR)
			{
				int cstr_len, ch;

				/* compute maximum number of chars wanted */
				if (tok == TOK_STR)
					cstr_len = tokc.str.size;
				else
					cstr_len = tokc.str.size / sizeof(nwchar_t);
				cstr_len--;
				nb = cstr_len;
				if (n >= 0 && nb > (n - len))
					nb = n - len;
				if (!(flags & DIF_SIZE_ONLY))
				{
					if (cstr_len > nb)
						tcc_warning("initializer-string for array is too long");
					/* in order to go faster for common case (char
					   string in global variable, we handle it
					   specifically */
					if (sec && tok == TOK_STR && size1 == 1)
					{
						if (!NODATA_WANTED)
							memcpy(sec->data + c + len, tokc.str.data, nb);
					}
					else
					{
						for(i=0; i<nb; i++)
						{
							if (tok == TOK_STR)
								ch = ((unsigned char *)tokc.str.data)[i];
							else
								ch = ((nwchar_t *)tokc.str.data)[i];
							vpushi(ch);
							init_putv(t1, sec, c + (len + i) * size1);
						}
					}
				}
				len += nb;
				next();
			}
			/* only add trailing zero if enough storage (no
			   warning in this case since it is standard) */
			if (n < 0 || len < n)
			{
				if (!(flags & DIF_SIZE_ONLY))
				{
					vpushi(0);
					init_putv(t1, sec, c + (len * size1));
				}
				len++;
			}
			len *= size1;
		}
		else
		{
			indexsym.c = 0;
			f = &indexsym;

do_init_list:
			len = 0;
			while (tok != '}' || (flags & DIF_HAVE_ELEM))
			{
				len = decl_designator(type, sec, c, &f, flags, len);
				flags &= ~DIF_HAVE_ELEM;
				if (type->t & VT_ARRAY)
				{
					++indexsym.c;
					/* special test for multi dimensional arrays (may not
					   be strictly correct if designators are used at the
					   same time) */
					if (no_oblock && len >= n*size1)
						break;
				}
				else
				{
					if (s->type.t == VT_UNION)
						f = NULL;
					else
						f = f->next;
					if (no_oblock && f == NULL)
						break;
				}

				if (tok == '}')
					break;
				skip(',');
			}
		}
		/* put zeros at the end */
		if (!(flags & DIF_SIZE_ONLY) && len < n*size1)
			init_putz(sec, c + len, n*size1 - len);
		if (!no_oblock)
			skip('}');
		/* patch type size if needed, which happens only for array types */
		if (n < 0)
			s->c = size1 == 1 ? len : ((len + size1 - 1)/size1);
	}
	else if ((type->t & VT_BTYPE) == VT_STRUCT)
	{
		size1 = 1;
		no_oblock = 1;
		if ((flags & DIF_FIRST) || tok == '{')
		{
			skip('{');
			no_oblock = 0;
		}
		s = type->ref;
		f = s->next;
		n = s->c;
		goto do_init_list;
	}
	else if (tok == '{')
	{
		if (flags & DIF_HAVE_ELEM)
			skip(';');
		next();
		decl_initializer(type, sec, c, flags & ~DIF_HAVE_ELEM);
		skip('}');
	}
	else if ((flags & DIF_SIZE_ONLY))
	{
		/* If we supported only ISO C we wouldn't have to accept calling
		   this on anything than an array if DIF_SIZE_ONLY (and even then
		   only on the outermost level, so no recursion would be needed),
		   because initializing a flex array member isn't supported.
		   But GNU C supports it, so we need to recurse even into
		   subfields of structs and arrays when DIF_SIZE_ONLY is set.  */
		/* just skip expression */
		skip_or_save_block(NULL);
	}
	else
	{
		if (!(flags & DIF_HAVE_ELEM))
		{
			/* This should happen only when we haven't parsed
			   the init element above for fear of committing a
			   string constant to memory too early.  */
			if (tok != TOK_STR && tok != TOK_LSTR)
				expect("string constant");
			parse_init_elem(!sec ? EXPR_ANY : EXPR_CONST);
		}
		init_putv(type, sec, c);
	}
}

/* parse an initializer for type 't' if 'has_init' is non zero, and
   allocate space in local or global data space ('r' is either
   VT_LOCAL or VT_CONST). If 'v' is non zero, then an associated
   variable 'v' of scope 'scope' is declared before initializers
   are parsed. If 'v' is zero, then a reference to the new object
   is put in the value stack. If 'has_init' is 2, a special parsing
   is done to handle string constants. */
static void decl_initializer_alloc(CType *type, AttributeDef *ad, int r,
                                   int has_init, int v, int scope)
{
	int size, align, addr;
	TokenString *init_str = NULL;

	Section *sec;
	Sym *flexible_array;
	Sym *sym = NULL;
	int saved_nocode_wanted = nocode_wanted;
#ifdef CONFIG_TCC_BCHECK
	int bcheck = tcc_state->do_bounds_check && !NODATA_WANTED;
#endif

	/* Always allocate static or global variables */
	if (v && (r & VT_VALMASK) == VT_CONST)
		nocode_wanted |= 0x80000000;

	flexible_array = NULL;
	if ((type->t & VT_BTYPE) == VT_STRUCT)
	{
		Sym *field = type->ref->next;
		if (field)
		{
			while (field->next)
				field = field->next;
			if (field->type.t & VT_ARRAY && field->type.ref->c < 0)
				flexible_array = field;
		}
	}

	size = type_size(type, &align);
	/* If unknown size, we must evaluate it before
	   evaluating initializers because
	   initializers can generate global data too
	   (e.g. string pointers or ISOC99 compound
	   literals). It also simplifies local
	   initializers handling */
	if (size < 0 || (flexible_array && has_init))
	{
		if (!has_init)
			tcc_error("unknown type size");
		/* get all init string */
		if (has_init == 2)
		{
			init_str = tok_str_alloc();
			/* only get strings */
			while (tok == TOK_STR || tok == TOK_LSTR)
			{
				tok_str_add_tok(init_str);
				next();
			}
			tok_str_add(init_str, -1);
			tok_str_add(init_str, 0);
		}
		else
		{
			skip_or_save_block(&init_str);
		}
		unget_tok(0);

		/* compute size */
		begin_macro(init_str, 1);
		next();
		decl_initializer(type, NULL, 0, DIF_FIRST | DIF_SIZE_ONLY);
		/* prepare second initializer parsing */
		macro_ptr = init_str->str;
		next();

		/* if still unknown size, error */
		size = type_size(type, &align);
		if (size < 0)
			tcc_error("unknown type size");
	}
	/* If there's a flex member and it was used in the initializer
	   adjust size.  */
	if (flexible_array &&
	        flexible_array->type.ref->c > 0)
		size += flexible_array->type.ref->c
		        * pointed_size(&flexible_array->type);
	/* take into account specified alignment if bigger */
	if (ad->a.aligned)
	{
		int speca = 1 << (ad->a.aligned - 1);
		if (speca > align)
			align = speca;
	}
	else if (ad->a.packed)
	{
		align = 1;
	}

	if (!v && NODATA_WANTED)
		size = 0, align = 1;

	if ((r & VT_VALMASK) == VT_LOCAL)
	{
		sec = NULL;
#ifdef CONFIG_TCC_BCHECK
		if (bcheck && v)
		{
			/* add padding between stack variables for bound checking */
			loc--;
		}
#endif
		loc = (loc - size) & -align;
		addr = loc;
#ifdef CONFIG_TCC_BCHECK
		if (bcheck && v)
		{
			/* add padding between stack variables for bound checking */
			loc--;
		}
#endif
		if (v)
		{
			/* local variable */
#ifdef CONFIG_TCC_ASM
			if (ad->asm_label)
			{
				int reg = asm_parse_regvar(ad->asm_label);
				if (reg >= 0)
					r = (r & ~VT_VALMASK) | reg;
			}
#endif
			sym = sym_push(v, type, r, addr);
			if (ad->cleanup_func)
			{
				Sym *cls = sym_push2(&all_cleanups,
				                     SYM_FIELD | ++cur_scope->cl.n, 0, 0);
				cls->prev_tok = sym;
				cls->next = ad->cleanup_func;
				cls->ncl = cur_scope->cl.s;
				cur_scope->cl.s = cls;
			}

			sym->a = ad->a;
		}
		else
		{
			/* push local reference */
			vset(type, r, addr);
		}
	}
	else
	{
		if (v && scope == VT_CONST)
		{
			/* see if the symbol was already defined */
			sym = sym_find(v);
			if (sym)
			{
				patch_storage(sym, ad, type);
				/* we accept several definitions of the same global variable. */
				if (!has_init && sym->c && elfsym(sym)->st_shndx != SHN_UNDEF)
					goto no_alloc;
			}
		}

		/* allocate symbol in corresponding section */
		sec = ad->section;
		if (!sec)
		{
			if (has_init)
				sec = data_section;
			else if (tcc_state->nocommon)
				sec = bss_section;
		}

		if (sec)
		{
			addr = section_add(sec, size, align);
#ifdef CONFIG_TCC_BCHECK
			/* add padding if bound check */
			if (bcheck)
				section_add(sec, 1, 1);
#endif
		}
		else
		{
			addr = align; /* SHN_COMMON is special, symbol value is align */
			sec = common_section;
		}

		if (v)
		{
			if (!sym)
			{
				sym = sym_push(v, type, r | VT_SYM, 0);
				patch_storage(sym, ad, NULL);
			}
			/* update symbol definition */
			put_extern_sym(sym, sec, addr, size);
		}
		else
		{
			/* push global reference */
			vpush_ref(type, sec, addr, size);
			sym = vtop->sym;
			vtop->r |= r;
		}

#ifdef CONFIG_TCC_BCHECK
		/* handles bounds now because the symbol must be defined
		   before for the relocation */
		if (bcheck)
		{
			addr_t *bounds_ptr;

			greloca(bounds_section, sym, bounds_section->data_offset, R_DATA_PTR, 0);
			/* then add global bound info */
			bounds_ptr = section_ptr_add(bounds_section, 2 * sizeof(addr_t));
			bounds_ptr[0] = 0; /* relocated */
			bounds_ptr[1] = size;
		}
#endif
	}

	if (type->t & VT_VLA)
	{
		int a;

		if (NODATA_WANTED)
			goto no_alloc;

		/* save current stack pointer */
		if (root_scope->vla.loc == 0)
		{
			struct scope *v = cur_scope;
			gen_vla_sp_save(loc -= PTR_SIZE);
			do v->vla.loc = loc;
			while ((v = v->prev));
		}

		vla_runtime_type_size(type, &a);
		gen_vla_alloc(type, a);
#if defined TCC_TARGET_PE && defined TCC_TARGET_X86_64
		/* on _WIN64, because of the function args scratch area, the
		   result of alloca differs from RSP and is returned in RAX.  */
		gen_vla_result(addr), addr = (loc -= PTR_SIZE);
#endif
		gen_vla_sp_save(addr);
		cur_scope->vla.loc = addr;
		cur_scope->vla.num++;
	}
	else if (has_init)
	{
		size_t oldreloc_offset = 0;
		if (sec && sec->reloc)
			oldreloc_offset = sec->reloc->data_offset;
		decl_initializer(type, sec, addr, DIF_FIRST);
		if (sec && sec->reloc)
			squeeze_multi_relocs(sec, oldreloc_offset);
		/* patch flexible array member size back to -1, */
		/* for possible subsequent similar declarations */
		if (flexible_array)
			flexible_array->type.ref->c = -1;
	}

no_alloc:
	/* restore parse state if needed */
	if (init_str)
	{
		end_macro();
		next();
	}

	nocode_wanted = saved_nocode_wanted;
}

/* parse a function defined by symbol 'sym' and generate its code in
   'cur_text_section' */
static void gen_function(Sym *sym)
{
	/* Initialize VLA state */
	struct scope f = { 0 };
	cur_scope = root_scope = &f;

	nocode_wanted = 0;
	ind = cur_text_section->data_offset;
	if (sym->a.aligned)
	{
		size_t newoff = section_add(cur_text_section, 0,
		                            1 << (sym->a.aligned - 1));
		gen_fill_nops(newoff - ind);
	}
	/* NOTE: we patch the symbol size later */
	put_extern_sym(sym, cur_text_section, ind, 0);
	if (sym->type.ref->f.func_ctor)
		add_array (tcc_state, ".init_array", sym->c);
	if (sym->type.ref->f.func_dtor)
		add_array (tcc_state, ".fini_array", sym->c);
	funcname = get_tok_str(sym->v, NULL);
	func_ind = ind;
	/* put debug symbol */
	tcc_debug_funcstart(tcc_state, sym);
	/* push a dummy symbol to enable local sym storage */
	sym_push2(&local_stack, SYM_FIELD, 0, 0);
	local_scope = 1; /* for function parameters */
	gfunc_prolog(sym);
	local_scope = 0;
	rsym = 0;
	clear_temp_local_var_list();
	block(0);
	gsym(rsym);
	nocode_wanted = 0;
	/* reset local stack */
	pop_local_syms(&local_stack, NULL, 0,
	               sym->type.ref->f.func_type == FUNC_ELLIPSIS);
	gfunc_epilog();
	cur_text_section->data_offset = ind;
	local_scope = 0;
	label_pop(&global_label_stack, NULL, 0);
	sym_pop(&all_cleanups, NULL, 0);
	/* patch symbol size */
	elfsym(sym)->st_size = ind - func_ind;
	/* end of function */
	tcc_debug_funcend(tcc_state, ind - func_ind);
	/* It's better to crash than to generate wrong code */
	cur_text_section = NULL;
	funcname = ""; /* for safety */
	func_vt.t = VT_VOID; /* for safety */
	func_var = 0; /* for safety */
	ind = 0; /* for safety */
	nocode_wanted = 0x80000000;
	check_vstack();
	/* do this after funcend debug info */
	next();
}

static void gen_inline_functions(TCCState *s)
{
	Sym *sym;
	int inline_generated, i;
	struct InlineFunc *fn;

	tcc_open_bf(s, ":inline:", 0);
	/* iterate while inline function are referenced */
	do
	{
		inline_generated = 0;
		for (i = 0; i < s->nb_inline_fns; ++i)
		{
			fn = s->inline_fns[i];
			sym = fn->sym;
			if (sym && (sym->c || !(sym->type.t & VT_INLINE)))
			{
				/* the function was used or forced (and then not internal):
				   generate its code and convert it to a normal function */
				fn->sym = NULL;
				tcc_debug_putfile(s, fn->filename);
				begin_macro(fn->func_str, 1);
				next();
				cur_text_section = text_section;
				gen_function(sym);
				end_macro();

				inline_generated = 1;
			}
		}
	}
	while (inline_generated);
	tcc_close();
}

static void free_inline_functions(TCCState *s)
{
	int i;
	/* free tokens of unused inline functions */
	for (i = 0; i < s->nb_inline_fns; ++i)
	{
		struct InlineFunc *fn = s->inline_fns[i];
		if (fn->sym)
			tok_str_free(fn->func_str);
	}
	dynarray_reset(&s->inline_fns, &s->nb_inline_fns);
}

/* 'l' is VT_LOCAL or VT_CONST to define default storage type, or VT_CMP
   if parsing old style parameter decl list (and FUNC_SYM is set then) */
static int decl0(int l, int is_for_loop_init, Sym *func_sym)
{
	int v, has_init, r;
	CType type, btype;
	Sym *sym;
	AttributeDef ad, adbase;

	while (1)
	{
		if (tok == TOK_STATIC_ASSERT)
		{
			int c;

			next();
			skip('(');
			c = expr_const();
			skip(',');
			if (c == 0)
				tcc_error("%s", get_tok_str(tok, &tokc));
			next();
			skip(')');
			skip(';');
			continue;
		}
		if (!parse_btype(&btype, &adbase))
		{
			if (is_for_loop_init)
				return 0;
			/* skip redundant ';' if not in old parameter decl scope */
			if (tok == ';' && l != VT_CMP)
			{
				next();
				continue;
			}
			if (l != VT_CONST)
				break;
			if (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3)
			{
				/* global asm block */
				asm_global_instr();
				continue;
			}
			if (tok >= TOK_UIDENT)
			{
				/* special test for old K&R protos without explicit int
				   type. Only accepted when defining global data */
				btype.t = VT_INT;
			}
			else
			{
				if (tok != TOK_EOF)
					expect("declaration");
				break;
			}
		}
		if (tok == ';')
		{
			if ((btype.t & VT_BTYPE) == VT_STRUCT)
			{
				int v = btype.ref->v;
				if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) >= SYM_FIRST_ANOM)
					tcc_warning("unnamed struct/union that defines no instances");
				next();
				continue;
			}
			if (IS_ENUM(btype.t))
			{
				next();
				continue;
			}
		}
		while (1)   /* iterate thru each declaration */
		{
			type = btype;
			/* If the base type itself was an array type of unspecified
			   size (like in 'typedef int arr[]; arr x = {1};') then
			   we will overwrite the unknown size by the real one for
			   this decl.  We need to unshare the ref symbol holding
			   that size.  */
			if ((type.t & VT_ARRAY) && type.ref->c < 0)
			{
				type.ref = sym_push(SYM_FIELD, &type.ref->type, 0, type.ref->c);
			}
			ad = adbase;
			type_decl(&type, &ad, &v, TYPE_DIRECT);
#if 0
			{
				char buf[500];
				type_to_str(buf, sizeof(buf), &type, get_tok_str(v, NULL));
				printf("type = '%s'\n", buf);
			}
#endif
			if ((type.t & VT_BTYPE) == VT_FUNC)
			{
				if ((type.t & VT_STATIC) && (l == VT_LOCAL))
					tcc_error("function without file scope cannot be static");
				/* if old style function prototype, we accept a
				   declaration list */
				sym = type.ref;
				if (sym->f.func_type == FUNC_OLD && l == VT_CONST)
					decl0(VT_CMP, 0, sym);
				/* always compile 'extern inline' */
				if (type.t & VT_EXTERN)
					type.t &= ~VT_INLINE;
			}

			if (gnu_ext && (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3))
			{
				ad.asm_label = asm_label_instr();
				/* parse one last attribute list, after asm label */
				parse_attribute(&ad);
#if 0
				/* gcc does not allow __asm__("label") with function definition,
				   but why not ... */
				if (tok == '{')
					expect(";");
#endif
			}

#ifdef TCC_TARGET_PE
			if (ad.a.dllimport || ad.a.dllexport)
			{
				if (type.t & VT_STATIC)
					tcc_error("cannot have dll linkage with static");
				if (type.t & VT_TYPEDEF)
				{
					tcc_warning("'%s' attribute ignored for typedef",
					            ad.a.dllimport ? (ad.a.dllimport = 0, "dllimport") :
					            (ad.a.dllexport = 0, "dllexport"));
				}
				else if (ad.a.dllimport)
				{
					if ((type.t & VT_BTYPE) == VT_FUNC)
						ad.a.dllimport = 0;
					else
						type.t |= VT_EXTERN;
				}
			}
#endif
			if (tok == '{')
			{
				if (l != VT_CONST)
					tcc_error("cannot use local functions");
				if ((type.t & VT_BTYPE) != VT_FUNC)
					expect("function definition");

				/* reject abstract declarators in function definition
				   make old style params without decl have int type */
				sym = type.ref;
				while ((sym = sym->next) != NULL)
				{
					if (!(sym->v & ~SYM_FIELD))
						expect("identifier");
					if (sym->type.t == VT_VOID)
						sym->type = int_type;
				}

				/* put function symbol */
				type.t &= ~VT_EXTERN;
				sym = external_sym(v, &type, 0, &ad);
				/* static inline functions are just recorded as a kind
				   of macro. Their code will be emitted at the end of
				   the compilation unit only if they are used */
				if (sym->type.t & VT_INLINE)
				{
					struct InlineFunc *fn;
					fn = tcc_malloc(sizeof *fn + strlen(file->filename));
					strcpy(fn->filename, file->filename);
					fn->sym = sym;
					skip_or_save_block(&fn->func_str);
					dynarray_add(&tcc_state->inline_fns,
					             &tcc_state->nb_inline_fns, fn);
				}
				else
				{
					/* compute text section */
					cur_text_section = ad.section;
					if (!cur_text_section)
						cur_text_section = text_section;
					gen_function(sym);
				}
				break;
			}
			else
			{
				if (l == VT_CMP)
				{
					/* find parameter in function parameter list */
					for (sym = func_sym->next; sym; sym = sym->next)
						if ((sym->v & ~SYM_FIELD) == v)
							goto found;
					tcc_error("declaration for parameter '%s' but no such parameter",
					          get_tok_str(v, NULL));
found:
					if (type.t & VT_STORAGE) /* 'register' is okay */
						tcc_error("storage class specified for '%s'",
						          get_tok_str(v, NULL));
					if (sym->type.t != VT_VOID)
						tcc_error("redefinition of parameter '%s'",
						          get_tok_str(v, NULL));
					convert_parameter_type(&type);
					sym->type = type;
				}
				else if (type.t & VT_TYPEDEF)
				{
					/* save typedefed type  */
					/* XXX: test storage specifiers ? */
					sym = sym_find(v);
					if (sym && sym->sym_scope == local_scope)
					{
						if (!is_compatible_types(&sym->type, &type)
						        || !(sym->type.t & VT_TYPEDEF))
							tcc_error("incompatible redefinition of '%s'",
							          get_tok_str(v, NULL));
						sym->type = type;
					}
					else
					{
						sym = sym_push(v, &type, 0, 0);
					}
					sym->a = ad.a;
					sym->f = ad.f;
				}
				else if ((type.t & VT_BTYPE) == VT_VOID
				         && !(type.t & VT_EXTERN))
				{
					tcc_error("declaration of void object");
				}
				else
				{
					r = 0;
					if ((type.t & VT_BTYPE) == VT_FUNC)
					{
						/* external function definition */
						/* specific case for func_call attribute */
						type.ref->f = ad.f;
					}
					else if (!(type.t & VT_ARRAY))
					{
						/* not lvalue if array */
						r |= VT_LVAL;
					}
					has_init = (tok == '=');
					if (has_init && (type.t & VT_VLA))
						tcc_error("variable length array cannot be initialized");
					if (((type.t & VT_EXTERN) && (!has_init || l != VT_CONST))
					        || (type.t & VT_BTYPE) == VT_FUNC
					        /* as with GCC, uninitialized global arrays with no size
					           are considered extern: */
					        || ((type.t & VT_ARRAY) && !has_init
					            && l == VT_CONST && type.ref->c < 0)
					   )
					{
						/* external variable or function */
						type.t |= VT_EXTERN;
						sym = external_sym(v, &type, r, &ad);
						if (ad.alias_target)
						{
							ElfSym *esym;
							Sym *alias_target;
							alias_target = sym_find(ad.alias_target);
							esym = elfsym(alias_target);
							if (!esym)
								tcc_error("unsupported forward __alias__ attribute");
							put_extern_sym2(sym, esym->st_shndx, esym->st_value, esym->st_size, 0);
						}
					}
					else
					{
						if (type.t & VT_STATIC)
							r |= VT_CONST;
						else
							r |= l;
						if (has_init)
							next();
						else if (l == VT_CONST)
							/* uninitialized global variables may be overridden */
							type.t |= VT_EXTERN;
						decl_initializer_alloc(&type, &ad, r, has_init, v, l);
					}
				}
				if (tok != ',')
				{
					if (is_for_loop_init)
						return 1;
					skip(';');
					break;
				}
				next();
			}
		}
	}
	return 0;
}

static void decl(int l)
{
	decl0(l, 0, NULL);
}

/* ------------------------------------------------------------------------- */
#undef gjmp_addr
#undef gjmp
/* ------------------------------------------------------------------------- */

//END tccgen.c

//START tccelf.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)


/* Define this to get some debug output during relocation processing.  */
#undef DEBUG_RELOC

/********************************************************/
/* global variables */

/* elf version information */
struct sym_version
{
	char *lib;
	char *version;
	int out_index;
	int prev_same_lib;
};

#define nb_sym_versions     s1->nb_sym_versions
#define sym_versions        s1->sym_versions
#define nb_sym_to_version   s1->nb_sym_to_version
#define sym_to_version      s1->sym_to_version
#define dt_verneednum       s1->dt_verneednum
#define versym_section      s1->versym_section
#define verneed_section     s1->verneed_section

/* special flag to indicate that the section should not be linked to the other ones */
#define SHF_PRIVATE 0x80000000
/* section is dynsymtab_section */
#define SHF_DYNSYM 0x40000000

/* ------------------------------------------------------------------------- */

ST_FUNC void tccelf_new(TCCState *s)
{
	TCCState *s1 = s;
	/* no section zero */
	dynarray_add(&s->sections, &s->nb_sections, NULL);

	/* create standard sections */
	text_section = new_section(s, ".text", SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR);
	data_section = new_section(s, ".data", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);
	bss_section = new_section(s, ".bss", SHT_NOBITS, SHF_ALLOC | SHF_WRITE);
	common_section = new_section(s, ".common", SHT_NOBITS, SHF_PRIVATE);
	common_section->sh_num = SHN_COMMON;

	/* symbols are always generated for linking stage */
	symtab_section = new_symtab(s, ".symtab", SHT_SYMTAB, 0,
	                            ".strtab",
	                            ".hashtab", SHF_PRIVATE);
	s->symtab = symtab_section;

	/* private symbol table for dynamic symbols */
	s->dynsymtab_section = new_symtab(s, ".dynsymtab", SHT_SYMTAB, SHF_PRIVATE|SHF_DYNSYM,
	                                  ".dynstrtab",
	                                  ".dynhashtab", SHF_PRIVATE);
	get_sym_attr(s, 0, 1);
}

#ifdef CONFIG_TCC_BCHECK
ST_FUNC void tccelf_bounds_new(TCCState *s)
{
	TCCState *s1 = s;
	/* create bounds sections */
	bounds_section = new_section(s, ".bounds",
	                             SHT_PROGBITS, SHF_ALLOC);
	lbounds_section = new_section(s, ".lbounds",
	                              SHT_PROGBITS, SHF_ALLOC);
}
#endif

ST_FUNC void tccelf_stab_new(TCCState *s)
{
	TCCState *s1 = s;
	int shf = 0;
#ifdef CONFIG_TCC_BACKTRACE
	/* include stab info with standalone backtrace support */
	if (s->do_backtrace && s->output_type != TCC_OUTPUT_MEMORY)
		shf = SHF_ALLOC;
#endif
	stab_section = new_section(s, ".stab", SHT_PROGBITS, shf);
	stab_section->sh_entsize = sizeof(Stab_Sym);
	stab_section->sh_addralign = sizeof ((Stab_Sym*)0)->n_value;
	stab_section->link = new_section(s, ".stabstr", SHT_STRTAB, shf);
	/* put first entry */
	put_stabs(s, "", 0, 0, 0, 0);
}

static void free_section(Section *s)
{
	tcc_free(s->data);
}

ST_FUNC void tccelf_delete(TCCState *s1)
{
	int i;

#ifndef ELF_OBJ_ONLY
	/* free symbol versions */
	for (i = 0; i < nb_sym_versions; i++)
	{
		tcc_free(sym_versions[i].version);
		tcc_free(sym_versions[i].lib);
	}
	tcc_free(sym_versions);
	tcc_free(sym_to_version);
#endif

	/* free all sections */
	for(i = 1; i < s1->nb_sections; i++)
		free_section(s1->sections[i]);
	dynarray_reset(&s1->sections, &s1->nb_sections);

	for(i = 0; i < s1->nb_priv_sections; i++)
		free_section(s1->priv_sections[i]);
	dynarray_reset(&s1->priv_sections, &s1->nb_priv_sections);

	/* free any loaded DLLs */
#ifdef TCC_IS_NATIVE
	for ( i = 0; i < s1->nb_loaded_dlls; i++)
	{
		DLLReference *ref = s1->loaded_dlls[i];
		if ( ref->handle )
# ifdef _WIN32
			FreeLibrary((HMODULE)ref->handle);
# else
			dlclose(ref->handle);
# endif
	}
#endif
	/* free loaded dlls array */
	dynarray_reset(&s1->loaded_dlls, &s1->nb_loaded_dlls);
	tcc_free(s1->sym_attrs);

	symtab_section = NULL; /* for tccrun.c:rt_printline() */
}

/* save section data state */
ST_FUNC void tccelf_begin_file(TCCState *s1)
{
	Section *s;
	int i;
	for (i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		s->sh_offset = s->data_offset;
	}
	/* disable symbol hashing during compilation */
	s = s1->symtab, s->reloc = s->hash, s->hash = NULL;
#if defined TCC_TARGET_X86_64 && defined TCC_TARGET_PE
	s1->uw_sym = 0;
#endif
}

/* At the end of compilation, convert any UNDEF syms to global, and merge
   with previously existing symbols */
ST_FUNC void tccelf_end_file(TCCState *s1)
{
	Section *s = s1->symtab;
	int first_sym, nb_syms, *tr, i;

	first_sym = s->sh_offset / sizeof (ElfSym);
	nb_syms = s->data_offset / sizeof (ElfSym) - first_sym;
	s->data_offset = s->sh_offset;
	s->link->data_offset = s->link->sh_offset;
	s->hash = s->reloc, s->reloc = NULL;
	tr = tcc_mallocz(nb_syms * sizeof *tr);

	for (i = 0; i < nb_syms; ++i)
	{
		ElfSym *sym = (ElfSym*)s->data + first_sym + i;
		if (sym->st_shndx == SHN_UNDEF
		        && ELFW(ST_BIND)(sym->st_info) == STB_LOCAL)
			sym->st_info = ELFW(ST_INFO)(STB_GLOBAL, ELFW(ST_TYPE)(sym->st_info));
		tr[i] = set_elf_sym(s, sym->st_value, sym->st_size, sym->st_info,
		                    sym->st_other, sym->st_shndx, (char*)s->link->data + sym->st_name);
	}
	/* now update relocations */
	for (i = 1; i < s1->nb_sections; i++)
	{
		Section *sr = s1->sections[i];
		if (sr->sh_type == SHT_RELX && sr->link == s)
		{
			ElfW_Rel *rel = (ElfW_Rel*)(sr->data + sr->sh_offset);
			ElfW_Rel *rel_end = (ElfW_Rel*)(sr->data + sr->data_offset);
			for (; rel < rel_end; ++rel)
			{
				int n = ELFW(R_SYM)(rel->r_info) - first_sym;
				//if (n < 0) tcc_error("internal: invalid symbol index in relocation");
				rel->r_info = ELFW(R_INFO)(tr[n], ELFW(R_TYPE)(rel->r_info));
			}
		}
	}
	tcc_free(tr);
}

ST_FUNC Section *new_section(TCCState *s1, const char *name, int sh_type, int sh_flags)
{
	Section *sec;

	sec = tcc_mallocz(sizeof(Section) + strlen(name));
	sec->s1 = s1;
	strcpy(sec->name, name);
	sec->sh_type = sh_type;
	sec->sh_flags = sh_flags;
	switch(sh_type)
	{
	case SHT_GNU_versym:
		sec->sh_addralign = 2;
		break;
	case SHT_HASH:
	case SHT_REL:
	case SHT_RELA:
	case SHT_DYNSYM:
	case SHT_SYMTAB:
	case SHT_DYNAMIC:
	case SHT_GNU_verneed:
	case SHT_GNU_verdef:
		sec->sh_addralign = PTR_SIZE;
		break;
	case SHT_STRTAB:
		sec->sh_addralign = 1;
		break;
	default:
		sec->sh_addralign =  PTR_SIZE; /* gcc/pcc default alignment */
		break;
	}

	if (sh_flags & SHF_PRIVATE)
	{
		dynarray_add(&s1->priv_sections, &s1->nb_priv_sections, sec);
	}
	else
	{
		sec->sh_num = s1->nb_sections;
		dynarray_add(&s1->sections, &s1->nb_sections, sec);
	}

	return sec;
}

ST_FUNC Section *new_symtab(TCCState *s1,
                            const char *symtab_name, int sh_type, int sh_flags,
                            const char *strtab_name,
                            const char *hash_name, int hash_sh_flags)
{
	Section *symtab, *strtab, *hash;
	int *ptr, nb_buckets;

	symtab = new_section(s1, symtab_name, sh_type, sh_flags);
	symtab->sh_entsize = sizeof(ElfW(Sym));
	strtab = new_section(s1, strtab_name, SHT_STRTAB, sh_flags);
	put_elf_str(strtab, "");
	symtab->link = strtab;
	put_elf_sym(symtab, 0, 0, 0, 0, 0, NULL);

	nb_buckets = 1;

	hash = new_section(s1, hash_name, SHT_HASH, hash_sh_flags);
	hash->sh_entsize = sizeof(int);
	symtab->hash = hash;
	hash->link = symtab;

	ptr = section_ptr_add(hash, (2 + nb_buckets + 1) * sizeof(int));
	ptr[0] = nb_buckets;
	ptr[1] = 1;
	memset(ptr + 2, 0, (nb_buckets + 1) * sizeof(int));
	return symtab;
}

/* realloc section and set its content to zero */
ST_FUNC void section_realloc(Section *sec, unsigned long new_size)
{
	unsigned long size;
	unsigned char *data;

	size = sec->data_allocated;
	if (size == 0)
		size = 1;
	while (size < new_size)
		size = size * 2;
	data = tcc_realloc(sec->data, size);
	memset(data + sec->data_allocated, 0, size - sec->data_allocated);
	sec->data = data;
	sec->data_allocated = size;
}

/* reserve at least 'size' bytes aligned per 'align' in section
   'sec' from current offset, and return the aligned offset */
ST_FUNC size_t section_add(Section *sec, addr_t size, int align)
{
	size_t offset, offset1;

	offset = (sec->data_offset + align - 1) & -align;
	offset1 = offset + size;
	if (sec->sh_type != SHT_NOBITS && offset1 > sec->data_allocated)
		section_realloc(sec, offset1);
	sec->data_offset = offset1;
	if (align > sec->sh_addralign)
		sec->sh_addralign = align;
	return offset;
}

/* reserve at least 'size' bytes in section 'sec' from
   sec->data_offset. */
ST_FUNC void *section_ptr_add(Section *sec, addr_t size)
{
	size_t offset = section_add(sec, size, 1);
	return sec->data + offset;
}

/* reserve at least 'size' bytes from section start */
ST_FUNC void section_reserve(Section *sec, unsigned long size)
{
	if (size > sec->data_allocated)
		section_realloc(sec, size);
	if (size > sec->data_offset)
		sec->data_offset = size;
}

static Section *find_section_create (TCCState *s1, const char *name, int create)
{
	Section *sec;
	int i;
	for(i = 1; i < s1->nb_sections; i++)
	{
		sec = s1->sections[i];
		if (!strcmp(name, sec->name))
			return sec;
	}
	/* sections are created as PROGBITS */
	return create ? new_section(s1, name, SHT_PROGBITS, SHF_ALLOC) : NULL;
}

/* return a reference to a section, and create it if it does not
   exists */
ST_FUNC Section *find_section(TCCState *s1, const char *name)
{
	return find_section_create (s1, name, 1);
}

/* ------------------------------------------------------------------------- */

ST_FUNC int put_elf_str(Section *s, const char *sym)
{
	int offset, len;
	char *ptr;

	len = strlen(sym) + 1;
	offset = s->data_offset;
	ptr = section_ptr_add(s, len);
	memmove(ptr, sym, len);
	return offset;
}

/* elf symbol hashing function */
static unsigned long elf_hash(const unsigned char *name)
{
	unsigned long h = 0, g;

	while (*name)
	{
		h = (h << 4) + *name++;
		g = h & 0xf0000000;
		if (g)
			h ^= g >> 24;
		h &= ~g;
	}
	return h;
}

/* rebuild hash table of section s */
/* NOTE: we do factorize the hash table code to go faster */
static void rebuild_hash(Section *s, unsigned int nb_buckets)
{
	ElfW(Sym) *sym;
	int *ptr, *hash, nb_syms, sym_index, h;
	unsigned char *strtab;

	strtab = s->link->data;
	nb_syms = s->data_offset / sizeof(ElfW(Sym));

	if (!nb_buckets)
		nb_buckets = ((int*)s->hash->data)[0];

	s->hash->data_offset = 0;
	ptr = section_ptr_add(s->hash, (2 + nb_buckets + nb_syms) * sizeof(int));
	ptr[0] = nb_buckets;
	ptr[1] = nb_syms;
	ptr += 2;
	hash = ptr;
	memset(hash, 0, (nb_buckets + 1) * sizeof(int));
	ptr += nb_buckets + 1;

	sym = (ElfW(Sym) *)s->data + 1;
	for(sym_index = 1; sym_index < nb_syms; sym_index++)
	{
		if (ELFW(ST_BIND)(sym->st_info) != STB_LOCAL)
		{
			h = elf_hash(strtab + sym->st_name) % nb_buckets;
			*ptr = hash[h];
			hash[h] = sym_index;
		}
		else
		{
			*ptr = 0;
		}
		ptr++;
		sym++;
	}
}

/* return the symbol number */
ST_FUNC int put_elf_sym(Section *s, addr_t value, unsigned long size,
                        int info, int other, int shndx, const char *name)
{
	int name_offset, sym_index;
	int nbuckets, h;
	ElfW(Sym) *sym;
	Section *hs;

	sym = section_ptr_add(s, sizeof(ElfW(Sym)));
	if (name && name[0])
		name_offset = put_elf_str(s->link, name);
	else
		name_offset = 0;
	/* XXX: endianness */
	sym->st_name = name_offset;
	sym->st_value = value;
	sym->st_size = size;
	sym->st_info = info;
	sym->st_other = other;
	sym->st_shndx = shndx;
	sym_index = sym - (ElfW(Sym) *)s->data;
	hs = s->hash;
	if (hs)
	{
		int *ptr, *base;
		ptr = section_ptr_add(hs, sizeof(int));
		base = (int *)hs->data;
		/* only add global or weak symbols. */
		if (ELFW(ST_BIND)(info) != STB_LOCAL)
		{
			/* add another hashing entry */
			nbuckets = base[0];
			h = elf_hash((unsigned char *)s->link->data + name_offset) % nbuckets;
			*ptr = base[2 + h];
			base[2 + h] = sym_index;
			base[1]++;
			/* we resize the hash table */
			hs->nb_hashed_syms++;
			if (hs->nb_hashed_syms > 2 * nbuckets)
			{
				rebuild_hash(s, 2 * nbuckets);
			}
		}
		else
		{
			*ptr = 0;
			base[1]++;
		}
	}
	return sym_index;
}

ST_FUNC int find_elf_sym(Section *s, const char *name)
{
	ElfW(Sym) *sym;
	Section *hs;
	int nbuckets, sym_index, h;
	const char *name1;

	hs = s->hash;
	if (!hs)
		return 0;
	nbuckets = ((int *)hs->data)[0];
	h = elf_hash((unsigned char *) name) % nbuckets;
	sym_index = ((int *)hs->data)[2 + h];
	while (sym_index != 0)
	{
		sym = &((ElfW(Sym) *)s->data)[sym_index];
		name1 = (char *) s->link->data + sym->st_name;
		if (!strcmp(name, name1))
			return sym_index;
		sym_index = ((int *)hs->data)[2 + nbuckets + sym_index];
	}
	return 0;
}

/* return elf symbol value, signal error if 'err' is nonzero */
ST_FUNC addr_t get_elf_sym_addr(TCCState *s1, const char *name, int err)
{
	int sym_index;
	ElfW(Sym) *sym;

	sym_index = find_elf_sym(s1->symtab, name);
	sym = &((ElfW(Sym) *)s1->symtab->data)[sym_index];
	if (!sym_index || sym->st_shndx == SHN_UNDEF)
	{
		if (err)
			tcc_error("%s not defined", name);
		return 0;
	}
	return sym->st_value;
}

/* list elf symbol names and values */
ST_FUNC void list_elf_symbols(TCCState *s, void *ctx,
                              void (*symbol_cb)(void *ctx, const char *name, const void *val))
{
	ElfW(Sym) *sym;
	Section *symtab;
	int sym_index, end_sym;
	const char *name;
	unsigned char sym_vis, sym_bind;

	symtab = s->symtab;
	end_sym = symtab->data_offset / sizeof (ElfSym);
	for (sym_index = 0; sym_index < end_sym; ++sym_index)
	{
		sym = &((ElfW(Sym) *)symtab->data)[sym_index];
		if (sym->st_value)
		{
			name = (char *) symtab->link->data + sym->st_name;
			sym_bind = ELFW(ST_BIND)(sym->st_info);
			sym_vis = ELFW(ST_VISIBILITY)(sym->st_other);
			if (sym_bind == STB_GLOBAL && sym_vis == STV_DEFAULT)
				symbol_cb(ctx, name, (void*)(uintptr_t)sym->st_value);
		}
	}
}

/* return elf symbol value */
LIBTCCAPI void *tcc_get_symbol(TCCState *s, const char *name)
{
	return (void*)(uintptr_t)get_elf_sym_addr(s, name, 0);
}

/* list elf symbol names and values */
LIBTCCAPI void tcc_list_symbols(TCCState *s, void *ctx,
                                void (*symbol_cb)(void *ctx, const char *name, const void *val))
{
	list_elf_symbols(s, ctx, symbol_cb);
}

#if defined TCC_IS_NATIVE || defined TCC_TARGET_PE
/* return elf symbol value or error */
ST_FUNC void* tcc_get_symbol_err(TCCState *s, const char *name)
{
	return (void*)(uintptr_t)get_elf_sym_addr(s, name, 1);
}
#endif

#ifndef ELF_OBJ_ONLY
static void
version_add (TCCState *s1)
{
	int i;
	ElfW(Sym) *sym;
	ElfW(Verneed) *vn = NULL;
	Section *symtab;
	int sym_index, end_sym, nb_versions = 2, nb_entries = 0;
	ElfW(Half) *versym;
	const char *name;

	if (0 == nb_sym_versions)
		return;
	versym_section = new_section(s1, ".gnu.version", SHT_GNU_versym, SHF_ALLOC);
	versym_section->sh_entsize = sizeof(ElfW(Half));
	versym_section->link = s1->dynsym;

	/* add needed symbols */
	symtab = s1->dynsym;
	end_sym = symtab->data_offset / sizeof (ElfSym);
	versym = section_ptr_add(versym_section, end_sym * sizeof(ElfW(Half)));
	for (sym_index = 0; sym_index < end_sym; ++sym_index)
	{
		int dllindex, verndx;
		sym = &((ElfW(Sym) *)symtab->data)[sym_index];
		name = (char *) symtab->link->data + sym->st_name;
		dllindex = find_elf_sym(s1->dynsymtab_section, name);
		verndx = (dllindex && dllindex < nb_sym_to_version)
		         ? sym_to_version[dllindex] : -1;
		if (verndx >= 0)
		{
			if (!sym_versions[verndx].out_index)
				sym_versions[verndx].out_index = nb_versions++;
			versym[sym_index] = sym_versions[verndx].out_index;
		}
		else
			versym[sym_index] = 0;
	}
	/* generate verneed section, but not when it will be empty.  Some
	   dynamic linkers look at their contents even when DTVERNEEDNUM and
	   section size is zero.  */
	if (nb_versions > 2)
	{
		verneed_section = new_section(s1, ".gnu.version_r",
		                              SHT_GNU_verneed, SHF_ALLOC);
		verneed_section->link = s1->dynsym->link;
		for (i = nb_sym_versions; i-- > 0;)
		{
			struct sym_version *sv = &sym_versions[i];
			int n_same_libs = 0, prev;
			size_t vnofs;
			ElfW(Vernaux) *vna = 0;
			if (sv->out_index < 1)
				continue;
			vnofs = section_add(verneed_section, sizeof(*vn), 1);
			vn = (ElfW(Verneed)*)(verneed_section->data + vnofs);
			vn->vn_version = 1;
			vn->vn_file = put_elf_str(verneed_section->link, sv->lib);
			vn->vn_aux = sizeof (*vn);
			do
			{
				prev = sv->prev_same_lib;
				if (sv->out_index > 0)
				{
					vna = section_ptr_add(verneed_section, sizeof(*vna));
					vna->vna_hash = elf_hash ((const unsigned char *)sv->version);
					vna->vna_flags = 0;
					vna->vna_other = sv->out_index;
					sv->out_index = -2;
					vna->vna_name = put_elf_str(verneed_section->link, sv->version);
					vna->vna_next = sizeof (*vna);
					n_same_libs++;
				}
				if (prev >= 0)
					sv = &sym_versions[prev];
			}
			while(prev >= 0);
			vna->vna_next = 0;
			vn = (ElfW(Verneed)*)(verneed_section->data + vnofs);
			vn->vn_cnt = n_same_libs;
			vn->vn_next = sizeof(*vn) + n_same_libs * sizeof(*vna);
			nb_entries++;
		}
		if (vn)
			vn->vn_next = 0;
		verneed_section->sh_info = nb_entries;
	}
	dt_verneednum = nb_entries;
}
#endif

/* add an elf symbol : check if it is already defined and patch
   it. Return symbol index. NOTE that sh_num can be SHN_UNDEF. */
ST_FUNC int set_elf_sym(Section *s, addr_t value, unsigned long size,
                        int info, int other, int shndx, const char *name)
{
	TCCState *s1 = s->s1;
	ElfW(Sym) *esym;
	int sym_bind, sym_index, sym_type, esym_bind;
	unsigned char sym_vis, esym_vis, new_vis;

	sym_bind = ELFW(ST_BIND)(info);
	sym_type = ELFW(ST_TYPE)(info);
	sym_vis = ELFW(ST_VISIBILITY)(other);

	if (sym_bind != STB_LOCAL)
	{
		/* we search global or weak symbols */
		sym_index = find_elf_sym(s, name);
		if (!sym_index)
			goto do_def;
		esym = &((ElfW(Sym) *)s->data)[sym_index];
		if (esym->st_value == value && esym->st_size == size && esym->st_info == info
		        && esym->st_other == other && esym->st_shndx == shndx)
			return sym_index;
		if (esym->st_shndx != SHN_UNDEF)
		{
			esym_bind = ELFW(ST_BIND)(esym->st_info);
			/* propagate the most constraining visibility */
			/* STV_DEFAULT(0)<STV_PROTECTED(3)<STV_HIDDEN(2)<STV_INTERNAL(1) */
			esym_vis = ELFW(ST_VISIBILITY)(esym->st_other);
			if (esym_vis == STV_DEFAULT)
			{
				new_vis = sym_vis;
			}
			else if (sym_vis == STV_DEFAULT)
			{
				new_vis = esym_vis;
			}
			else
			{
				new_vis = (esym_vis < sym_vis) ? esym_vis : sym_vis;
			}
			esym->st_other = (esym->st_other & ~ELFW(ST_VISIBILITY)(-1))
			                 | new_vis;
			other = esym->st_other; /* in case we have to patch esym */
			if (shndx == SHN_UNDEF)
			{
				/* ignore adding of undefined symbol if the
				   corresponding symbol is already defined */
			}
			else if (sym_bind == STB_GLOBAL && esym_bind == STB_WEAK)
			{
				/* global overrides weak, so patch */
				goto do_patch;
			}
			else if (sym_bind == STB_WEAK && esym_bind == STB_GLOBAL)
			{
				/* weak is ignored if already global */
			}
			else if (sym_bind == STB_WEAK && esym_bind == STB_WEAK)
			{
				/* keep first-found weak definition, ignore subsequents */
			}
			else if (sym_vis == STV_HIDDEN || sym_vis == STV_INTERNAL)
			{
				/* ignore hidden symbols after */
			}
			else if ((esym->st_shndx == SHN_COMMON
			          || esym->st_shndx == bss_section->sh_num)
			         && (shndx < SHN_LORESERVE
			             && shndx != bss_section->sh_num))
			{
				/* data symbol gets precedence over common/bss */
				goto do_patch;
			}
			else if (shndx == SHN_COMMON || shndx == bss_section->sh_num)
			{
				/* data symbol keeps precedence over common/bss */
			}
			else if (s->sh_flags & SHF_DYNSYM)
			{
				/* we accept that two DLL define the same symbol */
			}
			else if (esym->st_other & ST_ASM_SET)
			{
				/* If the existing symbol came from an asm .set
				   we can override.  */
				goto do_patch;
			}
			else
			{
#if 0
				printf("new_bind=%x new_shndx=%x new_vis=%x old_bind=%x old_shndx=%x old_vis=%x\n",
				       sym_bind, shndx, new_vis, esym_bind, esym->st_shndx, esym_vis);
#endif
				tcc_error_noabort("'%s' defined twice", name);
			}
		}
		else
		{
do_patch:
			esym->st_info = ELFW(ST_INFO)(sym_bind, sym_type);
			esym->st_shndx = shndx;
			s1->new_undef_sym = 1;
			esym->st_value = value;
			esym->st_size = size;
			esym->st_other = other;
		}
	}
	else
	{
do_def:
		sym_index = put_elf_sym(s, value, size,
		                        ELFW(ST_INFO)(sym_bind, sym_type), other,
		                        shndx, name);
	}
	return sym_index;
}

/* put relocation */
ST_FUNC void put_elf_reloca(Section *symtab, Section *s, unsigned long offset,
                            int type, int symbol, addr_t addend)
{
	TCCState *s1 = s->s1;
	char buf[256];
	Section *sr;
	ElfW_Rel *rel;

	sr = s->reloc;
	if (!sr)
	{
		/* if no relocation section, create it */
		snprintf(buf, sizeof(buf), REL_SECTION_FMT, s->name);
		/* if the symtab is allocated, then we consider the relocation
		   are also */
		sr = new_section(s->s1, buf, SHT_RELX, symtab->sh_flags);
		sr->sh_entsize = sizeof(ElfW_Rel);
		sr->link = symtab;
		sr->sh_info = s->sh_num;
		s->reloc = sr;
	}
	rel = section_ptr_add(sr, sizeof(ElfW_Rel));
	rel->r_offset = offset;
	rel->r_info = ELFW(R_INFO)(symbol, type);
#if SHT_RELX == SHT_RELA
	rel->r_addend = addend;
#endif
	if (SHT_RELX != SHT_RELA && addend)
		tcc_error("non-zero addend on REL architecture");
}

ST_FUNC void put_elf_reloc(Section *symtab, Section *s, unsigned long offset,
                           int type, int symbol)
{
	put_elf_reloca(symtab, s, offset, type, symbol, 0);
}

/* Remove relocations for section S->reloc starting at oldrelocoffset
   that are to the same place, retaining the last of them.  As side effect
   the relocations are sorted.  Possibly reduces the number of relocs.  */
ST_FUNC void squeeze_multi_relocs(Section *s, size_t oldrelocoffset)
{
	Section *sr = s->reloc;
	ElfW_Rel *r, *dest;
	ssize_t a;
	ElfW(Addr) addr;

	if (oldrelocoffset + sizeof(*r) >= sr->data_offset)
		return;
	/* The relocs we're dealing with are the result of initializer parsing.
	   So they will be mostly in order and there aren't many of them.
	   Secondly we need a stable sort (which qsort isn't).  We use
	   a simple insertion sort.  */
	for (a = oldrelocoffset + sizeof(*r); a < sr->data_offset; a += sizeof(*r))
	{
		ssize_t i = a - sizeof(*r);
		addr = ((ElfW_Rel*)(sr->data + a))->r_offset;
		for (; i >= (ssize_t)oldrelocoffset &&
		        ((ElfW_Rel*)(sr->data + i))->r_offset > addr; i -= sizeof(*r))
		{
			ElfW_Rel tmp = *(ElfW_Rel*)(sr->data + a);
			*(ElfW_Rel*)(sr->data + a) = *(ElfW_Rel*)(sr->data + i);
			*(ElfW_Rel*)(sr->data + i) = tmp;
		}
	}

	r = (ElfW_Rel*)(sr->data + oldrelocoffset);
	dest = r;
	for (; r < (ElfW_Rel*)(sr->data + sr->data_offset); r++)
	{
		if (dest->r_offset != r->r_offset)
			dest++;
		*dest = *r;
	}
	sr->data_offset = (unsigned char*)dest - sr->data + sizeof(*r);
}

/* put stab debug information */

ST_FUNC void put_stabs(TCCState *s1, const char *str, int type, int other, int desc,
                       unsigned long value)
{
	Stab_Sym *sym;

	unsigned offset;
	if (type == N_SLINE
	        && (offset = stab_section->data_offset)
	        && (sym = (Stab_Sym*)(stab_section->data + offset) - 1)
	        && sym->n_type == type
	        && sym->n_value == value)
	{
		/* just update line_number in previous entry */
		sym->n_desc = desc;
		return;
	}

	sym = section_ptr_add(stab_section, sizeof(Stab_Sym));
	if (str)
	{
		sym->n_strx = put_elf_str(stab_section->link, str);
	}
	else
	{
		sym->n_strx = 0;
	}
	sym->n_type = type;
	sym->n_other = other;
	sym->n_desc = desc;
	sym->n_value = value;
}

ST_FUNC void put_stabs_r(TCCState *s1, const char *str, int type, int other, int desc,
                         unsigned long value, Section *sec, int sym_index)
{
	put_elf_reloc(symtab_section, stab_section,
	              stab_section->data_offset + 8,
	              sizeof ((Stab_Sym*)0)->n_value == PTR_SIZE ? R_DATA_PTR : R_DATA_32,
	              sym_index);
	put_stabs(s1, str, type, other, desc, value);
}

ST_FUNC void put_stabn(TCCState *s1, int type, int other, int desc, int value)
{
	put_stabs(s1, NULL, type, other, desc, value);
}

ST_FUNC struct sym_attr *get_sym_attr(TCCState *s1, int index, int alloc)
{
	int n;
	struct sym_attr *tab;

	if (index >= s1->nb_sym_attrs)
	{
		if (!alloc)
			return s1->sym_attrs;
		/* find immediately bigger power of 2 and reallocate array */
		n = 1;
		while (index >= n)
			n *= 2;
		tab = tcc_realloc(s1->sym_attrs, n * sizeof(*s1->sym_attrs));
		s1->sym_attrs = tab;
		memset(s1->sym_attrs + s1->nb_sym_attrs, 0,
		       (n - s1->nb_sym_attrs) * sizeof(*s1->sym_attrs));
		s1->nb_sym_attrs = n;
	}
	return &s1->sym_attrs[index];
}

/* Browse each elem of type <type> in section <sec> starting at elem <startoff>
   using variable <elem> */
#define for_each_elem(sec, startoff, elem, type) \
    for (elem = (type *) sec->data + startoff; \
         elem < (type *) (sec->data + sec->data_offset); elem++)

/* In an ELF file symbol table, the local symbols must appear below
   the global and weak ones. Since TCC cannot sort it while generating
   the code, we must do it after. All the relocation tables are also
   modified to take into account the symbol table sorting */
static void sort_syms(TCCState *s1, Section *s)
{
	int *old_to_new_syms;
	ElfW(Sym) *new_syms;
	int nb_syms, i;
	ElfW(Sym) *p, *q;
	ElfW_Rel *rel;
	Section *sr;
	int type, sym_index;

	nb_syms = s->data_offset / sizeof(ElfW(Sym));
	new_syms = tcc_malloc(nb_syms * sizeof(ElfW(Sym)));
	old_to_new_syms = tcc_malloc(nb_syms * sizeof(int));

	/* first pass for local symbols */
	p = (ElfW(Sym) *)s->data;
	q = new_syms;
	for(i = 0; i < nb_syms; i++)
	{
		if (ELFW(ST_BIND)(p->st_info) == STB_LOCAL)
		{
			old_to_new_syms[i] = q - new_syms;
			*q++ = *p;
		}
		p++;
	}
	/* save the number of local symbols in section header */
	if( s->sh_size )    /* this 'if' makes IDA happy */
		s->sh_info = q - new_syms;

	/* then second pass for non local symbols */
	p = (ElfW(Sym) *)s->data;
	for(i = 0; i < nb_syms; i++)
	{
		if (ELFW(ST_BIND)(p->st_info) != STB_LOCAL)
		{
			old_to_new_syms[i] = q - new_syms;
			*q++ = *p;
		}
		p++;
	}

	/* we copy the new symbols to the old */
	memcpy(s->data, new_syms, nb_syms * sizeof(ElfW(Sym)));
	tcc_free(new_syms);

	/* now we modify all the relocations */
	for(i = 1; i < s1->nb_sections; i++)
	{
		sr = s1->sections[i];
		if (sr->sh_type == SHT_RELX && sr->link == s)
		{
			for_each_elem(sr, 0, rel, ElfW_Rel)
			{
				sym_index = ELFW(R_SYM)(rel->r_info);
				type = ELFW(R_TYPE)(rel->r_info);
				sym_index = old_to_new_syms[sym_index];
				rel->r_info = ELFW(R_INFO)(sym_index, type);
			}
		}
	}

	tcc_free(old_to_new_syms);
}

/* relocate symbol table, resolve undefined symbols if do_resolve is
   true and output error if undefined symbol. */
ST_FUNC void relocate_syms(TCCState *s1, Section *symtab, int do_resolve)
{
	ElfW(Sym) *sym;
	int sym_bind, sh_num;
	const char *name;

	for_each_elem(symtab, 1, sym, ElfW(Sym))
	{
		sh_num = sym->st_shndx;
		if (sh_num == SHN_UNDEF)
		{
			name = (char *) s1->symtab->link->data + sym->st_name;
			/* Use ld.so to resolve symbol for us (for tcc -run) */
			if (do_resolve)
			{
#if defined TCC_IS_NATIVE && !defined TCC_TARGET_PE
				void *addr = dlsym(RTLD_DEFAULT, name);
				if (addr)
				{
					sym->st_value = (addr_t) addr;
#ifdef DEBUG_RELOC
					printf ("relocate_sym: %s -> 0x%lx\n", name, sym->st_value);
#endif
					goto found;
				}
#endif
				/* if dynamic symbol exist, it will be used in relocate_section */
			}
			else if (s1->dynsym && find_elf_sym(s1->dynsym, name))
				goto found;
			/* XXX: _fp_hw seems to be part of the ABI, so we ignore
			   it */
			if (!strcmp(name, "_fp_hw"))
				goto found;
			/* only weak symbols are accepted to be undefined. Their
			   value is zero */
			sym_bind = ELFW(ST_BIND)(sym->st_info);
			if (sym_bind == STB_WEAK)
				sym->st_value = 0;
			else
				tcc_error_noabort("undefined symbol '%s'", name);
		}
		else if (sh_num < SHN_LORESERVE)
		{
			/* add section base */
			sym->st_value += s1->sections[sym->st_shndx]->sh_addr;
		}
found:
		;
	}
}

/* relocate a given section (CPU dependent) by applying the relocations
   in the associated relocation section */
ST_FUNC void relocate_section(TCCState *s1, Section *s)
{
	Section *sr = s->reloc;
	ElfW_Rel *rel;
	ElfW(Sym) *sym;
	int type, sym_index;
	unsigned char *ptr;
	addr_t tgt, addr;

	qrel = (ElfW_Rel *)sr->data;

	for_each_elem(sr, 0, rel, ElfW_Rel)
	{
		ptr = s->data + rel->r_offset;
		sym_index = ELFW(R_SYM)(rel->r_info);
		sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];
		type = ELFW(R_TYPE)(rel->r_info);
		tgt = sym->st_value;
#if SHT_RELX == SHT_RELA
		tgt += rel->r_addend;
#endif
		addr = s->sh_addr + rel->r_offset;
		relocate(s1, rel, type, ptr, addr, tgt);
	}
	/* if the relocation is allocated, we change its symbol table */
	if (sr->sh_flags & SHF_ALLOC)
	{
		sr->link = s1->dynsym;
		if (s1->output_type == TCC_OUTPUT_DLL)
		{
			size_t r = (uint8_t*)qrel - sr->data;
			if (sizeof ((Stab_Sym*)0)->n_value < PTR_SIZE
			        && 0 == strcmp(s->name, ".stab"))
				r = 0; /* cannot apply 64bit relocation to 32bit value */
			sr->data_offset = sr->sh_size = r;
		}
	}
}

#ifndef ELF_OBJ_ONLY
/* relocate relocation table in 'sr' */
static void relocate_rel(TCCState *s1, Section *sr)
{
	Section *s;
	ElfW_Rel *rel;

	s = s1->sections[sr->sh_info];
	for_each_elem(sr, 0, rel, ElfW_Rel)
	rel->r_offset += s->sh_addr;
}

/* count the number of dynamic relocations so that we can reserve
   their space */
static int prepare_dynamic_rel(TCCState *s1, Section *sr)
{
	int count = 0;
#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
	ElfW_Rel *rel;
	for_each_elem(sr, 0, rel, ElfW_Rel)
	{
		int sym_index = ELFW(R_SYM)(rel->r_info);
		int type = ELFW(R_TYPE)(rel->r_info);
		switch(type)
		{
#if defined(TCC_TARGET_I386)
		case R_386_32:
			if (!get_sym_attr(s1, sym_index, 0)->dyn_index
			        && ((ElfW(Sym)*)symtab_section->data + sym_index)->st_shndx == SHN_UNDEF)
			{
				/* don't fixup unresolved (weak) symbols */
				rel->r_info = ELFW(R_INFO)(sym_index, R_386_RELATIVE);
				break;
			}
#elif defined(TCC_TARGET_X86_64)
		case R_X86_64_32:
		case R_X86_64_32S:
		case R_X86_64_64:
#endif
			count++;
			break;
#if defined(TCC_TARGET_I386)
		case R_386_PC32:
#elif defined(TCC_TARGET_X86_64)
		case R_X86_64_PC32:
#endif
			if (get_sym_attr(s1, sym_index, 0)->dyn_index)
				count++;
			break;
		default:
			break;
		}
	}
	if (count)
	{
		/* allocate the section */
		sr->sh_flags |= SHF_ALLOC;
		sr->sh_size = count * sizeof(ElfW_Rel);
	}
#endif
	return count;
}

static void build_got(TCCState *s1)
{
	/* if no got, then create it */
	s1->got = new_section(s1, ".got", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);
	s1->got->sh_entsize = 4;
	set_elf_sym(symtab_section, 0, 4, ELFW(ST_INFO)(STB_GLOBAL, STT_OBJECT),
	            0, s1->got->sh_num, "_GLOBAL_OFFSET_TABLE_");
	/* keep space for _DYNAMIC pointer and two dummy got entries */
	section_ptr_add(s1->got, 3 * PTR_SIZE);
}

/* Create a GOT and (for function call) a PLT entry corresponding to a symbol
   in s1->symtab. When creating the dynamic symbol table entry for the GOT
   relocation, use 'size' and 'info' for the corresponding symbol metadata.
   Returns the offset of the GOT or (if any) PLT entry. */
static struct sym_attr * put_got_entry(TCCState *s1, int dyn_reloc_type,
                                       int sym_index)
{
	int need_plt_entry;
	const char *name;
	ElfW(Sym) *sym;
	struct sym_attr *attr;
	unsigned got_offset;
	char plt_name[100];
	int len;

	need_plt_entry = (dyn_reloc_type == R_JMP_SLOT);
	attr = get_sym_attr(s1, sym_index, 1);

	/* In case a function is both called and its address taken 2 GOT entries
	   are created, one for taking the address (GOT) and the other for the PLT
	   entry (PLTGOT).  */
	if (need_plt_entry ? attr->plt_offset : attr->got_offset)
		return attr;

	/* create the GOT entry */
	got_offset = s1->got->data_offset;
	section_ptr_add(s1->got, PTR_SIZE);

	/* Create the GOT relocation that will insert the address of the object or
	   function of interest in the GOT entry. This is a static relocation for
	   memory output (dlsym will give us the address of symbols) and dynamic
	   relocation otherwise (executable and DLLs). The relocation should be
	   done lazily for GOT entry with *_JUMP_SLOT relocation type (the one
	   associated to a PLT entry) but is currently done at load time for an
	   unknown reason. */

	sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];
	name = (char *) symtab_section->link->data + sym->st_name;

	if (s1->dynsym)
	{
		if (ELFW(ST_BIND)(sym->st_info) == STB_LOCAL)
		{
			/* Hack alarm.  We don't want to emit dynamic symbols
			   and symbol based relocs for STB_LOCAL symbols, but rather
			   want to resolve them directly.  At this point the symbol
			   values aren't final yet, so we must defer this.  We will later
			   have to create a RELATIVE reloc anyway, so we misuse the
			   relocation slot to smuggle the symbol reference until
			   fill_local_got_entries.  Not that the sym_index is
			   relative to symtab_section, not s1->dynsym!  Nevertheless
			   we use s1->dyn_sym so that if this is the first call
			   that got->reloc is correctly created.  Also note that
			   RELATIVE relocs are not normally created for the .got,
			   so the types serves as a marker for later (and is retained
			   also for the final output, which is okay because then the
			   got is just normal data).  */
			put_elf_reloc(s1->dynsym, s1->got, got_offset, R_RELATIVE,
			              sym_index);
		}
		else
		{
			if (0 == attr->dyn_index)
				attr->dyn_index = set_elf_sym(s1->dynsym, sym->st_value,
				                              sym->st_size, sym->st_info, 0,
				                              sym->st_shndx, name);
			put_elf_reloc(s1->dynsym, s1->got, got_offset, dyn_reloc_type,
			              attr->dyn_index);
		}
	}
	else
	{
		put_elf_reloc(symtab_section, s1->got, got_offset, dyn_reloc_type,
		              sym_index);
	}

	if (need_plt_entry)
	{
		if (!s1->plt)
		{
			s1->plt = new_section(s1, ".plt", SHT_PROGBITS,
			                      SHF_ALLOC | SHF_EXECINSTR);
			s1->plt->sh_entsize = 4;
		}

		attr->plt_offset = create_plt_entry(s1, got_offset, attr);

		/* create a symbol 'sym@plt' for the PLT jump vector */
		len = strlen(name);
		if (len > sizeof plt_name - 5)
			len = sizeof plt_name - 5;
		memcpy(plt_name, name, len);
		strcpy(plt_name + len, "@plt");
		attr->plt_sym = put_elf_sym(s1->symtab, attr->plt_offset, sym->st_size,
		                            ELFW(ST_INFO)(STB_GLOBAL, STT_FUNC), 0, s1->plt->sh_num, plt_name);

	}
	else
	{
		attr->got_offset = got_offset;
	}

	return attr;
}

/* build GOT and PLT entries */
ST_FUNC void build_got_entries(TCCState *s1)
{
	Section *s;
	ElfW_Rel *rel;
	ElfW(Sym) *sym;
	int i, type, gotplt_entry, reloc_type, sym_index;
	struct sym_attr *attr;

	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if (s->sh_type != SHT_RELX)
			continue;
		/* no need to handle got relocations */
		if (s->link != symtab_section)
			continue;
		for_each_elem(s, 0, rel, ElfW_Rel)
		{
			type = ELFW(R_TYPE)(rel->r_info);
			gotplt_entry = gotplt_entry_type(type);
			if (gotplt_entry == -1)
				tcc_error ("Unknown relocation type for got: %d", type);
			sym_index = ELFW(R_SYM)(rel->r_info);
			sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];

			if (gotplt_entry == NO_GOTPLT_ENTRY)
			{
				continue;
			}

			/* Automatically create PLT/GOT [entry] if it is an undefined
			reference (resolved at runtime), or the symbol is absolute,
			probably created by tcc_add_symbol, and thus on 64-bit
			targets might be too far from application code.  */
			if (gotplt_entry == AUTO_GOTPLT_ENTRY)
			{
				if (sym->st_shndx == SHN_UNDEF)
				{
					ElfW(Sym) *esym;
					int dynindex;
					if (s1->output_type == TCC_OUTPUT_DLL && ! PCRELATIVE_DLLPLT)
						continue;
					/* Relocations for UNDEF symbols would normally need
					   to be transferred into the executable or shared object.
					   If that were done AUTO_GOTPLT_ENTRY wouldn't exist.
					   But TCC doesn't do that (at least for exes), so we
					   need to resolve all such relocs locally.  And that
					   means PLT slots for functions in DLLs and COPY relocs for
					   data symbols.  COPY relocs were generated in
					   bind_exe_dynsyms (and the symbol adjusted to be defined),
					   and for functions we were generated a dynamic symbol
					   of function type.  */
					if (s1->dynsym)
					{
						/* dynsym isn't set for -run :-/  */
						dynindex = get_sym_attr(s1, sym_index, 0)->dyn_index;
						esym = (ElfW(Sym) *)s1->dynsym->data + dynindex;
						if (dynindex
						        && (ELFW(ST_TYPE)(esym->st_info) == STT_FUNC
						            || (ELFW(ST_TYPE)(esym->st_info) == STT_NOTYPE
						                && ELFW(ST_TYPE)(sym->st_info) == STT_FUNC)))
							goto jmp_slot;
					}
				}
				else if (!(sym->st_shndx == SHN_ABS
#ifndef TCC_TARGET_ARM
				           && PTR_SIZE == 8
#endif
				          ))
					continue;
			}

#ifdef TCC_TARGET_X86_64
			if ((type == R_X86_64_PLT32 || type == R_X86_64_PC32) &&
			        sym->st_shndx != SHN_UNDEF &&
			        (ELFW(ST_VISIBILITY)(sym->st_other) != STV_DEFAULT ||
			         ELFW(ST_BIND)(sym->st_info) == STB_LOCAL ||
			         s1->output_type == TCC_OUTPUT_EXE))
			{
				rel->r_info = ELFW(R_INFO)(sym_index, R_X86_64_PC32);
				continue;
			}
#endif
			reloc_type = code_reloc(type);
			if (reloc_type == -1)
				tcc_error ("Unknown relocation type: %d", type);
			else if (reloc_type != 0)
			{
jmp_slot:
				reloc_type = R_JMP_SLOT;
			}
			else
				reloc_type = R_GLOB_DAT;

			if (!s1->got)
				build_got(s1);

			if (gotplt_entry == BUILD_GOT_ONLY)
				continue;

			attr = put_got_entry(s1, reloc_type, sym_index);

			if (reloc_type == R_JMP_SLOT)
				rel->r_info = ELFW(R_INFO)(attr->plt_sym, type);
		}
	}
}

/* put dynamic tag */
static void put_dt(Section *dynamic, int dt, addr_t val)
{
	ElfW(Dyn) *dyn;
	dyn = section_ptr_add(dynamic, sizeof(ElfW(Dyn)));
	dyn->d_tag = dt;
	dyn->d_un.d_val = val;
}
#endif

ST_FUNC int set_global_sym(TCCState *s1, const char *name, Section *sec, long offs)
{
	int shn = sec ? sec->sh_num : offs ? SHN_ABS : SHN_UNDEF;
	if (sec && offs == -1)
		offs = sec->data_offset;
	return set_elf_sym(symtab_section, offs, 0,
	                   ELFW(ST_INFO)(name ? STB_GLOBAL : STB_LOCAL, STT_NOTYPE), 0, shn, name);
}

static void add_init_array_defines(TCCState *s1, const char *section_name)
{
	Section *s;
	long end_offset;
	char buf[1024];
	s = find_section(s1, section_name);
	if (!s)
	{
		end_offset = 0;
		s = data_section;
	}
	else
	{
		end_offset = s->data_offset;
	}
	snprintf(buf, sizeof(buf), "__%s_start", section_name + 1);
	set_global_sym(s1, buf, s, 0);
	snprintf(buf, sizeof(buf), "__%s_end", section_name + 1);
	set_global_sym(s1, buf, s, end_offset);
}

#ifndef TCC_TARGET_PE
static int tcc_add_support(TCCState *s1, const char *filename)
{
	char buf[1024];
	snprintf(buf, sizeof(buf), "%s/%s", s1->tcc_lib_path, filename);
	return tcc_add_file(s1, buf);
}
#endif

ST_FUNC void add_array (TCCState *s1, const char *sec, int c)
{
	Section *s;
	s = find_section(s1, sec);
	s->sh_flags |= SHF_WRITE;
#ifndef TCC_TARGET_PE
	s->sh_type = sec[1] == 'i' ? SHT_INIT_ARRAY : SHT_FINI_ARRAY;
#endif
	put_elf_reloc (s1->symtab, s, s->data_offset, R_DATA_PTR, c);
	section_ptr_add(s, PTR_SIZE);
}

#ifdef CONFIG_TCC_BCHECK
ST_FUNC void tcc_add_bcheck(TCCState *s1)
{
	if (0 == s1->do_bounds_check)
		return;
	section_ptr_add(bounds_section, sizeof(addr_t));
}
#endif

#ifdef CONFIG_TCC_BACKTRACE
static void put_ptr(TCCState *s1, Section *s, int offs)
{
	int c;
	c = set_global_sym(s1, NULL, s, offs);
	s = data_section;
	put_elf_reloc (s1->symtab, s, s->data_offset, R_DATA_PTR, c);
	section_ptr_add(s, PTR_SIZE);
}

/* set symbol to STB_LOCAL and resolve. The point is to not export it as
   a dynamic symbol to allow so's to have one each with a different value. */
static void set_local_sym(TCCState *s1, const char *name, Section *s, int offset)
{
	int c = find_elf_sym(s1->symtab, name);
	if (c)
	{
		ElfW(Sym) *esym = (ElfW(Sym)*)s1->symtab->data + c;
		esym->st_info = ELFW(ST_INFO)(STB_LOCAL, STT_NOTYPE);
		esym->st_value = offset;
		esym->st_shndx = s->sh_num;
	}
}

ST_FUNC void tcc_add_btstub(TCCState *s1)
{
	Section *s;
	int n, o;
	CString cstr;

	s = data_section;
	o = s->data_offset;
	/* create (part of) a struct rt_context (see tccrun.c) */
	put_ptr(s1, stab_section, 0);
	put_ptr(s1, stab_section, -1);
	put_ptr(s1, stab_section->link, 0);
	section_ptr_add(s, 3 * PTR_SIZE);
	/* prog_base */
	put_elf_reloc(s1->symtab, s, s->data_offset, R_DATA_PTR, 0);
	section_ptr_add(s, PTR_SIZE);
	n = 2 * PTR_SIZE;
#ifdef CONFIG_TCC_BCHECK
	if (s1->do_bounds_check)
	{
		put_ptr(s1, bounds_section, 0);
		n -= PTR_SIZE;
	}
#endif
	section_ptr_add(s, n);

	cstr_new(&cstr);
	cstr_printf(&cstr,
	            " extern void __bt_init(),*__rt_info[],__bt_init_dll();"
	            "__attribute__((constructor)) static void __bt_init_rt(){");
#ifdef TCC_TARGET_PE
	if (s1->output_type == TCC_OUTPUT_DLL)
#ifdef CONFIG_TCC_BCHECK
		cstr_printf(&cstr, "__bt_init_dll(%d);", s1->do_bounds_check);
#else
		cstr_printf(&cstr, "__bt_init_dll(0);");
#endif
#endif
	cstr_printf(&cstr, "__bt_init(__rt_info,%d);}",
	            s1->output_type == TCC_OUTPUT_DLL ? 0 : s1->rt_num_callers + 1);
	tcc_compile_string(s1, cstr.data);
	cstr_free(&cstr);
	set_local_sym(s1, "__rt_info", s, o);
}
#endif

#ifndef TCC_TARGET_PE
/* add tcc runtime libraries */
ST_FUNC void tcc_add_runtime(TCCState *s1)
{
	s1->filetype = 0;
#ifdef CONFIG_TCC_BCHECK
	tcc_add_bcheck(s1);
#endif
	tcc_add_pragma_libs(s1);
	/* add libc */
	if (!s1->nostdlib)
	{
		tcc_add_library_err(s1, "c");
#ifdef TCC_LIBGCC
		if (!s1->static_link)
		{
			if (TCC_LIBGCC[0] == '/')
				tcc_add_file(s1, TCC_LIBGCC);
			else
				tcc_add_dll(s1, TCC_LIBGCC, 0);
		}
#endif
#ifdef CONFIG_TCC_BCHECK
		if (s1->do_bounds_check && s1->output_type != TCC_OUTPUT_DLL)
		{
			tcc_add_library_err(s1, "pthread");
			tcc_add_library_err(s1, "dl");
			tcc_add_support(s1, "bcheck.o");
		}
#endif
#ifdef CONFIG_TCC_BACKTRACE
		if (s1->do_backtrace)
		{
			if (s1->output_type == TCC_OUTPUT_EXE)
				tcc_add_support(s1, "bt-exe.o");
			if (s1->output_type != TCC_OUTPUT_DLL)
				tcc_add_support(s1, "bt-log.o");
			if (s1->output_type != TCC_OUTPUT_MEMORY)
				tcc_add_btstub(s1);
		}
#endif
#ifdef TCC_LIBTCC1
		tcc_add_support(s1, TCC_LIBTCC1);
#endif
		/* add crt end if not memory output */
		if (s1->output_type != TCC_OUTPUT_MEMORY)
			tcc_add_crt(s1, "crtn.o");
	}
}
#endif

/* add various standard linker symbols (must be done after the
   sections are filled (for example after allocating common
   symbols)) */
static void tcc_add_linker_symbols(TCCState *s1)
{
	char buf[1024];
	int i;
	Section *s;

	set_global_sym(s1, "_etext", text_section, -1);
	set_global_sym(s1, "_edata", data_section, -1);
	set_global_sym(s1, "_end", bss_section, -1);
#ifdef TCC_TARGET_RISCV64
	/* XXX should be .sdata+0x800, not .data+0x800 */
	set_global_sym(s1, "__global_pointer$", data_section, 0x800);
#endif
	/* horrible new standard ldscript defines */
	add_init_array_defines(s1, ".preinit_array");
	add_init_array_defines(s1, ".init_array");
	add_init_array_defines(s1, ".fini_array");
	/* add start and stop symbols for sections whose name can be
	   expressed in C */
	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if ((s->sh_flags & SHF_ALLOC)
		        && (s->sh_type == SHT_PROGBITS
		            || s->sh_type == SHT_STRTAB))
		{
			const char *p;
			/* check if section name can be expressed in C */
			p = s->name;
			for(;;)
			{
				int c = *p;
				if (!c)
					break;
				if (!isid(c) && !isnum(c))
					goto next_sec;
				p++;
			}
			snprintf(buf, sizeof(buf), "__start_%s", s->name);
			set_global_sym(s1, buf, s, 0);
			snprintf(buf, sizeof(buf), "__stop_%s", s->name);
			set_global_sym(s1, buf, s, -1);
		}
next_sec:
		;
	}
}

ST_FUNC void resolve_common_syms(TCCState *s1)
{
	ElfW(Sym) *sym;

	/* Allocate common symbols in BSS.  */
	for_each_elem(symtab_section, 1, sym, ElfW(Sym))
	{
		if (sym->st_shndx == SHN_COMMON)
		{
			/* symbol alignment is in st_value for SHN_COMMONs */
			sym->st_value = section_add(bss_section, sym->st_size,
			                            sym->st_value);
			sym->st_shndx = bss_section->sh_num;
		}
	}

	/* Now assign linker provided symbols their value.  */
	tcc_add_linker_symbols(s1);
}

static void tcc_output_binary(TCCState *s1, FILE *f,
                              const int *sec_order)
{
	Section *s;
	int i, offset, size;

	offset = 0;
	for(i=1; i<s1->nb_sections; i++)
	{
		s = s1->sections[sec_order[i]];
		if (s->sh_type != SHT_NOBITS &&
		        (s->sh_flags & SHF_ALLOC))
		{
			while (offset < s->sh_offset)
			{
				fputc(0, f);
				offset++;
			}
			size = s->sh_size;
			fwrite(s->data, 1, size, f);
			offset += size;
		}
	}
}

#ifndef ELF_OBJ_ONLY
ST_FUNC void fill_got_entry(TCCState *s1, ElfW_Rel *rel)
{
	int sym_index = ELFW(R_SYM) (rel->r_info);
	ElfW(Sym) *sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];
	struct sym_attr *attr = get_sym_attr(s1, sym_index, 0);
	unsigned offset = attr->got_offset;

	if (0 == offset)
		return;
	section_reserve(s1->got, offset + PTR_SIZE);
#ifdef TCC_TARGET_X86_64
	write64le(s1->got->data + offset, sym->st_value);
#else
	write32le(s1->got->data + offset, sym->st_value);
#endif
}

/* Perform relocation to GOT or PLT entries */
ST_FUNC void fill_got(TCCState *s1)
{
	Section *s;
	ElfW_Rel *rel;
	int i;

	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if (s->sh_type != SHT_RELX)
			continue;
		/* no need to handle got relocations */
		if (s->link != symtab_section)
			continue;
		for_each_elem(s, 0, rel, ElfW_Rel)
		{
			switch (ELFW(R_TYPE) (rel->r_info))
			{
			case R_X86_64_GOT32:
			case R_X86_64_GOTPCREL:
			case R_X86_64_GOTPCRELX:
			case R_X86_64_REX_GOTPCRELX:
			case R_X86_64_PLT32:
				fill_got_entry(s1, rel);
				break;
			}
		}
	}
}

/* See put_got_entry for a description.  This is the second stage
   where GOT references to local defined symbols are rewritten.  */
static void fill_local_got_entries(TCCState *s1)
{
	ElfW_Rel *rel;
	if (!s1->got->reloc)
		return;
	for_each_elem(s1->got->reloc, 0, rel, ElfW_Rel)
	{
		if (ELFW(R_TYPE)(rel->r_info) == R_RELATIVE)
		{
			int sym_index = ELFW(R_SYM) (rel->r_info);
			ElfW(Sym) *sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];
			struct sym_attr *attr = get_sym_attr(s1, sym_index, 0);
			unsigned offset = attr->got_offset;
			if (offset != rel->r_offset - s1->got->sh_addr)
				tcc_error_noabort("huh");
			rel->r_info = ELFW(R_INFO)(0, R_RELATIVE);
#if SHT_RELX == SHT_RELA
			rel->r_addend = sym->st_value;
#else
			/* All our REL architectures also happen to be 32bit LE.  */
			write32le(s1->got->data + offset, sym->st_value);
#endif
		}
	}
}

/* Bind symbols of executable: resolve undefined symbols from exported symbols
   in shared libraries and export non local defined symbols to shared libraries
   if -rdynamic switch was given on command line */
static void bind_exe_dynsyms(TCCState *s1)
{
	const char *name;
	int sym_index, index;
	ElfW(Sym) *sym, *esym;
	int type;

	/* Resolve undefined symbols from dynamic symbols. When there is a match:
	   - if STT_FUNC or STT_GNU_IFUNC symbol -> add it in PLT
	   - if STT_OBJECT symbol -> add it in .bss section with suitable reloc */
	for_each_elem(symtab_section, 1, sym, ElfW(Sym))
	{
		if (sym->st_shndx == SHN_UNDEF)
		{
			name = (char *) symtab_section->link->data + sym->st_name;
			sym_index = find_elf_sym(s1->dynsymtab_section, name);
			if (sym_index)
			{
				esym = &((ElfW(Sym) *)s1->dynsymtab_section->data)[sym_index];
				type = ELFW(ST_TYPE)(esym->st_info);
				if ((type == STT_FUNC) || (type == STT_GNU_IFUNC))
				{
					/* Indirect functions shall have STT_FUNC type in executable
					 * dynsym section. Indeed, a dlsym call following a lazy
					 * resolution would pick the symbol value from the
					 * executable dynsym entry which would contain the address
					 * of the function wanted by the caller of dlsym instead of
					 * the address of the function that would return that
					 * address */
					int dynindex
					    = put_elf_sym(s1->dynsym, 0, esym->st_size,
					                  ELFW(ST_INFO)(STB_GLOBAL,STT_FUNC), 0, 0,
					                  name);
					int index = sym - (ElfW(Sym) *) symtab_section->data;
					get_sym_attr(s1, index, 1)->dyn_index = dynindex;
				}
				else if (type == STT_OBJECT)
				{
					unsigned long offset;
					ElfW(Sym) *dynsym;
					offset = bss_section->data_offset;
					/* XXX: which alignment ? */
					offset = (offset + 16 - 1) & -16;
					set_elf_sym (s1->symtab, offset, esym->st_size,
					             esym->st_info, 0, bss_section->sh_num, name);
					index = put_elf_sym(s1->dynsym, offset, esym->st_size,
					                    esym->st_info, 0, bss_section->sh_num,
					                    name);

					/* Ensure R_COPY works for weak symbol aliases */
					if (ELFW(ST_BIND)(esym->st_info) == STB_WEAK)
					{
						for_each_elem(s1->dynsymtab_section, 1, dynsym, ElfW(Sym))
						{
							if ((dynsym->st_value == esym->st_value)
							        && (ELFW(ST_BIND)(dynsym->st_info) == STB_GLOBAL))
							{
								char *dynname = (char *) s1->dynsymtab_section->link->data
								                + dynsym->st_name;
								put_elf_sym(s1->dynsym, offset, dynsym->st_size,
								            dynsym->st_info, 0,
								            bss_section->sh_num, dynname);
								break;
							}
						}
					}

					put_elf_reloc(s1->dynsym, bss_section,
					              offset, R_COPY, index);
					offset += esym->st_size;
					bss_section->data_offset = offset;
				}
			}
			else
			{
				/* STB_WEAK undefined symbols are accepted */
				/* XXX: _fp_hw seems to be part of the ABI, so we ignore it */
				if (ELFW(ST_BIND)(sym->st_info) == STB_WEAK ||
				        !strcmp(name, "_fp_hw"))
				{
				}
				else
				{
					tcc_error_noabort("undefined symbol '%s'", name);
				}
			}
		}
		else if (s1->rdynamic && ELFW(ST_BIND)(sym->st_info) != STB_LOCAL)
		{
			/* if -rdynamic option, then export all non local symbols */
			name = (char *) symtab_section->link->data + sym->st_name;
			set_elf_sym(s1->dynsym, sym->st_value, sym->st_size, sym->st_info,
			            0, sym->st_shndx, name);
		}
	}
}

/* Bind symbols of libraries: export all non local symbols of executable that
   are referenced by shared libraries. The reason is that the dynamic loader
   search symbol first in executable and then in libraries. Therefore a
   reference to a symbol already defined by a library can still be resolved by
   a symbol in the executable. */
static void bind_libs_dynsyms(TCCState *s1)
{
	const char *name;
	int sym_index;
	ElfW(Sym) *sym, *esym;

	for_each_elem(s1->dynsymtab_section, 1, esym, ElfW(Sym))
	{
		name = (char *) s1->dynsymtab_section->link->data + esym->st_name;
		sym_index = find_elf_sym(symtab_section, name);
		sym = &((ElfW(Sym) *)symtab_section->data)[sym_index];
		if (sym_index && sym->st_shndx != SHN_UNDEF
		        && ELFW(ST_BIND)(sym->st_info) != STB_LOCAL)
		{
			set_elf_sym(s1->dynsym, sym->st_value, sym->st_size,
			            sym->st_info, 0, sym->st_shndx, name);
		}
		else if (esym->st_shndx == SHN_UNDEF)
		{
			/* weak symbols can stay undefined */
			if (ELFW(ST_BIND)(esym->st_info) != STB_WEAK)
				tcc_warning("undefined dynamic symbol '%s'", name);
		}
	}
}

/* Export all non local symbols. This is used by shared libraries so that the
   non local symbols they define can resolve a reference in another shared
   library or in the executable. Correspondingly, it allows undefined local
   symbols to be resolved by other shared libraries or by the executable. */
static void export_global_syms(TCCState *s1)
{
	int dynindex, index;
	const char *name;
	ElfW(Sym) *sym;

	for_each_elem(symtab_section, 1, sym, ElfW(Sym))
	{
		if (ELFW(ST_BIND)(sym->st_info) != STB_LOCAL)
		{
			name = (char *) symtab_section->link->data + sym->st_name;
			dynindex = put_elf_sym(s1->dynsym, sym->st_value, sym->st_size,
			                       sym->st_info, 0, sym->st_shndx, name);
			index = sym - (ElfW(Sym) *) symtab_section->data;
			get_sym_attr(s1, index, 1)->dyn_index = dynindex;
		}
	}
}
#endif

/* Allocate strings for section names and decide if an unallocated section
   should be output.
   NOTE: the strsec section comes last, so its size is also correct ! */
static int alloc_sec_names(TCCState *s1, int file_type, Section *strsec)
{
	int i;
	Section *s;
	int textrel = 0;

	/* Allocate strings for section names */
	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		/* when generating a DLL, we include relocations but we may
		   patch them */
#ifndef ELF_OBJ_ONLY
		if (file_type == TCC_OUTPUT_DLL &&
		        s->sh_type == SHT_RELX &&
		        !(s->sh_flags & SHF_ALLOC) &&
		        (s1->sections[s->sh_info]->sh_flags & SHF_ALLOC) &&
		        prepare_dynamic_rel(s1, s))
		{
			if (!(s1->sections[s->sh_info]->sh_flags & SHF_WRITE))
				textrel = 1;
		}
		else
#endif
			if ((s1->do_debug && s->sh_type != SHT_RELX) ||
			        file_type == TCC_OUTPUT_OBJ ||
			        (s->sh_flags & SHF_ALLOC) ||
			        i == (s1->nb_sections - 1))
			{
				/* we output all sections if debug or object file */
				s->sh_size = s->data_offset;
			}
		if (s->sh_size || (s->sh_flags & SHF_ALLOC))
			s->sh_name = put_elf_str(strsec, s->name);
	}
	strsec->sh_size = strsec->data_offset;
	return textrel;
}

/* Info to be copied in dynamic section */
struct dyn_inf
{
	Section *dynamic;
	Section *dynstr;
	unsigned long data_offset;
	addr_t rel_addr;
	addr_t rel_size;
#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
	addr_t bss_addr;
	addr_t bss_size;
#endif
};

/* Assign sections to segments and decide how are sections laid out when loaded
   in memory. This function also fills corresponding program headers. */
static int layout_sections(TCCState *s1, ElfW(Phdr) *phdr, int phnum,
                           Section *interp, Section* strsec,
                           struct dyn_inf *dyninf, int *sec_order)
{
	int i, j, k, file_type, sh_order_index, file_offset;
	unsigned long s_align;
	long long tmp;
	addr_t addr;
	ElfW(Phdr) *ph;
	Section *s;

	file_type = s1->output_type;
	sh_order_index = 1;
	file_offset = 0;
	if (s1->output_format == TCC_OUTPUT_FORMAT_ELF)
		file_offset = sizeof(ElfW(Ehdr)) + phnum * sizeof(ElfW(Phdr));
	s_align = ELF_PAGE_SIZE;
	if (s1->section_align)
		s_align = s1->section_align;

	if (phnum > 0)
	{
		if (s1->has_text_addr)
		{
			int a_offset, p_offset;
			addr = s1->text_addr;
			/* we ensure that (addr % ELF_PAGE_SIZE) == file_offset %
			   ELF_PAGE_SIZE */
			a_offset = (int) (addr & (s_align - 1));
			p_offset = file_offset & (s_align - 1);
			if (a_offset < p_offset)
				a_offset += s_align;
			file_offset += (a_offset - p_offset);
		}
		else
		{
			if (file_type == TCC_OUTPUT_DLL)
				addr = 0;
			else
				addr = ELF_START_ADDR;
			/* compute address after headers */
			addr += (file_offset & (s_align - 1));
		}

		ph = &phdr[0];
		/* Leave one program headers for the program interpreter and one for
		   the program header table itself if needed. These are done later as
		   they require section layout to be done first. */
		if (interp)
			ph += 2;

		/* dynamic relocation table information, for .dynamic section */
		dyninf->rel_addr = dyninf->rel_size = 0;
#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
		dyninf->bss_addr = dyninf->bss_size = 0;
#endif

		for(j = 0; j < 2; j++)
		{
			ph->p_type = PT_LOAD;
			if (j == 0)
				ph->p_flags = PF_R | PF_X;
			else
				ph->p_flags = PF_R | PF_W;
			ph->p_align = s_align;

			/* Decide the layout of sections loaded in memory. This must
			   be done before program headers are filled since they contain
			   info about the layout. We do the following ordering: interp,
			   symbol tables, relocations, progbits, nobits */
			/* XXX: do faster and simpler sorting */
			for(k = 0; k < 5; k++)
			{
				for(i = 1; i < s1->nb_sections; i++)
				{
					s = s1->sections[i];
					/* compute if section should be included */
					if (j == 0)
					{
						if ((s->sh_flags & (SHF_ALLOC | SHF_WRITE)) !=
						        SHF_ALLOC)
							continue;
					}
					else
					{
						if ((s->sh_flags & (SHF_ALLOC | SHF_WRITE)) !=
						        (SHF_ALLOC | SHF_WRITE))
							continue;
					}
					if (s == interp)
					{
						if (k != 0)
							continue;
					}
					else if ((s->sh_type == SHT_DYNSYM ||
					          s->sh_type == SHT_STRTAB ||
					          s->sh_type == SHT_HASH)
					         && !strstr(s->name, ".stab"))
					{
						if (k != 1)
							continue;
					}
					else if (s->sh_type == SHT_RELX)
					{
						if (k != 2)
							continue;
					}
					else if (s->sh_type == SHT_NOBITS)
					{
						if (k != 4)
							continue;
					}
					else
					{
						if (k != 3)
							continue;
					}
					sec_order[sh_order_index++] = i;

					/* section matches: we align it and add its size */
					tmp = addr;
					addr = (addr + s->sh_addralign - 1) &
					       ~(s->sh_addralign - 1);
					file_offset += (int) ( addr - tmp );
					s->sh_offset = file_offset;
					s->sh_addr = addr;

					/* update program header infos */
					if (ph->p_offset == 0)
					{
						ph->p_offset = file_offset;
						ph->p_vaddr = addr;
						ph->p_paddr = ph->p_vaddr;
					}
					/* update dynamic relocation infos */
					if (s->sh_type == SHT_RELX)
					{
#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
						if (!strcmp(strsec->data + s->sh_name, ".rel.got"))
						{
							dyninf->rel_addr = addr;
							dyninf->rel_size += s->sh_size; /* XXX only first rel. */
						}
						if (!strcmp(strsec->data + s->sh_name, ".rel.bss"))
						{
							dyninf->bss_addr = addr;
							dyninf->bss_size = s->sh_size; /* XXX only first rel. */
						}
#else
						if (dyninf->rel_size == 0)
							dyninf->rel_addr = addr;
						dyninf->rel_size += s->sh_size;
#endif
					}
					addr += s->sh_size;
					if (s->sh_type != SHT_NOBITS)
						file_offset += s->sh_size;
				}
			}
			if (j == 0)
			{
				/* Make the first PT_LOAD segment include the program
				   headers itself (and the ELF header as well), it'll
				   come out with same memory use but will make various
				   tools like binutils strip work better.  */
				ph->p_offset &= ~(ph->p_align - 1);
				ph->p_vaddr &= ~(ph->p_align - 1);
				ph->p_paddr &= ~(ph->p_align - 1);
			}
			ph->p_filesz = file_offset - ph->p_offset;
			ph->p_memsz = addr - ph->p_vaddr;
			ph++;
			if (j == 0)
			{
				if (s1->output_format == TCC_OUTPUT_FORMAT_ELF)
				{
					/* if in the middle of a page, we duplicate the page in
					   memory so that one copy is RX and the other is RW */
					if ((addr & (s_align - 1)) != 0)
						addr += s_align;
				}
				else
				{
					addr = (addr + s_align - 1) & ~(s_align - 1);
					file_offset = (file_offset + s_align - 1) & ~(s_align - 1);
				}
			}
		}
	}

	/* all other sections come after */
	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if (phnum > 0 && (s->sh_flags & SHF_ALLOC))
			continue;
		sec_order[sh_order_index++] = i;

		file_offset = (file_offset + s->sh_addralign - 1) &
		              ~(s->sh_addralign - 1);
		s->sh_offset = file_offset;
		if (s->sh_type != SHT_NOBITS)
			file_offset += s->sh_size;
	}

	return file_offset;
}

#ifndef ELF_OBJ_ONLY
static void fill_unloadable_phdr(ElfW(Phdr) *phdr, int phnum, Section *interp,
                                 Section *dynamic)
{
	ElfW(Phdr) *ph;

	/* if interpreter, then add corresponding program header */
	if (interp)
	{
		ph = &phdr[0];

		ph->p_type = PT_PHDR;
		ph->p_offset = sizeof(ElfW(Ehdr));
		ph->p_filesz = ph->p_memsz = phnum * sizeof(ElfW(Phdr));
		ph->p_vaddr = interp->sh_addr - ph->p_filesz;
		ph->p_paddr = ph->p_vaddr;
		ph->p_flags = PF_R | PF_X;
		ph->p_align = 4; /* interp->sh_addralign; */
		ph++;

		ph->p_type = PT_INTERP;
		ph->p_offset = interp->sh_offset;
		ph->p_vaddr = interp->sh_addr;
		ph->p_paddr = ph->p_vaddr;
		ph->p_filesz = interp->sh_size;
		ph->p_memsz = interp->sh_size;
		ph->p_flags = PF_R;
		ph->p_align = interp->sh_addralign;
	}

	/* if dynamic section, then add corresponding program header */
	if (dynamic)
	{
		ph = &phdr[phnum - 1];

		ph->p_type = PT_DYNAMIC;
		ph->p_offset = dynamic->sh_offset;
		ph->p_vaddr = dynamic->sh_addr;
		ph->p_paddr = ph->p_vaddr;
		ph->p_filesz = dynamic->sh_size;
		ph->p_memsz = dynamic->sh_size;
		ph->p_flags = PF_R | PF_W;
		ph->p_align = dynamic->sh_addralign;
	}
}

/* Fill the dynamic section with tags describing the address and size of
   sections */
static void fill_dynamic(TCCState *s1, struct dyn_inf *dyninf)
{
	Section *dynamic = dyninf->dynamic;
	Section *s;

	/* put dynamic section entries */
	put_dt(dynamic, DT_HASH, s1->dynsym->hash->sh_addr);
	put_dt(dynamic, DT_STRTAB, dyninf->dynstr->sh_addr);
	put_dt(dynamic, DT_SYMTAB, s1->dynsym->sh_addr);
	put_dt(dynamic, DT_STRSZ, dyninf->dynstr->data_offset);
	put_dt(dynamic, DT_SYMENT, sizeof(ElfW(Sym)));
#if PTR_SIZE == 8
	put_dt(dynamic, DT_RELA, dyninf->rel_addr);
	put_dt(dynamic, DT_RELASZ, dyninf->rel_size);
	put_dt(dynamic, DT_RELAENT, sizeof(ElfW_Rel));
#else
#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
	put_dt(dynamic, DT_PLTGOT, s1->got->sh_addr);
	put_dt(dynamic, DT_PLTRELSZ, dyninf->rel_size);
	put_dt(dynamic, DT_JMPREL, dyninf->rel_addr);
	put_dt(dynamic, DT_PLTREL, DT_REL);
	put_dt(dynamic, DT_REL, dyninf->bss_addr);
	put_dt(dynamic, DT_RELSZ, dyninf->bss_size);
#else
	put_dt(dynamic, DT_REL, dyninf->rel_addr);
	put_dt(dynamic, DT_RELSZ, dyninf->rel_size);
	put_dt(dynamic, DT_RELENT, sizeof(ElfW_Rel));
#endif
#endif
	if (versym_section)
		put_dt(dynamic, DT_VERSYM, versym_section->sh_addr);
	if (verneed_section)
	{
		put_dt(dynamic, DT_VERNEED, verneed_section->sh_addr);
		put_dt(dynamic, DT_VERNEEDNUM, dt_verneednum);
	}
	s = find_section_create (s1, ".preinit_array", 0);
	if (s && s->data_offset)
	{
		put_dt(dynamic, DT_PREINIT_ARRAY, s->sh_addr);
		put_dt(dynamic, DT_PREINIT_ARRAYSZ, s->data_offset);
	}
	s = find_section_create (s1, ".init_array", 0);
	if (s && s->data_offset)
	{
		put_dt(dynamic, DT_INIT_ARRAY, s->sh_addr);
		put_dt(dynamic, DT_INIT_ARRAYSZ, s->data_offset);
	}
	s = find_section_create (s1, ".fini_array", 0);
	if (s && s->data_offset)
	{
		put_dt(dynamic, DT_FINI_ARRAY, s->sh_addr);
		put_dt(dynamic, DT_FINI_ARRAYSZ, s->data_offset);
	}
	s = find_section_create (s1, ".init", 0);
	if (s && s->data_offset)
	{
		put_dt(dynamic, DT_INIT, s->sh_addr);
	}
	s = find_section_create (s1, ".fini", 0);
	if (s && s->data_offset)
	{
		put_dt(dynamic, DT_FINI, s->sh_addr);
	}
	if (s1->do_debug)
		put_dt(dynamic, DT_DEBUG, 0);
	put_dt(dynamic, DT_NULL, 0);
}

/* Relocate remaining sections and symbols (that is those not related to
   dynamic linking) */
static int final_sections_reloc(TCCState *s1)
{
	int i;
	Section *s;

	relocate_syms(s1, s1->symtab, 0);

	if (s1->nb_errors != 0)
		return -1;

	/* relocate sections */
	/* XXX: ignore sections with allocated relocations ? */
	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if (s->reloc && (s != s1->got || s1->static_link))
			relocate_section(s1, s);
	}

	/* relocate relocation entries if the relocation tables are
	   allocated in the executable */
	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if ((s->sh_flags & SHF_ALLOC) &&
		        s->sh_type == SHT_RELX)
		{
			relocate_rel(s1, s);
		}
	}
	return 0;
}
#endif

/* Create an ELF file on disk.
   This function handle ELF specific layout requirements */
static void tcc_output_elf(TCCState *s1, FILE *f, int phnum, ElfW(Phdr) *phdr,
                           int file_offset, int *sec_order)
{
	int i, shnum, offset, size, file_type;
	Section *s;
	ElfW(Ehdr) ehdr;
	ElfW(Shdr) shdr, *sh;

	file_type = s1->output_type;
	shnum = s1->nb_sections;

	memset(&ehdr, 0, sizeof(ehdr));

	if (phnum > 0)
	{
		ehdr.e_phentsize = sizeof(ElfW(Phdr));
		ehdr.e_phnum = phnum;
		ehdr.e_phoff = sizeof(ElfW(Ehdr));
	}

	/* align to 4 */
	file_offset = (file_offset + 3) & -4;

	/* fill header */
	ehdr.e_ident[0] = ELFMAG0;
	ehdr.e_ident[1] = ELFMAG1;
	ehdr.e_ident[2] = ELFMAG2;
	ehdr.e_ident[3] = ELFMAG3;
	ehdr.e_ident[4] = ELFCLASSW;
	ehdr.e_ident[5] = ELFDATA2LSB;
	ehdr.e_ident[6] = EV_CURRENT;
#if !defined(TCC_TARGET_PE) && (defined(__FreeBSD__) || defined(__FreeBSD_kernel__))
	/* FIXME: should set only for freebsd _target_, but we exclude only PE target */
	ehdr.e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
#endif
#ifdef TCC_TARGET_ARM
#ifdef TCC_ARM_EABI
	ehdr.e_ident[EI_OSABI] = 0;
	ehdr.e_flags = EF_ARM_EABI_VER4;
	if (file_type == TCC_OUTPUT_EXE || file_type == TCC_OUTPUT_DLL)
		ehdr.e_flags |= EF_ARM_HASENTRY;
	if (s1->float_abi == ARM_HARD_FLOAT)
		ehdr.e_flags |= EF_ARM_VFP_FLOAT;
	else
		ehdr.e_flags |= EF_ARM_SOFT_FLOAT;
#else
	ehdr.e_ident[EI_OSABI] = ELFOSABI_ARM;
#endif
#elif defined TCC_TARGET_RISCV64
	ehdr.e_flags = EF_RISCV_FLOAT_ABI_DOUBLE;
#endif
	switch(file_type)
	{
	default:
	case TCC_OUTPUT_EXE:
		ehdr.e_type = ET_EXEC;
		ehdr.e_entry = get_elf_sym_addr(s1, "_start", 1);
		break;
	case TCC_OUTPUT_DLL:
		ehdr.e_type = ET_DYN;
		ehdr.e_entry = text_section->sh_addr; /* XXX: is it correct ? */
		break;
	case TCC_OUTPUT_OBJ:
		ehdr.e_type = ET_REL;
		break;
	}
	ehdr.e_machine = EM_TCC_TARGET;
	ehdr.e_version = EV_CURRENT;
	ehdr.e_shoff = file_offset;
	ehdr.e_ehsize = sizeof(ElfW(Ehdr));
	ehdr.e_shentsize = sizeof(ElfW(Shdr));
	ehdr.e_shnum = shnum;
	ehdr.e_shstrndx = shnum - 1;

	fwrite(&ehdr, 1, sizeof(ElfW(Ehdr)), f);
	fwrite(phdr, 1, phnum * sizeof(ElfW(Phdr)), f);
	offset = sizeof(ElfW(Ehdr)) + phnum * sizeof(ElfW(Phdr));

	sort_syms(s1, symtab_section);
	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[sec_order[i]];
		if (s->sh_type != SHT_NOBITS)
		{
			while (offset < s->sh_offset)
			{
				fputc(0, f);
				offset++;
			}
			size = s->sh_size;
			if (size)
				fwrite(s->data, 1, size, f);
			offset += size;
		}
	}

	/* output section headers */
	while (offset < ehdr.e_shoff)
	{
		fputc(0, f);
		offset++;
	}

	for(i = 0; i < s1->nb_sections; i++)
	{
		sh = &shdr;
		memset(sh, 0, sizeof(ElfW(Shdr)));
		s = s1->sections[i];
		if (s)
		{
			sh->sh_name = s->sh_name;
			sh->sh_type = s->sh_type;
			sh->sh_flags = s->sh_flags;
			sh->sh_entsize = s->sh_entsize;
			sh->sh_info = s->sh_info;
			if (s->link)
				sh->sh_link = s->link->sh_num;
			sh->sh_addralign = s->sh_addralign;
			sh->sh_addr = s->sh_addr;
			sh->sh_offset = s->sh_offset;
			sh->sh_size = s->sh_size;
		}
		fwrite(sh, 1, sizeof(ElfW(Shdr)), f);
	}
}

/* Write an elf, coff or "binary" file */
static int tcc_write_elf_file(TCCState *s1, const char *filename, int phnum,
                              ElfW(Phdr) *phdr, int file_offset, int *sec_order)
{
	int fd, mode, file_type;
	FILE *f;

	file_type = s1->output_type;
	if (file_type == TCC_OUTPUT_OBJ)
		mode = 0666;
	else
		mode = 0777;
	unlink(filename);
	fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, mode);
	if (fd < 0)
	{
		tcc_error_noabort("could not write '%s'", filename);
		return -1;
	}
	f = fdopen(fd, "wb");
	if (s1->verbose)
		printf("<- %s\n", filename);

#ifdef TCC_TARGET_COFF
	if (s1->output_format == TCC_OUTPUT_FORMAT_COFF)
		tcc_output_coff(s1, f);
	else
#endif
		if (s1->output_format == TCC_OUTPUT_FORMAT_ELF)
			tcc_output_elf(s1, f, phnum, phdr, file_offset, sec_order);
		else
			tcc_output_binary(s1, f, sec_order);
	fclose(f);

	return 0;
}

#ifndef ELF_OBJ_ONLY
/* Sort section headers by assigned sh_addr, remove sections
   that we aren't going to output.  */
static void tidy_section_headers(TCCState *s1, int *sec_order)
{
	int i, nnew, l, *backmap;
	Section **snew, *s;
	ElfW(Sym) *sym;

	snew = tcc_malloc(s1->nb_sections * sizeof(snew[0]));
	backmap = tcc_malloc(s1->nb_sections * sizeof(backmap[0]));
	for (i = 0, nnew = 0, l = s1->nb_sections; i < s1->nb_sections; i++)
	{
		s = s1->sections[sec_order[i]];
		if (!i || s->sh_name)
		{
			backmap[sec_order[i]] = nnew;
			snew[nnew] = s;
			++nnew;
		}
		else
		{
			backmap[sec_order[i]] = 0;
			snew[--l] = s;
		}
	}
	for (i = 0; i < nnew; i++)
	{
		s = snew[i];
		if (s)
		{
			s->sh_num = i;
			if (s->sh_type == SHT_RELX)
				s->sh_info = backmap[s->sh_info];
		}
	}

	for_each_elem(symtab_section, 1, sym, ElfW(Sym))
	if (sym->st_shndx != SHN_UNDEF && sym->st_shndx < SHN_LORESERVE)
		sym->st_shndx = backmap[sym->st_shndx];
	if( !s1->static_link )
	{
		for_each_elem(s1->dynsym, 1, sym, ElfW(Sym))
		if (sym->st_shndx != SHN_UNDEF && sym->st_shndx < SHN_LORESERVE)
			sym->st_shndx = backmap[sym->st_shndx];
	}
	for (i = 0; i < s1->nb_sections; i++)
		sec_order[i] = i;
	tcc_free(s1->sections);
	s1->sections = snew;
	s1->nb_sections = nnew;
	tcc_free(backmap);
}
#endif

/* Output an elf, coff or binary file */
/* XXX: suppress unneeded sections */
static int elf_output_file(TCCState *s1, const char *filename)
{
	int ret, phnum, shnum, file_type, file_offset, *sec_order;
	struct dyn_inf dyninf = {0};
	ElfW(Phdr) *phdr;
	Section *strsec, *interp, *dynamic, *dynstr;

	file_type = s1->output_type;
	s1->nb_errors = 0;
	ret = -1;
	phdr = NULL;
	sec_order = NULL;
	interp = dynamic = dynstr = NULL; /* avoid warning */

#ifndef ELF_OBJ_ONLY
	if (file_type != TCC_OUTPUT_OBJ)
	{
		/* if linking, also link in runtime libraries (libc, libgcc, etc.) */
		tcc_add_runtime(s1);
		resolve_common_syms(s1);

		if (!s1->static_link)
		{
			if (file_type == TCC_OUTPUT_EXE)
			{
				char *ptr;
				/* allow override the dynamic loader */
				const char *elfint = getenv("LD_SO");
				if (elfint == NULL)
					elfint = DEFAULT_ELFINTERP(s1);
				/* add interpreter section only if executable */
				interp = new_section(s1, ".interp", SHT_PROGBITS, SHF_ALLOC);
				interp->sh_addralign = 1;
				ptr = section_ptr_add(interp, 1 + strlen(elfint));
				strcpy(ptr, elfint);
			}

			/* add dynamic symbol table */
			s1->dynsym = new_symtab(s1, ".dynsym", SHT_DYNSYM, SHF_ALLOC,
			                        ".dynstr",
			                        ".hash", SHF_ALLOC);
			dynstr = s1->dynsym->link;
			/* add dynamic section */
			dynamic = new_section(s1, ".dynamic", SHT_DYNAMIC,
			                      SHF_ALLOC | SHF_WRITE);
			dynamic->link = dynstr;
			dynamic->sh_entsize = sizeof(ElfW(Dyn));

			build_got(s1);

			if (file_type == TCC_OUTPUT_EXE)
			{
				bind_exe_dynsyms(s1);
				if (s1->nb_errors)
					goto the_end;
				bind_libs_dynsyms(s1);
			}
			else
			{
				/* shared library case: simply export all global symbols */
				export_global_syms(s1);
			}
		}
		build_got_entries(s1);
		version_add (s1);
	}
#endif

	/* we add a section for symbols */
	strsec = new_section(s1, ".shstrtab", SHT_STRTAB, 0);
	put_elf_str(strsec, "");

	/* Allocate strings for section names */
	ret = alloc_sec_names(s1, file_type, strsec);

#ifndef ELF_OBJ_ONLY
	if (dynamic)
	{
		int i;
		/* add a list of needed dlls */
		for(i = 0; i < s1->nb_loaded_dlls; i++)
		{
			DLLReference *dllref = s1->loaded_dlls[i];
			if (dllref->level == 0)
				put_dt(dynamic, DT_NEEDED, put_elf_str(dynstr, dllref->name));
		}

		if (s1->rpath)
			put_dt(dynamic, s1->enable_new_dtags ? DT_RUNPATH : DT_RPATH,
			       put_elf_str(dynstr, s1->rpath));

		if (file_type == TCC_OUTPUT_DLL)
		{
			if (s1->soname)
				put_dt(dynamic, DT_SONAME, put_elf_str(dynstr, s1->soname));
			/* XXX: currently, since we do not handle PIC code, we
			   must relocate the readonly segments */
			if (ret)
				put_dt(dynamic, DT_TEXTREL, 0);
		}

		if (s1->symbolic)
			put_dt(dynamic, DT_SYMBOLIC, 0);

		dyninf.dynamic = dynamic;
		dyninf.dynstr = dynstr;
		/* remember offset and reserve space for 2nd call below */
		dyninf.data_offset = dynamic->data_offset;
		fill_dynamic(s1, &dyninf);
		dynamic->sh_size = dynamic->data_offset;
		dynstr->sh_size = dynstr->data_offset;
	}
#endif

	/* compute number of program headers */
	if (file_type == TCC_OUTPUT_OBJ)
		phnum = 0;
	else if (file_type == TCC_OUTPUT_DLL)
		phnum = 3;
	else if (s1->static_link)
		phnum = 2;
	else
		phnum = 5;

	/* allocate program segment headers */
	phdr = tcc_mallocz(phnum * sizeof(ElfW(Phdr)));

	/* compute number of sections */
	shnum = s1->nb_sections;

	/* this array is used to reorder sections in the output file */
	sec_order = tcc_malloc(sizeof(int) * shnum);
	sec_order[0] = 0;

	/* compute section to program header mapping */
	file_offset = layout_sections(s1, phdr, phnum, interp, strsec, &dyninf,
	                              sec_order);

#ifndef ELF_OBJ_ONLY
	/* Fill remaining program header and finalize relocation related to dynamic
	   linking. */
	if (file_type != TCC_OUTPUT_OBJ)
	{
		fill_unloadable_phdr(phdr, phnum, interp, dynamic);
		if (dynamic)
		{
			ElfW(Sym) *sym;
			dynamic->data_offset = dyninf.data_offset;
			fill_dynamic(s1, &dyninf);

			/* put in GOT the dynamic section address and relocate PLT */
			write32le(s1->got->data, dynamic->sh_addr);
			if (file_type == TCC_OUTPUT_EXE
			        || (RELOCATE_DLLPLT && file_type == TCC_OUTPUT_DLL))
				relocate_plt(s1);

			/* relocate symbols in .dynsym now that final addresses are known */
			for_each_elem(s1->dynsym, 1, sym, ElfW(Sym))
			{
				if (sym->st_shndx != SHN_UNDEF && sym->st_shndx < SHN_LORESERVE)
				{
					/* do symbol relocation */
					sym->st_value += s1->sections[sym->st_shndx]->sh_addr;
				}
			}
		}

		/* if building executable or DLL, then relocate each section
		   except the GOT which is already relocated */
		ret = final_sections_reloc(s1);
		if (ret)
			goto the_end;
		tidy_section_headers(s1, sec_order);

		/* Perform relocation to GOT or PLT entries */
		if (file_type == TCC_OUTPUT_EXE && s1->static_link)
			fill_got(s1);
		else if (s1->got)
			fill_local_got_entries(s1);
	}
#endif

	/* Create the ELF file with name 'filename' */
	ret = tcc_write_elf_file(s1, filename, phnum, phdr, file_offset, sec_order);
	s1->nb_sections = shnum;
	goto the_end;
the_end:
	tcc_free(sec_order);
	tcc_free(phdr);
	return ret;
}

LIBTCCAPI int tcc_output_file(TCCState *s, const char *filename)
{
	int ret;
#ifdef TCC_TARGET_PE
	if (s->output_type != TCC_OUTPUT_OBJ)
	{
		ret = pe_output_file(s, filename);
	}
	else
#endif
		ret = elf_output_file(s, filename);
	return ret;
}

ssize_t full_read(int fd, void *buf, size_t count)
{
	char *cbuf = buf;
	size_t rnum = 0;
	while (1)
	{
		ssize_t num = read(fd, cbuf, count-rnum);
		if (num < 0) return num;
		if (num == 0) return rnum;
		rnum += num;
		cbuf += num;
	}
}

static void *load_data(int fd, unsigned long file_offset, unsigned long size)
{
	void *data;

	data = tcc_malloc(size);
	lseek(fd, file_offset, SEEK_SET);
	full_read(fd, data, size);
	return data;
}

typedef struct SectionMergeInfo
{
	Section *s;            /* corresponding existing section */
	unsigned long offset;  /* offset of the new section in the existing section */
	uint8_t new_section;       /* true if section 's' was added */
	uint8_t link_once;         /* true if link once section */
} SectionMergeInfo;

ST_FUNC int tcc_object_type(int fd, ElfW(Ehdr) *h)
{
	int size = full_read(fd, h, sizeof *h);
	if (size == sizeof *h && 0 == memcmp(h, ELFMAG, 4))
	{
		if (h->e_type == ET_REL)
			return AFF_BINTYPE_REL;
		if (h->e_type == ET_DYN)
			return AFF_BINTYPE_DYN;
	}
	else if (size >= 8)
	{
		if (0 == memcmp(h, ARMAG, 8))
			return AFF_BINTYPE_AR;
#ifdef TCC_TARGET_COFF
		if (((struct filehdr*)h)->f_magic == COFF_C67_MAGIC)
			return AFF_BINTYPE_C67;
#endif
	}
	return 0;
}

/* load an object file and merge it with current files */
/* XXX: handle correctly stab (debug) info */
ST_FUNC int tcc_load_object_file(TCCState *s1,
                                 int fd, unsigned long file_offset)
{
	ElfW(Ehdr) ehdr;
	ElfW(Shdr) *shdr, *sh;
	int size, i, j, offset, offseti, nb_syms, sym_index, ret, seencompressed;
	char *strsec, *strtab;
	int stab_index, stabstr_index;
	int *old_to_new_syms;
	char *sh_name, *name;
	SectionMergeInfo *sm_table, *sm;
	ElfW(Sym) *sym, *symtab;
	ElfW_Rel *rel;
	Section *s;

	lseek(fd, file_offset, SEEK_SET);
	if (tcc_object_type(fd, &ehdr) != AFF_BINTYPE_REL)
		goto fail1;
	/* test CPU specific stuff */
	if (ehdr.e_ident[5] != ELFDATA2LSB ||
	        ehdr.e_machine != EM_TCC_TARGET)
	{
fail1:
		tcc_error_noabort("invalid object file");
		return -1;
	}
	/* read sections */
	shdr = load_data(fd, file_offset + ehdr.e_shoff,
	                 sizeof(ElfW(Shdr)) * ehdr.e_shnum);
	sm_table = tcc_mallocz(sizeof(SectionMergeInfo) * ehdr.e_shnum);

	/* load section names */
	sh = &shdr[ehdr.e_shstrndx];
	strsec = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);

	/* load symtab and strtab */
	old_to_new_syms = NULL;
	symtab = NULL;
	strtab = NULL;
	nb_syms = 0;
	seencompressed = 0;
	stab_index = stabstr_index = 0;

	for(i = 1; i < ehdr.e_shnum; i++)
	{
		sh = &shdr[i];
		if (sh->sh_type == SHT_SYMTAB)
		{
			if (symtab)
			{
				tcc_error_noabort("object must contain only one symtab");
fail:
				ret = -1;
				goto the_end;
			}
			nb_syms = sh->sh_size / sizeof(ElfW(Sym));
			symtab = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);
			sm_table[i].s = symtab_section;

			/* now load strtab */
			sh = &shdr[sh->sh_link];
			strtab = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);
		}
		if (sh->sh_flags & SHF_COMPRESSED)
			seencompressed = 1;
	}

	/* now examine each section and try to merge its content with the
	   ones in memory */
	for(i = 1; i < ehdr.e_shnum; i++)
	{
		/* no need to examine section name strtab */
		if (i == ehdr.e_shstrndx)
			continue;
		sh = &shdr[i];
		if (sh->sh_type == SHT_RELX)
			sh = &shdr[sh->sh_info];
		/* ignore sections types we do not handle (plus relocs to those) */
		if (sh->sh_type != SHT_PROGBITS &&
#ifdef TCC_ARM_EABI
		        sh->sh_type != SHT_ARM_EXIDX &&
#endif
		        sh->sh_type != SHT_NOBITS &&
		        sh->sh_type != SHT_PREINIT_ARRAY &&
		        sh->sh_type != SHT_INIT_ARRAY &&
		        sh->sh_type != SHT_FINI_ARRAY &&
		        strcmp(strsec + sh->sh_name, ".stabstr")
		   )
			continue;
		if (seencompressed
		        && !strncmp(strsec + sh->sh_name, ".debug_", sizeof(".debug_")-1))
			continue;

		sh = &shdr[i];
		sh_name = strsec + sh->sh_name;
		if (sh->sh_addralign < 1)
			sh->sh_addralign = 1;
		/* find corresponding section, if any */
		for(j = 1; j < s1->nb_sections; j++)
		{
			s = s1->sections[j];
			if (!strcmp(s->name, sh_name))
			{
				if (!strncmp(sh_name, ".gnu.linkonce",
				             sizeof(".gnu.linkonce") - 1))
				{
					/* if a 'linkonce' section is already present, we
					   do not add it again. It is a little tricky as
					   symbols can still be defined in
					   it. */
					sm_table[i].link_once = 1;
					goto next;
				}
				if (stab_section)
				{
					if (s == stab_section)
						stab_index = i;
					if (s == stab_section->link)
						stabstr_index = i;
				}
				goto found;
			}
		}
		/* not found: create new section */
		s = new_section(s1, sh_name, sh->sh_type, sh->sh_flags & ~SHF_GROUP);
		/* take as much info as possible from the section. sh_link and
		   sh_info will be updated later */
		s->sh_addralign = sh->sh_addralign;
		s->sh_entsize = sh->sh_entsize;
		sm_table[i].new_section = 1;
found:
		if (sh->sh_type != s->sh_type)
		{
			tcc_error_noabort("invalid section type");
			goto fail;
		}
		/* align start of section */
		s->data_offset += -s->data_offset & (sh->sh_addralign - 1);
		if (sh->sh_addralign > s->sh_addralign)
			s->sh_addralign = sh->sh_addralign;
		sm_table[i].offset = s->data_offset;
		sm_table[i].s = s;
		/* concatenate sections */
		size = sh->sh_size;
		if (sh->sh_type != SHT_NOBITS)
		{
			unsigned char *ptr;
			lseek(fd, file_offset + sh->sh_offset, SEEK_SET);
			ptr = section_ptr_add(s, size);
			full_read(fd, ptr, size);
		}
		else
		{
			s->data_offset += size;
		}
next:
		;
	}

	/* gr relocate stab strings */
	if (stab_index && stabstr_index)
	{
		Stab_Sym *a, *b;
		unsigned o;
		s = sm_table[stab_index].s;
		a = (Stab_Sym *)(s->data + sm_table[stab_index].offset);
		b = (Stab_Sym *)(s->data + s->data_offset);
		o = sm_table[stabstr_index].offset;
		while (a < b)
		{
			if (a->n_strx)
				a->n_strx += o;
			a++;
		}
	}

	/* second short pass to update sh_link and sh_info fields of new
	   sections */
	for(i = 1; i < ehdr.e_shnum; i++)
	{
		s = sm_table[i].s;
		if (!s || !sm_table[i].new_section)
			continue;
		sh = &shdr[i];
		if (sh->sh_link > 0)
			s->link = sm_table[sh->sh_link].s;
		if (sh->sh_type == SHT_RELX)
		{
			s->sh_info = sm_table[sh->sh_info].s->sh_num;
			/* update backward link */
			s1->sections[s->sh_info]->reloc = s;
		}
	}

	/* resolve symbols */
	old_to_new_syms = tcc_mallocz(nb_syms * sizeof(int));

	sym = symtab + 1;
	for(i = 1; i < nb_syms; i++, sym++)
	{
		if (sym->st_shndx != SHN_UNDEF &&
		        sym->st_shndx < SHN_LORESERVE)
		{
			sm = &sm_table[sym->st_shndx];
			if (sm->link_once)
			{
				/* if a symbol is in a link once section, we use the
				   already defined symbol. It is very important to get
				   correct relocations */
				if (ELFW(ST_BIND)(sym->st_info) != STB_LOCAL)
				{
					name = strtab + sym->st_name;
					sym_index = find_elf_sym(symtab_section, name);
					if (sym_index)
						old_to_new_syms[i] = sym_index;
				}
				continue;
			}
			/* if no corresponding section added, no need to add symbol */
			if (!sm->s)
				continue;
			/* convert section number */
			sym->st_shndx = sm->s->sh_num;
			/* offset value */
			sym->st_value += sm->offset;
		}
		/* add symbol */
		name = strtab + sym->st_name;
		sym_index = set_elf_sym(symtab_section, sym->st_value, sym->st_size,
		                        sym->st_info, sym->st_other,
		                        sym->st_shndx, name);
		old_to_new_syms[i] = sym_index;
	}

	/* third pass to patch relocation entries */
	for(i = 1; i < ehdr.e_shnum; i++)
	{
		s = sm_table[i].s;
		if (!s)
			continue;
		sh = &shdr[i];
		offset = sm_table[i].offset;
		switch(s->sh_type)
		{
		case SHT_RELX:
			/* take relocation offset information */
			offseti = sm_table[sh->sh_info].offset;
			for_each_elem(s, (offset / sizeof(*rel)), rel, ElfW_Rel)
			{
				int type;
				unsigned sym_index;
				/* convert symbol index */
				type = ELFW(R_TYPE)(rel->r_info);
				sym_index = ELFW(R_SYM)(rel->r_info);
				/* NOTE: only one symtab assumed */
				if (sym_index >= nb_syms)
					goto invalid_reloc;
				sym_index = old_to_new_syms[sym_index];
				/* ignore link_once in rel section. */
				if (!sym_index && !sm_table[sh->sh_info].link_once
#ifdef TCC_TARGET_ARM
				        && type != R_ARM_V4BX
#elif defined TCC_TARGET_RISCV64
				        && type != R_RISCV_ALIGN
				        && type != R_RISCV_RELAX
#endif
				   )
				{
invalid_reloc:
					tcc_error_noabort("Invalid relocation entry [%2d] '%s' @ %.8x",
					                  i, strsec + sh->sh_name, rel->r_offset);
					goto fail;
				}
				rel->r_info = ELFW(R_INFO)(sym_index, type);
				/* offset the relocation offset */
				rel->r_offset += offseti;
#ifdef TCC_TARGET_ARM
				/* Jumps and branches from a Thumb code to a PLT entry need
				   special handling since PLT entries are ARM code.
				   Unconditional bl instructions referencing PLT entries are
				   handled by converting these instructions into blx
				   instructions. Other case of instructions referencing a PLT
				   entry require to add a Thumb stub before the PLT entry to
				   switch to ARM mode. We set bit plt_thumb_stub of the
				   attribute of a symbol to indicate such a case. */
				if (type == R_ARM_THM_JUMP24)
					get_sym_attr(s1, sym_index, 1)->plt_thumb_stub = 1;
#endif
			}
			break;
		default:
			break;
		}
	}

	ret = 0;
the_end:
	tcc_free(symtab);
	tcc_free(strtab);
	tcc_free(old_to_new_syms);
	tcc_free(sm_table);
	tcc_free(strsec);
	tcc_free(shdr);
	return ret;
}

typedef struct ArchiveHeader
{
	char ar_name[16];           /* name of this member */
	char ar_date[12];           /* file mtime */
	char ar_uid[6];             /* owner uid; printed as decimal */
	char ar_gid[6];             /* owner gid; printed as decimal */
	char ar_mode[8];            /* file mode, printed as octal   */
	char ar_size[10];           /* file size, printed as decimal */
	char ar_fmag[2];            /* should contain ARFMAG */
} ArchiveHeader;

#define ARFMAG "`\n"

static unsigned long long get_be(const uint8_t *b, int n)
{
	unsigned long long ret = 0;
	while (n)
		ret = (ret << 8) | *b++, --n;
	return ret;
}

static int read_ar_header(int fd, int offset, ArchiveHeader *hdr)
{
	char *p, *e;
	int len;
	lseek(fd, offset, SEEK_SET);
	len = full_read(fd, hdr, sizeof(ArchiveHeader));
	if (len != sizeof(ArchiveHeader))
		return len ? -1 : 0;
	p = hdr->ar_name;
	for (e = p + sizeof hdr->ar_name; e > p && e[-1] == ' ';)
		--e;
	*e = '\0';
	hdr->ar_size[sizeof hdr->ar_size-1] = 0;
	return len;
}

/* load only the objects which resolve undefined symbols */
static int tcc_load_alacarte(TCCState *s1, int fd, int size, int entrysize)
{
	int i, bound, nsyms, sym_index, len, ret = -1;
	unsigned long long off;
	uint8_t *data;
	const char *ar_names, *p;
	const uint8_t *ar_index;
	ElfW(Sym) *sym;
	ArchiveHeader hdr;

	data = tcc_malloc(size);
	if (full_read(fd, data, size) != size)
		goto the_end;
	nsyms = get_be(data, entrysize);
	ar_index = data + entrysize;
	ar_names = (char *) ar_index + nsyms * entrysize;

	do
	{
		bound = 0;
		for (p = ar_names, i = 0; i < nsyms; i++, p += strlen(p)+1)
		{
			Section *s = symtab_section;
			sym_index = find_elf_sym(s, p);
			if (!sym_index)
				continue;
			sym = &((ElfW(Sym) *)s->data)[sym_index];
			if(sym->st_shndx != SHN_UNDEF)
				continue;
			off = get_be(ar_index + i * entrysize, entrysize);
			len = read_ar_header(fd, off, &hdr);
			if (len <= 0 || memcmp(hdr.ar_fmag, ARFMAG, 2))
			{
				tcc_error_noabort("invalid archive");
				goto the_end;
			}
			off += len;
			if (s1->verbose == 2)
				printf("   -> %s\n", hdr.ar_name);
			if (tcc_load_object_file(s1, fd, off) < 0)
				goto the_end;
			++bound;
		}
	}
	while(bound);
	ret = 0;
the_end:
	tcc_free(data);
	return ret;
}

/* load a '.a' file */
ST_FUNC int tcc_load_archive(TCCState *s1, int fd, int alacarte)
{
	ArchiveHeader hdr;
	/* char magic[8]; */
	int size, len;
	unsigned long file_offset;
	ElfW(Ehdr) ehdr;

	/* skip magic which was already checked */
	/* full_read(fd, magic, sizeof(magic)); */
	file_offset = sizeof ARMAG - 1;

	for(;;)
	{
		len = read_ar_header(fd, file_offset, &hdr);
		if (len == 0)
			return 0;
		if (len < 0)
		{
			tcc_error_noabort("invalid archive");
			return -1;
		}
		file_offset += len;
		size = strtol(hdr.ar_size, NULL, 0);
		/* align to even */
		size = (size + 1) & ~1;
		if (alacarte)
		{
			/* coff symbol table : we handle it */
			if (!strcmp(hdr.ar_name, "/"))
				return tcc_load_alacarte(s1, fd, size, 4);
			if (!strcmp(hdr.ar_name, "/SYM64/"))
				return tcc_load_alacarte(s1, fd, size, 8);
		}
		else if (tcc_object_type(fd, &ehdr) == AFF_BINTYPE_REL)
		{
			if (s1->verbose == 2)
				printf("   -> %s\n", hdr.ar_name);
			if (tcc_load_object_file(s1, fd, file_offset) < 0)
				return -1;
		}
		file_offset += size;
	}
}

#ifndef ELF_OBJ_ONLY
/* Set LV[I] to the global index of sym-version (LIB,VERSION).  Maybe resizes
   LV, maybe create a new entry for (LIB,VERSION).  */
static void set_ver_to_ver(TCCState *s1, int *n, int **lv, int i, char *lib, char *version)
{
	while (i >= *n)
	{
		*lv = tcc_realloc(*lv, (*n + 1) * sizeof(**lv));
		(*lv)[(*n)++] = -1;
	}
	if ((*lv)[i] == -1)
	{
		int v, prev_same_lib = -1;
		for (v = 0; v < nb_sym_versions; v++)
		{
			if (strcmp(sym_versions[v].lib, lib))
				continue;
			prev_same_lib = v;
			if (!strcmp(sym_versions[v].version, version))
				break;
		}
		if (v == nb_sym_versions)
		{
			sym_versions = tcc_realloc (sym_versions,
			                            (v + 1) * sizeof(*sym_versions));
			sym_versions[v].lib = tcc_strdup(lib);
			sym_versions[v].version = tcc_strdup(version);
			sym_versions[v].out_index = 0;
			sym_versions[v].prev_same_lib = prev_same_lib;
			nb_sym_versions++;
		}
		(*lv)[i] = v;
	}
}

/* Associates symbol SYM_INDEX (in dynsymtab) with sym-version index
   VERNDX.  */
static void
set_sym_version(TCCState *s1, int sym_index, int verndx)
{
	if (sym_index >= nb_sym_to_version)
	{
		int newelems = sym_index ? sym_index * 2 : 1;
		sym_to_version = tcc_realloc(sym_to_version,
		                             newelems * sizeof(*sym_to_version));
		memset(sym_to_version + nb_sym_to_version, -1,
		       (newelems - nb_sym_to_version) * sizeof(*sym_to_version));
		nb_sym_to_version = newelems;
	}
	if (sym_to_version[sym_index] < 0)
		sym_to_version[sym_index] = verndx;
}

struct versym_info
{
	int nb_versyms;
	ElfW(Verdef) *verdef;
	ElfW(Verneed) *verneed;
	ElfW(Half) *versym;
	int nb_local_ver, *local_ver;
};


static void store_version(TCCState *s1, struct versym_info *v, char *dynstr)
{
	char *lib, *version;
	uint32_t next;
	int i;

#define	DEBUG_VERSION 0

	if (v->versym && v->verdef)
	{
		ElfW(Verdef) *vdef = v->verdef;
		lib = NULL;
		do
		{
			ElfW(Verdaux) *verdaux =
			    (ElfW(Verdaux) *) (((char *) vdef) + vdef->vd_aux);

#if DEBUG_VERSION
			printf ("verdef: version:%u flags:%u index:%u, hash:%u\n",
			        vdef->vd_version, vdef->vd_flags, vdef->vd_ndx,
			        vdef->vd_hash);
#endif
			if (vdef->vd_cnt)
			{
				version = dynstr + verdaux->vda_name;

				if (lib == NULL)
					lib = version;
				else
					set_ver_to_ver(s1, &v->nb_local_ver, &v->local_ver, vdef->vd_ndx,
					               lib, version);
#if DEBUG_VERSION
				printf ("  verdaux(%u): %s\n", vdef->vd_ndx, version);
#endif
			}
			next = vdef->vd_next;
			vdef = (ElfW(Verdef) *) (((char *) vdef) + next);
		}
		while (next);
	}
	if (v->versym && v->verneed)
	{
		ElfW(Verneed) *vneed = v->verneed;
		do
		{
			ElfW(Vernaux) *vernaux =
			    (ElfW(Vernaux) *) (((char *) vneed) + vneed->vn_aux);

			lib = dynstr + vneed->vn_file;
#if DEBUG_VERSION
			printf ("verneed: %u %s\n", vneed->vn_version, lib);
#endif
			for (i = 0; i < vneed->vn_cnt; i++)
			{
				if ((vernaux->vna_other & 0x8000) == 0)   /* hidden */
				{
					version = dynstr + vernaux->vna_name;
					set_ver_to_ver(s1, &v->nb_local_ver, &v->local_ver, vernaux->vna_other,
					               lib, version);
#if DEBUG_VERSION
					printf ("  vernaux(%u): %u %u %s\n",
					        vernaux->vna_other, vernaux->vna_hash,
					        vernaux->vna_flags, version);
#endif
				}
				vernaux = (ElfW(Vernaux) *) (((char *) vernaux) + vernaux->vna_next);
			}
			next = vneed->vn_next;
			vneed = (ElfW(Verneed) *) (((char *) vneed) + next);
		}
		while (next);
	}

#if DEBUG_VERSION
	for (i = 0; i < v->nb_local_ver; i++)
	{
		if (v->local_ver[i] > 0)
		{
			printf ("%d: lib: %s, version %s\n",
			        i, sym_versions[v->local_ver[i]].lib,
			        sym_versions[v->local_ver[i]].version);
		}
	}
#endif
}

/* load a DLL and all referenced DLLs. 'level = 0' means that the DLL
   is referenced by the user (so it should be added as DT_NEEDED in
   the generated ELF file) */
ST_FUNC int tcc_load_dll(TCCState *s1, int fd, const char *filename, int level)
{
	ElfW(Ehdr) ehdr;
	ElfW(Shdr) *shdr, *sh, *sh1;
	int i, j, nb_syms, nb_dts, sym_bind, ret;
	ElfW(Sym) *sym, *dynsym;
	ElfW(Dyn) *dt, *dynamic;

	char *dynstr;
	int sym_index;
	const char *name, *soname;
	DLLReference *dllref;
	struct versym_info v;

	full_read(fd, &ehdr, sizeof(ehdr));

	/* test CPU specific stuff */
	if (ehdr.e_ident[5] != ELFDATA2LSB ||
	        ehdr.e_machine != EM_TCC_TARGET)
	{
		tcc_error_noabort("bad architecture");
		return -1;
	}

	/* read sections */
	shdr = load_data(fd, ehdr.e_shoff, sizeof(ElfW(Shdr)) * ehdr.e_shnum);

	/* load dynamic section and dynamic symbols */
	nb_syms = 0;
	nb_dts = 0;
	dynamic = NULL;
	dynsym = NULL; /* avoid warning */
	dynstr = NULL; /* avoid warning */
	memset(&v, 0, sizeof v);

	for(i = 0, sh = shdr; i < ehdr.e_shnum; i++, sh++)
	{
		switch(sh->sh_type)
		{
		case SHT_DYNAMIC:
			nb_dts = sh->sh_size / sizeof(ElfW(Dyn));
			dynamic = load_data(fd, sh->sh_offset, sh->sh_size);
			break;
		case SHT_DYNSYM:
			nb_syms = sh->sh_size / sizeof(ElfW(Sym));
			dynsym = load_data(fd, sh->sh_offset, sh->sh_size);
			sh1 = &shdr[sh->sh_link];
			dynstr = load_data(fd, sh1->sh_offset, sh1->sh_size);
			break;
		case SHT_GNU_verdef:
			v.verdef = load_data(fd, sh->sh_offset, sh->sh_size);
			break;
		case SHT_GNU_verneed:
			v.verneed = load_data(fd, sh->sh_offset, sh->sh_size);
			break;
		case SHT_GNU_versym:
			v.nb_versyms = sh->sh_size / sizeof(ElfW(Half));
			v.versym = load_data(fd, sh->sh_offset, sh->sh_size);
			break;
		default:
			break;
		}
	}

	/* compute the real library name */
	soname = tcc_basename(filename);

	for(i = 0, dt = dynamic; i < nb_dts; i++, dt++)
	{
		if (dt->d_tag == DT_SONAME)
		{
			soname = dynstr + dt->d_un.d_val;
		}
	}

	/* if the dll is already loaded, do not load it */
	for(i = 0; i < s1->nb_loaded_dlls; i++)
	{
		dllref = s1->loaded_dlls[i];
		if (!strcmp(soname, dllref->name))
		{
			/* but update level if needed */
			if (level < dllref->level)
				dllref->level = level;
			ret = 0;
			goto the_end;
		}
	}

	if (v.nb_versyms != nb_syms)
		tcc_free (v.versym), v.versym = NULL;
	else
		store_version(s1, &v, dynstr);

	/* add the dll and its level */
	dllref = tcc_mallocz(sizeof(DLLReference) + strlen(soname));
	dllref->level = level;
	strcpy(dllref->name, soname);
	dynarray_add(&s1->loaded_dlls, &s1->nb_loaded_dlls, dllref);

	/* add dynamic symbols in dynsym_section */
	for(i = 1, sym = dynsym + 1; i < nb_syms; i++, sym++)
	{
		sym_bind = ELFW(ST_BIND)(sym->st_info);
		if (sym_bind == STB_LOCAL)
			continue;
		name = dynstr + sym->st_name;
		sym_index = set_elf_sym(s1->dynsymtab_section, sym->st_value, sym->st_size,
		                        sym->st_info, sym->st_other, sym->st_shndx, name);
		if (v.versym)
		{
			ElfW(Half) vsym = v.versym[i];
			if ((vsym & 0x8000) == 0 && vsym > 0 && vsym < v.nb_local_ver)
				set_sym_version(s1, sym_index, v.local_ver[vsym]);
		}
	}

	/* load all referenced DLLs */
	for(i = 0, dt = dynamic; i < nb_dts; i++, dt++)
	{
		switch(dt->d_tag)
		{
		case DT_NEEDED:
			name = dynstr + dt->d_un.d_val;
			for(j = 0; j < s1->nb_loaded_dlls; j++)
			{
				dllref = s1->loaded_dlls[j];
				if (!strcmp(name, dllref->name))
					goto already_loaded;
			}
			if (tcc_add_dll(s1, name, AFF_REFERENCED_DLL) < 0)
			{
				tcc_error_noabort("referenced dll '%s' not found", name);
				ret = -1;
				goto the_end;
			}
already_loaded:
			break;
		}
	}
	ret = 0;
the_end:
	tcc_free(dynstr);
	tcc_free(dynsym);
	tcc_free(dynamic);
	tcc_free(shdr);
	tcc_free(v.local_ver);
	tcc_free(v.verdef);
	tcc_free(v.verneed);
	tcc_free(v.versym);
	return ret;
}

#define LD_TOK_NAME 256
#define LD_TOK_EOF  (-1)

static int ld_inp(TCCState *s1)
{
	char b;
	if (s1->cc != -1)
	{
		int c = s1->cc;
		s1->cc = -1;
		return c;
	}
	if (1 == read(s1->fd, &b, 1))
		return b;
	return CH_EOF;
}

/* return next ld script token */
static int ld_next(TCCState *s1, char *name, int name_size)
{
	int c, d, ch;
	char *q;

redo:
	ch = ld_inp(s1);
	switch(ch)
	{
	case ' ':
	case '\t':
	case '\f':
	case '\v':
	case '\r':
	case '\n':
		goto redo;
	case '/':
		ch = ld_inp(s1);
		if (ch == '*')   /* comment */
		{
			for (d = 0;; d = ch)
			{
				ch = ld_inp(s1);
				if (ch == CH_EOF || (ch == '/' && d == '*'))
					break;
			}
			goto redo;
		}
		else
		{
			q = name;
			*q++ = '/';
			goto parse_name;
		}
		break;
	case '\\':
	/* case 'a' ... 'z': */
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':
	/* case 'A' ... 'z': */
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case '.':
	case '$':
	case '~':
		q = name;
parse_name:
		for(;;)
		{
			if (!((ch >= 'a' && ch <= 'z') ||
			        (ch >= 'A' && ch <= 'Z') ||
			        (ch >= '0' && ch <= '9') ||
			        strchr("/.-_+=$:\\,~", ch)))
				break;
			if ((q - name) < name_size - 1)
			{
				*q++ = ch;
			}
			ch = ld_inp(s1);
		}
		s1->cc = ch;
		*q = '\0';
		c = LD_TOK_NAME;
		break;
	case CH_EOF:
		c = LD_TOK_EOF;
		break;
	default:
		c = ch;
		break;
	}
	return c;
}

static int ld_add_file(TCCState *s1, const char filename[])
{
	if (filename[0] == '/')
	{
		if (CONFIG_SYSROOT[0] == '\0'
		        && tcc_add_file_internal(s1, filename, AFF_TYPE_BIN) == 0)
			return 0;
		filename = tcc_basename(filename);
	}
	return tcc_add_dll(s1, filename, 0);
}

static int ld_add_file_list(TCCState *s1, const char *cmd, int as_needed)
{
	char filename[1048], libname[1024];
	int t, group, nblibs = 0, ret = 0;
	char **libs = NULL;

	group = !strcmp(cmd, "GROUP");
	if (!as_needed)
		s1->new_undef_sym = 0;
	t = ld_next(s1, filename, sizeof(filename));
	if (t != '(')
	{
		tcc_error_noabort("( expected");
		ret = -1;
		goto lib_parse_error;
	}
	t = ld_next(s1, filename, sizeof(filename));
	for(;;)
	{
		libname[0] = '\0';
		if (t == LD_TOK_EOF)
		{
			tcc_error_noabort("unexpected end of file");
			ret = -1;
			goto lib_parse_error;
		}
		else if (t == ')')
		{
			break;
		}
		else if (t == '-')
		{
			t = ld_next(s1, filename, sizeof(filename));
			if ((t != LD_TOK_NAME) || (filename[0] != 'l'))
			{
				tcc_error_noabort("library name expected");
				ret = -1;
				goto lib_parse_error;
			}
			pstrcpy(libname, sizeof libname, &filename[1]);
			if (s1->static_link)
			{
				snprintf(filename, sizeof filename, "lib%s.a", libname);
			}
			else
			{
				snprintf(filename, sizeof filename, "lib%s.so", libname);
			}
		}
		else if (t != LD_TOK_NAME)
		{
			tcc_error_noabort("filename expected");
			ret = -1;
			goto lib_parse_error;
		}
		if (!strcmp(filename, "AS_NEEDED"))
		{
			ret = ld_add_file_list(s1, cmd, 1);
			if (ret)
				goto lib_parse_error;
		}
		else
		{
			/* TODO: Implement AS_NEEDED support. Ignore it for now */
			if (!as_needed)
			{
				ret = ld_add_file(s1, filename);
				if (ret)
					goto lib_parse_error;
				if (group)
				{
					/* Add the filename *and* the libname to avoid future conversions */
					dynarray_add(&libs, &nblibs, tcc_strdup(filename));
					if (libname[0] != '\0')
						dynarray_add(&libs, &nblibs, tcc_strdup(libname));
				}
			}
		}
		t = ld_next(s1, filename, sizeof(filename));
		if (t == ',')
		{
			t = ld_next(s1, filename, sizeof(filename));
		}
	}
	if (group && !as_needed)
	{
		while (s1->new_undef_sym)
		{
			int i;
			s1->new_undef_sym = 0;
			for (i = 0; i < nblibs; i ++)
				ld_add_file(s1, libs[i]);
		}
	}
lib_parse_error:
	dynarray_reset(&libs, &nblibs);
	return ret;
}

/* interpret a subset of GNU ldscripts to handle the dummy libc.so
   files */
ST_FUNC int tcc_load_ldscript(TCCState *s1, int fd)
{
	char cmd[64];
	char filename[1024];
	int t, ret;

	s1->fd = fd;
	s1->cc = -1;
	for(;;)
	{
		t = ld_next(s1, cmd, sizeof(cmd));
		if (t == LD_TOK_EOF)
			return 0;
		else if (t != LD_TOK_NAME)
			return -1;
		if (!strcmp(cmd, "INPUT") ||
		        !strcmp(cmd, "GROUP"))
		{
			ret = ld_add_file_list(s1, cmd, 0);
			if (ret)
				return ret;
		}
		else if (!strcmp(cmd, "OUTPUT_FORMAT") ||
		         !strcmp(cmd, "TARGET"))
		{
			/* ignore some commands */
			t = ld_next(s1, cmd, sizeof(cmd));
			if (t != '(')
			{
				tcc_error_noabort("( expected");
				return -1;
			}
			for(;;)
			{
				t = ld_next(s1, filename, sizeof(filename));
				if (t == LD_TOK_EOF)
				{
					tcc_error_noabort("unexpected end of file");
					return -1;
				}
				else if (t == ')')
				{
					break;
				}
			}
		}
		else
		{
			return -1;
		}
	}
	return 0;
}
#endif /* !ELF_OBJ_ONLY */

//END tccelf.c

//START tccrun.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

/* only native compiler supports -run */
#ifdef TCC_IS_NATIVE

#ifdef CONFIG_TCC_BACKTRACE
typedef struct rt_context
{
	/* --> tccelf.c:tcc_add_btstub wants those below in that order: */
	Stab_Sym *stab_sym, *stab_sym_end;
	char *stab_str;
	ElfW(Sym) *esym_start, *esym_end;
	char *elf_str;
	addr_t prog_base;
	void *bounds_start;
	struct rt_context *next;
	/* <-- */
	int num_callers;
	addr_t ip, fp, sp;
	void *top_func;
	jmp_buf jmp_buf;
	char do_jmp;
} rt_context;

static rt_context g_rtctxt;
static void set_exception_handler(void);
static int _rt_error(void *fp, void *ip, const char *fmt, va_list ap);
static void rt_exit(int code);
#endif /* CONFIG_TCC_BACKTRACE */

/* defined when included from lib/bt-exe.c */
#ifndef CONFIG_TCC_BACKTRACE_ONLY

#ifndef _WIN32
# include <sys/mman.h>
#endif

static void set_pages_executable(TCCState *s1, void *ptr, unsigned long length);
static int tcc_relocate_ex(TCCState *s1, void *ptr, addr_t ptr_diff);

#ifdef _WIN64
static void *win64_add_function_table(TCCState *s1);
static void win64_del_function_table(void *);
#endif

/* ------------------------------------------------------------- */
/* Do all relocations (needed before using tcc_get_symbol())
   Returns -1 on error. */

LIBTCCAPI int tcc_relocate(TCCState *s1, void *ptr)
{
	int size;
	addr_t ptr_diff = 0;

	if (TCC_RELOCATE_AUTO != ptr)
		return tcc_relocate_ex(s1, ptr, 0);

	size = tcc_relocate_ex(s1, NULL, 0);
	if (size < 0)
		return -1;

#ifdef HAVE_SELINUX
	{
		/* Using mmap instead of malloc */
		void *prx;
		char tmpfname[] = "/tmp/.tccrunXXXXXX";
		int fd = mkstemp(tmpfname);
		unlink(tmpfname);
		ftruncate(fd, size);

		ptr = mmap (NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
		prx = mmap (NULL, size, PROT_READ|PROT_EXEC, MAP_SHARED, fd, 0);
		if (ptr == MAP_FAILED || prx == MAP_FAILED)
			tcc_error("tccrun: could not map memory");
		dynarray_add(&s1->runtime_mem, &s1->nb_runtime_mem, (void*)(addr_t)size);
		dynarray_add(&s1->runtime_mem, &s1->nb_runtime_mem, prx);
		ptr_diff = (char*)prx - (char*)ptr;
		close(fd);
	}
#else
	ptr = tcc_malloc(size);
#endif
	tcc_relocate_ex(s1, ptr, ptr_diff); /* no more errors expected */
	dynarray_add(&s1->runtime_mem, &s1->nb_runtime_mem, ptr);
	return 0;
}

ST_FUNC void tcc_run_free(TCCState *s1)
{
	int i;

	for (i = 0; i < s1->nb_runtime_mem; ++i)
	{
#ifdef HAVE_SELINUX
		unsigned size = (unsigned)(addr_t)s1->runtime_mem[i++];
		munmap(s1->runtime_mem[i++], size);
		munmap(s1->runtime_mem[i], size);
#else
#ifdef _WIN64
		win64_del_function_table(*(void**)s1->runtime_mem[i]);
#endif
		tcc_free(s1->runtime_mem[i]);
#endif
	}
	tcc_free(s1->runtime_mem);
}

static void run_cdtors(TCCState *s1, const char *start, const char *end)
{
	void **a = tcc_get_symbol(s1, start);
	void **b = tcc_get_symbol(s1, end);
	while (a != b)
		((void(*)(void))*a++)();
}

/* launch the compiled program with the given arguments */
LIBTCCAPI int tcc_run(TCCState *s1, int argc, char **argv)
{
	int (*prog_main)(int, char **), ret;
#ifdef CONFIG_TCC_BACKTRACE
	rt_context *rc = &g_rtctxt;
#endif

	s1->runtime_main = s1->nostdlib ? "_start" : "main";
	if ((s1->dflag & 16) && !find_elf_sym(s1->symtab, s1->runtime_main))
		return 0;
#ifdef CONFIG_TCC_BACKTRACE
	if (s1->do_debug)
		tcc_add_symbol(s1, "exit", rt_exit);
#endif
	if (tcc_relocate(s1, TCC_RELOCATE_AUTO) < 0)
		return -1;
	prog_main = tcc_get_symbol_err(s1, s1->runtime_main);

#ifdef CONFIG_TCC_BACKTRACE
	memset(rc, 0, sizeof *rc);
	if (s1->do_debug)
	{
		void *p;
		rc->stab_sym = (Stab_Sym *)stab_section->data;
		rc->stab_sym_end = (Stab_Sym *)(stab_section->data + stab_section->data_offset);
		rc->stab_str = (char *)stab_section->link->data;
		rc->esym_start = (ElfW(Sym) *)(symtab_section->data);
		rc->esym_end = (ElfW(Sym) *)(symtab_section->data + symtab_section->data_offset);
		rc->elf_str = (char *)symtab_section->link->data;
#if PTR_SIZE == 8
		rc->prog_base = text_section->sh_addr & 0xffffffff00000000ULL;
#endif
		rc->top_func = tcc_get_symbol(s1, "main");
		rc->num_callers = s1->rt_num_callers;
		rc->do_jmp = 1;
		if ((p = tcc_get_symbol(s1, "__rt_error")))
			*(void**)p = _rt_error;
#ifdef CONFIG_TCC_BCHECK
		if (s1->do_bounds_check)
		{
			if ((p = tcc_get_symbol(s1, "__bound_init")))
				((void(*)(void*))p)(bounds_section->data);
		}
#endif
		set_exception_handler();
	}
#endif

	errno = 0; /* clean errno value */
	fflush(stdout);
	fflush(stderr);
	run_cdtors(s1, "__init_array_start", "__init_array_end");
#ifdef CONFIG_TCC_BACKTRACE
	if (!rc->do_jmp || !(ret = setjmp(rc->jmp_buf)))
#endif
	{
		ret = prog_main(argc, argv);
	}
	run_cdtors(s1, "__fini_array_start", "__fini_array_end");
	if ((s1->dflag & 16) && ret)
		fprintf(s1->ppfp, "[returns %d]\n", ret), fflush(s1->ppfp);
	return ret;
}

#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
/* To avoid that x86 processors would reload cached instructions
   each time when data is written in the near, we need to make
   sure that code and data do not share the same 64 byte unit */
#define RUN_SECTION_ALIGNMENT 63
#else
#define RUN_SECTION_ALIGNMENT 0
#endif

/* relocate code. Return -1 on error, required size if ptr is NULL,
   otherwise copy code into buffer passed by the caller */
static int tcc_relocate_ex(TCCState *s1, void *ptr, addr_t ptr_diff)
{
	Section *s;
	unsigned offset, length, align, max_align, i, k, f;
	addr_t mem, addr;

	if (NULL == ptr)
	{
		s1->nb_errors = 0;
#ifdef TCC_TARGET_PE
		pe_output_file(s1, NULL);
#else
		tcc_add_runtime(s1);
		resolve_common_syms(s1);
		build_got_entries(s1);
#endif
		if (s1->nb_errors)
			return -1;
	}

	offset = max_align = 0, mem = (addr_t)ptr;
#ifdef _WIN64
	offset += sizeof (void*); /* space for function_table pointer */
#endif
	for (k = 0; k < 2; ++k)
	{
		f = 0, addr = k ? mem : mem + ptr_diff;
		for(i = 1; i < s1->nb_sections; i++)
		{
			s = s1->sections[i];
			if (0 == (s->sh_flags & SHF_ALLOC))
				continue;
			if (k != !(s->sh_flags & SHF_EXECINSTR))
				continue;
			align = s->sh_addralign - 1;
			if (++f == 1 && align < RUN_SECTION_ALIGNMENT)
				align = RUN_SECTION_ALIGNMENT;
			if (max_align < align)
				max_align = align;
			offset += -(addr + offset) & align;
			s->sh_addr = mem ? addr + offset : 0;
			offset += s->data_offset;
#if 0
			if (mem)
				printf("%-16s %p  len %04x  align %2d\n",
				       s->name, (void*)s->sh_addr, (unsigned)s->data_offset, align + 1);
#endif
		}
	}

	/* relocate symbols */
	relocate_syms(s1, s1->symtab, 1);
	if (s1->nb_errors)
		return -1;

	if (0 == mem)
		return offset + max_align;

#ifdef TCC_TARGET_PE
	s1->pe_imagebase = mem;
#endif

	/* relocate each section */
	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if (s->reloc)
			relocate_section(s1, s);
	}
#ifndef TCC_TARGET_PE
	relocate_plt(s1);
#endif

	for(i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];
		if (0 == (s->sh_flags & SHF_ALLOC))
			continue;
		length = s->data_offset;
		ptr = (void*)s->sh_addr;
		if (s->sh_flags & SHF_EXECINSTR)
			ptr = (char*)((addr_t)ptr - ptr_diff);
		if (NULL == s->data || s->sh_type == SHT_NOBITS)
			memset(ptr, 0, length);
		else
			memcpy(ptr, s->data, length);
		/* mark executable sections as executable in memory */
		if (s->sh_flags & SHF_EXECINSTR)
			set_pages_executable(s1, (char*)((addr_t)ptr + ptr_diff), length);
	}

#ifdef _WIN64
	*(void**)mem = win64_add_function_table(s1);
#endif

	return 0;
}

/* ------------------------------------------------------------- */
/* allow to run code in memory */

static void set_pages_executable(TCCState *s1, void *ptr, unsigned long length)
{
#ifdef _WIN32
	unsigned long old_protect;
	VirtualProtect(ptr, length, PAGE_EXECUTE_READWRITE, &old_protect);
#else
	void __clear_cache(void *beginning, void *end);
# ifndef HAVE_SELINUX
	addr_t start, end;
#  ifndef PAGESIZE
#   define PAGESIZE 4096
#  endif
	start = (addr_t)ptr & ~(PAGESIZE - 1);
	end = (addr_t)ptr + length;
	end = (end + PAGESIZE - 1) & ~(PAGESIZE - 1);
	if (mprotect((void *)start, end - start, PROT_READ | PROT_WRITE | PROT_EXEC))
		tcc_error("mprotect failed: did you mean to configure --with-selinux?");
# endif
# if defined TCC_TARGET_ARM || defined TCC_TARGET_ARM64
	__clear_cache(ptr, (char *)ptr + length);
# endif
#endif
}

#ifdef _WIN64
static void *win64_add_function_table(TCCState *s1)
{
	void *p = NULL;
	if (s1->uw_pdata)
	{
		p = (void*)s1->uw_pdata->sh_addr;
		RtlAddFunctionTable(
		    (RUNTIME_FUNCTION*)p,
		    s1->uw_pdata->data_offset / sizeof (RUNTIME_FUNCTION),
		    s1->pe_imagebase
		);
		s1->uw_pdata = NULL;
	}
	return p;
}

static void win64_del_function_table(void *p)
{
	if (p)
	{
		RtlDeleteFunctionTable((RUNTIME_FUNCTION*)p);
	}
}
#endif
#endif //ndef CONFIG_TCC_BACKTRACE_ONLY
/* ------------------------------------------------------------- */
#ifdef CONFIG_TCC_BACKTRACE

static int rt_vprintf(const char *fmt, va_list ap)
{
	int ret = vfprintf(stderr, fmt, ap);
	fflush(stderr);
	return ret;
}

static int rt_printf(const char *fmt, ...)
{
	va_list ap;
	int r;
	va_start(ap, fmt);
	r = rt_vprintf(fmt, ap);
	va_end(ap);
	return r;
}

#define INCLUDE_STACK_SIZE 32

/* print the position in the source file of PC value 'pc' by reading
   the stabs debug information */
static addr_t rt_printline (rt_context *rc, addr_t wanted_pc,
                            const char *msg, const char *skip)
{
	char func_name[128];
	addr_t func_addr, last_pc, pc;
	const char *incl_files[INCLUDE_STACK_SIZE];
	int incl_index, last_incl_index, len, last_line_num, i;
	const char *str, *p;
	ElfW(Sym) *esym;
	Stab_Sym *sym;

next:
	func_name[0] = '\0';
	func_addr = 0;
	incl_index = 0;
	last_pc = (addr_t)-1;
	last_line_num = 1;
	last_incl_index = 0;

	for (sym = rc->stab_sym + 1; sym < rc->stab_sym_end; ++sym)
	{
		str = rc->stab_str + sym->n_strx;
		pc = sym->n_value;

		switch(sym->n_type)
		{
		case N_SLINE:
			if (func_addr)
				goto rel_pc;
		case N_SO:
		case N_SOL:
			goto abs_pc;
		case N_FUN:
			if (sym->n_strx == 0) /* end of function */
				goto rel_pc;
abs_pc:
#if PTR_SIZE == 8
			/* Stab_Sym.n_value is only 32bits */
			pc += rc->prog_base;
#endif
			goto check_pc;
rel_pc:
			pc += func_addr;
check_pc:
			if (pc >= wanted_pc && wanted_pc >= last_pc)
				goto found;
			break;
		}

		switch(sym->n_type)
		{
		/* function start or end */
		case N_FUN:
			if (sym->n_strx == 0)
				goto reset_func;
			p = strchr(str, ':');
			if (0 == p || (len = p - str + 1, len > sizeof func_name))
				len = sizeof func_name;
			pstrcpy(func_name, len, str);
			func_addr = pc;
			break;
		/* line number info */
		case N_SLINE:
			last_pc = pc;
			last_line_num = sym->n_desc;
			last_incl_index = incl_index;
			break;
		/* include files */
		case N_BINCL:
			if (incl_index < INCLUDE_STACK_SIZE)
				incl_files[incl_index++] = str;
			break;
		case N_EINCL:
			if (incl_index > 1)
				incl_index--;
			break;
		/* start/end of translation unit */
		case N_SO:
			incl_index = 0;
			if (sym->n_strx)
			{
				/* do not add path */
				len = strlen(str);
				if (len > 0 && str[len - 1] != '/')
					incl_files[incl_index++] = str;
			}
reset_func:
			func_name[0] = '\0';
			func_addr = 0;
			last_pc = (addr_t)-1;
			break;
		/* alternative file name (from #line or #include directives) */
		case N_SOL:
			if (incl_index)
				incl_files[incl_index-1] = str;
			break;
		}
	}

	func_name[0] = '\0';
	func_addr = 0;
	last_incl_index = 0;

	/* we try symtab symbols (no line number info) */
	for (esym = rc->esym_start + 1; esym < rc->esym_end; ++esym)
	{
		int type = ELFW(ST_TYPE)(esym->st_info);
		if (type == STT_FUNC || type == STT_GNU_IFUNC)
		{
			if (wanted_pc >= esym->st_value &&
			        wanted_pc < esym->st_value + esym->st_size)
			{
				pstrcpy(func_name, sizeof(func_name),
				        rc->elf_str + esym->st_name);
				func_addr = esym->st_value;
				goto found;
			}
		}
	}

	if ((rc = rc->next))
		goto next;

found:
	i = last_incl_index;
	if (i > 0)
	{
		str = incl_files[--i];
		if (skip[0] && strstr(str, skip))
			return (addr_t)-1;
		rt_printf("%s:%d: ", str, last_line_num);
	}
	else
		rt_printf("%08llx : ", (long long)wanted_pc);
	rt_printf("%s %s", msg, func_name[0] ? func_name : "???");
#if 0
	if (--i >= 0)
	{
		rt_printf(" (included from ");
		for (;;)
		{
			rt_printf("%s", incl_files[i]);
			if (--i < 0)
				break;
			rt_printf(", ");
		}
		rt_printf(")");
	}
#endif
	return func_addr;
}

static int rt_get_caller_pc(addr_t *paddr, rt_context *rc, int level);

static int _rt_error(void *fp, void *ip, const char *fmt, va_list ap)
{
	rt_context *rc = &g_rtctxt;
	addr_t pc = 0;
	char skip[100];
	int i, level, ret, n;
	const char *a, *b, *msg;

	if (fp)
	{
		/* we're called from tcc_backtrace. */
		rc->fp = (addr_t)fp;
		rc->ip = (addr_t)ip;
		msg = "";
	}
	else
	{
		/* we're called from signal/exception handler */
		msg = "RUNTIME ERROR: ";
	}

	skip[0] = 0;
	/* If fmt is like "^file.c^..." then skip calls from 'file.c' */
	if (fmt[0] == '^' && (b = strchr(a = fmt + 1, fmt[0])))
	{
		memcpy(skip, a, b - a), skip[b - a] = 0;
		fmt = b + 1;
	}

	n = rc->num_callers ? rc->num_callers : 6;
	for (i = level = 0; level < n; i++)
	{
		ret = rt_get_caller_pc(&pc, rc, i);
		a = "%s";
		if (ret != -1)
		{
			pc = rt_printline(rc, pc, level ? "by" : "at", skip);
			if (pc == (addr_t)-1)
				continue;
			a = ": %s";
		}
		if (level == 0)
		{
			rt_printf(a, msg);
			rt_vprintf(fmt, ap);
		}
		else if (ret == -1)
			break;
		rt_printf("\n");
		if (ret == -1 || (pc == (addr_t)rc->top_func && pc))
			break;
		++level;
	}

	rc->ip = rc->fp = 0;
	return 0;
}

/* emit a run time error at position 'pc' */
static int rt_error(const char *fmt, ...)
{
	va_list ap;
	int ret;
	va_start(ap, fmt);
	ret = _rt_error(0, 0, fmt, ap);
	va_end(ap);
	return ret;
}

static void rt_exit(int code)
{
	rt_context *rc = &g_rtctxt;
	if (rc->do_jmp)
		longjmp(rc->jmp_buf, code ? code : 256);
	exit(code);
}

/* ------------------------------------------------------------- */

#ifndef _WIN32
# include <signal.h>
# ifndef __OpenBSD__
#  include <sys/ucontext.h>
# endif
#else
# define ucontext_t CONTEXT
#endif

/* translate from ucontext_t* to internal rt_context * */
static void rt_getcontext(ucontext_t *uc, rt_context *rc)
{
#if defined _WIN64
	rc->ip = uc->Rip;
	rc->fp = uc->Rbp;
	rc->sp = uc->Rsp;
#elif defined _WIN32
	rc->ip = uc->Eip;
	rc->fp = uc->Ebp;
	rc->sp = uc->Esp;
#elif defined __i386__
# if defined(__APPLE__)
	rc->ip = uc->uc_mcontext->__ss.__eip;
	rc->fp = uc->uc_mcontext->__ss.__ebp;
# elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
	rc->ip = uc->uc_mcontext.mc_eip;
	rc->fp = uc->uc_mcontext.mc_ebp;
# elif defined(__dietlibc__)
	rc->ip = uc->uc_mcontext.eip;
	rc->fp = uc->uc_mcontext.ebp;
# elif defined(__NetBSD__)
	rc->ip = uc->uc_mcontext.__gregs[_REG_EIP];
	rc->fp = uc->uc_mcontext.__gregs[_REG_EBP];
# elif defined(__OpenBSD__)
	rc->ip = uc->sc_eip;
	rc->fp = uc->sc_ebp;
# elif !defined REG_EIP && defined EIP /* fix for glibc 2.1 */
	rc->ip = uc->uc_mcontext.gregs[EIP];
	rc->fp = uc->uc_mcontext.gregs[EBP];
# else
	rc->ip = uc->uc_mcontext.gregs[REG_EIP];
	rc->fp = uc->uc_mcontext.gregs[REG_EBP];
# endif
#elif defined(__x86_64__)
# if defined(__APPLE__)
	rc->ip = uc->uc_mcontext->__ss.__rip;
	rc->fp = uc->uc_mcontext->__ss.__rbp;
# elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
	rc->ip = uc->uc_mcontext.mc_rip;
	rc->fp = uc->uc_mcontext.mc_rbp;
# elif defined(__NetBSD__)
	rc->ip = uc->uc_mcontext.__gregs[_REG_RIP];
	rc->fp = uc->uc_mcontext.__gregs[_REG_RBP];
# else
	rc->ip = uc->uc_mcontext.gregs[REG_RIP];
	rc->fp = uc->uc_mcontext.gregs[REG_RBP];
# endif
#elif defined(__arm__)
	rc->ip = uc->uc_mcontext.arm_pc;
	rc->fp = uc->uc_mcontext.arm_fp;
	rc->sp = uc->uc_mcontext.arm_sp;
#elif defined(__aarch64__)
	rc->ip = uc->uc_mcontext.pc;
	rc->fp = uc->uc_mcontext.regs[29];
#endif
}

/* ------------------------------------------------------------- */
#ifndef _WIN32
/* signal handler for fatal errors */
static void sig_error(int signum, siginfo_t *siginf, void *puc)
{
	rt_context *rc = &g_rtctxt;
	rt_getcontext(puc, rc);

	switch(signum)
	{
	case SIGFPE:
		switch(siginf->si_code)
		{
		case FPE_INTDIV:
		case FPE_FLTDIV:
			rt_error("division by zero");
			break;
		default:
			rt_error("floating point exception");
			break;
		}
		break;
	case SIGBUS:
	case SIGSEGV:
		rt_error("invalid memory access");
		break;
	case SIGILL:
		rt_error("illegal instruction");
		break;
	case SIGABRT:
		rt_error("abort() called");
		break;
	default:
		rt_error("caught signal %d", signum);
		break;
	}
	rt_exit(255);
}

#ifndef SA_SIGINFO
# define SA_SIGINFO 0x00000004u
#endif

/* Generate a stack backtrace when a CPU exception occurs. */
static void set_exception_handler(void)
{
	struct sigaction sigact;
	/* install TCC signal handlers to print debug info on fatal
	   runtime errors */
	sigact.sa_flags = SA_SIGINFO | SA_RESETHAND;
#if 0//def SIGSTKSZ // this causes signals not to work at all on some (older) linuxes
	sigact.sa_flags |= SA_ONSTACK;
#endif
	sigact.sa_sigaction = sig_error;
	sigemptyset(&sigact.sa_mask);
	sigaction(SIGFPE, &sigact, NULL);
	sigaction(SIGILL, &sigact, NULL);
	sigaction(SIGSEGV, &sigact, NULL);
	sigaction(SIGBUS, &sigact, NULL);
	sigaction(SIGABRT, &sigact, NULL);
#if 0//def SIGSTKSZ
	/* This allows stack overflow to be reported instead of a SEGV */
	{
		stack_t ss;
		static unsigned char stack[SIGSTKSZ] __attribute__((aligned(16)));

		ss.ss_sp = stack;
		ss.ss_size = SIGSTKSZ;
		ss.ss_flags = 0;
		sigaltstack(&ss, NULL);
	}
#endif
}

#else /* WIN32 */

/* signal handler for fatal errors */
static long __stdcall cpu_exception_handler(EXCEPTION_POINTERS *ex_info)
{
	rt_context *rc = &g_rtctxt;
	unsigned code;
	rt_getcontext(ex_info->ContextRecord, rc);

	switch (code = ex_info->ExceptionRecord->ExceptionCode)
	{
	case EXCEPTION_ACCESS_VIOLATION:
		rt_error("invalid memory access");
		break;
	case EXCEPTION_STACK_OVERFLOW:
		rt_error("stack overflow");
		break;
	case EXCEPTION_INT_DIVIDE_BY_ZERO:
		rt_error("division by zero");
		break;
	case EXCEPTION_BREAKPOINT:
	case EXCEPTION_SINGLE_STEP:
		rc->ip = *(addr_t*)rc->sp;
		rt_error("breakpoint/single-step exception:");
		return EXCEPTION_CONTINUE_SEARCH;
	default:
		rt_error("caught exception %08x", code);
		break;
	}
	if (rc->do_jmp)
		rt_exit(255);
	return EXCEPTION_EXECUTE_HANDLER;
}

/* Generate a stack backtrace when a CPU exception occurs. */
static void set_exception_handler(void)
{
	SetUnhandledExceptionFilter(cpu_exception_handler);
}

#endif

/* ------------------------------------------------------------- */
/* return the PC at frame level 'level'. Return negative if not found */
#if defined(__i386__) || defined(__x86_64__)
static int rt_get_caller_pc(addr_t *paddr, rt_context *rc, int level)
{
	addr_t ip, fp;
	if (level == 0)
	{
		ip = rc->ip;
	}
	else
	{
		ip = 0;
		fp = rc->fp;
		while (--level)
		{
			/* XXX: check address validity with program info */
			if (fp <= 0x1000)
				break;
			fp = ((addr_t *)fp)[0];
		}
		if (fp > 0x1000)
			ip = ((addr_t *)fp)[1];
	}
	if (ip <= 0x1000)
		return -1;
	*paddr = ip;
	return 0;
}

#elif defined(__arm__)
static int rt_get_caller_pc(addr_t *paddr, rt_context *rc, int level)
{
	/* XXX: only supports linux */
#if !defined(__linux__)
	return -1;
#else
	if (level == 0)
	{
		*paddr = rc->ip;
	}
	else
	{
		addr_t fp = rc->fp;
		addr_t sp = rc->sp;
		if (sp < 0x1000)
			sp = 0x1000;
		/* XXX: specific to tinycc stack frames */
		if (fp < sp + 12 || fp & 3)
			return -1;
		while (--level)
		{
			sp = ((addr_t *)fp)[-2];
			if (sp < fp || sp - fp > 16 || sp & 3)
				return -1;
			fp = ((addr_t *)fp)[-3];
			if (fp <= sp || fp - sp < 12 || fp & 3)
				return -1;
		}
		/* XXX: check address validity with program info */
		*paddr = ((addr_t *)fp)[-1];
	}
	return 0;
#endif
}

#elif defined(__aarch64__)
static int rt_get_caller_pc(addr_t *paddr, rt_context *rc, int level)
{
	if (level == 0)
	{
		*paddr = rc->ip;
	}
	else
	{
		addr_t *fp = (addr_t*)rc->fp;
		while (--level)
			fp = (addr_t *)fp[0];
		*paddr = fp[1];
	}
	return 0;
}

#else
#warning add arch specific rt_get_caller_pc()
static int rt_get_caller_pc(addr_t *paddr, rt_context *rc, int level)
{
	return -1;
}

#endif
#endif /* CONFIG_TCC_BACKTRACE */
/* ------------------------------------------------------------- */
#ifdef CONFIG_TCC_STATIC

/* dummy function for profiling */
ST_FUNC void *dlopen(const char *filename, int flag)
{
	return NULL;
}

ST_FUNC void dlclose(void *p)
{
}

ST_FUNC const char *dlerror(void)
{
	return "error";
}

typedef struct TCCSyms
{
	char *str;
	void *ptr;
} TCCSyms;


/* add the symbol you want here if no dynamic linking is done */
static TCCSyms tcc_syms[] =
{
#if !defined(CONFIG_TCCBOOT)
#define TCCSYM(a) { #a, &a, },
	TCCSYM(printf)
	TCCSYM(fprintf)
	TCCSYM(fopen)
	TCCSYM(fclose)
#undef TCCSYM
#endif
	{ NULL, NULL },
};

ST_FUNC void *dlsym(void *handle, const char *symbol)
{
	TCCSyms *p;
	p = tcc_syms;
	while (p->str != NULL)
	{
		if (!strcmp(p->str, symbol))
			return p->ptr;
		p++;
	}
	return NULL;
}

#endif /* CONFIG_TCC_STATIC */
#endif /* TCC_IS_NATIVE */
/* ------------------------------------------------------------- */

//END tccrun.c

//START EXTRA IMPL

#ifdef TCC_TARGET_C67

//START tcccoff.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE
# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

#define MAXNSCNS 255		/* MAXIMUM NUMBER OF SECTIONS         */
#define MAX_STR_TABLE 1000000
AOUTHDR o_filehdr;		/* OPTIONAL (A.OUT) FILE HEADER       */

SCNHDR section_header[MAXNSCNS];

#define MAX_FUNCS 1000
#define MAX_FUNC_NAME_LENGTH 128

int nFuncs;
char Func[MAX_FUNCS][MAX_FUNC_NAME_LENGTH];
char AssociatedFile[MAX_FUNCS][MAX_FUNC_NAME_LENGTH];
int LineNoFilePtr[MAX_FUNCS];
int EndAddress[MAX_FUNCS];
int LastLineNo[MAX_FUNCS];
int FuncEntries[MAX_FUNCS];

int OutputTheSection(Section * sect);
short int GetCoffFlags(const char *s);
void SortSymbolTable(TCCState *s1);
Section *FindSection(TCCState * s1, const char *sname);

int C67_main_entry_point;

int FindCoffSymbolIndex(TCCState * s1, const char *func_name);
int nb_syms;

typedef struct
{
	long tag;
	long size;
	long fileptr;
	long nextsym;
	short int dummy;
} AUXFUNC;

typedef struct
{
	long regmask;
	unsigned short lineno;
	unsigned short nentries;
	int localframe;
	int nextentry;
	short int dummy;
} AUXBF;

typedef struct
{
	long dummy;
	unsigned short lineno;
	unsigned short dummy1;
	int dummy2;
	int dummy3;
	unsigned short dummy4;
} AUXEF;

ST_FUNC int tcc_output_coff(TCCState *s1, FILE *f)
{
	Section *tcc_sect;
	SCNHDR *coff_sec;
	int file_pointer;
	char *Coff_str_table, *pCoff_str_table;
	int CoffTextSectionNo, coff_nb_syms;
	FILHDR file_hdr;		/* FILE HEADER STRUCTURE              */
	Section *stext, *sdata, *sbss;
	int i, NSectionsToOutput = 0;

	Coff_str_table = pCoff_str_table = NULL;

	stext = FindSection(s1, ".text");
	sdata = FindSection(s1, ".data");
	sbss = FindSection(s1, ".bss");

	nb_syms = symtab_section->data_offset / sizeof(Elf32_Sym);
	coff_nb_syms = FindCoffSymbolIndex(s1, "XXXXXXXXXX1");

	file_hdr.f_magic = COFF_C67_MAGIC;	/* magic number */
	file_hdr.f_timdat = 0;	/* time & date stamp */
	file_hdr.f_opthdr = sizeof(AOUTHDR);	/* sizeof(optional hdr) */
	file_hdr.f_flags = 0x1143;	/* flags (copied from what code composer does) */
	file_hdr.f_TargetID = 0x99;	/* for C6x = 0x0099 */

	o_filehdr.magic = 0x0108;	/* see magic.h                          */
	o_filehdr.vstamp = 0x0190;	/* version stamp                        */
	o_filehdr.tsize = stext->data_offset;	/* text size in bytes, padded to FW bdry */
	o_filehdr.dsize = sdata->data_offset;	/* initialized data "  "                */
	o_filehdr.bsize = sbss->data_offset;	/* uninitialized data "   "             */
	o_filehdr.entrypt = C67_main_entry_point;	/* entry pt.                          */
	o_filehdr.text_start = stext->sh_addr;	/* base of text used for this file      */
	o_filehdr.data_start = sdata->sh_addr;	/* base of data used for this file      */


	// create all the section headers

	file_pointer = FILHSZ + sizeof(AOUTHDR);

	CoffTextSectionNo = -1;

	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		if (OutputTheSection(tcc_sect))
		{
			NSectionsToOutput++;

			if (CoffTextSectionNo == -1 && tcc_sect == stext)
				CoffTextSectionNo = NSectionsToOutput;	// rem which coff sect number the .text sect is

			strcpy(coff_sec->s_name, tcc_sect->name);	/* section name */

			coff_sec->s_paddr = tcc_sect->sh_addr;	/* physical address */
			coff_sec->s_vaddr = tcc_sect->sh_addr;	/* virtual address */
			coff_sec->s_size = tcc_sect->data_offset;	/* section size */
			coff_sec->s_scnptr = 0;	/* file ptr to raw data for section */
			coff_sec->s_relptr = 0;	/* file ptr to relocation */
			coff_sec->s_lnnoptr = 0;	/* file ptr to line numbers */
			coff_sec->s_nreloc = 0;	/* number of relocation entries */
			coff_sec->s_flags = GetCoffFlags(coff_sec->s_name);	/* flags */
			coff_sec->s_reserved = 0;	/* reserved byte */
			coff_sec->s_page = 0;	/* memory page id */

			file_pointer += sizeof(SCNHDR);
		}
	}

	file_hdr.f_nscns = NSectionsToOutput;	/* number of sections */

	// now loop through and determine file pointer locations
	// for the raw data


	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		if (OutputTheSection(tcc_sect))
		{
			// put raw data
			coff_sec->s_scnptr = file_pointer;	/* file ptr to raw data for section */
			file_pointer += coff_sec->s_size;
		}
	}

	// now loop through and determine file pointer locations
	// for the relocation data

	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		if (OutputTheSection(tcc_sect))
		{
			// put relocations data
			if (coff_sec->s_nreloc > 0)
			{
				coff_sec->s_relptr = file_pointer;	/* file ptr to relocation */
				file_pointer += coff_sec->s_nreloc * sizeof(struct reloc);
			}
		}
	}

	// now loop through and determine file pointer locations
	// for the line number data

	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		coff_sec->s_nlnno = 0;
		coff_sec->s_lnnoptr = 0;

		if (s1->do_debug && tcc_sect == stext)
		{
			// count how many line nos data

			// also find association between source file name and function
			// so we can sort the symbol table


			Stab_Sym *sym, *sym_end;
			char func_name[MAX_FUNC_NAME_LENGTH],
			     last_func_name[MAX_FUNC_NAME_LENGTH];
			unsigned long func_addr, last_pc, pc;
			const char *incl_files[INCLUDE_STACK_SIZE];
			int incl_index, len, last_line_num;
			const char *str, *p;

			coff_sec->s_lnnoptr = file_pointer;	/* file ptr to linno */


			func_name[0] = '\0';
			func_addr = 0;
			incl_index = 0;
			last_func_name[0] = '\0';
			last_pc = 0xffffffff;
			last_line_num = 1;
			sym = (Stab_Sym *) stab_section->data + 1;
			sym_end =
			    (Stab_Sym *) (stab_section->data +
			                  stab_section->data_offset);

			nFuncs = 0;
			while (sym < sym_end)
			{
				switch (sym->n_type)
				{
				/* function start or end */
				case N_FUN:
					if (sym->n_strx == 0)
					{
						// end of function

						coff_sec->s_nlnno++;
						file_pointer += LINESZ;

						pc = sym->n_value + func_addr;
						func_name[0] = '\0';
						func_addr = 0;
						EndAddress[nFuncs] = pc;
						FuncEntries[nFuncs] =
						    (file_pointer -
						     LineNoFilePtr[nFuncs]) / LINESZ - 1;
						LastLineNo[nFuncs++] = last_line_num + 1;
					}
					else
					{
						// beginning of function

						LineNoFilePtr[nFuncs] = file_pointer;
						coff_sec->s_nlnno++;
						file_pointer += LINESZ;

						str =
						    (const char *) stabstr_section->data +
						    sym->n_strx;

						p = strchr(str, ':');
						if (!p)
						{
							pstrcpy(func_name, sizeof(func_name), str);
							pstrcpy(Func[nFuncs], sizeof(func_name), str);
						}
						else
						{
							len = p - str;
							if (len > sizeof(func_name) - 1)
								len = sizeof(func_name) - 1;
							memcpy(func_name, str, len);
							memcpy(Func[nFuncs], str, len);
							func_name[len] = '\0';
						}

						// save the file that it came in so we can sort later
						pstrcpy(AssociatedFile[nFuncs], sizeof(func_name),
						        incl_files[incl_index - 1]);

						func_addr = sym->n_value;
					}
					break;

				/* line number info */
				case N_SLINE:
					pc = sym->n_value + func_addr;

					last_pc = pc;
					last_line_num = sym->n_desc;

					/* XXX: slow! */
					strcpy(last_func_name, func_name);

					coff_sec->s_nlnno++;
					file_pointer += LINESZ;
					break;
				/* include files */
				case N_BINCL:
					str =
					    (const char *) stabstr_section->data + sym->n_strx;
add_incl:
					if (incl_index < INCLUDE_STACK_SIZE)
					{
						incl_files[incl_index++] = str;
					}
					break;
				case N_EINCL:
					if (incl_index > 1)
						incl_index--;
					break;
				case N_SO:
					if (sym->n_strx == 0)
					{
						incl_index = 0;	/* end of translation unit */
					}
					else
					{
						str =
						    (const char *) stabstr_section->data +
						    sym->n_strx;
						/* do not add path */
						len = strlen(str);
						if (len > 0 && str[len - 1] != '/')
							goto add_incl;
					}
					break;
				}
				sym++;
			}
		}

	}

	file_hdr.f_symptr = file_pointer;	/* file pointer to symtab */

	if (s1->do_debug)
		file_hdr.f_nsyms = coff_nb_syms;	/* number of symtab entries */
	else
		file_hdr.f_nsyms = 0;

	file_pointer += file_hdr.f_nsyms * SYMNMLEN;

	// OK now we are all set to write the file


	fwrite(&file_hdr, FILHSZ, 1, f);
	fwrite(&o_filehdr, sizeof(o_filehdr), 1, f);

	// write section headers
	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		if (OutputTheSection(tcc_sect))
		{
			fwrite(coff_sec, sizeof(SCNHDR), 1, f);
		}
	}

	// write raw data
	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		if (OutputTheSection(tcc_sect))
		{
			fwrite(tcc_sect->data, tcc_sect->data_offset, 1, f);
		}
	}

	// write relocation data
	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		if (OutputTheSection(tcc_sect))
		{
			// put relocations data
			if (coff_sec->s_nreloc > 0)
			{
				fwrite(tcc_sect->reloc,
				       coff_sec->s_nreloc * sizeof(struct reloc), 1, f);
			}
		}
	}


	// group the symbols in order of filename, func1, func2, etc
	// finally global symbols

	if (s1->do_debug)
		SortSymbolTable(s1);

	// write line no data

	for (i = 1; i < s1->nb_sections; i++)
	{
		coff_sec = &section_header[i];
		tcc_sect = s1->sections[i];

		if (s1->do_debug && tcc_sect == stext)
		{
			// count how many line nos data


			Stab_Sym *sym, *sym_end;
			char func_name[128], last_func_name[128];
			unsigned long func_addr, last_pc, pc;
			const char *incl_files[INCLUDE_STACK_SIZE];
			int incl_index, len, last_line_num;
			const char *str, *p;

			LINENO CoffLineNo;

			func_name[0] = '\0';
			func_addr = 0;
			incl_index = 0;
			last_func_name[0] = '\0';
			last_pc = 0;
			last_line_num = 1;
			sym = (Stab_Sym *) stab_section->data + 1;
			sym_end =
			    (Stab_Sym *) (stab_section->data +
			                  stab_section->data_offset);

			while (sym < sym_end)
			{
				switch (sym->n_type)
				{
				/* function start or end */
				case N_FUN:
					if (sym->n_strx == 0)
					{
						// end of function

						CoffLineNo.l_addr.l_paddr = last_pc;
						CoffLineNo.l_lnno = last_line_num + 1;
						fwrite(&CoffLineNo, 6, 1, f);

						pc = sym->n_value + func_addr;
						func_name[0] = '\0';
						func_addr = 0;
					}
					else
					{
						// beginning of function

						str =
						    (const char *) stabstr_section->data +
						    sym->n_strx;


						p = strchr(str, ':');
						if (!p)
						{
							pstrcpy(func_name, sizeof(func_name), str);
						}
						else
						{
							len = p - str;
							if (len > sizeof(func_name) - 1)
								len = sizeof(func_name) - 1;
							memcpy(func_name, str, len);
							func_name[len] = '\0';
						}
						func_addr = sym->n_value;
						last_pc = func_addr;
						last_line_num = -1;

						// output a function begin

						CoffLineNo.l_addr.l_symndx =
						    FindCoffSymbolIndex(s1, func_name);
						CoffLineNo.l_lnno = 0;

						fwrite(&CoffLineNo, 6, 1, f);
					}
					break;

				/* line number info */
				case N_SLINE:
					pc = sym->n_value + func_addr;


					/* XXX: slow! */
					strcpy(last_func_name, func_name);

					// output a line reference

					CoffLineNo.l_addr.l_paddr = last_pc;

					if (last_line_num == -1)
					{
						CoffLineNo.l_lnno = sym->n_desc;
					}
					else
					{
						CoffLineNo.l_lnno = last_line_num + 1;
					}

					fwrite(&CoffLineNo, 6, 1, f);

					last_pc = pc;
					last_line_num = sym->n_desc;

					break;

				/* include files */
				case N_BINCL:
					str =
					    (const char *) stabstr_section->data + sym->n_strx;
add_incl2:
					if (incl_index < INCLUDE_STACK_SIZE)
					{
						incl_files[incl_index++] = str;
					}
					break;
				case N_EINCL:
					if (incl_index > 1)
						incl_index--;
					break;
				case N_SO:
					if (sym->n_strx == 0)
					{
						incl_index = 0;	/* end of translation unit */
					}
					else
					{
						str =
						    (const char *) stabstr_section->data +
						    sym->n_strx;
						/* do not add path */
						len = strlen(str);
						if (len > 0 && str[len - 1] != '/')
							goto add_incl2;
					}
					break;
				}
				sym++;
			}
		}
	}

	// write symbol table
	if (s1->do_debug)
	{
		int k;
		struct syment csym;
		AUXFUNC auxfunc;
		AUXBF auxbf;
		AUXEF auxef;
		int i;
		Elf32_Sym *p;
		const char *name;
		int nstr;
		int n = 0;

		Coff_str_table = (char *) tcc_malloc(MAX_STR_TABLE);
		pCoff_str_table = Coff_str_table;
		nstr = 0;

		p = (Elf32_Sym *) symtab_section->data;


		for (i = 0; i < nb_syms; i++)
		{

			name = symtab_section->link->data + p->st_name;

			for (k = 0; k < 8; k++)
				csym._n._n_name[k] = 0;

			if (strlen(name) <= 8)
			{
				strcpy(csym._n._n_name, name);
			}
			else
			{
				if (pCoff_str_table - Coff_str_table + strlen(name) >
				        MAX_STR_TABLE - 1)
					tcc_error("String table too large");

				csym._n._n_n._n_zeroes = 0;
				csym._n._n_n._n_offset =
				    pCoff_str_table - Coff_str_table + 4;

				strcpy(pCoff_str_table, name);
				pCoff_str_table += strlen(name) + 1;	// skip over null
				nstr++;
			}

			if (p->st_info == 4)
			{
				// put a filename symbol
				csym.n_value = 33;	// ?????
				csym.n_scnum = N_DEBUG;
				csym.n_type = 0;
				csym.n_sclass = C_FILE;
				csym.n_numaux = 0;
				fwrite(&csym, 18, 1, f);
				n++;

			}
			else if (p->st_info == 0x12)
			{
				// find the function data

				for (k = 0; k < nFuncs; k++)
				{
					if (strcmp(name, Func[k]) == 0)
						break;
				}

				if (k >= nFuncs)
				{
					tcc_error("debug info can't find function: %s", name);
				}
				// put a Function Name

				csym.n_value = p->st_value;	// physical address
				csym.n_scnum = CoffTextSectionNo;
				csym.n_type = MKTYPE(T_INT, DT_FCN, 0, 0, 0, 0, 0);
				csym.n_sclass = C_EXT;
				csym.n_numaux = 1;
				fwrite(&csym, 18, 1, f);

				// now put aux info

				auxfunc.tag = 0;
				auxfunc.size = EndAddress[k] - p->st_value;
				auxfunc.fileptr = LineNoFilePtr[k];
				auxfunc.nextsym = n + 6;	// tktk
				auxfunc.dummy = 0;
				fwrite(&auxfunc, 18, 1, f);

				// put a .bf

				strcpy(csym._n._n_name, ".bf");
				csym.n_value = p->st_value;	// physical address
				csym.n_scnum = CoffTextSectionNo;
				csym.n_type = 0;
				csym.n_sclass = C_FCN;
				csym.n_numaux = 1;
				fwrite(&csym, 18, 1, f);

				// now put aux info

				auxbf.regmask = 0;
				auxbf.lineno = 0;
				auxbf.nentries = FuncEntries[k];
				auxbf.localframe = 0;
				auxbf.nextentry = n + 6;
				auxbf.dummy = 0;
				fwrite(&auxbf, 18, 1, f);

				// put a .ef

				strcpy(csym._n._n_name, ".ef");
				csym.n_value = EndAddress[k];	// physical address
				csym.n_scnum = CoffTextSectionNo;
				csym.n_type = 0;
				csym.n_sclass = C_FCN;
				csym.n_numaux = 1;
				fwrite(&csym, 18, 1, f);

				// now put aux info

				auxef.dummy = 0;
				auxef.lineno = LastLineNo[k];
				auxef.dummy1 = 0;
				auxef.dummy2 = 0;
				auxef.dummy3 = 0;
				auxef.dummy4 = 0;
				fwrite(&auxef, 18, 1, f);

				n += 6;

			}
			else
			{
				// try an put some type info

				if ((p->st_other & VT_BTYPE) == VT_DOUBLE)
				{
					csym.n_type = T_DOUBLE;	// int
					csym.n_sclass = C_EXT;
				}
				else if ((p->st_other & VT_BTYPE) == VT_FLOAT)
				{
					csym.n_type = T_FLOAT;
					csym.n_sclass = C_EXT;
				}
				else if ((p->st_other & VT_BTYPE) == VT_INT)
				{
					csym.n_type = T_INT;	// int
					csym.n_sclass = C_EXT;
				}
				else if ((p->st_other & VT_BTYPE) == VT_SHORT)
				{
					csym.n_type = T_SHORT;
					csym.n_sclass = C_EXT;
				}
				else if ((p->st_other & VT_BTYPE) == VT_BYTE)
				{
					csym.n_type = T_CHAR;
					csym.n_sclass = C_EXT;
				}
				else
				{
					csym.n_type = T_INT;	// just mark as a label
					csym.n_sclass = C_LABEL;
				}


				csym.n_value = p->st_value;
				csym.n_scnum = 2;
				csym.n_numaux = 1;
				fwrite(&csym, 18, 1, f);

				auxfunc.tag = 0;
				auxfunc.size = 0x20;
				auxfunc.fileptr = 0;
				auxfunc.nextsym = 0;
				auxfunc.dummy = 0;
				fwrite(&auxfunc, 18, 1, f);
				n++;
				n++;

			}

			p++;
		}
	}

	if (s1->do_debug)
	{
		// write string table

		// first write the size
		i = pCoff_str_table - Coff_str_table;
		fwrite(&i, 4, 1, f);

		// then write the strings
		fwrite(Coff_str_table, i, 1, f);

		tcc_free(Coff_str_table);
	}

	return 0;
}



// group the symbols in order of filename, func1, func2, etc
// finally global symbols

void SortSymbolTable(TCCState *s1)
{
	int i, j, k, n = 0;
	Elf32_Sym *p, *p2, *NewTable;
	char *name, *name2;

	NewTable = (Elf32_Sym *) tcc_malloc(nb_syms * sizeof(Elf32_Sym));

	p = (Elf32_Sym *) symtab_section->data;


	// find a file symbol, copy it over
	// then scan the whole symbol list and copy any function
	// symbols that match the file association

	for (i = 0; i < nb_syms; i++)
	{
		if (p->st_info == 4)
		{
			name = (char *) symtab_section->link->data + p->st_name;

			// this is a file symbol, copy it over

			NewTable[n++] = *p;

			p2 = (Elf32_Sym *) symtab_section->data;

			for (j = 0; j < nb_syms; j++)
			{
				if (p2->st_info == 0x12)
				{
					// this is a func symbol

					name2 =
					    (char *) symtab_section->link->data + p2->st_name;

					// find the function data index

					for (k = 0; k < nFuncs; k++)
					{
						if (strcmp(name2, Func[k]) == 0)
							break;
					}

					if (k >= nFuncs)
					{
						tcc_error("debug (sort) info can't find function: %s", name2);
					}

					if (strcmp(AssociatedFile[k], name) == 0)
					{
						// yes they match copy it over

						NewTable[n++] = *p2;
					}
				}
				p2++;
			}
		}
		p++;
	}

	// now all the filename and func symbols should have been copied over
	// copy all the rest over (all except file and funcs)

	p = (Elf32_Sym *) symtab_section->data;
	for (i = 0; i < nb_syms; i++)
	{
		if (p->st_info != 4 && p->st_info != 0x12)
		{
			NewTable[n++] = *p;
		}
		p++;
	}

	if (n != nb_syms)
		tcc_error("Internal Compiler error, debug info");

	// copy it all back

	p = (Elf32_Sym *) symtab_section->data;
	for (i = 0; i < nb_syms; i++)
	{
		*p++ = NewTable[i];
	}

	tcc_free(NewTable);
}


int FindCoffSymbolIndex(TCCState *s1, const char *func_name)
{
	int i, n = 0;
	Elf32_Sym *p;
	char *name;

	p = (Elf32_Sym *) symtab_section->data;

	for (i = 0; i < nb_syms; i++)
	{

		name = (char *) symtab_section->link->data + p->st_name;

		if (p->st_info == 4)
		{
			// put a filename symbol
			n++;
		}
		else if (p->st_info == 0x12)
		{

			if (strcmp(func_name, name) == 0)
				return n;

			n += 6;

			// put a Function Name

			// now put aux info

			// put a .bf

			// now put aux info

			// put a .ef

			// now put aux info

		}
		else
		{
			n += 2;
		}

		p++;
	}

	return n;			// total number of symbols
}

int OutputTheSection(Section * sect)
{
	const char *s = sect->name;

	if (!strcmp(s, ".text"))
		return 1;
	else if (!strcmp(s, ".data"))
		return 1;
	else
		return 0;
}

short int GetCoffFlags(const char *s)
{
	if (!strcmp(s, ".text"))
		return STYP_TEXT | STYP_DATA | STYP_ALIGN | 0x400;
	else if (!strcmp(s, ".data"))
		return STYP_DATA;
	else if (!strcmp(s, ".bss"))
		return STYP_BSS;
	else if (!strcmp(s, ".stack"))
		return STYP_BSS | STYP_ALIGN | 0x200;
	else if (!strcmp(s, ".cinit"))
		return STYP_COPY | STYP_DATA | STYP_ALIGN | 0x200;
	else
		return 0;
}

Section *FindSection(TCCState * s1, const char *sname)
{
	Section *s;
	int i;

	for (i = 1; i < s1->nb_sections; i++)
	{
		s = s1->sections[i];

		if (!strcmp(sname, s->name))
			return s;
	}

	tcc_error("could not find section %s", sname);
	return 0;
}

ST_FUNC int tcc_load_coff(TCCState * s1, int fd)
{
// tktk TokenSym *ts;

	FILE *f;
	unsigned int str_size;
	char *Coff_str_table, *name;
	int i, k;
	struct syment csym;
	char name2[9];
	FILHDR file_hdr;		/* FILE HEADER STRUCTURE              */

	f = fdopen(fd, "rb");
	if (!f)
	{
		tcc_error("Unable to open .out file for input");
	}

	if (fread(&file_hdr, FILHSZ, 1, f) != 1)
		tcc_error("error reading .out file for input");

	if (fread(&o_filehdr, sizeof(o_filehdr), 1, f) != 1)
		tcc_error("error reading .out file for input");

	// first read the string table

	if (fseek(f, file_hdr.f_symptr + file_hdr.f_nsyms * SYMESZ, SEEK_SET))
		tcc_error("error reading .out file for input");

	if (fread(&str_size, sizeof(int), 1, f) != 1)
		tcc_error("error reading .out file for input");


	Coff_str_table = (char *) tcc_malloc(str_size);

	if (fread(Coff_str_table, str_size - 4, 1, f) != 1)
		tcc_error("error reading .out file for input");

	// read/process all the symbols

	// seek back to symbols

	if (fseek(f, file_hdr.f_symptr, SEEK_SET))
		tcc_error("error reading .out file for input");

	for (i = 0; i < file_hdr.f_nsyms; i++)
	{
		if (fread(&csym, SYMESZ, 1, f) != 1)
			tcc_error("error reading .out file for input");

		if (csym._n._n_n._n_zeroes == 0)
		{
			name = Coff_str_table + csym._n._n_n._n_offset - 4;
		}
		else
		{
			name = csym._n._n_name;

			if (name[7] != 0)
			{
				for (k = 0; k < 8; k++)
					name2[k] = name[k];

				name2[8] = 0;

				name = name2;
			}
		}
//              if (strcmp("_DAC_Buffer",name)==0)  // tktk
//                      name[0]=0;

		if (((csym.n_type & 0x30) == 0x20 && csym.n_sclass == 0x2) || ((csym.n_type & 0x30) == 0x30 && csym.n_sclass == 0x2) || (csym.n_type == 0x4 && csym.n_sclass == 0x2) || (csym.n_type == 0x8 && csym.n_sclass == 0x2) ||	// structures
		        (csym.n_type == 0x18 && csym.n_sclass == 0x2) ||	// pointer to structure
		        (csym.n_type == 0x7 && csym.n_sclass == 0x2) ||	// doubles
		        (csym.n_type == 0x6 && csym.n_sclass == 0x2))	// floats
		{
			// strip off any leading underscore (except for other main routine)

			if (name[0] == '_' && strcmp(name, "_main") != 0)
				name++;

			tcc_add_symbol(s1, name, (void*)(uintptr_t)csym.n_value);
		}
		// skip any aux records

		if (csym.n_numaux == 1)
		{
			if (fread(&csym, SYMESZ, 1, f) != 1)
				tcc_error("error reading .out file for input");
			i++;
		}
	}

	return 0;
}
//END tcccoff.c

#elif defined(TCC_TARGET_X86_64) || defined(TCC_TARGET_I386)

//START i386-asm.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

#define MAX_OPERANDS 3

#define TOK_ASM_first TOK_ASM_clc
#define TOK_ASM_last TOK_ASM_emms
#define TOK_ASM_alllast TOK_ASM_subps

#define OPC_B          0x01  /* only used with OPC_WL */
#define OPC_WL         0x02  /* accepts w, l or no suffix */
#define OPC_BWL        (OPC_B | OPC_WL) /* accepts b, w, l or no suffix */
#define OPC_REG        0x04 /* register is added to opcode */
#define OPC_MODRM      0x08 /* modrm encoding */

#define OPCT_MASK      0x70
#define OPC_FWAIT      0x10 /* add fwait opcode */
#define OPC_SHIFT      0x20 /* shift opcodes */
#define OPC_ARITH      0x30 /* arithmetic opcodes */
#define OPC_FARITH     0x40 /* FPU arithmetic opcodes */
#define OPC_TEST       0x50 /* test opcodes */
#define OPCT_IS(v,i) (((v) & OPCT_MASK) == (i))

#define OPC_0F        0x100 /* Is secondary map (0x0f prefix) */
#define OPC_48        0x200 /* Always has REX prefix */
#ifdef TCC_TARGET_X86_64
# define OPC_WLQ     0x1000  /* accepts w, l, q or no suffix */
# define OPC_BWLQ    (OPC_B | OPC_WLQ) /* accepts b, w, l, q or no suffix */
# define OPC_WLX     OPC_WLQ
# define OPC_BWLX    OPC_BWLQ
#else
# define OPC_WLX     OPC_WL
# define OPC_BWLX    OPC_BWL
#endif

#define OPC_GROUP_SHIFT 13

/* in order to compress the operand type, we use specific operands and
   we or only with EA  */
enum
{
	OPT_REG8=0, /* warning: value is hardcoded from TOK_ASM_xxx */
	OPT_REG16,  /* warning: value is hardcoded from TOK_ASM_xxx */
	OPT_REG32,  /* warning: value is hardcoded from TOK_ASM_xxx */
#ifdef TCC_TARGET_X86_64
	OPT_REG64,  /* warning: value is hardcoded from TOK_ASM_xxx */
#endif
	OPT_MMX,    /* warning: value is hardcoded from TOK_ASM_xxx */
	OPT_SSE,    /* warning: value is hardcoded from TOK_ASM_xxx */
	OPT_CR,     /* warning: value is hardcoded from TOK_ASM_xxx */
	OPT_TR,     /* warning: value is hardcoded from TOK_ASM_xxx */
	OPT_DB,     /* warning: value is hardcoded from TOK_ASM_xxx */
	OPT_SEG,
	OPT_ST,
#ifdef TCC_TARGET_X86_64
	OPT_REG8_LOW, /* %spl,%bpl,%sil,%dil, encoded like ah,ch,dh,bh, but
		     with REX prefix, not used in insn templates */
#endif
	OPT_IM8,
	OPT_IM8S,
	OPT_IM16,
	OPT_IM32,
#ifdef TCC_TARGET_X86_64
	OPT_IM64,
#endif
	OPT_EAX,    /* %al, %ax, %eax or %rax register */
	OPT_ST0,    /* %st(0) register */
	OPT_CL,     /* %cl register */
	OPT_DX,     /* %dx register */
	OPT_ADDR,   /* OP_EA with only offset */
	OPT_INDIR,  /* *(expr) */
	/* composite types */
	OPT_COMPOSITE_FIRST,
	OPT_IM,     /* IM8 | IM16 | IM32 */
	OPT_REG,    /* REG8 | REG16 | REG32 | REG64 */
	OPT_REGW,   /* REG16 | REG32 | REG64 */
	OPT_IMW,    /* IM16 | IM32 */
	OPT_MMXSSE, /* MMX | SSE */
	OPT_DISP,   /* Like OPT_ADDR, but emitted as displacement (for jumps) */
	OPT_DISP8,  /* Like OPT_ADDR, but only 8bit (short jumps) */
	/* can be ored with any OPT_xxx */
	OPT_EA = 0x80
};

#define OP_REG8   (1 << OPT_REG8)
#define OP_REG16  (1 << OPT_REG16)
#define OP_REG32  (1 << OPT_REG32)
#define OP_MMX    (1 << OPT_MMX)
#define OP_SSE    (1 << OPT_SSE)
#define OP_CR     (1 << OPT_CR)
#define OP_TR     (1 << OPT_TR)
#define OP_DB     (1 << OPT_DB)
#define OP_SEG    (1 << OPT_SEG)
#define OP_ST     (1 << OPT_ST)
#define OP_IM8    (1 << OPT_IM8)
#define OP_IM8S   (1 << OPT_IM8S)
#define OP_IM16   (1 << OPT_IM16)
#define OP_IM32   (1 << OPT_IM32)
#define OP_EAX    (1 << OPT_EAX)
#define OP_ST0    (1 << OPT_ST0)
#define OP_CL     (1 << OPT_CL)
#define OP_DX     (1 << OPT_DX)
#define OP_ADDR   (1 << OPT_ADDR)
#define OP_INDIR  (1 << OPT_INDIR)
#ifdef TCC_TARGET_X86_64
# define OP_REG64 (1 << OPT_REG64)
# define OP_REG8_LOW (1 << OPT_REG8_LOW)
# define OP_IM64  (1 << OPT_IM64)
# define OP_EA32  (OP_EA << 1)
#else
# define OP_REG64 0
# define OP_REG8_LOW 0
# define OP_IM64  0
# define OP_EA32  0
#endif

#define OP_EA     0x40000000
#define OP_REG    (OP_REG8 | OP_REG16 | OP_REG32 | OP_REG64)

#ifdef TCC_TARGET_X86_64
# define TREG_XAX   TREG_RAX
# define TREG_XCX   TREG_RCX
# define TREG_XDX   TREG_RDX
#else
# define TREG_XAX   TREG_EAX
# define TREG_XCX   TREG_ECX
# define TREG_XDX   TREG_EDX
#endif

typedef struct ASMInstr
{
	uint16_t sym;
	uint16_t opcode;
	uint16_t instr_type;
	uint8_t nb_ops;
	uint8_t op_type[MAX_OPERANDS]; /* see OP_xxx */
} ASMInstr;

typedef struct Operand
{
	uint32_t type;
	int8_t  reg; /* register, -1 if none */
	int8_t  reg2; /* second register, -1 if none */
	uint8_t shift;
	ExprValue e;
} Operand;

static const uint8_t reg_to_size[9] =
{
	/*
	    [OP_REG8] = 0,
	    [OP_REG16] = 1,
	    [OP_REG32] = 2,
#ifdef TCC_TARGET_X86_64
	    [OP_REG64] = 3,
#endif
	*/
	0, 0, 1, 0, 2, 0, 0, 0, 3
};

#define NB_TEST_OPCODES 30

static const uint8_t test_bits[NB_TEST_OPCODES] =
{
	0x00, /* o */
	0x01, /* no */
	0x02, /* b */
	0x02, /* c */
	0x02, /* nae */
	0x03, /* nb */
	0x03, /* nc */
	0x03, /* ae */
	0x04, /* e */
	0x04, /* z */
	0x05, /* ne */
	0x05, /* nz */
	0x06, /* be */
	0x06, /* na */
	0x07, /* nbe */
	0x07, /* a */
	0x08, /* s */
	0x09, /* ns */
	0x0a, /* p */
	0x0a, /* pe */
	0x0b, /* np */
	0x0b, /* po */
	0x0c, /* l */
	0x0c, /* nge */
	0x0d, /* nl */
	0x0d, /* ge */
	0x0e, /* le */
	0x0e, /* ng */
	0x0f, /* nle */
	0x0f, /* g */
};

static const uint8_t segment_prefixes[] =
{
	0x26, /* es */
	0x2e, /* cs */
	0x36, /* ss */
	0x3e, /* ds */
	0x64, /* fs */
	0x65  /* gs */
};

static const ASMInstr asm_instrs[] =
{
#define ALT(x) x
	/* This removes a 0x0f in the second byte */
#define O(o) ((uint64_t) ((((o) & 0xff00) == 0x0f00) ? ((((o) >> 8) & ~0xff) | ((o) & 0xff)) : (o)))
	/* This constructs instr_type from opcode, type and group.  */
#define T(o,i,g) ((i) | ((g) << OPC_GROUP_SHIFT) | ((((o) & 0xff00) == 0x0f00) ? OPC_0F : 0))
#define DEF_ASM_OP0(name, opcode)
#define DEF_ASM_OP0L(name, opcode, group, instr_type) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 0, { 0 } },
#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 1, { op0 }},
#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 2, { op0, op1 }},
#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 3, { op0, op1, op2 }},
#ifdef TCC_TARGET_X86_64

//START x86_64-asm.h

#define X86ASMOPCODE
#include "tinycc.h"

//END x86_64-asm.h
#else
#define i386ASMOPCODE
#include "tinycc.h"
#endif
	/* last operation */
	{ 0, },
};

static const uint16_t op0_codes[] =
{
#define ALT(x)
#define DEF_ASM_OP0(x, opcode) opcode,
#define DEF_ASM_OP0L(name, opcode, group, instr_type)
#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)
#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)
#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)
#ifdef TCC_TARGET_X86_64
//START x86_64-asm.h

#define X86ASMOPCODE
#include "tinycc.h"

//END x86_64-asm.h
#else
#define i386ASMOPCODE
#include "tinycc.h"
#endif
};

static inline int get_reg_shift(TCCState *s1)
{
	int shift, v;
	v = asm_int_expr(s1);
	switch(v)
	{
	case 1:
		shift = 0;
		break;
	case 2:
		shift = 1;
		break;
	case 4:
		shift = 2;
		break;
	case 8:
		shift = 3;
		break;
	default:
		expect("1, 2, 4 or 8 constant");
		shift = 0;
		break;
	}
	return shift;
}

#ifdef TCC_TARGET_X86_64
static int asm_parse_numeric_reg(int t, unsigned int *type)
{
	int reg = -1;
	if (t >= TOK_IDENT && t < tok_ident)
	{
		const char *s = table_ident[t - TOK_IDENT]->str;
		char c;
		*type = OP_REG64;
		if (*s == 'c')
		{
			s++;
			*type = OP_CR;
		}
		if (*s++ != 'r')
			return -1;
		/* Don't allow leading '0'.  */
		if ((c = *s++) >= '1' && c <= '9')
			reg = c - '0';
		else
			return -1;
		if ((c = *s) >= '0' && c <= '5')
			s++, reg = reg * 10 + c - '0';
		if (reg > 15)
			return -1;
		if ((c = *s) == 0)
			;
		else if (*type != OP_REG64)
			return -1;
		else if (c == 'b' && !s[1])
			*type = OP_REG8;
		else if (c == 'w' && !s[1])
			*type = OP_REG16;
		else if (c == 'd' && !s[1])
			*type = OP_REG32;
		else
			return -1;
	}
	return reg;
}
#endif

static int asm_parse_reg(unsigned int *type)
{
	int reg = 0;
	*type = 0;
	if (tok != '%')
		goto error_32;
	next();
	if (tok >= TOK_ASM_eax && tok <= TOK_ASM_edi)
	{
		reg = tok - TOK_ASM_eax;
		*type = OP_REG32;
#ifdef TCC_TARGET_X86_64
	}
	else if (tok >= TOK_ASM_rax && tok <= TOK_ASM_rdi)
	{
		reg = tok - TOK_ASM_rax;
		*type = OP_REG64;
	}
	else if (tok == TOK_ASM_rip)
	{
		reg = -2; /* Probably should use different escape code. */
		*type = OP_REG64;
	}
	else if ((reg = asm_parse_numeric_reg(tok, type)) >= 0
	         && (*type == OP_REG32 || *type == OP_REG64))
	{
		;
#endif
	}
	else
	{
error_32:
		expect("register");
	}
	next();
	return reg;
}

static void parse_operand(TCCState *s1, Operand *op)
{
	ExprValue e;
	int reg, indir;
	const char *p;

	indir = 0;
	if (tok == '*')
	{
		next();
		indir = OP_INDIR;
	}

	if (tok == '%')
	{
		next();
		if (tok >= TOK_ASM_al && tok <= TOK_ASM_db7)
		{
			reg = tok - TOK_ASM_al;
			op->type = 1 << (reg >> 3); /* WARNING: do not change constant order */
			op->reg = reg & 7;
			if ((op->type & OP_REG) && op->reg == TREG_XAX)
				op->type |= OP_EAX;
			else if (op->type == OP_REG8 && op->reg == TREG_XCX)
				op->type |= OP_CL;
			else if (op->type == OP_REG16 && op->reg == TREG_XDX)
				op->type |= OP_DX;
		}
		else if (tok >= TOK_ASM_dr0 && tok <= TOK_ASM_dr7)
		{
			op->type = OP_DB;
			op->reg = tok - TOK_ASM_dr0;
		}
		else if (tok >= TOK_ASM_es && tok <= TOK_ASM_gs)
		{
			op->type = OP_SEG;
			op->reg = tok - TOK_ASM_es;
		}
		else if (tok == TOK_ASM_st)
		{
			op->type = OP_ST;
			op->reg = 0;
			next();
			if (tok == '(')
			{
				next();
				if (tok != TOK_PPNUM)
					goto reg_error;
				p = tokc.str.data;
				reg = p[0] - '0';
				if ((unsigned)reg >= 8 || p[1] != '\0')
					goto reg_error;
				op->reg = reg;
				next();
				skip(')');
			}
			if (op->reg == 0)
				op->type |= OP_ST0;
			goto no_skip;
#ifdef TCC_TARGET_X86_64
		}
		else if (tok >= TOK_ASM_spl && tok <= TOK_ASM_dil)
		{
			op->type = OP_REG8 | OP_REG8_LOW;
			op->reg = 4 + tok - TOK_ASM_spl;
		}
		else if ((op->reg = asm_parse_numeric_reg(tok, &op->type)) >= 0)
		{
			;
#endif
		}
		else
		{
reg_error:
			tcc_error("unknown register %%%s", get_tok_str(tok, &tokc));
		}
		next();
no_skip:
		;
	}
	else if (tok == '$')
	{
		/* constant value */
		next();
		asm_expr(s1, &e);
		op->type = OP_IM32;
		op->e = e;
		if (!op->e.sym)
		{
			if (op->e.v == (uint8_t)op->e.v)
				op->type |= OP_IM8;
			if (op->e.v == (int8_t)op->e.v)
				op->type |= OP_IM8S;
			if (op->e.v == (uint16_t)op->e.v)
				op->type |= OP_IM16;
#ifdef TCC_TARGET_X86_64
			if (op->e.v != (int32_t)op->e.v && op->e.v != (uint32_t)op->e.v)
				op->type = OP_IM64;
#endif
		}
	}
	else
	{
		/* address(reg,reg2,shift) with all variants */
		op->type = OP_EA;
		op->reg = -1;
		op->reg2 = -1;
		op->shift = 0;
		if (tok != '(')
		{
			asm_expr(s1, &e);
			op->e = e;
		}
		else
		{
			next();
			if (tok == '%')
			{
				unget_tok('(');
				op->e.v = 0;
				op->e.sym = NULL;
			}
			else
			{
				/* bracketed offset expression */
				asm_expr(s1, &e);
				if (tok != ')')
					expect(")");
				next();
				op->e.v = e.v;
				op->e.sym = e.sym;
			}
			op->e.pcrel = 0;
		}
		if (tok == '(')
		{
			unsigned int type = 0;
			next();
			if (tok != ',')
			{
				op->reg = asm_parse_reg(&type);
			}
			if (tok == ',')
			{
				next();
				if (tok != ',')
				{
					op->reg2 = asm_parse_reg(&type);
				}
				if (tok == ',')
				{
					next();
					op->shift = get_reg_shift(s1);
				}
			}
			if (type & OP_REG32)
				op->type |= OP_EA32;
			skip(')');
		}
		if (op->reg == -1 && op->reg2 == -1)
			op->type |= OP_ADDR;
	}
	op->type |= indir;
}

/* XXX: unify with C code output ? */
ST_FUNC void gen_expr32(ExprValue *pe)
{
	if (pe->pcrel)
		/* If PC-relative, always set VT_SYM, even without symbol,
		so as to force a relocation to be emitted.  */
		gen_addrpc32(VT_SYM, pe->sym, pe->v);
	else
		gen_addr32(pe->sym ? VT_SYM : 0, pe->sym, pe->v);
}

#ifdef TCC_TARGET_X86_64
ST_FUNC void gen_expr64(ExprValue *pe)
{
	gen_addr64(pe->sym ? VT_SYM : 0, pe->sym, pe->v);
}
#endif

/* XXX: unify with C code output ? */
static void gen_disp32(ExprValue *pe)
{
	Sym *sym = pe->sym;
	ElfSym *esym = elfsym(sym);
	if (esym && esym->st_shndx == cur_text_section->sh_num)
	{
		/* same section: we can output an absolute value. Note
		   that the TCC compiler behaves differently here because
		   it always outputs a relocation to ease (future) code
		   elimination in the linker */
		gen_le32(pe->v + esym->st_value - ind - 4);
	}
	else
	{
		if (sym && sym->type.t == VT_VOID)
		{
			sym->type.t = VT_FUNC;
			sym->type.ref = NULL;
		}
		gen_addrpc32(VT_SYM, sym, pe->v);
	}
}

/* generate the modrm operand */
static inline int asm_modrm(int reg, Operand *op)
{
	int mod, reg1, reg2, sib_reg1;

	if (op->type & (OP_REG | OP_MMX | OP_SSE))
	{
		g(0xc0 + (reg << 3) + op->reg);
	}
	else if (op->reg == -1 && op->reg2 == -1)
	{
		/* displacement only */
#ifdef TCC_TARGET_X86_64
		g(0x04 + (reg << 3));
		g(0x25);
#else
		g(0x05 + (reg << 3));
#endif
		gen_expr32(&op->e);
#ifdef TCC_TARGET_X86_64
	}
	else if (op->reg == -2)
	{
		ExprValue *pe = &op->e;
		g(0x05 + (reg << 3));
		gen_addrpc32(pe->sym ? VT_SYM : 0, pe->sym, pe->v);
		return ind;
#endif
	}
	else
	{
		sib_reg1 = op->reg;
		/* fist compute displacement encoding */
		if (sib_reg1 == -1)
		{
			sib_reg1 = 5;
			mod = 0x00;
		}
		else if (op->e.v == 0 && !op->e.sym && op->reg != 5)
		{
			mod = 0x00;
		}
		else if (op->e.v == (int8_t)op->e.v && !op->e.sym)
		{
			mod = 0x40;
		}
		else
		{
			mod = 0x80;
		}
		/* compute if sib byte needed */
		reg1 = op->reg;
		if (op->reg2 != -1)
			reg1 = 4;
		g(mod + (reg << 3) + reg1);
		if (reg1 == 4)
		{
			/* add sib byte */
			reg2 = op->reg2;
			if (reg2 == -1)
				reg2 = 4; /* indicate no index */
			g((op->shift << 6) + (reg2 << 3) + sib_reg1);
		}
		/* add offset */
		if (mod == 0x40)
		{
			g(op->e.v);
		}
		else if (mod == 0x80 || op->reg == -1)
		{
			gen_expr32(&op->e);
		}
	}
	return 0;
}

#ifdef TCC_TARGET_X86_64
#define REX_W 0x48
#define REX_R 0x44
#define REX_X 0x42
#define REX_B 0x41

static void asm_rex(int width64, Operand *ops, int nb_ops, int *op_type,
                    int regi, int rmi)
{
	unsigned char rex = width64 ? 0x48 : 0;
	int saw_high_8bit = 0;
	int i;
	if (rmi == -1)
	{
		/* No mod/rm byte, but we might have a register op nevertheless
		   (we will add it to the opcode later).  */
		for(i = 0; i < nb_ops; i++)
		{
			if (op_type[i] & (OP_REG | OP_ST))
			{
				if (ops[i].reg >= 8)
				{
					rex |= REX_B;
					ops[i].reg -= 8;
				}
				else if (ops[i].type & OP_REG8_LOW)
					rex |= 0x40;
				else if (ops[i].type & OP_REG8 && ops[i].reg >= 4)
					/* An 8 bit reg >= 4 without REG8 is ah/ch/dh/bh */
					saw_high_8bit = ops[i].reg;
				break;
			}
		}
	}
	else
	{
		if (regi != -1)
		{
			if (ops[regi].reg >= 8)
			{
				rex |= REX_R;
				ops[regi].reg -= 8;
			}
			else if (ops[regi].type & OP_REG8_LOW)
				rex |= 0x40;
			else if (ops[regi].type & OP_REG8 && ops[regi].reg >= 4)
				/* An 8 bit reg >= 4 without REG8 is ah/ch/dh/bh */
				saw_high_8bit = ops[regi].reg;
		}
		if (ops[rmi].type & (OP_REG | OP_MMX | OP_SSE | OP_CR | OP_EA))
		{
			if (ops[rmi].reg >= 8)
			{
				rex |= REX_B;
				ops[rmi].reg -= 8;
			}
			else if (ops[rmi].type & OP_REG8_LOW)
				rex |= 0x40;
			else if (ops[rmi].type & OP_REG8 && ops[rmi].reg >= 4)
				/* An 8 bit reg >= 4 without REG8 is ah/ch/dh/bh */
				saw_high_8bit = ops[rmi].reg;
		}
		if (ops[rmi].type & OP_EA && ops[rmi].reg2 >= 8)
		{
			rex |= REX_X;
			ops[rmi].reg2 -= 8;
		}
	}
	if (rex)
	{
		if (saw_high_8bit)
			tcc_error("can't encode register %%%ch when REX prefix is required",
			          "acdb"[saw_high_8bit-4]);
		g(rex);
	}
}
#endif

static void maybe_print_stats (void)
{
	static int already = 1;
	if (!already)
		/* print stats about opcodes */
	{
		const struct ASMInstr *pa;
		int freq[4];
		int op_vals[500];
		int nb_op_vals, i, j;

		already = 1;
		nb_op_vals = 0;
		memset(freq, 0, sizeof(freq));
		for(pa = asm_instrs; pa->sym != 0; pa++)
		{
			freq[pa->nb_ops]++;
			//for(i=0;i<pa->nb_ops;i++) {
			for(j=0; j<nb_op_vals; j++)
			{
				//if (pa->op_type[i] == op_vals[j])
				if (pa->instr_type == op_vals[j])
					goto found;
			}
			//op_vals[nb_op_vals++] = pa->op_type[i];
			op_vals[nb_op_vals++] = pa->instr_type;
found:
			;
			//}
		}
		for(i=0; i<nb_op_vals; i++)
		{
			int v = op_vals[i];
			//if ((v & (v - 1)) != 0)
			printf("%3d: %08x\n", i, v);
		}
		printf("size=%d nb=%d f0=%d f1=%d f2=%d f3=%d\n",
		       (int)sizeof(asm_instrs),
		       (int)sizeof(asm_instrs) / (int)sizeof(ASMInstr),
		       freq[0], freq[1], freq[2], freq[3]);
	}
}

ST_FUNC void asm_opcode(TCCState *s1, int opcode)
{
	const ASMInstr *pa;
	int i, modrm_index, modreg_index, reg, v, op1, seg_prefix, pc;
	int nb_ops, s;
	Operand ops[MAX_OPERANDS], *pop;
	int op_type[3]; /* decoded op type */
	int alltypes;   /* OR of all operand types */
	int autosize;
	int p66;
#ifdef TCC_TARGET_X86_64
	int rex64;
#endif

	maybe_print_stats();
	/* force synthetic ';' after prefix instruction, so we can handle */
	/* one-line things like "rep stosb" instead of only "rep\nstosb" */
	if (opcode >= TOK_ASM_wait && opcode <= TOK_ASM_repnz)
		unget_tok(';');

	/* get operands */
	pop = ops;
	nb_ops = 0;
	seg_prefix = 0;
	alltypes = 0;
	for(;;)
	{
		if (tok == ';' || tok == TOK_LINEFEED)
			break;
		if (nb_ops >= MAX_OPERANDS)
		{
			tcc_error("incorrect number of operands");
		}
		parse_operand(s1, pop);
		if (tok == ':')
		{
			if (pop->type != OP_SEG || seg_prefix)
				tcc_error("incorrect prefix");
			seg_prefix = segment_prefixes[pop->reg];
			next();
			parse_operand(s1, pop);
			if (!(pop->type & OP_EA))
			{
				tcc_error("segment prefix must be followed by memory reference");
			}
		}
		pop++;
		nb_ops++;
		if (tok != ',')
			break;
		next();
	}

	s = 0; /* avoid warning */

again:
	/* optimize matching by using a lookup table (no hashing is needed
	   !) */
	for(pa = asm_instrs; pa->sym != 0; pa++)
	{
		int it = pa->instr_type & OPCT_MASK;
		s = 0;
		if (it == OPC_FARITH)
		{
			v = opcode - pa->sym;
			if (!((unsigned)v < 8 * 6 && (v % 6) == 0))
				continue;
		}
		else if (it == OPC_ARITH)
		{
			if (!(opcode >= pa->sym && opcode < pa->sym + 8*NBWLX))
				continue;
			s = (opcode - pa->sym) % NBWLX;
			if ((pa->instr_type & OPC_BWLX) == OPC_WLX)
			{
				/* We need to reject the xxxb opcodes that we accepted above.
				   Note that pa->sym for WLX opcodes is the 'w' token,
				   to get the 'b' token subtract one.  */
				if (((opcode - pa->sym + 1) % NBWLX) == 0)
					continue;
				s++;
			}
		}
		else if (it == OPC_SHIFT)
		{
			if (!(opcode >= pa->sym && opcode < pa->sym + 7*NBWLX))
				continue;
			s = (opcode - pa->sym) % NBWLX;
		}
		else if (it == OPC_TEST)
		{
			if (!(opcode >= pa->sym && opcode < pa->sym + NB_TEST_OPCODES))
				continue;
			/* cmovxx is a test opcode but accepts multiple sizes.
			   The suffixes aren't encoded in the table, instead we
			   simply force size autodetection always and deal with suffixed
			   variants below when we don't find e.g. "cmovzl".  */
			if (pa->instr_type & OPC_WLX)
				s = NBWLX - 1;
		}
		else if (pa->instr_type & OPC_B)
		{
#ifdef TCC_TARGET_X86_64
			/* Some instructions don't have the full size but only
			   bwl form.  insb e.g. */
			if ((pa->instr_type & OPC_WLQ) != OPC_WLQ
			        && !(opcode >= pa->sym && opcode < pa->sym + NBWLX-1))
				continue;
#endif
			if (!(opcode >= pa->sym && opcode < pa->sym + NBWLX))
				continue;
			s = opcode - pa->sym;
		}
		else if (pa->instr_type & OPC_WLX)
		{
			if (!(opcode >= pa->sym && opcode < pa->sym + NBWLX-1))
				continue;
			s = opcode - pa->sym + 1;
		}
		else
		{
			if (pa->sym != opcode)
				continue;
		}
		if (pa->nb_ops != nb_ops)
			continue;
#ifdef TCC_TARGET_X86_64
		/* Special case for moves.  Selecting the IM64->REG64 form
		   should only be done if we really have an >32bit imm64, and that
		   is hardcoded.  Ignore it here.  */
		if (pa->opcode == 0xb0 && ops[0].type != OP_IM64
		        && (ops[1].type & OP_REG) == OP_REG64
		        && !(pa->instr_type & OPC_0F))
			continue;
#endif
		/* now decode and check each operand */
		alltypes = 0;
		for(i = 0; i < nb_ops; i++)
		{
			int op1, op2;
			op1 = pa->op_type[i];
			op2 = op1 & 0x1f;
			switch(op2)
			{
			case OPT_IM:
				v = OP_IM8 | OP_IM16 | OP_IM32;
				break;
			case OPT_REG:
				v = OP_REG8 | OP_REG16 | OP_REG32 | OP_REG64;
				break;
			case OPT_REGW:
				v = OP_REG16 | OP_REG32 | OP_REG64;
				break;
			case OPT_IMW:
				v = OP_IM16 | OP_IM32;
				break;
			case OPT_MMXSSE:
				v = OP_MMX | OP_SSE;
				break;
			case OPT_DISP:
			case OPT_DISP8:
				v = OP_ADDR;
				break;
			default:
				v = 1 << op2;
				break;
			}
			if (op1 & OPT_EA)
				v |= OP_EA;
			op_type[i] = v;
			if ((ops[i].type & v) == 0)
				goto next;
			alltypes |= ops[i].type;
		}
		/* all is matching ! */
		break;
next:
		;
	}
	if (pa->sym == 0)
	{
		if (opcode >= TOK_ASM_first && opcode <= TOK_ASM_last)
		{
			int b;
			b = op0_codes[opcode - TOK_ASM_first];
			if (b & 0xff00)
				g(b >> 8);
			g(b);
			return;
		}
		else if (opcode <= TOK_ASM_alllast)
		{
			tcc_error("bad operand with opcode '%s'",
			          get_tok_str(opcode, NULL));
		}
		else
		{
			/* Special case for cmovcc, we accept size suffixes but ignore
			   them, but we don't want them to blow up our tables.  */
			TokenSym *ts = table_ident[opcode - TOK_IDENT];
			if (ts->len >= 6
			        && strchr("wlq", ts->str[ts->len-1])
			        && !memcmp(ts->str, "cmov", 4))
			{
				opcode = tok_alloc(ts->str, ts->len-1)->tok;
				goto again;
			}
			tcc_error("unknown opcode '%s'", ts->str);
		}
	}
	/* if the size is unknown, then evaluate it (OPC_B or OPC_WL case) */
	autosize = NBWLX-1;
#ifdef TCC_TARGET_X86_64
	/* XXX the autosize should rather be zero, to not have to adjust this
	   all the time.  */
	if ((pa->instr_type & OPC_BWLQ) == OPC_B)
		autosize = NBWLX-2;
#endif
	if (s == autosize)
	{
		/* Check for register operands providing hints about the size.
		   Start from the end, i.e. destination operands.  This matters
		   only for opcodes accepting different sized registers, lar and lsl
		   are such opcodes.  */
		for(i = nb_ops - 1; s == autosize && i >= 0; i--)
		{
			if ((ops[i].type & OP_REG) && !(op_type[i] & (OP_CL | OP_DX)))
				s = reg_to_size[ops[i].type & OP_REG];
		}
		if (s == autosize)
		{
			if ((opcode == TOK_ASM_push || opcode == TOK_ASM_pop) &&
			        (ops[0].type & (OP_SEG | OP_IM8S | OP_IM32)))
				s = 2;
			else if ((opcode == TOK_ASM_push || opcode == TOK_ASM_pop) &&
			         (ops[0].type & OP_EA))
				s = NBWLX - 2;
			else
				tcc_error("cannot infer opcode suffix");
		}
	}

#ifdef TCC_TARGET_X86_64
	/* Generate addr32 prefix if needed */
	for(i = 0; i < nb_ops; i++)
	{
		if (ops[i].type & OP_EA32)
		{
			g(0x67);
			break;
		}
	}
#endif
	/* generate data16 prefix if needed */
	p66 = 0;
	if (s == 1)
		p66 = 1;
	else
	{
		/* accepting mmx+sse in all operands --> needs 0x66 to
		   switch to sse mode.  Accepting only sse in an operand --> is
		   already SSE insn and needs 0x66/f2/f3 handling.  */
		for (i = 0; i < nb_ops; i++)
			if ((op_type[i] & (OP_MMX | OP_SSE)) == (OP_MMX | OP_SSE)
			        && ops[i].type & OP_SSE)
				p66 = 1;
	}
	if (p66)
		g(0x66);
#ifdef TCC_TARGET_X86_64
	rex64 = 0;
	if (pa->instr_type & OPC_48)
		rex64 = 1;
	else if (s == 3 || (alltypes & OP_REG64))
	{
		/* generate REX prefix */
		int default64 = 0;
		for(i = 0; i < nb_ops; i++)
		{
			if (op_type[i] == OP_REG64 && pa->opcode != 0xb8)
			{
				/* If only 64bit regs are accepted in one operand
				   this is a default64 instruction without need for
				   REX prefixes, except for movabs(0xb8).  */
				default64 = 1;
				break;
			}
		}
		/* XXX find better encoding for the default64 instructions.  */
		if (((opcode != TOK_ASM_push && opcode != TOK_ASM_pop
		        && opcode != TOK_ASM_pushw && opcode != TOK_ASM_pushl
		        && opcode != TOK_ASM_pushq && opcode != TOK_ASM_popw
		        && opcode != TOK_ASM_popl && opcode != TOK_ASM_popq
		        && opcode != TOK_ASM_call && opcode != TOK_ASM_jmp))
		        && !default64)
			rex64 = 1;
	}
#endif

	/* now generates the operation */
	if (OPCT_IS(pa->instr_type, OPC_FWAIT))
		g(0x9b);
	if (seg_prefix)
		g(seg_prefix);

	v = pa->opcode;
	if (pa->instr_type & OPC_0F)
		v = ((v & ~0xff) << 8) | 0x0f00 | (v & 0xff);
	if ((v == 0x69 || v == 0x6b) && nb_ops == 2)
	{
		/* kludge for imul $im, %reg */
		nb_ops = 3;
		ops[2] = ops[1];
		op_type[2] = op_type[1];
	}
	else if (v == 0xcd && ops[0].e.v == 3 && !ops[0].e.sym)
	{
		v--; /* int $3 case */
		nb_ops = 0;
	}
	else if ((v == 0x06 || v == 0x07))
	{
		if (ops[0].reg >= 4)
		{
			/* push/pop %fs or %gs */
			v = 0x0fa0 + (v - 0x06) + ((ops[0].reg - 4) << 3);
		}
		else
		{
			v += ops[0].reg << 3;
		}
		nb_ops = 0;
	}
	else if (v <= 0x05)
	{
		/* arith case */
		v += ((opcode - TOK_ASM_addb) / NBWLX) << 3;
	}
	else if ((pa->instr_type & (OPCT_MASK | OPC_MODRM)) == OPC_FARITH)
	{
		/* fpu arith case */
		v += ((opcode - pa->sym) / 6) << 3;
	}

	/* search which operand will be used for modrm */
	modrm_index = -1;
	modreg_index = -1;
	if (pa->instr_type & OPC_MODRM)
	{
		if (!nb_ops)
		{
			/* A modrm opcode without operands is a special case (e.g. mfence).
			   It has a group and acts as if there's an register operand 0
			   (ax).  */
			i = 0;
			ops[i].type = OP_REG;
			ops[i].reg = 0;
			goto modrm_found;
		}
		/* first look for an ea operand */
		for(i = 0; i < nb_ops; i++)
		{
			if (op_type[i] & OP_EA)
				goto modrm_found;
		}
		/* then if not found, a register or indirection (shift instructions) */
		for(i = 0; i < nb_ops; i++)
		{
			if (op_type[i] & (OP_REG | OP_MMX | OP_SSE | OP_INDIR))
				goto modrm_found;
		}
#ifdef ASM_DEBUG
		tcc_error("bad op table");
#endif
modrm_found:
		modrm_index = i;
		/* if a register is used in another operand then it is
		   used instead of group */
		for(i = 0; i < nb_ops; i++)
		{
			int t = op_type[i];
			if (i != modrm_index &&
			        (t & (OP_REG | OP_MMX | OP_SSE | OP_CR | OP_TR | OP_DB | OP_SEG)))
			{
				modreg_index = i;
				break;
			}
		}
	}
#ifdef TCC_TARGET_X86_64
	asm_rex (rex64, ops, nb_ops, op_type, modreg_index, modrm_index);
#endif

	if (pa->instr_type & OPC_REG)
	{
		/* mov $im, %reg case */
		if (v == 0xb0 && s >= 1)
			v += 7;
		for(i = 0; i < nb_ops; i++)
		{
			if (op_type[i] & (OP_REG | OP_ST))
			{
				v += ops[i].reg;
				break;
			}
		}
	}
	if (pa->instr_type & OPC_B)
		v += s >= 1;
	if (nb_ops == 1 && pa->op_type[0] == OPT_DISP8)
	{
		ElfSym *esym;
		int jmp_disp;

		/* see if we can really generate the jump with a byte offset */
		esym = elfsym(ops[0].e.sym);
		if (!esym || esym->st_shndx != cur_text_section->sh_num)
			goto no_short_jump;
		jmp_disp = ops[0].e.v + esym->st_value - ind - 2 - (v >= 0xff);
		if (jmp_disp == (int8_t)jmp_disp)
		{
			/* OK to generate jump */
			ops[0].e.sym = 0;
			ops[0].e.v = jmp_disp;
			op_type[0] = OP_IM8S;
		}
		else
		{
no_short_jump:
			/* long jump will be allowed. need to modify the
			   opcode slightly */
			if (v == 0xeb) /* jmp */
				v = 0xe9;
			else if (v == 0x70) /* jcc */
				v += 0x0f10;
			else
				tcc_error("invalid displacement");
		}
	}
	if (OPCT_IS(pa->instr_type, OPC_TEST))
		v += test_bits[opcode - pa->sym];
	op1 = v >> 16;
	if (op1)
		g(op1);
	op1 = (v >> 8) & 0xff;
	if (op1)
		g(op1);
	g(v);

	if (OPCT_IS(pa->instr_type, OPC_SHIFT))
	{
		reg = (opcode - pa->sym) / NBWLX;
		if (reg == 6)
			reg = 7;
	}
	else if (OPCT_IS(pa->instr_type, OPC_ARITH))
	{
		reg = (opcode - pa->sym) / NBWLX;
	}
	else if (OPCT_IS(pa->instr_type, OPC_FARITH))
	{
		reg = (opcode - pa->sym) / 6;
	}
	else
	{
		reg = (pa->instr_type >> OPC_GROUP_SHIFT) & 7;
	}

	pc = 0;
	if (pa->instr_type & OPC_MODRM)
	{
		/* if a register is used in another operand then it is
		   used instead of group */
		if (modreg_index >= 0)
			reg = ops[modreg_index].reg;
		pc = asm_modrm(reg, &ops[modrm_index]);
	}

	/* emit constants */
#ifndef TCC_TARGET_X86_64
	if (!(pa->instr_type & OPC_0F)
	        && (pa->opcode == 0x9a || pa->opcode == 0xea))
	{
		/* ljmp or lcall kludge */
		gen_expr32(&ops[1].e);
		if (ops[0].e.sym)
			tcc_error("cannot relocate");
		gen_le16(ops[0].e.v);
		return;
	}
#endif
	for(i = 0; i < nb_ops; i++)
	{
		v = op_type[i];
		if (v & (OP_IM8 | OP_IM16 | OP_IM32 | OP_IM64 | OP_IM8S | OP_ADDR))
		{
			/* if multiple sizes are given it means we must look
			   at the op size */
			if ((v | OP_IM8 | OP_IM64) == (OP_IM8 | OP_IM16 | OP_IM32 | OP_IM64))
			{
				if (s == 0)
					v = OP_IM8;
				else if (s == 1)
					v = OP_IM16;
				else if (s == 2 || (v & OP_IM64) == 0)
					v = OP_IM32;
				else
					v = OP_IM64;
			}

			if ((v & (OP_IM8 | OP_IM8S | OP_IM16)) && ops[i].e.sym)
				tcc_error("cannot relocate");

			if (v & (OP_IM8 | OP_IM8S))
			{
				g(ops[i].e.v);
			}
			else if (v & OP_IM16)
			{
				gen_le16(ops[i].e.v);
#ifdef TCC_TARGET_X86_64
			}
			else if (v & OP_IM64)
			{
				gen_expr64(&ops[i].e);
#endif
			}
			else if (pa->op_type[i] == OPT_DISP || pa->op_type[i] == OPT_DISP8)
			{
				gen_disp32(&ops[i].e);
			}
			else
			{
				gen_expr32(&ops[i].e);
			}
		}
	}

	/* after immediate operands, adjust pc-relative address */
	if (pc)
		add32le(cur_text_section->data + pc - 4, pc - ind);
}

/* return the constraint priority (we allocate first the lowest
   numbered constraints) */
static inline int constraint_priority(const char *str)
{
	int priority, c, pr;

	/* we take the lowest priority */
	priority = 0;
	for(;;)
	{
		c = *str;
		if (c == '\0')
			break;
		str++;
		switch(c)
		{
		case 'A':
			pr = 0;
			break;
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'S':
		case 'D':
			pr = 1;
			break;
		case 'q':
			pr = 2;
			break;
		case 'r':
		case 'R':
		case 'p':
			pr = 3;
			break;
		case 'N':
		case 'M':
		case 'I':
		case 'e':
		case 'i':
		case 'm':
		case 'g':
			pr = 4;
			break;
		default:
			tcc_error("unknown constraint '%c'", c);
			pr = 0;
		}
		if (pr > priority)
			priority = pr;
	}
	return priority;
}

static const char *skip_constraint_modifiers(const char *p)
{
	while (*p == '=' || *p == '&' || *p == '+' || *p == '%')
		p++;
	return p;
}

/* If T (a token) is of the form "%reg" returns the register
   number and type, otherwise return -1.  */
ST_FUNC int asm_parse_regvar (int t)
{
	const char *s;
	Operand op;
	if (t < TOK_IDENT)
		return -1;
	s = table_ident[t - TOK_IDENT]->str;
	if (s[0] != '%')
		return -1;
	t = tok_alloc(s+1, strlen(s)-1)->tok;
	unget_tok(t);
	unget_tok('%');
	parse_operand(tcc_state, &op);
	/* Accept only integer regs for now.  */
	if (op.type & OP_REG)
		return op.reg;
	else
		return -1;
}

#define REG_OUT_MASK 0x01
#define REG_IN_MASK  0x02

#define is_reg_allocated(reg) (regs_allocated[reg] & reg_mask)

ST_FUNC void asm_compute_constraints(ASMOperand *operands,
                                     int nb_operands, int nb_outputs,
                                     const uint8_t *clobber_regs,
                                     int *pout_reg)
{
	ASMOperand *op;
	int sorted_op[MAX_ASM_OPERANDS];
	int i, j, k, p1, p2, tmp, reg, c, reg_mask;
	const char *str;
	uint8_t regs_allocated[NB_ASM_REGS];

	/* init fields */
	for(i=0; i<nb_operands; i++)
	{
		op = &operands[i];
		op->input_index = -1;
		op->ref_index = -1;
		op->reg = -1;
		op->is_memory = 0;
		op->is_rw = 0;
	}
	/* compute constraint priority and evaluate references to output
	   constraints if input constraints */
	for(i=0; i<nb_operands; i++)
	{
		op = &operands[i];
		str = op->constraint;
		str = skip_constraint_modifiers(str);
		if (isnum(*str) || *str == '[')
		{
			/* this is a reference to another constraint */
			k = find_constraint(operands, nb_operands, str, NULL);
			if ((unsigned)k >= i || i < nb_outputs)
				tcc_error("invalid reference in constraint %d ('%s')",
				          i, str);
			op->ref_index = k;
			if (operands[k].input_index >= 0)
				tcc_error("cannot reference twice the same operand");
			operands[k].input_index = i;
			op->priority = 5;
		}
		else if ((op->vt->r & VT_VALMASK) == VT_LOCAL
		         && op->vt->sym
		         && (reg = op->vt->sym->r & VT_VALMASK) < VT_CONST)
		{
			op->priority = 1;
			op->reg = reg;
		}
		else
		{
			op->priority = constraint_priority(str);
		}
	}

	/* sort operands according to their priority */
	for(i=0; i<nb_operands; i++)
		sorted_op[i] = i;
	for(i=0; i<nb_operands - 1; i++)
	{
		for(j=i+1; j<nb_operands; j++)
		{
			p1 = operands[sorted_op[i]].priority;
			p2 = operands[sorted_op[j]].priority;
			if (p2 < p1)
			{
				tmp = sorted_op[i];
				sorted_op[i] = sorted_op[j];
				sorted_op[j] = tmp;
			}
		}
	}

	for(i = 0; i < NB_ASM_REGS; i++)
	{
		if (clobber_regs[i])
			regs_allocated[i] = REG_IN_MASK | REG_OUT_MASK;
		else
			regs_allocated[i] = 0;
	}
	/* esp cannot be used */
	regs_allocated[4] = REG_IN_MASK | REG_OUT_MASK;
	/* ebp cannot be used yet */
	regs_allocated[5] = REG_IN_MASK | REG_OUT_MASK;

	/* allocate registers and generate corresponding asm moves */
	for(i=0; i<nb_operands; i++)
	{
		j = sorted_op[i];
		op = &operands[j];
		str = op->constraint;
		/* no need to allocate references */
		if (op->ref_index >= 0)
			continue;
		/* select if register is used for output, input or both */
		if (op->input_index >= 0)
		{
			reg_mask = REG_IN_MASK | REG_OUT_MASK;
		}
		else if (j < nb_outputs)
		{
			reg_mask = REG_OUT_MASK;
		}
		else
		{
			reg_mask = REG_IN_MASK;
		}
		if (op->reg >= 0)
		{
			if (is_reg_allocated(op->reg))
				tcc_error("asm regvar requests register that's taken already");
			reg = op->reg;
			goto reg_found;
		}
try_next:
		c = *str++;
		switch(c)
		{
		case '=':
			goto try_next;
		case '+':
			op->is_rw = 1;
		/* FALL THRU */
		case '&':
			if (j >= nb_outputs)
				tcc_error("'%c' modifier can only be applied to outputs", c);
			reg_mask = REG_IN_MASK | REG_OUT_MASK;
			goto try_next;
		case 'A':
			/* allocate both eax and edx */
			if (is_reg_allocated(TREG_XAX) ||
			        is_reg_allocated(TREG_XDX))
				goto try_next;
			op->is_llong = 1;
			op->reg = TREG_XAX;
			regs_allocated[TREG_XAX] |= reg_mask;
			regs_allocated[TREG_XDX] |= reg_mask;
			break;
		case 'a':
			reg = TREG_XAX;
			goto alloc_reg;
		case 'b':
			reg = 3;
			goto alloc_reg;
		case 'c':
			reg = TREG_XCX;
			goto alloc_reg;
		case 'd':
			reg = TREG_XDX;
			goto alloc_reg;
		case 'S':
			reg = 6;
			goto alloc_reg;
		case 'D':
			reg = 7;
alloc_reg:
			if (is_reg_allocated(reg))
				goto try_next;
			goto reg_found;
		case 'q':
			/* eax, ebx, ecx or edx */
			for(reg = 0; reg < 4; reg++)
			{
				if (!is_reg_allocated(reg))
					goto reg_found;
			}
			goto try_next;
		case 'r':
		case 'R':
		case 'p': /* A general address, for x86(64) any register is acceptable*/
			/* any general register */
			for(reg = 0; reg < 8; reg++)
			{
				if (!is_reg_allocated(reg))
					goto reg_found;
			}
			goto try_next;
reg_found:
			/* now we can reload in the register */
			op->is_llong = 0;
			op->reg = reg;
			regs_allocated[reg] |= reg_mask;
			break;
		case 'e':
		case 'i':
			if (!((op->vt->r & (VT_VALMASK | VT_LVAL)) == VT_CONST))
				goto try_next;
			break;
		case 'I':
		case 'N':
		case 'M':
			if (!((op->vt->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST))
				goto try_next;
			break;
		case 'm':
		case 'g':
			/* nothing special to do because the operand is already in
			   memory, except if the pointer itself is stored in a
			   memory variable (VT_LLOCAL case) */
			/* XXX: fix constant case */
			/* if it is a reference to a memory zone, it must lie
			   in a register, so we reserve the register in the
			   input registers and a load will be generated
			   later */
			if (j < nb_outputs || c == 'm')
			{
				if ((op->vt->r & VT_VALMASK) == VT_LLOCAL)
				{
					/* any general register */
					for(reg = 0; reg < 8; reg++)
					{
						if (!(regs_allocated[reg] & REG_IN_MASK))
							goto reg_found1;
					}
					goto try_next;
reg_found1:
					/* now we can reload in the register */
					regs_allocated[reg] |= REG_IN_MASK;
					op->reg = reg;
					op->is_memory = 1;
				}
			}
			break;
		default:
			tcc_error("asm constraint %d ('%s') could not be satisfied",
			          j, op->constraint);
			break;
		}
		/* if a reference is present for that operand, we assign it too */
		if (op->input_index >= 0)
		{
			operands[op->input_index].reg = op->reg;
			operands[op->input_index].is_llong = op->is_llong;
		}
	}

	/* compute out_reg. It is used to store outputs registers to memory
	   locations references by pointers (VT_LLOCAL case) */
	*pout_reg = -1;
	for(i=0; i<nb_operands; i++)
	{
		op = &operands[i];
		if (op->reg >= 0 &&
		        (op->vt->r & VT_VALMASK) == VT_LLOCAL  &&
		        !op->is_memory)
		{
			for(reg = 0; reg < 8; reg++)
			{
				if (!(regs_allocated[reg] & REG_OUT_MASK))
					goto reg_found2;
			}
			tcc_error("could not find free output register for reloading");
reg_found2:
			*pout_reg = reg;
			break;
		}
	}

	/* print sorted constraints */
#ifdef ASM_DEBUG
	for(i=0; i<nb_operands; i++)
	{
		j = sorted_op[i];
		op = &operands[j];
		printf("%%%d [%s]: \"%s\" r=0x%04x reg=%d\n",
		       j,
		       op->id ? get_tok_str(op->id, NULL) : "",
		       op->constraint,
		       op->vt->r,
		       op->reg);
	}
	if (*pout_reg >= 0)
		printf("out_reg=%d\n", *pout_reg);
#endif
}

ST_FUNC void subst_asm_operand(CString *add_str,
                               SValue *sv, int modifier)
{
	int r, reg, size, val;
	char buf[64];

	r = sv->r;
	if ((r & VT_VALMASK) == VT_CONST)
	{
		if (!(r & VT_LVAL) && modifier != 'c' && modifier != 'n' &&
		        modifier != 'P')
			cstr_ccat(add_str, '$');
		if (r & VT_SYM)
		{
			const char *name = get_tok_str(sv->sym->v, NULL);
			if (sv->sym->v >= SYM_FIRST_ANOM)
			{
				/* In case of anonymous symbols ("L.42", used
				   for static data labels) we can't find them
				   in the C symbol table when later looking up
				   this name.  So enter them now into the asm label
				   list when we still know the symbol.  */
				get_asm_sym(tok_alloc(name, strlen(name))->tok, sv->sym);
			}
			cstr_cat(add_str, name, -1);
			if ((uint32_t)sv->c.i == 0)
				goto no_offset;
			cstr_ccat(add_str, '+');
		}
		val = sv->c.i;
		if (modifier == 'n')
			val = -val;
		snprintf(buf, sizeof(buf), "%d", (int)sv->c.i);
		cstr_cat(add_str, buf, -1);
no_offset:
		;
#ifdef TCC_TARGET_X86_64
		if (r & VT_LVAL)
			cstr_cat(add_str, "(%rip)", -1);
#endif
	}
	else if ((r & VT_VALMASK) == VT_LOCAL)
	{
#ifdef TCC_TARGET_X86_64
		snprintf(buf, sizeof(buf), "%d(%%rbp)", (int)sv->c.i);
#else
		snprintf(buf, sizeof(buf), "%d(%%ebp)", (int)sv->c.i);
#endif
		cstr_cat(add_str, buf, -1);
	}
	else if (r & VT_LVAL)
	{
		reg = r & VT_VALMASK;
		if (reg >= VT_CONST)
			tcc_error("internal compiler error");
		snprintf(buf, sizeof(buf), "(%%%s)",
#ifdef TCC_TARGET_X86_64
		         get_tok_str(TOK_ASM_rax + reg, NULL)
#else
		         get_tok_str(TOK_ASM_eax + reg, NULL)
#endif
		        );
		cstr_cat(add_str, buf, -1);
	}
	else
	{
		/* register case */
		reg = r & VT_VALMASK;
		if (reg >= VT_CONST)
			tcc_error("internal compiler error");

		/* choose register operand size */
		if ((sv->type.t & VT_BTYPE) == VT_BYTE ||
		        (sv->type.t & VT_BTYPE) == VT_BOOL)
			size = 1;
		else if ((sv->type.t & VT_BTYPE) == VT_SHORT)
			size = 2;
#ifdef TCC_TARGET_X86_64
		else if ((sv->type.t & VT_BTYPE) == VT_LLONG ||
		         (sv->type.t & VT_BTYPE) == VT_PTR)
			size = 8;
#endif
		else
			size = 4;
		if (size == 1 && reg >= 4)
			size = 4;

		if (modifier == 'b')
		{
			if (reg >= 4)
				tcc_error("cannot use byte register");
			size = 1;
		}
		else if (modifier == 'h')
		{
			if (reg >= 4)
				tcc_error("cannot use byte register");
			size = -1;
		}
		else if (modifier == 'w')
		{
			size = 2;
		}
		else if (modifier == 'k')
		{
			size = 4;
#ifdef TCC_TARGET_X86_64
		}
		else if (modifier == 'q')
		{
			size = 8;
#endif
		}

		switch(size)
		{
		case -1:
			reg = TOK_ASM_ah + reg;
			break;
		case 1:
			reg = TOK_ASM_al + reg;
			break;
		case 2:
			reg = TOK_ASM_ax + reg;
			break;
		default:
			reg = TOK_ASM_eax + reg;
			break;
#ifdef TCC_TARGET_X86_64
		case 8:
			reg = TOK_ASM_rax + reg;
			break;
#endif
		}
		snprintf(buf, sizeof(buf), "%%%s", get_tok_str(reg, NULL));
		cstr_cat(add_str, buf, -1);
	}
}

/* generate prolog and epilog code for asm statement */
ST_FUNC void asm_gen_code(ASMOperand *operands, int nb_operands,
                          int nb_outputs, int is_output,
                          uint8_t *clobber_regs,
                          int out_reg)
{
	uint8_t regs_allocated[NB_ASM_REGS];
	ASMOperand *op;
	int i, reg;

	/* Strictly speaking %Xbp and %Xsp should be included in the
	   call-preserved registers, but currently it doesn't matter.  */
#ifdef TCC_TARGET_X86_64
#ifdef TCC_TARGET_PE
	static uint8_t reg_saved[] = { 3, 6, 7, 12, 13, 14, 15 };
#else
	static uint8_t reg_saved[] = { 3, 12, 13, 14, 15 };
#endif
#else
	static uint8_t reg_saved[] = { 3, 6, 7 };
#endif

	/* mark all used registers */
	memcpy(regs_allocated, clobber_regs, sizeof(regs_allocated));
	for(i = 0; i < nb_operands; i++)
	{
		op = &operands[i];
		if (op->reg >= 0)
			regs_allocated[op->reg] = 1;
	}
	if (!is_output)
	{
		/* generate reg save code */
		for(i = 0; i < sizeof(reg_saved)/sizeof(reg_saved[0]); i++)
		{
			reg = reg_saved[i];
			if (regs_allocated[reg])
			{
				if (reg >= 8)
					g(0x41), reg-=8;
				g(0x50 + reg);
			}
		}

		/* generate load code */
		for(i = 0; i < nb_operands; i++)
		{
			op = &operands[i];
			if (op->reg >= 0)
			{
				if ((op->vt->r & VT_VALMASK) == VT_LLOCAL &&
				        op->is_memory)
				{
					/* memory reference case (for both input and
					   output cases) */
					SValue sv;
					sv = *op->vt;
					sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL | VT_LVAL;
					sv.type.t = VT_PTR;
					load(op->reg, &sv);
				}
				else if (i >= nb_outputs || op->is_rw)
				{
					/* load value in register */
					load(op->reg, op->vt);
					if (op->is_llong)
					{
						SValue sv;
						sv = *op->vt;
						sv.c.i += 4;
						load(TREG_XDX, &sv);
					}
				}
			}
		}
	}
	else
	{
		/* generate save code */
		for(i = 0 ; i < nb_outputs; i++)
		{
			op = &operands[i];
			if (op->reg >= 0)
			{
				if ((op->vt->r & VT_VALMASK) == VT_LLOCAL)
				{
					if (!op->is_memory)
					{
						SValue sv;
						sv = *op->vt;
						sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL;
						sv.type.t = VT_PTR;
						load(out_reg, &sv);

						sv = *op->vt;
						sv.r = (sv.r & ~VT_VALMASK) | out_reg;
						store(op->reg, &sv);
					}
				}
				else
				{
					store(op->reg, op->vt);
					if (op->is_llong)
					{
						SValue sv;
						sv = *op->vt;
						sv.c.i += 4;
						store(TREG_XDX, &sv);
					}
				}
			}
		}
		/* generate reg restore code */
		for(i = sizeof(reg_saved)/sizeof(reg_saved[0]) - 1; i >= 0; i--)
		{
			reg = reg_saved[i];
			if (regs_allocated[reg])
			{
				if (reg >= 8)
					g(0x41), reg-=8;
				g(0x58 + reg);
			}
		}
	}
}

ST_FUNC void asm_clobber(uint8_t *clobber_regs, const char *str)
{
	int reg;
	TokenSym *ts;
#ifdef TCC_TARGET_X86_64
	unsigned int type;
#endif

	if (!strcmp(str, "memory") ||
	        !strcmp(str, "cc") ||
	        !strcmp(str, "flags"))
		return;
	ts = tok_alloc(str, strlen(str));
	reg = ts->tok;
	if (reg >= TOK_ASM_eax && reg <= TOK_ASM_edi)
	{
		reg -= TOK_ASM_eax;
	}
	else if (reg >= TOK_ASM_ax && reg <= TOK_ASM_di)
	{
		reg -= TOK_ASM_ax;
#ifdef TCC_TARGET_X86_64
	}
	else if (reg >= TOK_ASM_rax && reg <= TOK_ASM_rdi)
	{
		reg -= TOK_ASM_rax;
	}
	else if ((reg = asm_parse_numeric_reg(reg, &type)) >= 0)
	{
		;
#endif
	}
	else
	{
		tcc_error("invalid clobber register '%s'", str);
	}
	clobber_regs[reg] = 1;
}
//END i386-asm.c


#elif defined(TCC_TARGET_RISCV64)
#include "riscv64-gen.c"
#include "riscv64-link.c"
#else
#error unknown target
#endif
#ifdef CONFIG_TCC_ASM

//START tccasm.c


#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) tcc_state->sym
# define TCC_SET_STATE(fn) fn

#ifdef CONFIG_TCC_ASM

static Section *last_text_section; /* to handle .previous asm directive */

ST_FUNC int asm_get_local_label_name(TCCState *s1, unsigned int n)
{
	char buf[64];
	TokenSym *ts;

	snprintf(buf, sizeof(buf), "L..%u", n);
	ts = tok_alloc(buf, strlen(buf));
	return ts->tok;
}

static int tcc_assemble_internal(TCCState *s1, int do_preprocess, int global);
static Sym* asm_new_label(TCCState *s1, int label, int is_local);
static Sym* asm_new_label1(TCCState *s1, int label, int is_local, int sh_num, int value);

static Sym *asm_label_find(int v)
{
	Sym *sym = sym_find(v);
	while (sym && sym->sym_scope && !(sym->type.t & VT_STATIC))
		sym = sym->prev_tok;
	return sym;
}

static Sym *asm_label_push(int v)
{
	/* We always add VT_EXTERN, for sym definition that's tentative
	   (for .set, removed for real defs), for mere references it's correct
	   as is.  */
	return global_identifier_push(v, VT_ASM | VT_EXTERN | VT_STATIC, 0);
}

/* Return a symbol we can use inside the assembler, having name NAME.
   Symbols from asm and C source share a namespace.  If we generate
   an asm symbol it's also a (file-global) C symbol, but it's
   either not accessible by name (like "L.123"), or its type information
   is such that it's not usable without a proper C declaration.

   Sometimes we need symbols accessible by name from asm, which
   are anonymous in C, in this case CSYM can be used to transfer
   all information from that symbol to the (possibly newly created)
   asm symbol.  */
ST_FUNC Sym* get_asm_sym(int name, Sym *csym)
{
	Sym *sym = asm_label_find(name);
	if (!sym)
	{
		sym = asm_label_push(name);
		if (csym)
			sym->c = csym->c;
	}
	return sym;
}

static Sym* asm_section_sym(TCCState *s1, Section *sec)
{
	char buf[100];
	int label = tok_alloc(buf,
	                      snprintf(buf, sizeof buf, "L.%s", sec->name)
	                     )->tok;
	Sym *sym = asm_label_find(label);
	return sym ? sym : asm_new_label1(s1, label, 1, sec->sh_num, 0);
}

/* We do not use the C expression parser to handle symbols. Maybe the
   C expression parser could be tweaked to do so. */

static void asm_expr_unary(TCCState *s1, ExprValue *pe)
{
	Sym *sym;
	int op, label;
	uint64_t n;
	const char *p;

	switch(tok)
	{
	case TOK_PPNUM:
		p = tokc.str.data;
		n = strtoull(p, (char **)&p, 0);
		if (*p == 'b' || *p == 'f')
		{
			/* backward or forward label */
			label = asm_get_local_label_name(s1, n);
			sym = asm_label_find(label);
			if (*p == 'b')
			{
				/* backward : find the last corresponding defined label */
				if (sym && (!sym->c || elfsym(sym)->st_shndx == SHN_UNDEF))
					sym = sym->prev_tok;
				if (!sym)
					tcc_error("local label '%d' not found backward", n);
			}
			else
			{
				/* forward */
				if (!sym || (sym->c && elfsym(sym)->st_shndx != SHN_UNDEF))
				{
					/* if the last label is defined, then define a new one */
					sym = asm_label_push(label);
				}
			}
			pe->v = 0;
			pe->sym = sym;
			pe->pcrel = 0;
		}
		else if (*p == '\0')
		{
			pe->v = n;
			pe->sym = NULL;
			pe->pcrel = 0;
		}
		else
		{
			tcc_error("invalid number syntax");
		}
		next();
		break;
	case '+':
		next();
		asm_expr_unary(s1, pe);
		break;
	case '-':
	case '~':
		op = tok;
		next();
		asm_expr_unary(s1, pe);
		if (pe->sym)
			tcc_error("invalid operation with label");
		if (op == '-')
			pe->v = -pe->v;
		else
			pe->v = ~pe->v;
		break;
	case TOK_CCHAR:
	case TOK_LCHAR:
		pe->v = tokc.i;
		pe->sym = NULL;
		pe->pcrel = 0;
		next();
		break;
	case '(':
		next();
		asm_expr(s1, pe);
		skip(')');
		break;
	case '.':
		pe->v = ind;
		pe->sym = asm_section_sym(s1, cur_text_section);
		pe->pcrel = 0;
		next();
		break;
	default:
		if (tok >= TOK_IDENT)
		{
			ElfSym *esym;
			/* label case : if the label was not found, add one */
			sym = get_asm_sym(tok, NULL);
			esym = elfsym(sym);
			if (esym && esym->st_shndx == SHN_ABS)
			{
				/* if absolute symbol, no need to put a symbol value */
				pe->v = esym->st_value;
				pe->sym = NULL;
				pe->pcrel = 0;
			}
			else
			{
				pe->v = 0;
				pe->sym = sym;
				pe->pcrel = 0;
			}
			next();
		}
		else
		{
			tcc_error("bad expression syntax [%s]", get_tok_str(tok, &tokc));
		}
		break;
	}
}

static void asm_expr_prod(TCCState *s1, ExprValue *pe)
{
	int op;
	ExprValue e2;

	asm_expr_unary(s1, pe);
	for(;;)
	{
		op = tok;
		if (op != '*' && op != '/' && op != '%' &&
		        op != TOK_SHL && op != TOK_SAR)
			break;
		next();
		asm_expr_unary(s1, &e2);
		if (pe->sym || e2.sym)
			tcc_error("invalid operation with label");
		switch(op)
		{
		case '*':
			pe->v *= e2.v;
			break;
		case '/':
			if (e2.v == 0)
			{
div_error:
				tcc_error("division by zero");
			}
			pe->v /= e2.v;
			break;
		case '%':
			if (e2.v == 0)
				goto div_error;
			pe->v %= e2.v;
			break;
		case TOK_SHL:
			pe->v <<= e2.v;
			break;
		default:
		case TOK_SAR:
			pe->v >>= e2.v;
			break;
		}
	}
}

static void asm_expr_logic(TCCState *s1, ExprValue *pe)
{
	int op;
	ExprValue e2;

	asm_expr_prod(s1, pe);
	for(;;)
	{
		op = tok;
		if (op != '&' && op != '|' && op != '^')
			break;
		next();
		asm_expr_prod(s1, &e2);
		if (pe->sym || e2.sym)
			tcc_error("invalid operation with label");
		switch(op)
		{
		case '&':
			pe->v &= e2.v;
			break;
		case '|':
			pe->v |= e2.v;
			break;
		default:
		case '^':
			pe->v ^= e2.v;
			break;
		}
	}
}

static inline void asm_expr_sum(TCCState *s1, ExprValue *pe)
{
	int op;
	ExprValue e2;

	asm_expr_logic(s1, pe);
	for(;;)
	{
		op = tok;
		if (op != '+' && op != '-')
			break;
		next();
		asm_expr_logic(s1, &e2);
		if (op == '+')
		{
			if (pe->sym != NULL && e2.sym != NULL)
				goto cannot_relocate;
			pe->v += e2.v;
			if (pe->sym == NULL && e2.sym != NULL)
				pe->sym = e2.sym;
		}
		else
		{
			pe->v -= e2.v;
			/* NOTE: we are less powerful than gas in that case
			   because we store only one symbol in the expression */
			if (!e2.sym)
			{
				/* OK */
			}
			else if (pe->sym == e2.sym)
			{
				/* OK */
				pe->sym = NULL; /* same symbols can be subtracted to NULL */
			}
			else
			{
				ElfSym *esym1, *esym2;
				esym1 = elfsym(pe->sym);
				esym2 = elfsym(e2.sym);
				if (esym1 && esym1->st_shndx == esym2->st_shndx
				        && esym1->st_shndx != SHN_UNDEF)
				{
					/* we also accept defined symbols in the same section */
					pe->v += esym1->st_value - esym2->st_value;
					pe->sym = NULL;
				}
				else if (esym2->st_shndx == cur_text_section->sh_num)
				{
					/* When subtracting a defined symbol in current section
					   this actually makes the value PC-relative.  */
					pe->v -= esym2->st_value - ind - 4;
					pe->pcrel = 1;
					e2.sym = NULL;
				}
				else
				{
cannot_relocate:
					tcc_error("invalid operation with label");
				}
			}
		}
	}
}

static inline void asm_expr_cmp(TCCState *s1, ExprValue *pe)
{
	int op;
	ExprValue e2;

	asm_expr_sum(s1, pe);
	for(;;)
	{
		op = tok;
		if (op != TOK_EQ && op != TOK_NE
		        && (op > TOK_GT || op < TOK_ULE))
			break;
		next();
		asm_expr_sum(s1, &e2);
		if (pe->sym || e2.sym)
			tcc_error("invalid operation with label");
		switch(op)
		{
		case TOK_EQ:
			pe->v = pe->v == e2.v;
			break;
		case TOK_NE:
			pe->v = pe->v != e2.v;
			break;
		case TOK_LT:
			pe->v = (int64_t)pe->v < (int64_t)e2.v;
			break;
		case TOK_GE:
			pe->v = (int64_t)pe->v >= (int64_t)e2.v;
			break;
		case TOK_LE:
			pe->v = (int64_t)pe->v <= (int64_t)e2.v;
			break;
		case TOK_GT:
			pe->v = (int64_t)pe->v > (int64_t)e2.v;
			break;
		default:
			break;
		}
		/* GAS compare results are -1/0 not 1/0.  */
		pe->v = -(int64_t)pe->v;
	}
}

ST_FUNC void asm_expr(TCCState *s1, ExprValue *pe)
{
	asm_expr_cmp(s1, pe);
}

ST_FUNC int asm_int_expr(TCCState *s1)
{
	ExprValue e;
	asm_expr(s1, &e);
	if (e.sym)
		expect("constant");
	return e.v;
}

static Sym* asm_new_label1(TCCState *s1, int label, int is_local,
                           int sh_num, int value)
{
	Sym *sym;
	ElfSym *esym;

	sym = asm_label_find(label);
	if (sym)
	{
		esym = elfsym(sym);
		/* A VT_EXTERN symbol, even if it has a section is considered
		   overridable.  This is how we "define" .set targets.  Real
		   definitions won't have VT_EXTERN set.  */
		if (esym && esym->st_shndx != SHN_UNDEF)
		{
			/* the label is already defined */
			if (IS_ASM_SYM(sym)
			        && (is_local == 1 || (sym->type.t & VT_EXTERN)))
				goto new_label;
			if (!(sym->type.t & VT_EXTERN))
				tcc_error("assembler label '%s' already defined",
				          get_tok_str(label, NULL));
		}
	}
	else
	{
new_label:
		sym = asm_label_push(label);
	}
	if (!sym->c)
		put_extern_sym2(sym, SHN_UNDEF, 0, 0, 0);
	esym = elfsym(sym);
	esym->st_shndx = sh_num;
	esym->st_value = value;
	if (is_local != 2)
		sym->type.t &= ~VT_EXTERN;
	return sym;
}

static Sym* asm_new_label(TCCState *s1, int label, int is_local)
{
	return asm_new_label1(s1, label, is_local, cur_text_section->sh_num, ind);
}

/* Set the value of LABEL to that of some expression (possibly
   involving other symbols).  LABEL can be overwritten later still.  */
static Sym* set_symbol(TCCState *s1, int label)
{
	long n;
	ExprValue e;
	Sym *sym;
	ElfSym *esym;
	next();
	asm_expr(s1, &e);
	n = e.v;
	esym = elfsym(e.sym);
	if (esym)
		n += esym->st_value;
	sym = asm_new_label1(s1, label, 2, esym ? esym->st_shndx : SHN_ABS, n);
	elfsym(sym)->st_other |= ST_ASM_SET;
	return sym;
}

static void use_section1(TCCState *s1, Section *sec)
{
	cur_text_section->data_offset = ind;
	cur_text_section = sec;
	ind = cur_text_section->data_offset;
}

static void use_section(TCCState *s1, const char *name)
{
	Section *sec;
	sec = find_section(s1, name);
	use_section1(s1, sec);
}

static void push_section(TCCState *s1, const char *name)
{
	Section *sec = find_section(s1, name);
	sec->prev = cur_text_section;
	use_section1(s1, sec);
}

static void pop_section(TCCState *s1)
{
	Section *prev = cur_text_section->prev;
	if (!prev)
		tcc_error(".popsection without .pushsection");
	cur_text_section->prev = NULL;
	use_section1(s1, prev);
}

static void asm_parse_directive(TCCState *s1, int global)
{
	int n, offset, v, size, tok1;
	Section *sec;
	uint8_t *ptr;

	/* assembler directive */
	sec = cur_text_section;
	switch(tok)
	{
	case TOK_ASMDIR_align:
	case TOK_ASMDIR_balign:
	case TOK_ASMDIR_p2align:
	case TOK_ASMDIR_skip:
	case TOK_ASMDIR_space:
		tok1 = tok;
		next();
		n = asm_int_expr(s1);
		if (tok1 == TOK_ASMDIR_p2align)
		{
			if (n < 0 || n > 30)
				tcc_error("invalid p2align, must be between 0 and 30");
			n = 1 << n;
			tok1 = TOK_ASMDIR_align;
		}
		if (tok1 == TOK_ASMDIR_align || tok1 == TOK_ASMDIR_balign)
		{
			if (n < 0 || (n & (n-1)) != 0)
				tcc_error("alignment must be a positive power of two");
			offset = (ind + n - 1) & -n;
			size = offset - ind;
			/* the section must have a compatible alignment */
			if (sec->sh_addralign < n)
				sec->sh_addralign = n;
		}
		else
		{
			if (n < 0)
				n = 0;
			size = n;
		}
		v = 0;
		if (tok == ',')
		{
			next();
			v = asm_int_expr(s1);
		}
zero_pad:
		if (sec->sh_type != SHT_NOBITS)
		{
			sec->data_offset = ind;
			ptr = section_ptr_add(sec, size);
			memset(ptr, v, size);
		}
		ind += size;
		break;
	case TOK_ASMDIR_quad:
#ifdef TCC_TARGET_X86_64
		size = 8;
		goto asm_data;
#else
		next();
		for(;;)
		{
			uint64_t vl;
			const char *p;

			p = tokc.str.data;
			if (tok != TOK_PPNUM)
			{
error_constant:
				tcc_error("64 bit constant");
			}
			vl = strtoll(p, (char **)&p, 0);
			if (*p != '\0')
				goto error_constant;
			next();
			if (sec->sh_type != SHT_NOBITS)
			{
				/* XXX: endianness */
				gen_le32(vl);
				gen_le32(vl >> 32);
			}
			else
			{
				ind += 8;
			}
			if (tok != ',')
				break;
			next();
		}
		break;
#endif
	case TOK_ASMDIR_byte:
		size = 1;
		goto asm_data;
	case TOK_ASMDIR_word:
	case TOK_ASMDIR_short:
		size = 2;
		goto asm_data;
	case TOK_ASMDIR_long:
	case TOK_ASMDIR_int:
		size = 4;
asm_data:
		next();
		for(;;)
		{
			ExprValue e;
			asm_expr(s1, &e);
			if (sec->sh_type != SHT_NOBITS)
			{
				if (size == 4)
				{
					gen_expr32(&e);
#ifdef TCC_TARGET_X86_64
				}
				else if (size == 8)
				{
					gen_expr64(&e);
#endif
				}
				else
				{
					if (e.sym)
						expect("constant");
					if (size == 1)
						g(e.v);
					else
						gen_le16(e.v);
				}
			}
			else
			{
				ind += size;
			}
			if (tok != ',')
				break;
			next();
		}
		break;
	case TOK_ASMDIR_fill:
	{
		int repeat, size, val, i, j;
		uint8_t repeat_buf[8];
		next();
		repeat = asm_int_expr(s1);
		if (repeat < 0)
		{
			tcc_error("repeat < 0; .fill ignored");
			break;
		}
		size = 1;
		val = 0;
		if (tok == ',')
		{
			next();
			size = asm_int_expr(s1);
			if (size < 0)
			{
				tcc_error("size < 0; .fill ignored");
				break;
			}
			if (size > 8)
				size = 8;
			if (tok == ',')
			{
				next();
				val = asm_int_expr(s1);
			}
		}
		/* XXX: endianness */
		repeat_buf[0] = val;
		repeat_buf[1] = val >> 8;
		repeat_buf[2] = val >> 16;
		repeat_buf[3] = val >> 24;
		repeat_buf[4] = 0;
		repeat_buf[5] = 0;
		repeat_buf[6] = 0;
		repeat_buf[7] = 0;
		for(i = 0; i < repeat; i++)
		{
			for(j = 0; j < size; j++)
			{
				g(repeat_buf[j]);
			}
		}
	}
	break;
	case TOK_ASMDIR_rept:
	{
		int repeat;
		TokenString *init_str;
		next();
		repeat = asm_int_expr(s1);
		init_str = tok_str_alloc();
		while (next(), tok != TOK_ASMDIR_endr)
		{
			if (tok == CH_EOF)
				tcc_error("we at end of file, .endr not found");
			tok_str_add_tok(init_str);
		}
		tok_str_add(init_str, -1);
		tok_str_add(init_str, 0);
		begin_macro(init_str, 1);
		while (repeat-- > 0)
		{
			tcc_assemble_internal(s1, (parse_flags & PARSE_FLAG_PREPROCESS),
			                      global);
			macro_ptr = init_str->str;
		}
		end_macro();
		next();
		break;
	}
	case TOK_ASMDIR_org:
	{
		unsigned long n;
		ExprValue e;
		ElfSym *esym;
		next();
		asm_expr(s1, &e);
		n = e.v;
		esym = elfsym(e.sym);
		if (esym)
		{
			if (esym->st_shndx != cur_text_section->sh_num)
				expect("constant or same-section symbol");
			n += esym->st_value;
		}
		if (n < ind)
			tcc_error("attempt to .org backwards");
		v = 0;
		size = n - ind;
		goto zero_pad;
	}
	break;
	case TOK_ASMDIR_set:
		next();
		tok1 = tok;
		next();
		/* Also accept '.set stuff', but don't do anything with this.
		   It's used in GAS to set various features like '.set mips16'.  */
		if (tok == ',')
			set_symbol(s1, tok1);
		break;
	case TOK_ASMDIR_globl:
	case TOK_ASMDIR_global:
	case TOK_ASMDIR_weak:
	case TOK_ASMDIR_hidden:
		tok1 = tok;
		do
		{
			Sym *sym;
			next();
			sym = get_asm_sym(tok, NULL);
			if (tok1 != TOK_ASMDIR_hidden)
				sym->type.t &= ~VT_STATIC;
			if (tok1 == TOK_ASMDIR_weak)
				sym->a.weak = 1;
			else if (tok1 == TOK_ASMDIR_hidden)
				sym->a.visibility = STV_HIDDEN;
			update_storage(sym);
			next();
		}
		while (tok == ',');
		break;
	case TOK_ASMDIR_string:
	case TOK_ASMDIR_ascii:
	case TOK_ASMDIR_asciz:
	{
		const uint8_t *p;
		int i, size, t;

		t = tok;
		next();
		for(;;)
		{
			if (tok != TOK_STR)
				expect("string constant");
			p = tokc.str.data;
			size = tokc.str.size;
			if (t == TOK_ASMDIR_ascii && size > 0)
				size--;
			for(i = 0; i < size; i++)
				g(p[i]);
			next();
			if (tok == ',')
			{
				next();
			}
			else if (tok != TOK_STR)
			{
				break;
			}
		}
	}
	break;
	case TOK_ASMDIR_text:
	case TOK_ASMDIR_data:
	case TOK_ASMDIR_bss:
	{
		char sname[64];
		tok1 = tok;
		n = 0;
		next();
		if (tok != ';' && tok != TOK_LINEFEED)
		{
			n = asm_int_expr(s1);
			next();
		}
		if (n)
			sprintf(sname, "%s%d", get_tok_str(tok1, NULL), n);
		else
			sprintf(sname, "%s", get_tok_str(tok1, NULL));
		use_section(s1, sname);
	}
	break;
	case TOK_ASMDIR_file:
	{
		char filename[512];

		filename[0] = '\0';
		next();

		if (tok == TOK_STR)
			pstrcat(filename, sizeof(filename), tokc.str.data);
		else
			pstrcat(filename, sizeof(filename), get_tok_str(tok, NULL));

		if (s1->warn_unsupported)
			tcc_warning("ignoring .file %s", filename);

		next();
	}
	break;
	case TOK_ASMDIR_ident:
	{
		char ident[256];

		ident[0] = '\0';
		next();

		if (tok == TOK_STR)
			pstrcat(ident, sizeof(ident), tokc.str.data);
		else
			pstrcat(ident, sizeof(ident), get_tok_str(tok, NULL));

		if (s1->warn_unsupported)
			tcc_warning("ignoring .ident %s", ident);

		next();
	}
	break;
	case TOK_ASMDIR_size:
	{
		Sym *sym;

		next();
		sym = asm_label_find(tok);
		if (!sym)
		{
			tcc_error("label not found: %s", get_tok_str(tok, NULL));
		}

		/* XXX .size name,label2-label1 */
		if (s1->warn_unsupported)
			tcc_warning("ignoring .size %s,*", get_tok_str(tok, NULL));

		next();
		skip(',');
		while (tok != TOK_LINEFEED && tok != ';' && tok != CH_EOF)
		{
			next();
		}
	}
	break;
	case TOK_ASMDIR_type:
	{
		Sym *sym;
		const char *newtype;

		next();
		sym = get_asm_sym(tok, NULL);
		next();
		skip(',');
		if (tok == TOK_STR)
		{
			newtype = tokc.str.data;
		}
		else
		{
			if (tok == '@' || tok == '%')
				next();
			newtype = get_tok_str(tok, NULL);
		}

		if (!strcmp(newtype, "function") || !strcmp(newtype, "STT_FUNC"))
		{
			sym->type.t = (sym->type.t & ~VT_BTYPE) | VT_FUNC;
		}
		else if (s1->warn_unsupported)
			tcc_warning("change type of '%s' from 0x%x to '%s' ignored",
			            get_tok_str(sym->v, NULL), sym->type.t, newtype);

		next();
	}
	break;
	case TOK_ASMDIR_pushsection:
	case TOK_ASMDIR_section:
	{
		char sname[256];
		int old_nb_section = s1->nb_sections;

		tok1 = tok;
		/* XXX: support more options */
		next();
		sname[0] = '\0';
		while (tok != ';' && tok != TOK_LINEFEED && tok != ',')
		{
			if (tok == TOK_STR)
				pstrcat(sname, sizeof(sname), tokc.str.data);
			else
				pstrcat(sname, sizeof(sname), get_tok_str(tok, NULL));
			next();
		}
		if (tok == ',')
		{
			/* skip section options */
			next();
			if (tok != TOK_STR)
				expect("string constant");
			next();
			if (tok == ',')
			{
				next();
				if (tok == '@' || tok == '%')
					next();
				next();
			}
		}
		last_text_section = cur_text_section;
		if (tok1 == TOK_ASMDIR_section)
			use_section(s1, sname);
		else
			push_section(s1, sname);
		/* If we just allocated a new section reset its alignment to
		   1.  new_section normally acts for GCC compatibility and
		   sets alignment to PTR_SIZE.  The assembler behaves different. */
		if (old_nb_section != s1->nb_sections)
			cur_text_section->sh_addralign = 1;
	}
	break;
	case TOK_ASMDIR_previous:
	{
		Section *sec;
		next();
		if (!last_text_section)
			tcc_error("no previous section referenced");
		sec = cur_text_section;
		use_section1(s1, last_text_section);
		last_text_section = sec;
	}
	break;
	case TOK_ASMDIR_popsection:
		next();
		pop_section(s1);
		break;
#ifdef TCC_TARGET_I386
	case TOK_ASMDIR_code16:
	{
		next();
		s1->seg_size = 16;
	}
	break;
	case TOK_ASMDIR_code32:
	{
		next();
		s1->seg_size = 32;
	}
	break;
#endif
#ifdef TCC_TARGET_X86_64
	/* added for compatibility with GAS */
	case TOK_ASMDIR_code64:
		next();
		break;
#endif
	default:
		tcc_error("unknown assembler directive '.%s'", get_tok_str(tok, NULL));
		break;
	}
}


/* assemble a file */
static int tcc_assemble_internal(TCCState *s1, int do_preprocess, int global)
{
	int opcode;
	int saved_parse_flags = parse_flags;

	parse_flags = PARSE_FLAG_ASM_FILE | PARSE_FLAG_TOK_STR;
	if (do_preprocess)
		parse_flags |= PARSE_FLAG_PREPROCESS;
	for(;;)
	{
		next();
		if (tok == TOK_EOF)
			break;
		parse_flags |= PARSE_FLAG_LINEFEED; /* XXX: suppress that hack */
redo:
		if (tok == '#')
		{
			/* horrible gas comment */
			while (tok != TOK_LINEFEED)
				next();
		}
		else if (tok >= TOK_ASMDIR_FIRST && tok <= TOK_ASMDIR_LAST)
		{
			asm_parse_directive(s1, global);
		}
		else if (tok == TOK_PPNUM)
		{
			const char *p;
			int n;
			p = tokc.str.data;
			n = strtoul(p, (char **)&p, 10);
			if (*p != '\0')
				expect("':'");
			/* new local label */
			asm_new_label(s1, asm_get_local_label_name(s1, n), 1);
			next();
			skip(':');
			goto redo;
		}
		else if (tok >= TOK_IDENT)
		{
			/* instruction or label */
			opcode = tok;
			next();
			if (tok == ':')
			{
				/* new label */
				asm_new_label(s1, opcode, 0);
				next();
				goto redo;
			}
			else if (tok == '=')
			{
				set_symbol(s1, opcode);
				goto redo;
			}
			else
			{
				asm_opcode(s1, opcode);
			}
		}
		/* end of line */
		if (tok != ';' && tok != TOK_LINEFEED)
			expect("end of line");
		parse_flags &= ~PARSE_FLAG_LINEFEED; /* XXX: suppress that hack */
	}

	parse_flags = saved_parse_flags;
	return 0;
}

/* Assemble the current file */
ST_FUNC int tcc_assemble(TCCState *s1, int do_preprocess)
{
	int ret;
	tcc_debug_start(s1);
	/* default section is text */
	cur_text_section = text_section;
	ind = cur_text_section->data_offset;
	nocode_wanted = 0;
	ret = tcc_assemble_internal(s1, do_preprocess, 1);
	cur_text_section->data_offset = ind;
	tcc_debug_end(s1);
	return ret;
}

/* Intel syntax asm to at&t */

#define LINE_MAX_OPERANDS 32
#define LINE_MAX_LENGTH 255

typedef char ChBuf[LINE_MAX_LENGTH+1];

enum OpFlags
{
	Op_SizeByte   = 0x01,
	Op_SizeWord   = 0x02,
	Op_SizeDWord  = 0x04,
	Op_SizeQWord  = 0x08,
	Op_SizeOWord  = 0x10,
};
#define Op_SizeMask (Op_SizeByte|Op_SizeWord|Op_SizeDWord|Op_SizeQWord|Op_SizeOWord)

/** Single operand in an assembly line. */
typedef struct
{
	ChBuf txt;
	short flags;
} operand_t;

enum ComFlags
{
	Com_DataDef      = 0x01,
	Com_Directive    = 0x02,
	Com_IOInstr      = 0x04,
	Com_JmpInstr     = 0x08,
	Com_ManyOperands = 0x80,
};

/** Content of an assembly line. */
typedef struct
{
	ChBuf label;
	ChBuf com;
	short com_flags;
	ChBuf rem;
	operand_t op[LINE_MAX_OPERANDS];
	int op_len;
} AsmLine;

/** Information required for conversion which applies to the whole file. */
typedef struct
{
	//TODO: Make a buffer here to store all labels in the input file.
} AsmCodeProps;

typedef void (*modfunc)(AsmLine *ln);

typedef struct
{
	char wrd[8];
	modfunc p;
	int waslab;
} ModStruct;

typedef struct
{
	char src[8];
	char dst[8];
} ReplaceStruct;

typedef struct
{
	char name[8];
	short size;
} RegStruct;

typedef struct
{
	ChBuf disp;
	ChBuf base;
	ChBuf index;
	ChBuf scale;
	short flags;
} MemoryAddress;


/** List of recognized CPU registers.
 *  Must be sorted in order to make bsearch() work.
 */
const RegStruct regslist[] =
{
	{"ah",1},
	{"al",1},
	{"ax",2},
	{"bh",1},
	{"bl",1},
	{"bp",2},
	{"bx",2},
	{"ch",1},
	{"cl",1},
	{"cr0",4},
	{"cr1",4},
	{"cr2",4},
	{"cr3",4},
	{"cr4",4},
	{"cx",2},
	{"dh",1},
	{"di",2},
	{"dl",1},
	{"dr0",4},
	{"dr1",4},
	{"dr2",4},
	{"dr3",4},
	{"dr4",4},
	{"dr5",4},
	{"dr6",4},
	{"dr7",4},
	{"dx",2},
	{"eax",4},
	{"ebp",4},
	{"ebx",4},
	{"ecx",4},
	{"edi",4},
	{"edx",4},
	{"esi",4},
	{"esp",4},
	{"si",2},
	{"sp",2},
	{"tr6",4},// Test register
	{"tr7",4} // Test register
};
#define REGSLIST_LEN (sizeof(regslist)/sizeof(regslist[0]))

int operandDataTypeSize(const char **op);
void eqSgnReshuffle(AsmLine *ln);
void equReshuffle(AsmLine *ln);
void textequReshuffle(AsmLine *ln);

/** List of modifier routines for specific keywords.
 *  Must be sorted in order to make bsearch() work.
 */
const ModStruct wrdmods[] =
{
	{"=",eqSgnReshuffle,1},
	{"dosseg",NULL,0},
	{"end",NULL,0},
	{"equ",equReshuffle,1},
	{"extrn",NULL,0},
	{"ideal",NULL,0},
	{"model",NULL,0},
	{"p386",NULL,0},
	{"stack",NULL,0},
	{"textequ",textequReshuffle,1},
};
#define WORD_MODS_LEN (sizeof(wrdmods)/sizeof(wrdmods[0]))

/** List of pairs, to replace specific words.
 *  Must be sorted in order to make bsearch() work.
 */
const ReplaceStruct wrdreplace[] =
{
	{"align",".align"},
	{"cbw","cbtw"},
	{"cdq","cltd"},
	{"cmpsd","cmpsl"},
	{"codeseg",".text"},
	{"cwd","cwtd"},
	{"cwde","cwtl"},
	{"dataseg",".data"},
	{"db",".byte"},
	{"dd",".int"}, // may also be float
	{"ddq",".octet"}, //TODO if there is 'double quad' in AT&T, put it here
	{"do",".octet"}, //TODO if there is 'double quad' in AT&T, put it here
	{"dq",".quad"}, // may also be double
	{"dt",".octet"}, // TODO check what should be here; not sure if it's double quad
	{"dw",".short"},
	{"insd","insl"},
	{"lodsd","lodsl"},
	{"movsd","movsl"},
	{"movsx","movs"},
	{"movzx","movz"},
	{"outsd","outsl"},
	{"public",".globl"},
	{"scasd","scasl"},
	{"stosd","stosl"},
};
#define WORD_REPLACE_LEN (sizeof(wrdreplace)/sizeof(wrdreplace[0]))


/** For strings in form "LABEL = NUMBER".
 */
void eqSgnReshuffle(AsmLine *ln)
{
	const char *opg;
	int idx;
	idx=0;
	if (ln->op_len != 1)
		return;
	opg = ln->op[idx].txt;
	if (operandDataTypeSize(&opg) > 0)
	{
		// after type, there should be 'ptr'; skip it
		opg += strspn(opg," \t"); // skip white spaces
		if ((strncasecmp(opg,"ptr",3) == 0) && isspace(opg[3]))
		{
			opg += 4;
			opg += strspn(opg," \t");
		}
		memmove(ln->op[idx].txt,opg,strlen(opg)+1);
	}
}

void equReshuffle(AsmLine *ln)
{
	strcpy(ln->com,ln->label);
	strcat(ln->com,",");
	strcpy(ln->label,".equ");
}

void textequReshuffle(AsmLine *ln)
{
	strcpy(ln->com,ln->label);
	strcat(ln->com,",");
	strcpy(ln->label,".textequ");
}

/** Uses wrdreplace[] array to replace Intel syntax words with AT&T replacements.
 */
int checkWordsReplace(AsmLine *ln)
{
	ReplaceStruct *p;
	p = (ReplaceStruct *)bsearch(ln->com,wrdreplace,WORD_REPLACE_LEN,sizeof(ReplaceStruct),(void*)strcasecmp);
	if (p != NULL)
	{
		strcpy(ln->com,p->dst);
		return 0;
	}
	p = (ReplaceStruct *)bsearch(ln->label,wrdreplace,WORD_REPLACE_LEN,sizeof(ReplaceStruct),(void*)strcasecmp);
	if (p != NULL)
	{
		strcpy(ln->label,p->dst);
		return 1;
	}
	return -1;
}

/** Uses wrdmods[] array to make advanced replacements of Intel syntax words.
 *  For every matching line, a function is called to adjust it to AT&T syntax.
 */
int checkWordsModify(AsmLine *ln)
{
	ModStruct *p;
	int waslabel;
	waslabel = -1;
	p = NULL;
	if (p == NULL)
	{
		p = (ModStruct *)bsearch(ln->com,wrdmods,WORD_MODS_LEN,sizeof(ModStruct),(void *)strcasecmp);
		if (p != NULL)
			waslabel = 0;
	}
	if (p == NULL)
	{
		p = (ModStruct *)bsearch(ln->label,wrdmods,WORD_MODS_LEN,sizeof(ModStruct),(void *)strcasecmp);
		if (p != NULL)
			waslabel = 1;
	}
	if (p != NULL)
	{
		if(p->p != NULL)
		{
			waslabel = p->waslab;
			p->p(ln);
		}
		else
		{
			ln->label[0] = '\0';
			ln->com[0] = '\0';
			ln->op_len = 0;
		}
	}
	return waslabel;
}

/** If given operand is a register in Intel syntax, returns the register size.
 */
int cpuRegisterSize(const ChBuf op)
{
	RegStruct *p;
	ChBuf buf;
	int len;
	len = strcspn(op," \t");
	strncpy(buf,op,len);
	buf[len]= '\0';
	strlwr(buf);
	p = (RegStruct *)bsearch(buf, regslist,REGSLIST_LEN,sizeof(RegStruct),(void *)strcmp);
	if (p != NULL)
		return p->size;
	return 0;
}

/** Returns if given command is a data definition.
 */
int isDataDefinition(const ChBuf com)
{
	if (strcasecmp(com,".byte") == 0)
		return 1;
	if (strcasecmp(com,".short") == 0)
		return 1;
	if (strcasecmp(com,".int") == 0)
		return 1;
	if (strcasecmp(com,".quad") == 0)
		return 1;
	if (strcasecmp(com,".equ") == 0)
		return 1;
	if (strcasecmp(com,"=") == 0)
		return 1;
	return 0;
}

/** Returns if given command is an IO instruction.
 */
int isIOInstruction(const ChBuf com)
{
	if (strcasecmp(com,"out") == 0)
		return 1;
	if (strcasecmp(com,"in") == 0)
		return 1;
	return 0;
}

/** Returns if given command is a jump instruction.
 */
int isJumpInstruction(const ChBuf com)
{
	if ((com[0] == 'j') || (com[0] == 'J'))
		return 1;
	return 0;
}

void strTrimLeft(ChBuf op)
{
	int len = strlen(op);
	int skip;
	for (skip=0; op[skip] != '\0'; skip++)
	{
		if((op[skip] != ' ') && (op[skip] != '\t'))
			break;
	}
	if (skip > 0)
	{
		memmove(op,op+skip,len+1-skip);
	}
}

void strTrimRight(ChBuf op)
{
	int len = strlen(op)-1;
	while((op[len] == ' ') || (op[len] == '\t'))
	{
		op[len] = '\0';
		len--;
	}
}

/** If given operand starts with data size definition, returns the size.
 *  Increases 'op' pointer so that it skips the definition.
 */
int operandDataTypeSize(const char **op)
{
	static const RegStruct varkindlist[] =
	{
		{"byte\0",1},
		{"word\0",2},
		{"dword\0",4},
		{"qword\0",8},
	};
	int idx,len;
	for (idx = 0; idx < sizeof(varkindlist)/sizeof(varkindlist[0]); idx++)
	{
		len = strlen(varkindlist[idx].name);
		if (strncasecmp((*op),varkindlist[idx].name,len) == 0)
		{
			if (isspace((*op)[len]))
			{
				(*op) += len;
				return varkindlist[idx].size;
			}
		}
	}
	return 0;
}

int parseOperandDataType(const char **op, MemoryAddress *maddr)
{
	int len;
	len = operandDataTypeSize(op);
	switch (len)
	{
	case 1:
		maddr->flags |= Op_SizeByte;
		break;
	case 2:
		maddr->flags |= Op_SizeWord;
		break;
	case 4:
		maddr->flags |= Op_SizeDWord;
		break;
	case 8:
		maddr->flags |= Op_SizeQWord;
		break;
	case 16:
		maddr->flags |= Op_SizeOWord;
		break;
	case 0:
		return 0;
	}
	return 1;
}

/** Analyzes memory addressing operand from Intel syntax parameter.
 *  General input syntax: "TYPE [DISP+BASE+INDEX*SCALE]",
 *   ie "dword [ebx + ecx*4 + mem_location]".
 *   DISP is constant offset, BASE is register, INDEX is register
 *    and SCALE is constant number.
 */
int chopIntelMemoryAddress(const operand_t *op, MemoryAddress *maddr)
{
	int len;
	ChBuf wrd;
	char last_opertr[2];
	char *mul_pos;
	const char *opg;
	memset(maddr,0,sizeof(MemoryAddress));
	strcpy(maddr->base,"$");
	strcpy(maddr->index,"$");
	last_opertr[0] = '\0';
	last_opertr[1] = '\0';
	opg = op->txt;
	// first word should be length (TYPE) of the variable inside address
	// we will check for TYPE and DISP at start - it may sometimes be before '['
	// but it may also be inside (i think..) so we'll check again later
	if (parseOperandDataType(&opg,maddr))
	{
		// after type, there should be 'ptr'; skip it
		opg += strspn(opg," \t"); // skip white spaces
		if ((strncasecmp(opg,"ptr",3) == 0) && isspace(opg[3]))
		{
			opg += 4;
			opg += strspn(opg," \t");
		}
	}
	len = strcspn(opg,"[");
	strncpy(wrd,opg,len);
	wrd[len] = '\0';
	if (len > 0)
	{
		while ((mul_pos = strchr(wrd,'(')) != NULL)
			memmove(mul_pos,mul_pos+1,strlen(mul_pos));
		while ((mul_pos = strchr(wrd,')')) != NULL)
			memmove(mul_pos,mul_pos+1,strlen(mul_pos));
		strcpy(maddr->disp,wrd);
		last_opertr[0] = '+';
	}
	opg += len+1; // skip to after the '['
	opg += strspn(opg," \t"); // and skip white spaces
	// check for TYPE again - maybe it's inside
	parseOperandDataType(&opg,maddr);
	do
	{
		// Get rid of white chars
		opg += strspn(opg," \t");
		// find an argument of +/- operation and make a separate string out of it
		len = strcspn(opg,"+-]");
		strncpy(wrd,opg,len);
		wrd[len] = '\0';
		// check if the operand is multiplication of two
		mul_pos = strchr(wrd,'*');
		if (mul_pos != NULL)
		{
			// if it is multiplication, analyze operands as offset and multiplier
			*mul_pos = '\0';
			if(cpuRegisterSize(wrd) > 0)
			{
				maddr->index[0] = '%';
				strcpy(maddr->index+1,wrd);
				strcpy(maddr->scale,mul_pos+1);
			}
			else if(cpuRegisterSize(mul_pos+1) > 0)
			{
				maddr->index[0] = '%';
				strcpy(maddr->index+1,mul_pos+1);
				strcpy(maddr->scale,wrd);
			}
			else
			{
				strcat(maddr->disp,last_opertr);
				strncat(maddr->disp,opg,len);
			}
		}
		else
		{
			// if it is single, analyze it as base, or offset with multiplier=1
			if(cpuRegisterSize(wrd) > 0)
			{
				if (maddr->base[1])
				{
					maddr->index[0] = '%';
					strcpy(maddr->index+1,wrd);
				}
				else
				{
					maddr->base[0] = '%';
					strcpy(maddr->base+1,wrd);
				}
			}
			else
			{
				strcat(maddr->disp,last_opertr);
				strcat(maddr->disp,wrd);
			}
		}
		// if the addressing bracket closes, finish
		if (opg[len] == ']') break;
		// else store the +/- operation for next iteration
		last_opertr[0] = opg[len];
		opg += len+1;
	}
	while(1);
	return 1;
}

/** Converts memory address data into operand string with AT&T syntax.
 *  General output syntax: "DISP(BASE,INDEX,SCALE)", ie "mem_location(%ebx,%ecx,4)".
 */
int linkAtntMemoryAddress(operand_t *op, const MemoryAddress *maddr)
{
	char *opg;
	opg=op->txt;
	*opg=0;
	op->flags |= maddr->flags;
	strcat(opg,*maddr->disp=='+'?maddr->disp+1:maddr->disp);
	if(*(maddr->base+1)||*(maddr->index+1))
	{
		strcat(opg,"(");
		if (*(maddr->base+1)) strcat(opg,maddr->base);
		if (*(maddr->index+1))
		{
			strcat(opg,",");
			strcat(opg,maddr->index);
			if(*maddr->scale)
			{
				strcat(opg,",");
				strcat(opg,maddr->scale);
			}
		}
		strcat(opg,")");
	}
	return 1;
}

/** Converts hex and bin values inside operand from Intel to AT&T syntax.
 */
void operandHexBinValues2Atnt(operand_t *op)
{
	int len,num_len;
	char *opg;
	opg = op->txt;
	while (len=strcspn(opg,"0123456789"),opg+=len,isdigit(*opg))
	{
		num_len = strspn(opg,"0123456789abcdefABCDEF");
		if ((len > 0) && (isalpha(*(opg-1)) || *(opg-1)=='@' || *(opg-1)=='_'))
		{
		}
		else
		{
			char ch;
			if ((*(opg+num_len)&0xdf)=='H')
			{
				ch='x';
frot:
				memmove(opg+num_len+1,opg+num_len,strlen(opg+num_len)+1);
				memmove(opg+2,opg,num_len);
				*opg='0';
				*(++opg)=ch;
			}
			else if ((*(opg+num_len-1)&0xdf)=='B')
			{
				num_len--;
				ch='B';
				goto frot;
			}
		}
		opg += num_len;
	}
}

/** Converts a single instruction operand from Intel to AT&T syntax.
 */
int operandChange2Atnt(operand_t *op, short com_flags)
{
	char *temp,*opg;
	int len;
	opg = op->txt;
	// skip spaces
	opg += strspn(opg," \t");
	if (strchr(opg,'[') != NULL)
	{
		MemoryAddress maddr;
		chopIntelMemoryAddress(op, &maddr);
		// merge back the elements into operand
		linkAtntMemoryAddress(op, &maddr);
		// Check if no size was provided in this operand. This may happen
		// when using memory offset constant defined with "equ" or "=".
		if ((op->flags & Op_SizeMask) == 0)
		{
			//TODO: we should remember label and size of the memory location, and get the data from there
			//if ((com_flags & Com_ManyOperands) == 0)
			//    op->flags |= Op_SizeDWord; -- assuming constant size would be very bad.
		}
	}
	else if ((strncasecmp(opg,"offset",6) == 0) && isspace(opg[6]))
	{
		temp = opg+7;
		temp += strspn(temp," \t");
		if ((com_flags & Com_DataDef) != 0) // if we have data definition
		{ }
		else
		{
			temp--;
			*temp = '$';
		}
		memmove(opg,temp,strlen(temp)+1);
	}
	else if ((len = cpuRegisterSize(opg)) > 0)
	{
		if (len == 1)
		{
			op->flags |= Op_SizeByte;
		}
		else if (len == 2)
		{
			op->flags |= Op_SizeWord;
		}
		else if (len == 4)
		{
			op->flags |= Op_SizeDWord;
		}
		else if (len == 8)
		{
			op->flags |= Op_SizeQWord;
		}
		else if (len == 16)
		{
			op->flags |= Op_SizeOWord;
		}
		memmove(opg+1,opg,strlen(opg)+1);
		*opg = '%';
	}
	else if ((com_flags & Com_JmpInstr) != 0)
	{
		if ((strncasecmp(opg,"short",5) == 0) && isspace(opg[5]))
		{
			temp = opg+6;
			temp += strspn(temp," \t");
			memmove(opg,temp,strlen(temp)+1);
		}
	}
	else if ((com_flags & Com_DataDef) != 0)  // if we have data definition
	{
		// nothing to do
	}
	else if (isdigit(*opg))  // if we have immediate numeric value
	{
		memmove(opg+1,opg,strlen(opg)+1);
		*opg = '$';
	}
	else
	{
		// then it must be some variable
		memmove(opg+1,opg,strlen(opg)+1);
		*opg = '$';
	}
	operandHexBinValues2Atnt(op);
	strTrimRight(op->txt);
	return 1;
}

/** Parses an assembly line in Intel syntax.
 *  Divides it into label, assembler command with operands, and remark.
 */
int chopIntelAssemblyLine(char *iline, AsmLine *ln)
{
	int len,op_idx;
	op_idx = 0;

	// now get the assembly command in this line
	iline += strspn(iline," \t"); // skip spaces and tabs
	len = strcspn(iline," \t;"); // find length until space, tab or ';'
	// if the line only contains a comment, 'len' may be 0
	strncpy(ln->com,iline,len);
	ln->com[len] = '\0';
	iline += len;
	// if remark starts here, we may skip trying the operands
	if (*iline == ';')
		goto remark;
	iline += strspn(iline," \t");
	// Do the operands
	while ((*iline != 0) && (*iline != ';') && (op_idx < LINE_MAX_OPERANDS))
	{
		len = strcspn(iline,",;");
		strncpy(ln->op[op_idx].txt, iline, len);
		ln->op[op_idx++].txt[len] = '\0';
		iline += len;
		iline += strspn(iline," \t,");
	}

	if (*iline == ';')
remark:
	{
		strcpy(ln->rem,iline);
		ln->rem[0] = '#';
	}
	ln->op_len = op_idx;
	return 1;
}

/** Converts chopped assembly line from Intel syntax into AT&T one.
 */
void changeAssemblyLineToAtnt(AsmLine *ln,AsmCodeProps *props)
{
	int waslabel;
	int label_len;
	int idx;
	waslabel = -1;
	{
		waslabel = checkWordsReplace(ln);
	}
	if (waslabel == -1)
	{
		waslabel = checkWordsModify(ln);
	}
	if (waslabel == 0)
	{
		label_len = strlen(ln->label);
		if ((label_len > 0) && (ln->label[label_len-1] != ':'))
		{
			ln->label[label_len++] = ':';
			ln->label[label_len] = '\0';
		}
	}
	// set flags determining what the instruction is
	if (isDataDefinition(ln->com))
		ln->com_flags |= Com_DataDef;
	if (isIOInstruction(ln->com))
		ln->com_flags |= Com_IOInstr;
	if (isJumpInstruction(ln->com))
		ln->com_flags |= Com_JmpInstr;
	if (ln->op_len > 1)
		ln->com_flags |= Com_ManyOperands;
	for(idx=0; idx < ln->op_len; idx++)
	{
		operandChange2Atnt(&ln->op[idx],ln->com_flags);
	}
}

/** Links the assembly line described in AsmLine into a single string.
 */
void linkAtntAssemblyLine(const AsmLine *ln, char *oline)
{
	int idx;
	int sizesuf = 0;
	oline[0] = '\0';
	if ((ln->label[0] != '\0') || (ln->com[0] != '\0'))
	{
		strcat(oline,ln->label);
		//strcat(oline,"\t");
		sizesuf=0;
		for(idx=0; idx < ln->op_len; idx++)
		{
			sizesuf |= ln->op[idx].flags;
		}
		if((ln->com_flags & Com_IOInstr) && (sizesuf != Op_SizeWord))
			sizesuf &= ~Op_SizeWord;
		strcat(oline,ln->com);
		if (sizesuf & Op_SizeByte)  strcat(oline,"b");
		if (sizesuf & Op_SizeWord)  strcat(oline,"w");
		if (sizesuf & Op_SizeDWord) strcat(oline,"l");
		if (sizesuf & Op_SizeQWord) strcat(oline,"q");
		int len = strlen(oline);
		oline[len] = ' ';
		oline[len+1] = '\0';

		// Add operands - order depends on whether it's data definition or not
		if (ln->com_flags & Com_DataDef)
		{
			for(idx=0; idx < ln->op_len; )
			{
				strcat(oline,ln->op[idx++].txt);
				if(idx < ln->op_len) strcat(oline,",");
			}
		}
		else
		{
			for(idx=ln->op_len-1; idx >= 0; )
			{
				strcat(oline,ln->op[idx--].txt);
				if (idx >= 0) strcat(oline,",");
			}
		}
		if (ln->rem[0] != '\0')
			strcat(oline,"\t");
	}
	// If line has a remark, add it to output
	if (ln->rem[0] != '\0')
		strcat(oline,ln->rem);
}


/********************************************************************/
/* GCC inline asm support */

/* assemble the string 'str' in the current C compilation unit without
   C preprocessing. NOTE: str is modified by modifying the '\0' at the
   end */
static void tcc_assemble_inline(TCCState *s1, char *str, int len, int global)
{
	const int *saved_macro_ptr = macro_ptr;
	int dotid = set_idnum('.', IS_ID);

//	printf("%s", str);
	if(s1->intelasm)
	{
		char intelstr[len*2]; //this should be enough, intel syntax is slimmer than at&t
		char tmpline[256];
		int tlen = 0;
		int _len = 0;
		int line_len = 0;
		int tline_len = 0;
		AsmLine ln;
		memset(&ln, 0, sizeof(AsmLine));
		AsmCodeProps props;
		memset(&props, 0, sizeof(AsmCodeProps));

		while(tline_len < len-1)
		{
			line_len = chstrlen(&str[tline_len], '\n');
			memcpy(tmpline, &str[tline_len], line_len);
			tline_len += line_len;
			if (line_len > 0)
				tmpline[line_len-1] = '\0';

			chopIntelAssemblyLine(tmpline, &ln);
			changeAssemblyLineToAtnt(&ln, &props);
			linkAtntAssemblyLine(&ln, tmpline);

			_len = strlen(tmpline);
			tmpline[_len] = '\n';
			_len++;
			memcpy(&intelstr[tlen], tmpline, _len);
			tlen += _len;
		}
		tcc_open_bf(s1, ":asm:", tlen);
		memcpy(file->buffer, intelstr, tlen);
		macro_ptr = NULL;
		tcc_assemble_internal(s1, 0, global);
		tcc_close();

		set_idnum('.', dotid);
		macro_ptr = saved_macro_ptr;
		return;
	}
	tcc_open_bf(s1, ":asm:", len);
	memcpy(file->buffer, str, len);
	macro_ptr = NULL;
	tcc_assemble_internal(s1, 0, global);
	tcc_close();

	set_idnum('.', dotid);
	macro_ptr = saved_macro_ptr;
}

/* find a constraint by its number or id (gcc 3 extended
   syntax). return -1 if not found. Return in *pp in char after the
   constraint */
ST_FUNC int find_constraint(ASMOperand *operands, int nb_operands,
                            const char *name, const char **pp)
{
	int index;
	TokenSym *ts;
	const char *p;

	if (isnum(*name))
	{
		index = 0;
		while (isnum(*name))
		{
			index = (index * 10) + (*name) - '0';
			name++;
		}
		if ((unsigned)index >= nb_operands)
			index = -1;
	}
	else if (*name == '[')
	{
		name++;
		p = strchr(name, ']');
		if (p)
		{
			ts = tok_alloc(name, p - name);
			for(index = 0; index < nb_operands; index++)
			{
				if (operands[index].id == ts->tok)
					goto found;
			}
			index = -1;
found:
			name = p + 1;
		}
		else
		{
			index = -1;
		}
	}
	else
	{
		index = -1;
	}
	if (pp)
		*pp = name;
	return index;
}

static void subst_asm_operands(ASMOperand *operands, int nb_operands,
                               CString *out_str, CString *in_str)
{
	int c, index, modifier;
	const char *str;
	ASMOperand *op;
	SValue sv;

	cstr_new(out_str);
	str = in_str->data;
	for(;;)
	{
		c = *str++;
		if (c == '%')
		{
			if (*str == '%')
			{
				str++;
				goto add_char;
			}
			modifier = 0;
			if (*str == 'c' || *str == 'n' ||
			        *str == 'b' || *str == 'w' || *str == 'h' || *str == 'k' ||
			        *str == 'q' ||
			        /* P in GCC would add "@PLT" to symbol refs in PIC mode,
			           and make literal operands not be decorated with '$'.  */
			        *str == 'P')
				modifier = *str++;
			index = find_constraint(operands, nb_operands, str, &str);
			if (index < 0)
				tcc_error("invalid operand reference after %%");
			op = &operands[index];
			sv = *op->vt;
			if (op->reg >= 0)
			{
				sv.r = op->reg;
				if ((op->vt->r & VT_VALMASK) == VT_LLOCAL && op->is_memory)
					sv.r |= VT_LVAL;
			}
			subst_asm_operand(out_str, &sv, modifier);
		}
		else
		{
add_char:
			cstr_ccat(out_str, c);
			if (c == '\0')
				break;
		}
	}
}


static void parse_asm_operands(ASMOperand *operands, int *nb_operands_ptr,
                               int is_output)
{
	ASMOperand *op;
	int nb_operands;

	if (tok != ':')
	{
		nb_operands = *nb_operands_ptr;
		for(;;)
		{
			CString astr;
			if (nb_operands >= MAX_ASM_OPERANDS)
				tcc_error("too many asm operands");
			op = &operands[nb_operands++];
			op->id = 0;
			if (tok == '[')
			{
				next();
				if (tok < TOK_IDENT)
					expect("identifier");
				op->id = tok;
				next();
				skip(']');
			}
			parse_mult_str(&astr, "string constant");
			op->constraint = tcc_malloc(astr.size);
			strcpy(op->constraint, astr.data);
			cstr_free(&astr);
			skip('(');
			gexpr();
			if (is_output)
			{
				if (!(vtop->type.t & VT_ARRAY))
					test_lvalue();
			}
			else
			{
				/* we want to avoid LLOCAL case, except when the 'm'
				   constraint is used. Note that it may come from
				   register storage, so we need to convert (reg)
				   case */
				if ((vtop->r & VT_LVAL) &&
				        ((vtop->r & VT_VALMASK) == VT_LLOCAL ||
				         (vtop->r & VT_VALMASK) < VT_CONST) &&
				        !strchr(op->constraint, 'm'))
				{
					gv(RC_INT);
				}
			}
			op->vt = vtop;
			skip(')');
			if (tok == ',')
			{
				next();
			}
			else
			{
				break;
			}
		}
		*nb_operands_ptr = nb_operands;
	}
}

/* parse the GCC asm() instruction */
ST_FUNC void asm_instr(void)
{
	CString astr, astr1;
	ASMOperand operands[MAX_ASM_OPERANDS];
	int nb_outputs, nb_operands, i, must_subst, out_reg;
	uint8_t clobber_regs[NB_ASM_REGS];
	Section *sec;

	/* since we always generate the asm() instruction, we can ignore
	   volatile */
	if (tok == TOK_VOLATILE1 || tok == TOK_VOLATILE2 || tok == TOK_VOLATILE3)
	{
		next();
	}
	parse_asm_str(&astr);
	nb_operands = 0;
	nb_outputs = 0;
	must_subst = 0;
	memset(clobber_regs, 0, sizeof(clobber_regs));
	if (tok == ':')
	{
		next();
		must_subst = 1;
		/* output args */
		parse_asm_operands(operands, &nb_operands, 1);
		nb_outputs = nb_operands;
		if (tok == ':')
		{
			next();
			if (tok != ')')
			{
				/* input args */
				parse_asm_operands(operands, &nb_operands, 0);
				if (tok == ':')
				{
					/* clobber list */
					/* XXX: handle registers */
					next();
					for(;;)
					{
						if (tok != TOK_STR)
							expect("string constant");
						asm_clobber(clobber_regs, tokc.str.data);
						next();
						if (tok == ',')
						{
							next();
						}
						else
						{
							break;
						}
					}
				}
			}
		}
	}
	skip(')');
	/* NOTE: we do not eat the ';' so that we can restore the current
	   token after the assembler parsing */
	if (tok != ';')
		expect("';'");

	/* save all values in the memory */
	save_regs(0);

	/* compute constraints */
	asm_compute_constraints(operands, nb_operands, nb_outputs,
	                        clobber_regs, &out_reg);

	/* substitute the operands in the asm string. No substitution is
	   done if no operands (GCC behaviour) */
#ifdef ASM_DEBUG
	printf("asm: \"%s\"\n", (char *)astr.data);
#endif
	if (must_subst)
	{
		subst_asm_operands(operands, nb_operands, &astr1, &astr);
		cstr_free(&astr);
	}
	else
	{
		astr1 = astr;
	}
#ifdef ASM_DEBUG
	printf("subst_asm: \"%s\"\n", (char *)astr1.data);
#endif

	/* generate loads */
	asm_gen_code(operands, nb_operands, nb_outputs, 0,
	             clobber_regs, out_reg);

	/* We don't allow switching section within inline asm to
	   bleed out to surrounding code.  */
	sec = cur_text_section;
	/* assemble the string with tcc internal assembler */
	tcc_assemble_inline(tcc_state, astr1.data, astr1.size - 1, 0);
	if (sec != cur_text_section)
	{
		tcc_warning("inline asm tries to change current section");
		use_section1(tcc_state, sec);
	}

	/* restore the current C token */
	next();

	/* store the output values if needed */
	asm_gen_code(operands, nb_operands, nb_outputs, 1,
	             clobber_regs, out_reg);

	/* free everything */
	for(i=0; i<nb_operands; i++)
	{
		ASMOperand *op;
		op = &operands[i];
		tcc_free(op->constraint);
		vpop();
	}
	cstr_free(&astr1);
}

ST_FUNC void asm_global_instr(void)
{
	CString astr;
	int saved_nocode_wanted = nocode_wanted;

	/* Global asm blocks are always emitted.  */
	nocode_wanted = 0;
	next();
	parse_asm_str(&astr);
	skip(')');
	/* NOTE: we do not eat the ';' so that we can restore the current
	   token after the assembler parsing */
	if (tok != ';')
		expect("';'");

#ifdef ASM_DEBUG
	printf("asm_global: \"%s\"\n", (char *)astr.data);
#endif
	cur_text_section = text_section;
	ind = cur_text_section->data_offset;

	/* assemble the string with tcc internal assembler */
	tcc_assemble_inline(tcc_state, astr.data, astr.size - 1, 1);

	cur_text_section->data_offset = ind;

	/* restore the current C token */
	next();

	cstr_free(&astr);
	nocode_wanted = saved_nocode_wanted;
}
#endif /* CONFIG_TCC_ASM */
//END tccasm.c

#endif
#ifdef TCC_TARGET_PE

//START tccpe.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

#define PE_MERGE_DATA
/* #define PE_PRINT_SECTIONS */

#ifndef _WIN32
#define stricmp strcasecmp
#define strnicmp strncasecmp
#include <sys/stat.h> /* chmod() */
#endif

#ifdef TCC_TARGET_X86_64
# define ADDR3264 ULONGLONG
# define PE_IMAGE_REL IMAGE_REL_BASED_DIR64
# define REL_TYPE_DIRECT R_X86_64_64
# define R_XXX_THUNKFIX R_X86_64_PC32
# define R_XXX_RELATIVE R_X86_64_RELATIVE
# define IMAGE_FILE_MACHINE 0x8664
# define RSRC_RELTYPE 3

#elif defined TCC_TARGET_ARM
# define ADDR3264 DWORD
# define PE_IMAGE_REL IMAGE_REL_BASED_HIGHLOW
# define REL_TYPE_DIRECT R_ARM_ABS32
# define R_XXX_THUNKFIX R_ARM_ABS32
# define R_XXX_RELATIVE R_ARM_RELATIVE
# define IMAGE_FILE_MACHINE 0x01C0
# define RSRC_RELTYPE 7 /* ??? (not tested) */

#elif defined TCC_TARGET_I386
# define ADDR3264 DWORD
# define PE_IMAGE_REL IMAGE_REL_BASED_HIGHLOW
# define REL_TYPE_DIRECT R_386_32
# define R_XXX_THUNKFIX R_386_32
# define R_XXX_RELATIVE R_386_RELATIVE
# define IMAGE_FILE_MACHINE 0x014C
# define RSRC_RELTYPE 7 /* DIR32NB */

#endif

#ifndef IMAGE_NT_SIGNATURE
/* ----------------------------------------------------------- */
/* definitions below are from winnt.h */

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int DWORD;
typedef unsigned long long ULONGLONG;
#pragma pack(push, 1)

typedef struct _IMAGE_DOS_HEADER    /* DOS .EXE header */
{
	WORD e_magic;         /* Magic number */
	WORD e_cblp;          /* Bytes on last page of file */
	WORD e_cp;            /* Pages in file */
	WORD e_crlc;          /* Relocations */
	WORD e_cparhdr;       /* Size of header in paragraphs */
	WORD e_minalloc;      /* Minimum extra paragraphs needed */
	WORD e_maxalloc;      /* Maximum extra paragraphs needed */
	WORD e_ss;            /* Initial (relative) SS value */
	WORD e_sp;            /* Initial SP value */
	WORD e_csum;          /* Checksum */
	WORD e_ip;            /* Initial IP value */
	WORD e_cs;            /* Initial (relative) CS value */
	WORD e_lfarlc;        /* File address of relocation table */
	WORD e_ovno;          /* Overlay number */
	WORD e_res[4];        /* Reserved words */
	WORD e_oemid;         /* OEM identifier (for e_oeminfo) */
	WORD e_oeminfo;       /* OEM information; e_oemid specific */
	WORD e_res2[10];      /* Reserved words */
	DWORD e_lfanew;        /* File address of new exe header */
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

#define IMAGE_NT_SIGNATURE  0x00004550  /* PE00 */
#define SIZE_OF_NT_SIGNATURE 4

typedef struct _IMAGE_FILE_HEADER
{
	WORD    Machine;
	WORD    NumberOfSections;
	DWORD   TimeDateStamp;
	DWORD   PointerToSymbolTable;
	DWORD   NumberOfSymbols;
	WORD    SizeOfOptionalHeader;
	WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;


#define IMAGE_SIZEOF_FILE_HEADER 20

typedef struct _IMAGE_DATA_DIRECTORY
{
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;


typedef struct _IMAGE_OPTIONAL_HEADER
{
	/* Standard fields. */
	WORD    Magic;
	BYTE    MajorLinkerVersion;
	BYTE    MinorLinkerVersion;
	DWORD   SizeOfCode;
	DWORD   SizeOfInitializedData;
	DWORD   SizeOfUninitializedData;
	DWORD   AddressOfEntryPoint;
	DWORD   BaseOfCode;
#ifndef TCC_TARGET_X86_64
	DWORD   BaseOfData;
#endif
	/* NT additional fields. */
	ADDR3264 ImageBase;
	DWORD   SectionAlignment;
	DWORD   FileAlignment;
	WORD    MajorOperatingSystemVersion;
	WORD    MinorOperatingSystemVersion;
	WORD    MajorImageVersion;
	WORD    MinorImageVersion;
	WORD    MajorSubsystemVersion;
	WORD    MinorSubsystemVersion;
	DWORD   Win32VersionValue;
	DWORD   SizeOfImage;
	DWORD   SizeOfHeaders;
	DWORD   CheckSum;
	WORD    Subsystem;
	WORD    DllCharacteristics;
	ADDR3264 SizeOfStackReserve;
	ADDR3264 SizeOfStackCommit;
	ADDR3264 SizeOfHeapReserve;
	ADDR3264 SizeOfHeapCommit;
	DWORD   LoaderFlags;
	DWORD   NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, IMAGE_OPTIONAL_HEADER64, IMAGE_OPTIONAL_HEADER;

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   /* Export Directory */
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   /* Import Directory */
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   /* Resource Directory */
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   /* Exception Directory */
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   /* Security Directory */
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   /* Base Relocation Table */
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   /* Debug Directory */
/*      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7      (X86 usage) */
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   /* Architecture Specific Data */
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   /* RVA of GP */
#define IMAGE_DIRECTORY_ENTRY_TLS             9   /* TLS Directory */
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   /* Load Configuration Directory */
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   /* Bound Import Directory in headers */
#define IMAGE_DIRECTORY_ENTRY_IAT            12   /* Import Address Table */
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   /* Delay Load Import Descriptors */
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   /* COM Runtime descriptor */

/* Section header format. */
#define IMAGE_SIZEOF_SHORT_NAME         8

typedef struct _IMAGE_SECTION_HEADER
{
	BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
	union
	{
		DWORD   PhysicalAddress;
		DWORD   VirtualSize;
	} Misc;
	DWORD   VirtualAddress;
	DWORD   SizeOfRawData;
	DWORD   PointerToRawData;
	DWORD   PointerToRelocations;
	DWORD   PointerToLinenumbers;
	WORD    NumberOfRelocations;
	WORD    NumberOfLinenumbers;
	DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER     40

typedef struct _IMAGE_EXPORT_DIRECTORY
{
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions;
	DWORD AddressOfNames;
	DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_IMPORT_DESCRIPTOR
{
	union
	{
		DWORD Characteristics;
		DWORD OriginalFirstThunk;
	};
	DWORD TimeDateStamp;
	DWORD ForwarderChain;
	DWORD Name;
	DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BASE_RELOCATION
{
	DWORD   VirtualAddress;
	DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;

#define IMAGE_SIZEOF_BASE_RELOCATION     8

#define IMAGE_REL_BASED_ABSOLUTE         0
#define IMAGE_REL_BASED_HIGH             1
#define IMAGE_REL_BASED_LOW              2
#define IMAGE_REL_BASED_HIGHLOW          3
#define IMAGE_REL_BASED_HIGHADJ          4
#define IMAGE_REL_BASED_MIPS_JMPADDR     5
#define IMAGE_REL_BASED_SECTION          6
#define IMAGE_REL_BASED_REL32            7
#define IMAGE_REL_BASED_DIR64           10

#define IMAGE_SCN_CNT_CODE                  0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA      0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA    0x00000080
#define IMAGE_SCN_MEM_DISCARDABLE           0x02000000
#define IMAGE_SCN_MEM_SHARED                0x10000000
#define IMAGE_SCN_MEM_EXECUTE               0x20000000
#define IMAGE_SCN_MEM_READ                  0x40000000
#define IMAGE_SCN_MEM_WRITE                 0x80000000

#pragma pack(pop)

/* ----------------------------------------------------------- */
#endif /* ndef IMAGE_NT_SIGNATURE */
/* ----------------------------------------------------------- */

#ifndef IMAGE_REL_BASED_DIR64
# define IMAGE_REL_BASED_DIR64 10
#endif

#pragma pack(push, 1)
struct pe_header
{
	IMAGE_DOS_HEADER doshdr;
	BYTE dosstub[0x40];
	DWORD nt_sig;
	IMAGE_FILE_HEADER filehdr;
#ifdef TCC_TARGET_X86_64
	IMAGE_OPTIONAL_HEADER64 opthdr;
#else
#ifdef _WIN64
	IMAGE_OPTIONAL_HEADER32 opthdr;
#else
	IMAGE_OPTIONAL_HEADER opthdr;
#endif
#endif
};

struct pe_reloc_header
{
	DWORD offset;
	DWORD size;
};

struct pe_rsrc_header
{
	struct _IMAGE_FILE_HEADER filehdr;
	struct _IMAGE_SECTION_HEADER sectionhdr;
};

struct pe_rsrc_reloc
{
	DWORD offset;
	DWORD size;
	WORD type;
};
#pragma pack(pop)

/* ------------------------------------------------------------- */
/* internal temporary structures */

enum
{
	sec_text = 0,
	sec_data,
	sec_bss,
	sec_idata,
	sec_pdata,
	sec_other,
	sec_rsrc,
	sec_stab,
	sec_stabstr,
	sec_reloc,
	sec_last
};

#if 0
static const DWORD pe_sec_flags[] =
{
	0x60000020, /* ".text"     , */
	0xC0000040, /* ".data"     , */
	0xC0000080, /* ".bss"      , */
	0x40000040, /* ".idata"    , */
	0x40000040, /* ".pdata"    , */
	0xE0000060, /* < other >   , */
	0x40000040, /* ".rsrc"     , */
	0x42000802, /* ".stab"     , */
	0x42000040, /* ".reloc"    , */
};
#endif

struct section_info
{
	int cls;
	char name[32];
	DWORD sh_addr;
	DWORD sh_size;
	DWORD pe_flags;
	Section *sec;
	DWORD data_size;
	IMAGE_SECTION_HEADER ish;
};

struct import_symbol
{
	int sym_index;
	int iat_index;
	int thk_offset;
};

struct pe_import_info
{
	int dll_index;
	int sym_count;
	struct import_symbol **symbols;
};

struct pe_info
{
	TCCState *s1;
	Section *reloc;
	Section *thunk;
	const char *filename;
	int type;
	DWORD sizeofheaders;
	ADDR3264 imagebase;
	const char *start_symbol;
	DWORD start_addr;
	DWORD imp_offs;
	DWORD imp_size;
	DWORD iat_offs;
	DWORD iat_size;
	DWORD exp_offs;
	DWORD exp_size;
	int subsystem;
	DWORD section_align;
	DWORD file_align;
	struct section_info **sec_info;
	int sec_count;
	struct pe_import_info **imp_info;
	int imp_count;
};

#define PE_NUL 0
#define PE_DLL 1
#define PE_GUI 2
#define PE_EXE 3
#define PE_RUN 4

/* --------------------------------------------*/

static const char *pe_export_name(TCCState *s1, ElfW(Sym) *sym)
{
	const char *name = (char*)symtab_section->link->data + sym->st_name;
	if (s1->leading_underscore && name[0] == '_' && !(sym->st_other & ST_PE_STDCALL))
		return name + 1;
	return name;
}

static int pe_find_import(TCCState * s1, ElfW(Sym) *sym)
{
	char buffer[200];
	const char *s, *p;
	int sym_index = 0, n = 0;
	int a, err = 0;

	do
	{
		s = pe_export_name(s1, sym);
		a = 0;
		if (n)
		{
			/* second try: */
			if (sym->st_other & ST_PE_STDCALL)
			{
				/* try w/0 stdcall deco (windows API convention) */
				p = strrchr(s, '@');
				if (!p || s[0] != '_')
					break;
				strcpy(buffer, s+1)[p-s-1] = 0;
			}
			else if (s[0] != '_')     /* try non-ansi function */
			{
				buffer[0] = '_', strcpy(buffer + 1, s);
			}
			else if (0 == memcmp(s, "__imp_", 6))     /* mingw 2.0 */
			{
				strcpy(buffer, s + 6), a = 1;
			}
			else if (0 == memcmp(s, "_imp__", 6))     /* mingw 3.7 */
			{
				strcpy(buffer, s + 6), a = 1;
			}
			else
			{
				continue;
			}
			s = buffer;
		}
		sym_index = find_elf_sym(s1->dynsymtab_section, s);
		// printf("find (%d) %d %s\n", n, sym_index, s);
		if (sym_index
		        && ELFW(ST_TYPE)(sym->st_info) == STT_OBJECT
		        && 0 == (sym->st_other & ST_PE_IMPORT)
		        && 0 == a
		   ) err = -1, sym_index = 0;
	}
	while (0 == sym_index && ++n < 2);
	return n == 2 ? err : sym_index;
}

/*----------------------------------------------------------------------------*/

static int dynarray_assoc(void **pp, int n, int key)
{
	int i;
	for (i = 0; i < n; ++i, ++pp)
		if (key == **(int **) pp)
			return i;
	return -1;
}

static DWORD umin(DWORD a, DWORD b)
{
	return a < b ? a : b;
}

static DWORD umax(DWORD a, DWORD b)
{
	return a < b ? b : a;
}

static DWORD pe_file_align(struct pe_info *pe, DWORD n)
{
	return (n + (pe->file_align - 1)) & ~(pe->file_align - 1);
}

static DWORD pe_virtual_align(struct pe_info *pe, DWORD n)
{
	return (n + (pe->section_align - 1)) & ~(pe->section_align - 1);
}

static void pe_align_section(Section *s, int a)
{
	int i = s->data_offset & (a-1);
	if (i)
		section_ptr_add(s, a - i);
}

static void pe_set_datadir(struct pe_header *hdr, int dir, DWORD addr, DWORD size)
{
	hdr->opthdr.DataDirectory[dir].VirtualAddress = addr;
	hdr->opthdr.DataDirectory[dir].Size = size;
}

struct pe_file
{
	FILE *op;
	DWORD sum;
	unsigned pos;
};

static int pe_fwrite(void *data, int len, struct pe_file *pf)
{
	WORD *p = data;
	DWORD sum;
	int ret, i;
	pf->pos += (ret = fwrite(data, 1, len, pf->op));
	sum = pf->sum;
	for (i = len; i > 0; i -= 2)
	{
		sum += (i >= 2) ? *p++ : *(BYTE*)p;
		sum = (sum + (sum >> 16)) & 0xFFFF;
	}
	pf->sum = sum;
	return len == ret ? 0 : -1;
}

static void pe_fpad(struct pe_file *pf, DWORD new_pos)
{
	char buf[256];
	int n, diff = new_pos - pf->pos;
	memset(buf, 0, sizeof buf);
	while (diff > 0)
	{
		diff -= n = umin(diff, sizeof buf);
		fwrite(buf, n, 1, pf->op);
	}
	pf->pos = new_pos;
}

/*----------------------------------------------------------------------------*/
static int pe_write(struct pe_info *pe)
{
	static const struct pe_header pe_template =
	{
		{
			/* IMAGE_DOS_HEADER doshdr */
			0x5A4D, /*WORD e_magic;         Magic number */
			0x0090, /*WORD e_cblp;          Bytes on last page of file */
			0x0003, /*WORD e_cp;            Pages in file */
			0x0000, /*WORD e_crlc;          Relocations */

			0x0004, /*WORD e_cparhdr;       Size of header in paragraphs */
			0x0000, /*WORD e_minalloc;      Minimum extra paragraphs needed */
			0xFFFF, /*WORD e_maxalloc;      Maximum extra paragraphs needed */
			0x0000, /*WORD e_ss;            Initial (relative) SS value */

			0x00B8, /*WORD e_sp;            Initial SP value */
			0x0000, /*WORD e_csum;          Checksum */
			0x0000, /*WORD e_ip;            Initial IP value */
			0x0000, /*WORD e_cs;            Initial (relative) CS value */
			0x0040, /*WORD e_lfarlc;        File address of relocation table */
			0x0000, /*WORD e_ovno;          Overlay number */
			{0,0,0,0}, /*WORD e_res[4];     Reserved words */
			0x0000, /*WORD e_oemid;         OEM identifier (for e_oeminfo) */
			0x0000, /*WORD e_oeminfo;       OEM information; e_oemid specific */
			{0,0,0,0,0,0,0,0,0,0}, /*WORD e_res2[10];      Reserved words */
			0x00000080  /*DWORD   e_lfanew;        File address of new exe header */
		},{
			/* BYTE dosstub[0x40] */
			/* 14 code bytes + "This program cannot be run in DOS mode.\r\r\n$" + 6 * 0x00 */
			0x0e,0x1f,0xba,0x0e,0x00,0xb4,0x09,0xcd,0x21,0xb8,0x01,0x4c,0xcd,0x21,0x54,0x68,
			0x69,0x73,0x20,0x70,0x72,0x6f,0x67,0x72,0x61,0x6d,0x20,0x63,0x61,0x6e,0x6e,0x6f,
			0x74,0x20,0x62,0x65,0x20,0x72,0x75,0x6e,0x20,0x69,0x6e,0x20,0x44,0x4f,0x53,0x20,
			0x6d,0x6f,0x64,0x65,0x2e,0x0d,0x0d,0x0a,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		},
		0x00004550, /* DWORD nt_sig = IMAGE_NT_SIGNATURE */
		{
			/* IMAGE_FILE_HEADER filehdr */
			IMAGE_FILE_MACHINE, /*WORD    Machine; */
			0x0003, /*WORD    NumberOfSections; */
			0x00000000, /*DWORD   TimeDateStamp; */
			0x00000000, /*DWORD   PointerToSymbolTable; */
			0x00000000, /*DWORD   NumberOfSymbols; */
#if defined(TCC_TARGET_X86_64)
			0x00F0, /*WORD    SizeOfOptionalHeader; */
			0x022F  /*WORD    Characteristics; */
#define CHARACTERISTICS_DLL 0x222E
#elif defined(TCC_TARGET_I386)
			0x00E0, /*WORD    SizeOfOptionalHeader; */
			0x030F  /*WORD    Characteristics; */
#define CHARACTERISTICS_DLL 0x230E
#elif defined(TCC_TARGET_ARM)
			0x00E0, /*WORD    SizeOfOptionalHeader; */
			0x010F, /*WORD    Characteristics; */
#define CHARACTERISTICS_DLL 0x230F
#endif
		},{
			/* IMAGE_OPTIONAL_HEADER opthdr */
			/* Standard fields. */
#ifdef TCC_TARGET_X86_64
			0x020B, /*WORD    Magic; */
#else
			0x010B, /*WORD    Magic; */
#endif
			0x06, /*BYTE    MajorLinkerVersion; */
			0x00, /*BYTE    MinorLinkerVersion; */
			0x00000000, /*DWORD   SizeOfCode; */
			0x00000000, /*DWORD   SizeOfInitializedData; */
			0x00000000, /*DWORD   SizeOfUninitializedData; */
			0x00000000, /*DWORD   AddressOfEntryPoint; */
			0x00000000, /*DWORD   BaseOfCode; */
#ifndef TCC_TARGET_X86_64
			0x00000000, /*DWORD   BaseOfData; */
#endif
			/* NT additional fields. */
#if defined(TCC_TARGET_ARM)
			0x00100000,	    /*DWORD   ImageBase; */
#else
			0x00400000,	    /*DWORD   ImageBase; */
#endif
			0x00001000, /*DWORD   SectionAlignment; */
			0x00000200, /*DWORD   FileAlignment; */
			0x0004, /*WORD    MajorOperatingSystemVersion; */
			0x0000, /*WORD    MinorOperatingSystemVersion; */
			0x0000, /*WORD    MajorImageVersion; */
			0x0000, /*WORD    MinorImageVersion; */
			0x0004, /*WORD    MajorSubsystemVersion; */
			0x0000, /*WORD    MinorSubsystemVersion; */
			0x00000000, /*DWORD   Win32VersionValue; */
			0x00000000, /*DWORD   SizeOfImage; */
			0x00000200, /*DWORD   SizeOfHeaders; */
			0x00000000, /*DWORD   CheckSum; */
			0x0002, /*WORD    Subsystem; */
			0x0000, /*WORD    DllCharacteristics; */
			0x00100000, /*DWORD   SizeOfStackReserve; */
			0x00001000, /*DWORD   SizeOfStackCommit; */
			0x00100000, /*DWORD   SizeOfHeapReserve; */
			0x00001000, /*DWORD   SizeOfHeapCommit; */
			0x00000000, /*DWORD   LoaderFlags; */
			0x00000010, /*DWORD   NumberOfRvaAndSizes; */

			/* IMAGE_DATA_DIRECTORY DataDirectory[16]; */
			{	{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
				{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}
			}
		}
	};

	struct pe_header pe_header = pe_template;

	int i;
	struct pe_file pf = {0};
	DWORD file_offset;
	struct section_info *si;
	IMAGE_SECTION_HEADER *psh;
	TCCState *s1 = pe->s1;

	pf.op = fopen(pe->filename, "wb");
	if (NULL == pf.op)
	{
		tcc_error_noabort("could not write '%s': %s", pe->filename, strerror(errno));
		return -1;
	}

	pe->sizeofheaders = pe_file_align(pe,
	                                  sizeof (struct pe_header)
	                                  + pe->sec_count * sizeof (IMAGE_SECTION_HEADER)
	                                 );

	file_offset = pe->sizeofheaders;

	if (2 == pe->s1->verbose)
		printf("-------------------------------"
		       "\n  virt   file   size  section" "\n");
	for (i = 0; i < pe->sec_count; ++i)
	{
		DWORD addr, size;
		const char *sh_name;

		si = pe->sec_info[i];
		sh_name = si->name;
		addr = si->sh_addr - pe->imagebase;
		size = si->sh_size;
		psh = &si->ish;

		if (2 == pe->s1->verbose)
			printf("%6x %6x %6x  %s\n",
			       (unsigned)addr, (unsigned)file_offset, (unsigned)size, sh_name);

		switch (si->cls)
		{
		case sec_text:
			if (!pe_header.opthdr.BaseOfCode)
				pe_header.opthdr.BaseOfCode = addr;
			break;

		case sec_data:
#ifndef TCC_TARGET_X86_64
			if (!pe_header.opthdr.BaseOfData)
				pe_header.opthdr.BaseOfData = addr;
#endif
			break;

		case sec_bss:
			break;

		case sec_reloc:
			pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_BASERELOC, addr, size);
			break;

		case sec_rsrc:
			pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_RESOURCE, addr, size);
			break;

		case sec_pdata:
			pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_EXCEPTION, addr, size);
			break;
		}

		if (pe->imp_size)
		{
			pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_IMPORT,
			               pe->imp_offs, pe->imp_size);
			pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_IAT,
			               pe->iat_offs, pe->iat_size);
		}
		if (pe->exp_size)
		{
			pe_set_datadir(&pe_header, IMAGE_DIRECTORY_ENTRY_EXPORT,
			               pe->exp_offs, pe->exp_size);
		}

		memcpy(psh->Name, sh_name, umin(strlen(sh_name), sizeof psh->Name));

		psh->Characteristics = si->pe_flags;
		psh->VirtualAddress = addr;
		psh->Misc.VirtualSize = size;
		pe_header.opthdr.SizeOfImage =
		    umax(pe_virtual_align(pe, size + addr), pe_header.opthdr.SizeOfImage);

		if (si->data_size)
		{
			psh->PointerToRawData = file_offset;
			file_offset = pe_file_align(pe, file_offset + si->data_size);
			psh->SizeOfRawData = file_offset - psh->PointerToRawData;
			if (si->cls == sec_text)
				pe_header.opthdr.SizeOfCode += psh->SizeOfRawData;
			else
				pe_header.opthdr.SizeOfInitializedData += psh->SizeOfRawData;
		}
	}

	//pe_header.filehdr.TimeDateStamp = time(NULL);
	pe_header.filehdr.NumberOfSections = pe->sec_count;
	pe_header.opthdr.AddressOfEntryPoint = pe->start_addr;
	pe_header.opthdr.SizeOfHeaders = pe->sizeofheaders;
	pe_header.opthdr.ImageBase = pe->imagebase;
	pe_header.opthdr.Subsystem = pe->subsystem;
	if (pe->s1->pe_stack_size)
		pe_header.opthdr.SizeOfStackReserve = pe->s1->pe_stack_size;
	if (PE_DLL == pe->type)
		pe_header.filehdr.Characteristics = CHARACTERISTICS_DLL;
	pe_header.filehdr.Characteristics |= pe->s1->pe_characteristics;

	pe_fwrite(&pe_header, sizeof pe_header, &pf);
	for (i = 0; i < pe->sec_count; ++i)
		pe_fwrite(&pe->sec_info[i]->ish, sizeof(IMAGE_SECTION_HEADER), &pf);

	file_offset = pe->sizeofheaders;
	for (i = 0; i < pe->sec_count; ++i)
	{
		Section *s;
		si = pe->sec_info[i];
		for (s = si->sec; s; s = s->prev)
		{
			pe_fpad(&pf, file_offset);
			pe_fwrite(s->data, s->data_offset, &pf);
			if (s->prev)
				file_offset += s->prev->sh_addr - s->sh_addr;
		}
		file_offset = si->ish.PointerToRawData + si->ish.SizeOfRawData;
		pe_fpad(&pf, file_offset);
	}

	pf.sum += file_offset;
	fseek(pf.op, offsetof(struct pe_header, opthdr.CheckSum), SEEK_SET);
	pe_fwrite(&pf.sum, sizeof (DWORD), &pf);

	fclose (pf.op);
#ifndef _WIN32
	chmod(pe->filename, 0777);
#endif

	if (2 == pe->s1->verbose)
		printf("-------------------------------\n");
	if (pe->s1->verbose)
		printf("<- %s (%u bytes)\n", pe->filename, (unsigned)file_offset);

	return 0;
}

/*----------------------------------------------------------------------------*/

static struct import_symbol *pe_add_import(struct pe_info *pe, int sym_index)
{
	int i;
	int dll_index;
	struct pe_import_info *p;
	struct import_symbol *s;
	ElfW(Sym) *isym;

	isym = (ElfW(Sym) *)pe->s1->dynsymtab_section->data + sym_index;
	dll_index = isym->st_size;

	i = dynarray_assoc ((void**)pe->imp_info, pe->imp_count, dll_index);
	if (-1 != i)
	{
		p = pe->imp_info[i];
		goto found_dll;
	}
	p = tcc_mallocz(sizeof *p);
	p->dll_index = dll_index;
	dynarray_add(&pe->imp_info, &pe->imp_count, p);

found_dll:
	i = dynarray_assoc ((void**)p->symbols, p->sym_count, sym_index);
	if (-1 != i)
		return p->symbols[i];

	s = tcc_mallocz(sizeof *s);
	dynarray_add(&p->symbols, &p->sym_count, s);
	s->sym_index = sym_index;
	return s;
}

void pe_free_imports(struct pe_info *pe)
{
	int i;
	for (i = 0; i < pe->imp_count; ++i)
	{
		struct pe_import_info *p = pe->imp_info[i];
		dynarray_reset(&p->symbols, &p->sym_count);
	}
	dynarray_reset(&pe->imp_info, &pe->imp_count);
}

/*----------------------------------------------------------------------------*/
static void pe_build_imports(struct pe_info *pe)
{
	int thk_ptr, ent_ptr, dll_ptr, sym_cnt, i;
	DWORD rva_base = pe->thunk->sh_addr - pe->imagebase;
	int ndlls = pe->imp_count;
	TCCState *s1 = pe->s1;

	for (sym_cnt = i = 0; i < ndlls; ++i)
		sym_cnt += pe->imp_info[i]->sym_count;

	if (0 == sym_cnt)
		return;

	pe_align_section(pe->thunk, 16);
	pe->imp_size = (ndlls + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR);
	pe->iat_size = (sym_cnt + ndlls) * sizeof(ADDR3264);
	dll_ptr = pe->thunk->data_offset;
	thk_ptr = dll_ptr + pe->imp_size;
	ent_ptr = thk_ptr + pe->iat_size;
	pe->imp_offs = dll_ptr + rva_base;
	pe->iat_offs = thk_ptr + rva_base;
	section_ptr_add(pe->thunk, pe->imp_size + 2*pe->iat_size);

	for (i = 0; i < pe->imp_count; ++i)
	{
		IMAGE_IMPORT_DESCRIPTOR *hdr;
		int k, n, dllindex;
		ADDR3264 v;
		struct pe_import_info *p = pe->imp_info[i];
		const char *name;
		DLLReference *dllref;

		dllindex = p->dll_index;
		if (dllindex)
			name = (dllref = pe->s1->loaded_dlls[dllindex-1])->name;
		else
			name = "", dllref = NULL;

		/* put the dll name into the import header */
		v = put_elf_str(pe->thunk, name);
		hdr = (IMAGE_IMPORT_DESCRIPTOR*)(pe->thunk->data + dll_ptr);
		hdr->FirstThunk = thk_ptr + rva_base;
		hdr->OriginalFirstThunk = ent_ptr + rva_base;
		hdr->Name = v + rva_base;

		for (k = 0, n = p->sym_count; k <= n; ++k)
		{
			if (k < n)
			{
				int iat_index = p->symbols[k]->iat_index;
				int sym_index = p->symbols[k]->sym_index;
				ElfW(Sym) *imp_sym = (ElfW(Sym) *)pe->s1->dynsymtab_section->data + sym_index;
				ElfW(Sym) *org_sym = (ElfW(Sym) *)symtab_section->data + iat_index;
				const char *name = (char*)pe->s1->dynsymtab_section->link->data + imp_sym->st_name;
				int ordinal;

				org_sym->st_value = thk_ptr;
				org_sym->st_shndx = pe->thunk->sh_num;

				if (dllref)
					v = 0, ordinal = imp_sym->st_value; /* ordinal from pe_load_def */
				else
					ordinal = 0, v = imp_sym->st_value; /* address from tcc_add_symbol() */

#ifdef TCC_IS_NATIVE
				if (pe->type == PE_RUN)
				{
					if (dllref)
					{
						if ( !dllref->handle )
							dllref->handle = LoadLibrary(dllref->name);
						v = (ADDR3264)GetProcAddress(dllref->handle, ordinal?(char*)0+ordinal:name);
					}
					if (!v)
						tcc_error_noabort("can't build symbol '%s'", name);
				}
				else
#endif
					if (ordinal)
					{
						v = ordinal | (ADDR3264)1 << (sizeof(ADDR3264)*8 - 1);
					}
					else
					{
						v = pe->thunk->data_offset + rva_base;
						section_ptr_add(pe->thunk, sizeof(WORD)); /* hint, not used */
						put_elf_str(pe->thunk, name);
					}

			}
			else
			{
				v = 0; /* last entry is zero */
			}

			*(ADDR3264*)(pe->thunk->data+thk_ptr) =
			    *(ADDR3264*)(pe->thunk->data+ent_ptr) = v;
			thk_ptr += sizeof (ADDR3264);
			ent_ptr += sizeof (ADDR3264);
		}
		dll_ptr += sizeof(IMAGE_IMPORT_DESCRIPTOR);
	}
}

/* ------------------------------------------------------------- */

struct pe_sort_sym
{
	int index;
	const char *name;
};

static int sym_cmp(const void *va, const void *vb)
{
	const char *ca = (*(struct pe_sort_sym**)va)->name;
	const char *cb = (*(struct pe_sort_sym**)vb)->name;
	return strcmp(ca, cb);
}

static void pe_build_exports(struct pe_info *pe)
{
	ElfW(Sym) *sym;
	int sym_index, sym_end;
	DWORD rva_base, base_o, func_o, name_o, ord_o, str_o;
	IMAGE_EXPORT_DIRECTORY *hdr;
	int sym_count, ord;
	struct pe_sort_sym **sorted, *p;
	TCCState *s1 = pe->s1;

	FILE *op;
	char buf[260];
	const char *dllname;
	const char *name;

	rva_base = pe->thunk->sh_addr - pe->imagebase;
	sym_count = 0, sorted = NULL, op = NULL;

	sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));
	for (sym_index = 1; sym_index < sym_end; ++sym_index)
	{
		sym = (ElfW(Sym)*)symtab_section->data + sym_index;
		name = pe_export_name(pe->s1, sym);
		if ((sym->st_other & ST_PE_EXPORT)
		        /* export only symbols from actually written sections */
		        && pe->s1->sections[sym->st_shndx]->sh_addr)
		{
			p = tcc_malloc(sizeof *p);
			p->index = sym_index;
			p->name = name;
			dynarray_add(&sorted, &sym_count, p);
		}
#if 0
		if (sym->st_other & ST_PE_EXPORT)
			printf("export: %s\n", name);
		if (sym->st_other & ST_PE_STDCALL)
			printf("stdcall: %s\n", name);
#endif
	}

	if (0 == sym_count)
		return;

	qsort (sorted, sym_count, sizeof *sorted, sym_cmp);

	pe_align_section(pe->thunk, 16);
	dllname = tcc_basename(pe->filename);

	base_o = pe->thunk->data_offset;
	func_o = base_o + sizeof(IMAGE_EXPORT_DIRECTORY);
	name_o = func_o + sym_count * sizeof (DWORD);
	ord_o = name_o + sym_count * sizeof (DWORD);
	str_o = ord_o + sym_count * sizeof(WORD);

	hdr = section_ptr_add(pe->thunk, str_o - base_o);
	hdr->Characteristics        = 0;
	hdr->Base                   = 1;
	hdr->NumberOfFunctions      = sym_count;
	hdr->NumberOfNames          = sym_count;
	hdr->AddressOfFunctions     = func_o + rva_base;
	hdr->AddressOfNames         = name_o + rva_base;
	hdr->AddressOfNameOrdinals  = ord_o + rva_base;
	hdr->Name                   = str_o + rva_base;
	put_elf_str(pe->thunk, dllname);

#if 1
	/* automatically write exports to <output-filename>.def */
	pstrcpy(buf, sizeof buf, pe->filename);
	strcpy(tcc_fileextension(buf), ".def");
	op = fopen(buf, "wb");
	if (NULL == op)
	{
		tcc_error_noabort("could not create '%s': %s", buf, strerror(errno));
	}
	else
	{
		fprintf(op, "LIBRARY %s\n\nEXPORTS\n", dllname);
		if (pe->s1->verbose)
			printf("<- %s (%d symbol%s)\n", buf, sym_count, &"s"[sym_count < 2]);
	}
#endif

	for (ord = 0; ord < sym_count; ++ord)
	{
		p = sorted[ord], sym_index = p->index, name = p->name;
		/* insert actual address later in relocate_section() */
		put_elf_reloc(symtab_section, pe->thunk,
		              func_o, R_XXX_RELATIVE, sym_index);
		*(DWORD*)(pe->thunk->data + name_o)
		    = pe->thunk->data_offset + rva_base;
		*(WORD*)(pe->thunk->data + ord_o)
		    = ord;
		put_elf_str(pe->thunk, name);
		func_o += sizeof (DWORD);
		name_o += sizeof (DWORD);
		ord_o += sizeof (WORD);
		if (op)
			fprintf(op, "%s\n", name);
	}

	pe->exp_offs = base_o + rva_base;
	pe->exp_size = pe->thunk->data_offset - base_o;
	dynarray_reset(&sorted, &sym_count);
	if (op)
		fclose(op);
}

/* ------------------------------------------------------------- */
static void pe_build_reloc (struct pe_info *pe)
{
	DWORD offset, block_ptr, sh_addr, addr;
	int count, i;
	ElfW_Rel *rel, *rel_end;
	Section *s = NULL, *sr;
	struct pe_reloc_header *hdr;

	sh_addr = offset = block_ptr = count = i = 0;
	rel = rel_end = NULL;

	for(;;)
	{
		if (rel < rel_end)
		{
			int type = ELFW(R_TYPE)(rel->r_info);
			addr = rel->r_offset + sh_addr;
			++ rel;
			if (type != REL_TYPE_DIRECT)
				continue;
			if (count == 0)   /* new block */
			{
				block_ptr = pe->reloc->data_offset;
				section_ptr_add(pe->reloc, sizeof(struct pe_reloc_header));
				offset = addr & 0xFFFFFFFF<<12;
			}
			if ((addr -= offset)  < (1<<12))   /* one block spans 4k addresses */
			{
				WORD *wp = section_ptr_add(pe->reloc, sizeof (WORD));
				*wp = addr | PE_IMAGE_REL<<12;
				++count;
				continue;
			}
			-- rel;

		}
		else if (s)
		{
			sr = s->reloc;
			if (sr)
			{
				rel = (ElfW_Rel *)sr->data;
				rel_end = (ElfW_Rel *)(sr->data + sr->data_offset);
				sh_addr = s->sh_addr;
			}
			s = s->prev;
			continue;

		}
		else if (i < pe->sec_count)
		{
			s = pe->sec_info[i]->sec, ++i;
			continue;

		}
		else if (!count)
			break;

		/* fill the last block and ready for a new one */
		if (count & 1) /* align for DWORDS */
			section_ptr_add(pe->reloc, sizeof(WORD)), ++count;
		hdr = (struct pe_reloc_header *)(pe->reloc->data + block_ptr);
		hdr -> offset = offset - pe->imagebase;
		hdr -> size = count * sizeof(WORD) + sizeof(struct pe_reloc_header);
		count = 0;
	}
}

/* ------------------------------------------------------------- */
static int pe_section_class(Section *s)
{
	int type, flags;
	const char *name;

	type = s->sh_type;
	flags = s->sh_flags;
	name = s->name;
	if (flags & SHF_ALLOC)
	{
		if (type == SHT_PROGBITS)
		{
			if (flags & SHF_EXECINSTR)
				return sec_text;
			if (flags & SHF_WRITE)
				return sec_data;
			if (0 == strcmp(name, ".rsrc"))
				return sec_rsrc;
			if (0 == strcmp(name, ".iedat"))
				return sec_idata;
			if (0 == strcmp(name, ".pdata"))
				return sec_pdata;
		}
		else if (type == SHT_NOBITS)
		{
			if (flags & SHF_WRITE)
				return sec_bss;
		}
	}
	else
	{
		if (0 == strcmp(name, ".reloc"))
			return sec_reloc;
	}
	if (0 == memcmp(name, ".stab", 5))
		return name[5] ? sec_stabstr : sec_stab;
	if (flags & SHF_ALLOC)
		return sec_other;
	return -1;
}

static int pe_assign_addresses (struct pe_info *pe)
{
	int i, k, o, c;
	DWORD addr;
	int *section_order;
	struct section_info *si;
	Section *s;

	if (PE_DLL == pe->type)
		pe->reloc = new_section(pe->s1, ".reloc", SHT_PROGBITS, 0);
	// pe->thunk = new_section(pe->s1, ".iedat", SHT_PROGBITS, SHF_ALLOC);

	section_order = tcc_malloc(pe->s1->nb_sections * sizeof (int));
	for (o = k = 0 ; k < sec_last; ++k)
	{
		for (i = 1; i < pe->s1->nb_sections; ++i)
		{
			s = pe->s1->sections[i];
			if (k == pe_section_class(s))
				section_order[o++] = i;
		}
	}

	si = NULL;
	addr = pe->imagebase + 1;

	for (i = 0; i < o; ++i)
	{
		k = section_order[i];
		s = pe->s1->sections[k];
		c = pe_section_class(s);

		if ((c == sec_stab || c == sec_stabstr) && 0 == pe->s1->do_debug)
			continue;

#ifdef PE_MERGE_DATA
		if (c == sec_bss)
			c = sec_data;
#endif
		if (si && c == si->cls)
		{
			/* merge with previous section */
			s->sh_addr = addr = ((addr - 1) | (16 - 1)) + 1;
		}
		else
		{
			si = NULL;
			s->sh_addr = addr = pe_virtual_align(pe, addr);
		}

		if (c == sec_data && NULL == pe->thunk)
			pe->thunk = s;

		if (s == pe->thunk)
		{
			pe_build_imports(pe);
			pe_build_exports(pe);
		}
		if (s == pe->reloc)
			pe_build_reloc (pe);

		if (0 == s->data_offset)
			continue;

		if (si)
			goto add_section;

		si = tcc_mallocz(sizeof *si);
		dynarray_add(&pe->sec_info, &pe->sec_count, si);

		strcpy(si->name, s->name);
		si->cls = c;
		si->sh_addr = addr;

		si->pe_flags = IMAGE_SCN_MEM_READ;
		if (s->sh_flags & SHF_EXECINSTR)
			si->pe_flags |= IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE;
		else if (s->sh_type == SHT_NOBITS)
			si->pe_flags |= IMAGE_SCN_CNT_UNINITIALIZED_DATA;
		else
			si->pe_flags |= IMAGE_SCN_CNT_INITIALIZED_DATA;
		if (s->sh_flags & SHF_WRITE)
			si->pe_flags |= IMAGE_SCN_MEM_WRITE;
		if (0 == (s->sh_flags & SHF_ALLOC))
			si->pe_flags |= IMAGE_SCN_MEM_DISCARDABLE;

add_section:
		addr += s->data_offset;
		si->sh_size = addr - si->sh_addr;
		if (s->sh_type != SHT_NOBITS)
		{
			Section **ps = &si->sec;
			while (*ps)
				ps = &(*ps)->prev;
			*ps = s, s->prev = NULL;
			si->data_size = si->sh_size;
		}
		//printf("%08x %05x %08x %s\n", si->sh_addr, si->sh_size, si->pe_flags, s->name);
	}
	tcc_free(section_order);
#if 0
	for (i = 1; i < pe->s1->nb_sections; ++i)
	{
		Section *s = pe->s1->sections[i];
		int type = s->sh_type;
		int flags = s->sh_flags;
		printf("section %-16s %-10s %08x %04x %s,%s,%s\n",
		       s->name,
		       type == SHT_PROGBITS ? "progbits" :
		       type == SHT_NOBITS ? "nobits" :
		       type == SHT_SYMTAB ? "symtab" :
		       type == SHT_STRTAB ? "strtab" :
		       type == SHT_RELX ? "rel" : "???",
		       s->sh_addr,
		       s->data_offset,
		       flags & SHF_ALLOC ? "alloc" : "",
		       flags & SHF_WRITE ? "write" : "",
		       flags & SHF_EXECINSTR ? "exec" : ""
		      );
	}
	pe->s1->verbose = 2;
#endif
	return 0;
}

/*----------------------------------------------------------------------------*/

static int pe_isafunc(TCCState *s1, int sym_index)
{
	Section *sr = text_section->reloc;
	ElfW_Rel *rel, *rel_end;
	Elf32_Word info = ELF32_R_INFO(sym_index, R_386_PC32);
	if (!sr)
		return 0;
	rel_end = (ElfW_Rel *)(sr->data + sr->data_offset);
	for (rel = (ElfW_Rel *)sr->data; rel < rel_end; rel++)
		if (rel->r_info == info)
			return 1;
	return 0;
}

/*----------------------------------------------------------------------------*/
static int pe_check_symbols(struct pe_info *pe)
{
	ElfW(Sym) *sym;
	int sym_index, sym_end;
	int ret = 0;
	TCCState *s1 = pe->s1;

	pe_align_section(text_section, 8);

	sym_end = symtab_section->data_offset / sizeof(ElfW(Sym));
	for (sym_index = 1; sym_index < sym_end; ++sym_index)
	{

		sym = (ElfW(Sym) *)symtab_section->data + sym_index;
		if (sym->st_shndx == SHN_UNDEF)
		{

			const char *name = (char*)symtab_section->link->data + sym->st_name;
			unsigned type = ELFW(ST_TYPE)(sym->st_info);
			int imp_sym = pe_find_import(pe->s1, sym);
			struct import_symbol *is;

			if (imp_sym <= 0)
				goto not_found;

			if (type == STT_NOTYPE)
			{
				/* symbols from assembler have no type, find out which */
				if (pe_isafunc(s1, sym_index))
					type = STT_FUNC;
				else
					type = STT_OBJECT;
			}

			is = pe_add_import(pe, imp_sym);

			if (type == STT_FUNC)
			{
				unsigned long offset = is->thk_offset;
				if (offset)
				{
					/* got aliased symbol, like stricmp and _stricmp */

				}
				else
				{
					char buffer[100];
					WORD *p;

					offset = text_section->data_offset;
					/* add the 'jmp IAT[x]' instruction */
#ifdef TCC_TARGET_ARM
					p = section_ptr_add(text_section, 8+4); // room for code and address
					(*(DWORD*)(p)) = 0xE59FC000; // arm code ldr ip, [pc] ; PC+8+0 = 0001xxxx
					(*(DWORD*)(p+2)) = 0xE59CF000; // arm code ldr pc, [ip]
#else
					p = section_ptr_add(text_section, 8);
					*p = 0x25FF;
#ifdef TCC_TARGET_X86_64
					*(DWORD*)(p+1) = (DWORD)-4;
#endif
#endif
					/* add a helper symbol, will be patched later in
					   pe_build_imports */
					sprintf(buffer, "IAT.%s", name);
					is->iat_index = put_elf_sym(
					                    symtab_section, 0, sizeof(DWORD),
					                    ELFW(ST_INFO)(STB_GLOBAL, STT_OBJECT),
					                    0, SHN_UNDEF, buffer);
#ifdef TCC_TARGET_ARM
					put_elf_reloc(symtab_section, text_section,
					              offset + 8, R_XXX_THUNKFIX, is->iat_index); // offset to IAT position
#else
					put_elf_reloc(symtab_section, text_section,
					              offset + 2, R_XXX_THUNKFIX, is->iat_index);
#endif
					is->thk_offset = offset;
				}

				/* tcc_realloc might have altered sym's address */
				sym = (ElfW(Sym) *)symtab_section->data + sym_index;

				/* patch the original symbol */
				sym->st_value = offset;
				sym->st_shndx = text_section->sh_num;
				sym->st_other &= ~ST_PE_EXPORT; /* do not export */
				continue;
			}

			if (type == STT_OBJECT)   /* data, ptr to that should be */
			{
				if (0 == is->iat_index)
				{
					/* original symbol will be patched later in pe_build_imports */
					is->iat_index = sym_index;
					continue;
				}
			}

not_found:
			if (ELFW(ST_BIND)(sym->st_info) == STB_WEAK)
				/* STB_WEAK undefined symbols are accepted */
				continue;
			tcc_error_noabort("undefined symbol '%s'%s", name,
			                  imp_sym < 0 ? ", missing __declspec(dllimport)?":"");
			ret = -1;

		}
		else if (pe->s1->rdynamic
		         && ELFW(ST_BIND)(sym->st_info) != STB_LOCAL)
		{
			/* if -rdynamic option, then export all non local symbols */
			sym->st_other |= ST_PE_EXPORT;
		}
	}
	return ret;
}

/*----------------------------------------------------------------------------*/
#ifdef PE_PRINT_SECTIONS
static void pe_print_section(FILE * f, Section * s)
{
	/* just if you're curious */
	BYTE *p, *e, b;
	int i, n, l, m;
	p = s->data;
	e = s->data + s->data_offset;
	l = e - p;

	fprintf(f, "section  \"%s\"", s->name);
	if (s->link)
		fprintf(f, "\nlink     \"%s\"", s->link->name);
	if (s->reloc)
		fprintf(f, "\nreloc    \"%s\"", s->reloc->name);
	fprintf(f, "\nv_addr   %08X", (unsigned)s->sh_addr);
	fprintf(f, "\ncontents %08X", (unsigned)l);
	fprintf(f, "\n\n");

	if (s->sh_type == SHT_NOBITS)
		return;

	if (0 == l)
		return;

	if (s->sh_type == SHT_SYMTAB)
		m = sizeof(ElfW(Sym));
	else if (s->sh_type == SHT_RELX)
		m = sizeof(ElfW_Rel);
	else
		m = 16;

	fprintf(f, "%-8s", "offset");
	for (i = 0; i < m; ++i)
		fprintf(f, " %02x", i);
	n = 56;

	if (s->sh_type == SHT_SYMTAB || s->sh_type == SHT_RELX)
	{
		const char *fields1[] =
		{
			"name",
			"value",
			"size",
			"bind",
			"type",
			"other",
			"shndx",
			NULL
		};

		const char *fields2[] =
		{
			"offs",
			"type",
			"symb",
			NULL
		};

		const char **p;

		if (s->sh_type == SHT_SYMTAB)
			p = fields1, n = 106;
		else
			p = fields2, n = 58;

		for (i = 0; p[i]; ++i)
			fprintf(f, "%6s", p[i]);
		fprintf(f, "  symbol");
	}

	fprintf(f, "\n");
	for (i = 0; i < n; ++i)
		fprintf(f, "-");
	fprintf(f, "\n");

	for (i = 0; i < l;)
	{
		fprintf(f, "%08X", i);
		for (n = 0; n < m; ++n)
		{
			if (n + i < l)
				fprintf(f, " %02X", p[i + n]);
			else
				fprintf(f, "   ");
		}

		if (s->sh_type == SHT_SYMTAB)
		{
			ElfW(Sym) *sym = (ElfW(Sym) *) (p + i);
			const char *name = s->link->data + sym->st_name;
			fprintf(f, "  %04X  %04X  %04X   %02X    %02X    %02X   %04X  \"%s\"",
			        (unsigned)sym->st_name,
			        (unsigned)sym->st_value,
			        (unsigned)sym->st_size,
			        (unsigned)ELFW(ST_BIND)(sym->st_info),
			        (unsigned)ELFW(ST_TYPE)(sym->st_info),
			        (unsigned)sym->st_other,
			        (unsigned)sym->st_shndx,
			        name);

		}
		else if (s->sh_type == SHT_RELX)
		{
			ElfW_Rel *rel = (ElfW_Rel *) (p + i);
			ElfW(Sym) *sym =
			    (ElfW(Sym) *) s->link->data + ELFW(R_SYM)(rel->r_info);
			const char *name = s->link->link->data + sym->st_name;
			fprintf(f, "  %04X   %02X   %04X  \"%s\"",
			        (unsigned)rel->r_offset,
			        (unsigned)ELFW(R_TYPE)(rel->r_info),
			        (unsigned)ELFW(R_SYM)(rel->r_info),
			        name);
		}
		else
		{
			fprintf(f, "   ");
			for (n = 0; n < m; ++n)
			{
				if (n + i < l)
				{
					b = p[i + n];
					if (b < 32 || b >= 127)
						b = '.';
					fprintf(f, "%c", b);
				}
			}
		}
		i += m;
		fprintf(f, "\n");
	}
	fprintf(f, "\n\n");
}

static void pe_print_sections(TCCState *s1, const char *fname)
{
	Section *s;
	FILE *f;
	int i;
	f = fopen(fname, "w");
	for (i = 1; i < s1->nb_sections; ++i)
	{
		s = s1->sections[i];
		pe_print_section(f, s);
	}
	pe_print_section(f, s1->dynsymtab_section);
	fclose(f);
}
#endif

/* ------------------------------------------------------------- */
/* helper function for load/store to insert one more indirection */

#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
ST_FUNC SValue *pe_getimport(SValue *sv, SValue *v2)
{
	int r2;
	if ((sv->r & (VT_VALMASK|VT_SYM)) != (VT_CONST|VT_SYM) || (sv->r2 != VT_CONST))
		return sv;
	if (!sv->sym->a.dllimport)
		return sv;
	// printf("import %04x %04x %04x %s\n", sv->type.t, sv->sym->type.t, sv->r, get_tok_str(sv->sym->v, NULL));
	memset(v2, 0, sizeof *v2);
	v2->type.t = VT_PTR;
	v2->r = VT_CONST | VT_SYM | VT_LVAL;
	v2->sym = sv->sym;

	r2 = get_reg(RC_INT);
	load(r2, v2);
	v2->r = r2;
	if ((uint32_t)sv->c.i)
	{
		vpushv(v2);
		vpushi(sv->c.i);
		gen_opi('+');
		*v2 = *vtop--;
	}
	v2->type.t = sv->type.t;
	v2->r |= sv->r & VT_LVAL;
	return v2;
}
#endif

ST_FUNC int pe_putimport(TCCState *s1, int dllindex, const char *name, addr_t value)
{
	return set_elf_sym(
	           s1->dynsymtab_section,
	           value,
	           dllindex, /* st_size */
	           ELFW(ST_INFO)(STB_GLOBAL, STT_NOTYPE),
	           0,
	           value ? SHN_ABS : SHN_UNDEF,
	           name
	       );
}

static int add_dllref(TCCState *s1, const char *dllname)
{
	DLLReference *dllref;
	int i;
	for (i = 0; i < s1->nb_loaded_dlls; ++i)
		if (0 == strcmp(s1->loaded_dlls[i]->name, dllname))
			return i + 1;
	dllref = tcc_mallocz(sizeof(DLLReference) + strlen(dllname));
	strcpy(dllref->name, dllname);
	dynarray_add(&s1->loaded_dlls, &s1->nb_loaded_dlls, dllref);
	return s1->nb_loaded_dlls;
}

/* ------------------------------------------------------------- */

static int read_mem(int fd, unsigned offset, void *buffer, unsigned len)
{
	lseek(fd, offset, SEEK_SET);
	return len == read(fd, buffer, len);
}

/* ------------------------------------------------------------- */

PUB_FUNC int tcc_get_dllexports(const char *filename, char **pp)
{
	int l, i, n, n0, ret;
	char *p;
	int fd;

	IMAGE_SECTION_HEADER ish;
	IMAGE_EXPORT_DIRECTORY ied;
	IMAGE_DOS_HEADER dh;
	IMAGE_FILE_HEADER ih;
	DWORD sig, ref, addr, ptr, namep;

	int pef_hdroffset, opt_hdroffset, sec_hdroffset;

	n = n0 = 0;
	p = NULL;
	ret = -1;

	fd = open(filename, O_RDONLY | O_BINARY);
	if (fd < 0)
		goto the_end_1;
	ret = 1;
	if (!read_mem(fd, 0, &dh, sizeof dh))
		goto the_end;
	if (!read_mem(fd, dh.e_lfanew, &sig, sizeof sig))
		goto the_end;
	if (sig != 0x00004550)
		goto the_end;
	pef_hdroffset = dh.e_lfanew + sizeof sig;
	if (!read_mem(fd, pef_hdroffset, &ih, sizeof ih))
		goto the_end;
	opt_hdroffset = pef_hdroffset + sizeof ih;
	if (ih.Machine == 0x014C)
	{
		IMAGE_OPTIONAL_HEADER32 oh;
		sec_hdroffset = opt_hdroffset + sizeof oh;
		if (!read_mem(fd, opt_hdroffset, &oh, sizeof oh))
			goto the_end;
		if (IMAGE_DIRECTORY_ENTRY_EXPORT >= oh.NumberOfRvaAndSizes)
			goto the_end_0;
		addr = oh.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	}
	else if (ih.Machine == 0x8664)
	{
		IMAGE_OPTIONAL_HEADER64 oh;
		sec_hdroffset = opt_hdroffset + sizeof oh;
		if (!read_mem(fd, opt_hdroffset, &oh, sizeof oh))
			goto the_end;
		if (IMAGE_DIRECTORY_ENTRY_EXPORT >= oh.NumberOfRvaAndSizes)
			goto the_end_0;
		addr = oh.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	}
	else
		goto the_end;

	//printf("addr: %08x\n", addr);
	for (i = 0; i < ih.NumberOfSections; ++i)
	{
		if (!read_mem(fd, sec_hdroffset + i * sizeof ish, &ish, sizeof ish))
			goto the_end;
		//printf("vaddr: %08x\n", ish.VirtualAddress);
		if (addr >= ish.VirtualAddress && addr < ish.VirtualAddress + ish.SizeOfRawData)
			goto found;
	}
	goto the_end_0;

found:
	ref = ish.VirtualAddress - ish.PointerToRawData;
	if (!read_mem(fd, addr - ref, &ied, sizeof ied))
		goto the_end;

	namep = ied.AddressOfNames - ref;
	for (i = 0; i < ied.NumberOfNames; ++i)
	{
		if (!read_mem(fd, namep, &ptr, sizeof ptr))
			goto the_end;
		namep += sizeof ptr;
		for (l = 0;;)
		{
			if (n+1 >= n0)
				p = tcc_realloc(p, n0 = n0 ? n0 * 2 : 256);
			if (!read_mem(fd, ptr - ref + l++, p + n, 1))
			{
				tcc_free(p), p = NULL;
				goto the_end;
			}
			if (p[n++] == 0)
				break;
		}
	}
	if (p)
		p[n] = 0;
the_end_0:
	ret = 0;
the_end:
	close(fd);
the_end_1:
	*pp = p;
	return ret;
}

/* -------------------------------------------------------------
 *  This is for compiled windows resources in 'coff' format
 *  as generated by 'windres.exe -O coff ...'.
 */

static int pe_load_res(TCCState *s1, int fd)
{
	struct pe_rsrc_header hdr;
	Section *rsrc_section;
	int i, ret = -1, sym_index;
	BYTE *ptr;
	unsigned offs;

	if (!read_mem(fd, 0, &hdr, sizeof hdr))
		goto quit;

	if (hdr.filehdr.Machine != IMAGE_FILE_MACHINE
	        || hdr.filehdr.NumberOfSections != 1
	        || strcmp((char*)hdr.sectionhdr.Name, ".rsrc") != 0)
		goto quit;

	rsrc_section = new_section(s1, ".rsrc", SHT_PROGBITS, SHF_ALLOC);
	ptr = section_ptr_add(rsrc_section, hdr.sectionhdr.SizeOfRawData);
	offs = hdr.sectionhdr.PointerToRawData;
	if (!read_mem(fd, offs, ptr, hdr.sectionhdr.SizeOfRawData))
		goto quit;
	offs = hdr.sectionhdr.PointerToRelocations;
	sym_index = put_elf_sym(symtab_section, 0, 0, 0, 0, rsrc_section->sh_num, ".rsrc");
	for (i = 0; i < hdr.sectionhdr.NumberOfRelocations; ++i)
	{
		struct pe_rsrc_reloc rel;
		if (!read_mem(fd, offs, &rel, sizeof rel))
			goto quit;
		// printf("rsrc_reloc: %x %x %x\n", rel.offset, rel.size, rel.type);
		if (rel.type != RSRC_RELTYPE)
			goto quit;
		put_elf_reloc(symtab_section, rsrc_section,
		              rel.offset, R_XXX_RELATIVE, sym_index);
		offs += sizeof rel;
	}
	ret = 0;
quit:
	return ret;
}

/* ------------------------------------------------------------- */

static char *trimfront(char *p)
{
	while (*p && (unsigned char)*p <= ' ')
		++p;
	return p;
}

static char *trimback(char *a, char *e)
{
	while (e > a && (unsigned char)e[-1] <= ' ')
		--e;
	*e = 0;;
	return a;
}

/* ------------------------------------------------------------- */
static int pe_load_def(TCCState *s1, int fd)
{
	int state = 0, ret = -1, dllindex = 0, ord;
	char line[400], dllname[80], *p, *x;
	FILE *fp;

	fp = fdopen(dup(fd), "rb");
	while (fgets(line, sizeof line, fp))
	{
		p = trimfront(trimback(line, strchr(line, 0)));
		if (0 == *p || ';' == *p)
			continue;

		switch (state)
		{
		case 0:
			if (0 != strnicmp(p, "LIBRARY", 7))
				goto quit;
			pstrcpy(dllname, sizeof dllname, trimfront(p+7));
			++state;
			continue;

		case 1:
			if (0 != stricmp(p, "EXPORTS"))
				goto quit;
			++state;
			continue;

		case 2:
			dllindex = add_dllref(s1, dllname);
			++state;
		/* fall through */
		default:
			/* get ordinal and will store in sym->st_value */
			ord = 0;
			x = strchr(p, ' ');
			if (x)
			{
				*x = 0, x = strrchr(x + 1, '@');
				if (x)
				{
					char *d;
					ord = (int)strtol(x + 1, &d, 10);
					if (*d)
						ord = 0;
				}
			}
			pe_putimport(s1, dllindex, p, ord);
			continue;
		}
	}
	ret = 0;
quit:
	fclose(fp);
	return ret;
}

/* ------------------------------------------------------------- */
static int pe_load_dll(TCCState *s1, const char *filename)
{
	char *p, *q;
	int index, ret;

	ret = tcc_get_dllexports(filename, &p);
	if (ret)
	{
		return -1;
	}
	else if (p)
	{
		index = add_dllref(s1, tcc_basename(filename));
		for (q = p; *q; q += 1 + strlen(q))
			pe_putimport(s1, index, q, 0);
		tcc_free(p);
	}
	return 0;
}

/* ------------------------------------------------------------- */
ST_FUNC int pe_load_file(struct TCCState *s1, const char *filename, int fd)
{
	int ret = -1;
	char buf[10];
	if (0 == strcmp(tcc_fileextension(filename), ".def"))
		ret = pe_load_def(s1, fd);
	else if (pe_load_res(s1, fd) == 0)
		ret = 0;
	else if (read_mem(fd, 0, buf, 4) && 0 == memcmp(buf, "MZ", 2))
		ret = pe_load_dll(s1, filename);
	return ret;
}

/* ------------------------------------------------------------- */
#ifdef TCC_TARGET_X86_64
static unsigned pe_add_uwwind_info(TCCState *s1)
{
	if (NULL == s1->uw_pdata)
	{
		s1->uw_pdata = find_section(s1, ".pdata");
		s1->uw_pdata->sh_addralign = 4;
	}
	if (0 == s1->uw_sym)
		s1->uw_sym = put_elf_sym(symtab_section, 0, 0, 0, 0, text_section->sh_num, ".uw_base");
	if (0 == s1->uw_offs)
	{
		/* As our functions all have the same stackframe, we use one entry for all */
		static const unsigned char uw_info[] =
		{
			0x01, // UBYTE: 3 Version , UBYTE: 5 Flags
			0x04, // UBYTE Size of prolog
			0x02, // UBYTE Count of unwind codes
			0x05, // UBYTE: 4 Frame Register (rbp), UBYTE: 4 Frame Register offset (scaled)
			// USHORT * n Unwind codes array
			// 0x0b, 0x01, 0xff, 0xff, // stack size
			0x04, 0x03, // set frame ptr (mov rsp -> rbp)
			0x01, 0x50  // push reg (rbp)
		};

		Section *s = text_section;
		unsigned char *p;

		section_ptr_add(s, -s->data_offset & 3); /* align */
		s1->uw_offs = s->data_offset;
		p = section_ptr_add(s, sizeof uw_info);
		memcpy(p, uw_info, sizeof uw_info);
	}

	return s1->uw_offs;
}

ST_FUNC void pe_add_unwind_data(unsigned start, unsigned end, unsigned stack)
{
	TCCState *s1 = tcc_state;
	Section *pd;
	unsigned o, n, d;
	struct /* _RUNTIME_FUNCTION */
	{
		DWORD BeginAddress;
		DWORD EndAddress;
		DWORD UnwindData;
	} *p;

	d = pe_add_uwwind_info(s1);
	pd = s1->uw_pdata;
	o = pd->data_offset;
	p = section_ptr_add(pd, sizeof *p);

	/* record this function */
	p->BeginAddress = start;
	p->EndAddress = end;
	p->UnwindData = d;

	/* put relocations on it */
	for (n = o + sizeof *p; o < n; o += sizeof p->BeginAddress)
		put_elf_reloc(symtab_section, pd, o, R_XXX_RELATIVE, s1->uw_sym);
}
#endif
/* ------------------------------------------------------------- */
#ifdef TCC_TARGET_X86_64
#define PE_STDSYM(n,s) n
#else
#define PE_STDSYM(n,s) "_" n s
#endif

static void tcc_add_support(TCCState *s1, const char *filename)
{
	if (tcc_add_dll(s1, filename, 0) < 0)
		tcc_error_noabort("%s not found", filename);
}

static void pe_add_runtime(TCCState *s1, struct pe_info *pe)
{
	const char *start_symbol;
	int pe_type = 0;
	int unicode_entry = 0;

	if (find_elf_sym(symtab_section, PE_STDSYM("WinMain","@16")))
		pe_type = PE_GUI;
	else if (find_elf_sym(symtab_section, PE_STDSYM("wWinMain","@16")))
	{
		pe_type = PE_GUI;
		unicode_entry = PE_GUI;
	}
	else if (TCC_OUTPUT_DLL == s1->output_type)
	{
		pe_type = PE_DLL;
	}
	else
	{
		pe_type = PE_EXE;
		if (find_elf_sym(symtab_section, "wmain"))
			unicode_entry = PE_EXE;
	}

	start_symbol =
	    TCC_OUTPUT_MEMORY == s1->output_type
	    ? PE_GUI == pe_type ? (unicode_entry ? "__runwwinmain" : "__runwinmain")
	    : (unicode_entry ? "__runwmain" : "__runmain")
	    : PE_DLL == pe_type ? PE_STDSYM("__dllstart","@12")
	    : PE_GUI == pe_type ? (unicode_entry ? "__wwinstart": "__winstart")
	    : (unicode_entry ? "__wstart" : "__start")
	    ;

	if (!s1->leading_underscore || strchr(start_symbol, '@'))
		++start_symbol;

#ifdef CONFIG_TCC_BACKTRACE
	if (s1->do_backtrace)
	{
#ifdef CONFIG_TCC_BCHECK
		if (s1->do_bounds_check && s1->output_type != TCC_OUTPUT_DLL)
			tcc_add_support(s1, "bcheck.o");
#endif
		if (s1->output_type == TCC_OUTPUT_EXE)
			tcc_add_support(s1, "bt-exe.o");
		if (s1->output_type == TCC_OUTPUT_DLL)
			tcc_add_support(s1, "bt-dll.o");
		if (s1->output_type != TCC_OUTPUT_DLL)
			tcc_add_support(s1, "bt-log.o");
		if (s1->output_type != TCC_OUTPUT_MEMORY)
			tcc_add_btstub(s1);
	}
#endif

	/* grab the startup code from libtcc1.a */
#ifdef TCC_IS_NATIVE
	if (TCC_OUTPUT_MEMORY != s1->output_type || s1->runtime_main)
#endif
		set_global_sym(s1, start_symbol, NULL, 0);

	if (0 == s1->nostdlib)
	{
		static const char *libs[] =
		{
			"msvcrt", "kernel32", "", "user32", "gdi32", NULL
		};
		const char **pp, *p;
#ifdef TCC_LIBTCC1
		tcc_add_support(s1, TCC_LIBTCC1);
#endif
		for (pp = libs; 0 != (p = *pp); ++pp)
		{
			if (*p)
				tcc_add_library_err(s1, p);
			else if (PE_DLL != pe_type && PE_GUI != pe_type)
				break;
		}
	}

	/* need this for 'tccelf.c:relocate_section()' */
	if (TCC_OUTPUT_DLL == s1->output_type)
		s1->output_type = TCC_OUTPUT_EXE;
	if (TCC_OUTPUT_MEMORY == s1->output_type)
		pe_type = PE_RUN;
	pe->type = pe_type;
	pe->start_symbol = start_symbol;
}

static void pe_set_options(TCCState * s1, struct pe_info *pe)
{
	if (PE_DLL == pe->type)
	{
		/* XXX: check if is correct for arm-pe target */
		pe->imagebase = 0x10000000;
	}
	else
	{
#if defined(TCC_TARGET_ARM)
		pe->imagebase = 0x00010000;
#else
		pe->imagebase = 0x00400000;
#endif
	}

#if defined(TCC_TARGET_ARM)
	/* we use "console" subsystem by default */
	pe->subsystem = 9;
#else
	if (PE_DLL == pe->type || PE_GUI == pe->type)
		pe->subsystem = 2;
	else
		pe->subsystem = 3;
#endif
	/* Allow override via -Wl,-subsystem=... option */
	if (s1->pe_subsystem != 0)
		pe->subsystem = s1->pe_subsystem;

	/* set default file/section alignment */
	if (pe->subsystem == 1)
	{
		pe->section_align = 0x20;
		pe->file_align = 0x20;
	}
	else
	{
		pe->section_align = 0x1000;
		pe->file_align = 0x200;
	}

	if (s1->section_align != 0)
		pe->section_align = s1->section_align;
	if (s1->pe_file_align != 0)
		pe->file_align = s1->pe_file_align;

	if ((pe->subsystem >= 10) && (pe->subsystem <= 12))
		pe->imagebase = 0;

	if (s1->has_text_addr)
		pe->imagebase = s1->text_addr;
}

ST_FUNC int pe_output_file(TCCState *s1, const char *filename)
{
	int ret;
	struct pe_info pe;
	int i;

	memset(&pe, 0, sizeof pe);
	pe.filename = filename;
	pe.s1 = s1;

#ifdef CONFIG_TCC_BCHECK
	tcc_add_bcheck(s1);
#endif
	tcc_add_pragma_libs(s1);
	pe_add_runtime(s1, &pe);
	resolve_common_syms(s1);
	pe_set_options(s1, &pe);

	ret = pe_check_symbols(&pe);
	if (ret)
		;
	else if (filename)
	{
		pe_assign_addresses(&pe);
		relocate_syms(s1, s1->symtab, 0);
		s1->pe_imagebase = pe.imagebase;
		for (i = 1; i < s1->nb_sections; ++i)
		{
			Section *s = s1->sections[i];
			if (s->reloc)
			{
				relocate_section(s1, s);
			}
		}
		pe.start_addr = (DWORD)
		                ((uintptr_t)tcc_get_symbol_err(s1, pe.start_symbol)
		                 - pe.imagebase);
		if (s1->nb_errors)
			ret = -1;
		else
			ret = pe_write(&pe);
		dynarray_reset(&pe.sec_info, &pe.sec_count);
	}
	else
	{
#ifdef TCC_IS_NATIVE
		pe.thunk = data_section;
		pe_build_imports(&pe);
		s1->runtime_main = pe.start_symbol;
#ifdef TCC_TARGET_X86_64
		s1->uw_pdata = find_section(s1, ".pdata");
#endif
#endif
	}

	pe_free_imports(&pe);

#ifdef PE_PRINT_SECTIONS
	pe_print_sections(s1, "tcc.log");
#endif
	return ret;
}


//END tccpe.c

#endif
#endif /* ONE_SOURCE */


#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)

/********************************************************/
/* global variables */

/* XXX: get rid of this ASAP (or maybe not) */
ST_DATA struct TCCState *tcc_state;

#ifdef MEM_DEBUG
static int nb_states;
#endif

/********************************************************/
#ifdef _WIN32
ST_FUNC char *normalize_slashes(char *path)
{
	char *p;
	for (p = path; *p; ++p)
		if (*p == '\\')
			*p = '/';
	return path;
}

static HMODULE tcc_module;

/* on win32, we suppose the lib and includes are at the location of 'tcc.exe' */
static void tcc_set_lib_path_w32(TCCState *s)
{
	char path[1024], *p;
	GetModuleFileNameA(tcc_module, path, sizeof path);
	p = tcc_basename(normalize_slashes(strlwr(path)));
	if (p > path)
		--p;
	*p = 0;
	tcc_set_lib_path(s, path);
}

#ifdef TCC_TARGET_PE
static void tcc_add_systemdir(TCCState *s)
{
	char buf[1000];
	GetSystemDirectory(buf, sizeof buf);
	tcc_add_library_path(s, normalize_slashes(buf));
}
#endif

#ifdef LIBTCC_AS_DLL
BOOL WINAPI DllMain (HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
	if (DLL_PROCESS_ATTACH == dwReason)
		tcc_module = hDll;
	return TRUE;
}
#endif
#endif

/********************************************************/
#ifndef CONFIG_TCC_SEMLOCK
#define WAIT_SEM()
#define POST_SEM()
#elif defined _WIN32
static int tcc_sem_init;
static CRITICAL_SECTION tcc_cr;
static void wait_sem(void)
{
	if (!tcc_sem_init)
		InitializeCriticalSection(&tcc_cr), tcc_sem_init = 1;
	EnterCriticalSection(&tcc_cr);
}
#define WAIT_SEM() wait_sem()
#define POST_SEM() LeaveCriticalSection(&tcc_cr);
#else
#include <semaphore.h>
static int tcc_sem_init;
static sem_t tcc_sem;
static void wait_sem(void)
{
	if (!tcc_sem_init)
		sem_init(&tcc_sem, 0, 1), tcc_sem_init = 1;
	while (sem_wait (&tcc_sem) < 0 && errno == EINTR);
}
#define WAIT_SEM() wait_sem()
#define POST_SEM() sem_post(&tcc_sem)
#endif

/********************************************************/
/* copy a string and truncate it. */
ST_FUNC char *pstrcpy(char *buf, size_t buf_size, const char *s)
{
	char *q, *q_end;
	int c;

	if (buf_size > 0)
	{
		q = buf;
		q_end = buf + buf_size - 1;
		while (q < q_end)
		{
			c = *s++;
			if (c == '\0')
				break;
			*q++ = c;
		}
		*q = '\0';
	}
	return buf;
}

/* strcat and truncate. */
ST_FUNC char *pstrcat(char *buf, size_t buf_size, const char *s)
{
	size_t len;
	len = strlen(buf);
	if (len < buf_size)
		pstrcpy(buf + len, buf_size - len, s);
	return buf;
}

ST_FUNC char *pstrncpy(char *out, const char *in, size_t num)
{
	memcpy(out, in, num);
	out[num] = '\0';
	return out;
}

/* extract the basename of a file */
PUB_FUNC char *tcc_basename(const char *name)
{
	char *p = strchr(name, 0);
	while (p > name && !IS_DIRSEP(p[-1]))
		--p;
	return p;
}

/* extract extension part of a file
 *
 * (if no extension, return pointer to end-of-string)
 */
PUB_FUNC char *tcc_fileextension (const char *name)
{
	char *b = tcc_basename(name);
	char *e = strrchr(b, '.');
	return e ? e : strchr(b, 0);
}

/********************************************************/
/* memory management */

#undef free
#undef malloc
#undef realloc

#ifndef MEM_DEBUG

PUB_FUNC void tcc_free(void *ptr)
{
	free(ptr);
}

PUB_FUNC void *tcc_malloc(unsigned long size)
{
	void *ptr;
	ptr = malloc(size);
	if (!ptr && size)
		_tcc_error("memory full (malloc)");
	return ptr;
}

PUB_FUNC void *tcc_mallocz(unsigned long size)
{
	void *ptr;
	ptr = tcc_malloc(size);
	memset(ptr, 0, size);
	return ptr;
}

PUB_FUNC void *tcc_realloc(void *ptr, unsigned long size)
{
	void *ptr1;
	ptr1 = realloc(ptr, size);
	if (!ptr1 && size)
		_tcc_error("memory full (realloc)");
	return ptr1;
}

PUB_FUNC char *tcc_strdup(const char *str)
{
	char *ptr;
	ptr = tcc_malloc(strlen(str) + 1);
	strcpy(ptr, str);
	return ptr;
}

#else

#define MEM_DEBUG_MAGIC1 0xFEEDDEB1
#define MEM_DEBUG_MAGIC2 0xFEEDDEB2
#define MEM_DEBUG_MAGIC3 0xFEEDDEB3
#define MEM_DEBUG_FILE_LEN 40
#define MEM_DEBUG_CHECK3(header) \
    ((mem_debug_header_t*)((char*)header + header->size))->magic3
#define MEM_USER_PTR(header) \
    ((char *)header + offsetof(mem_debug_header_t, magic3))
#define MEM_HEADER_PTR(ptr) \
    (mem_debug_header_t *)((char*)ptr - offsetof(mem_debug_header_t, magic3))

struct mem_debug_header
{
	unsigned magic1;
	unsigned size;
	struct mem_debug_header *prev;
	struct mem_debug_header *next;
	int line_num;
	char file_name[MEM_DEBUG_FILE_LEN + 1];
	unsigned magic2;
	ALIGNED(16) unsigned magic3;
};

typedef struct mem_debug_header mem_debug_header_t;

static mem_debug_header_t *mem_debug_chain;
static unsigned mem_cur_size;
static unsigned mem_max_size;

static mem_debug_header_t *malloc_check(void *ptr, const char *msg)
{
	mem_debug_header_t * header = MEM_HEADER_PTR(ptr);
	if (header->magic1 != MEM_DEBUG_MAGIC1 ||
	        header->magic2 != MEM_DEBUG_MAGIC2 ||
	        MEM_DEBUG_CHECK3(header) != MEM_DEBUG_MAGIC3 ||
	        header->size == (unsigned)-1)
	{
		fprintf(stderr, "%s check failed\n", msg);
		if (header->magic1 == MEM_DEBUG_MAGIC1)
			fprintf(stderr, "%s:%u: block allocated here.\n",
			        header->file_name, header->line_num);
		exit(1);
	}
	return header;
}

PUB_FUNC void *tcc_malloc_debug(unsigned long size, const char *file, int line)
{
	int ofs;
	mem_debug_header_t *header;

	header = malloc(sizeof(mem_debug_header_t) + size);
	if (!header)
		_tcc_error("memory full (malloc)");

	header->magic1 = MEM_DEBUG_MAGIC1;
	header->magic2 = MEM_DEBUG_MAGIC2;
	header->size = size;
	MEM_DEBUG_CHECK3(header) = MEM_DEBUG_MAGIC3;
	header->line_num = line;
	ofs = strlen(file) - MEM_DEBUG_FILE_LEN;
	strncpy(header->file_name, file + (ofs > 0 ? ofs : 0), MEM_DEBUG_FILE_LEN);
	header->file_name[MEM_DEBUG_FILE_LEN] = 0;

	header->next = mem_debug_chain;
	header->prev = NULL;
	if (header->next)
		header->next->prev = header;
	mem_debug_chain = header;

	mem_cur_size += size;
	if (mem_cur_size > mem_max_size)
		mem_max_size = mem_cur_size;

	return MEM_USER_PTR(header);
}

PUB_FUNC void tcc_free_debug(void *ptr)
{
	mem_debug_header_t *header;
	if (!ptr)
		return;
	header = malloc_check(ptr, "tcc_free");
	mem_cur_size -= header->size;
	header->size = (unsigned)-1;
	if (header->next)
		header->next->prev = header->prev;
	if (header->prev)
		header->prev->next = header->next;
	if (header == mem_debug_chain)
		mem_debug_chain = header->next;
	free(header);
}

PUB_FUNC void *tcc_mallocz_debug(unsigned long size, const char *file, int line)
{
	void *ptr;
	ptr = tcc_malloc_debug(size,file,line);
	memset(ptr, 0, size);
	return ptr;
}

PUB_FUNC void *tcc_realloc_debug(void *ptr, unsigned long size, const char *file, int line)
{
	mem_debug_header_t *header;
	int mem_debug_chain_update = 0;
	if (!ptr)
		return tcc_malloc_debug(size, file, line);
	header = malloc_check(ptr, "tcc_realloc");
	mem_cur_size -= header->size;
	mem_debug_chain_update = (header == mem_debug_chain);
	header = realloc(header, sizeof(mem_debug_header_t) + size);
	if (!header)
		_tcc_error("memory full (realloc)");
	header->size = size;
	MEM_DEBUG_CHECK3(header) = MEM_DEBUG_MAGIC3;
	if (header->next)
		header->next->prev = header;
	if (header->prev)
		header->prev->next = header;
	if (mem_debug_chain_update)
		mem_debug_chain = header;
	mem_cur_size += size;
	if (mem_cur_size > mem_max_size)
		mem_max_size = mem_cur_size;
	return MEM_USER_PTR(header);
}

PUB_FUNC char *tcc_strdup_debug(const char *str, const char *file, int line)
{
	char *ptr;
	ptr = tcc_malloc_debug(strlen(str) + 1, file, line);
	strcpy(ptr, str);
	return ptr;
}

PUB_FUNC void tcc_memcheck(void)
{
	if (mem_cur_size)
	{
		mem_debug_header_t *header = mem_debug_chain;
		fprintf(stderr, "MEM_DEBUG: mem_leak= %d bytes, mem_max_size= %d bytes\n",
		        mem_cur_size, mem_max_size);
		while (header)
		{
			fprintf(stderr, "%s:%u: error: %u bytes leaked\n",
			        header->file_name, header->line_num, header->size);
			header = header->next;
		}
#if MEM_DEBUG-0 == 2
		exit(2);
#endif
	}
}
#endif /* MEM_DEBUG */

#define free(p) use_tcc_free(p)
#define malloc(s) use_tcc_malloc(s)
#define realloc(p, s) use_tcc_realloc(p, s)

/********************************************************/
/* dynarrays */

ST_FUNC void dynarray_add(void *ptab, int *nb_ptr, void *data)
{
	int nb, nb_alloc;
	void **pp;

	nb = *nb_ptr;
	pp = *(void ***)ptab;
	/* every power of two we double array size */
	if ((nb & (nb - 1)) == 0)
	{
		if (!nb)
			nb_alloc = 1;
		else
			nb_alloc = nb * 2;
		pp = tcc_realloc(pp, nb_alloc * sizeof(void *));
		*(void***)ptab = pp;
	}
	pp[nb++] = data;
	*nb_ptr = nb;
}

ST_FUNC void dynarray_reset(void *pp, int *n)
{
	void **p;
	for (p = *(void***)pp; *n; ++p, --*n)
		if (*p)
			tcc_free(*p);
	tcc_free(*(void**)pp);
	*(void**)pp = NULL;
}

static void tcc_split_path(TCCState *s, void *p_ary, int *p_nb_ary, const char *in)
{
	const char *p;
	do
	{
		int c;
		CString str;

		cstr_new(&str);
		for (p = in; c = *p, c != '\0' && c != PATHSEP[0]; ++p)
		{
			if (c == '{' && p[1] && p[2] == '}')
			{
				c = p[1], p += 2;
				if (c == 'B')
					cstr_cat(&str, s->tcc_lib_path, -1);
				if (c == 'f' && file)
				{
					/* substitute current file's dir */
					const char *f = file->true_filename;
					const char *b = tcc_basename(f);
					if (b > f)
						cstr_cat(&str, f, b - f - 1);
					else
						cstr_cat(&str, ".", 1);
				}
			}
			else
			{
				cstr_ccat(&str, c);
			}
		}
		if (str.size)
		{
			cstr_ccat(&str, '\0');
			dynarray_add(p_ary, p_nb_ary, tcc_strdup(str.data));
		}
		cstr_free(&str);
		in = p+1;
	}
	while (*p);
}

/********************************************************/

static void strcat_vprintf(char *buf, int buf_size, const char *fmt, va_list ap)
{
	int len;
	len = strlen(buf);
	vsnprintf(buf + len, buf_size - len, fmt, ap);
}

static void strcat_printf(char *buf, int buf_size, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	strcat_vprintf(buf, buf_size, fmt, ap);
	va_end(ap);
}

#define ERROR_WARN 0
#define ERROR_NOABORT 1
#define ERROR_ERROR 2

PUB_FUNC void tcc_enter_state(TCCState *s1)
{
	WAIT_SEM();
	tcc_state = s1;
}

static void error1(int mode, const char *fmt, va_list ap)
{
	char buf[2048];
	BufferedFile **pf, *f;
	TCCState *s1 = tcc_state;

	/* 's1->error_set_jmp_enabled' means that we're called from
	    within the parser/generator and 'tcc_state' was already
	    set (i.e. not by the function above).

	    Otherwise, 's1 = NULL' means we're called because of severe
	    problems from tcc_malloc() which under normal conditions
	    should never happen. */

	if (s1 && !s1->error_set_jmp_enabled)
	{
		tcc_state = NULL;
		POST_SEM();
	}

	if (mode == ERROR_WARN)
	{
		if (s1->warn_none)
			return;
		if (s1->warn_error)
			mode = ERROR_ERROR;
	}

	buf[0] = '\0';
	/* use upper file if inline ":asm:" or token ":paste:" */
	for (f = file; f && f->filename[0] == ':'; f = f->prev)
		;
	if (f)
	{
		for(pf = s1->include_stack; pf < s1->include_stack_ptr; pf++)
			strcat_printf(buf, sizeof(buf), "In file included from %s:%d:\n",
			              (*pf)->filename, (*pf)->line_num);
		if (s1->error_set_jmp_enabled)
		{
			strcat_printf(buf, sizeof(buf), "%s:%d: ",
			              f->filename, f->line_num - !!(tok_flags & TOK_FLAG_BOL));
		}
		else
		{
			strcat_printf(buf, sizeof(buf), "%s: ",
			              f->filename);
		}
	}
	else
	{
		strcat_printf(buf, sizeof(buf), "tcc: ");
	}
	if (mode == ERROR_WARN)
		strcat_printf(buf, sizeof(buf), "warning: ");
	else
		strcat_printf(buf, sizeof(buf), "error: ");
	strcat_vprintf(buf, sizeof(buf), fmt, ap);
	if (!s1 || !s1->error_func)
	{
		/* default case: stderr */
		if (s1 && s1->output_type == TCC_OUTPUT_PREPROCESS && s1->ppfp == stdout)
			/* print a newline during tcc -E */
			printf("\n"), fflush(stdout);
		fflush(stdout); /* flush -v output */
		fprintf(stderr, "%s\n", buf);
		fflush(stderr); /* print error/warning now (win32) */
	}
	else
	{
		s1->error_func(s1->error_opaque, buf);
	}
	if (s1)
	{
		if (mode != ERROR_WARN)
			s1->nb_errors++;
		if (mode != ERROR_ERROR)
			return;
		if (s1->error_set_jmp_enabled)
			longjmp(s1->error_jmp_buf, 1);
	}
	exit(1);
}

LIBTCCAPI void tcc_set_error_func(TCCState *s, void *error_opaque, TCCErrorFunc error_func)
{
	s->error_opaque = error_opaque;
	s->error_func = error_func;
}

LIBTCCAPI TCCErrorFunc tcc_get_error_func(TCCState *s)
{
	return s->error_func;
}

LIBTCCAPI void *tcc_get_error_opaque(TCCState *s)
{
	return s->error_opaque;
}

/* error without aborting current compilation */
PUB_FUNC void _tcc_error_noabort(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	error1(ERROR_NOABORT, fmt, ap);
	va_end(ap);
}

PUB_FUNC void _tcc_error(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	for (;;) error1(ERROR_ERROR, fmt, ap);
}

PUB_FUNC void _tcc_warning(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	error1(ERROR_WARN, fmt, ap);
	va_end(ap);
}

/********************************************************/
/* I/O layer */

ST_FUNC void tcc_open_bf(TCCState *s1, const char *filename, int initlen)
{
	BufferedFile *bf;
	int buflen = initlen ? initlen : IO_BUF_SIZE;

	bf = tcc_mallocz(sizeof(BufferedFile) + buflen);
	bf->buf_ptr = bf->buffer;
	bf->buf_end = bf->buffer + initlen;
	bf->buf_end[0] = CH_EOB; /* put eob symbol */
	pstrcpy(bf->filename, sizeof(bf->filename), filename);
#ifdef _WIN32
	normalize_slashes(bf->filename);
#endif
	bf->true_filename = bf->filename;
	bf->line_num = 1;
	bf->ifdef_stack_ptr = s1->ifdef_stack_ptr;
	bf->fd = -1;
	bf->prev = file;
	file = bf;
	tok_flags = TOK_FLAG_BOL | TOK_FLAG_BOF;
}

ST_FUNC void tcc_close(void)
{
	TCCState *s1 = tcc_state;
	BufferedFile *bf = file;
	if (bf->fd > 0)
	{
		close(bf->fd);
		total_lines += bf->line_num;
	}
	if (bf->true_filename != bf->filename)
		tcc_free(bf->true_filename);
	file = bf->prev;
	tcc_free(bf);
}

static int _tcc_open(TCCState *s1, const char *filename)
{
	int fd;
	if (strcmp(filename, "-") == 0)
		fd = 0, filename = "<stdin>";
	else
		fd = open(filename, O_RDONLY | O_BINARY);
	if ((s1->verbose == 2 && fd >= 0) || s1->verbose == 3)
		printf("%s %*s%s\n", fd < 0 ? "nf":"->",
		       (int)(s1->include_stack_ptr - s1->include_stack), "", filename);
	return fd;
}

ST_FUNC int tcc_open(TCCState *s1, const char *filename)
{
	int fd = _tcc_open(s1, filename);
	if (fd < 0)
		return -1;
	tcc_open_bf(s1, filename, 0);
	file->fd = fd;
	return 0;
}

/* compile the file opened in 'file'. Return non zero if errors. */
static int tcc_compile(TCCState *s1, int filetype, const char *str, int fd)
{
	/* Here we enter the code section where we use the global variables for
	   parsing and code generation (tccpp.c, tccgen.c, <target>-gen.c).
	   Other threads need to wait until we're done.

	   Alternatively we could use thread local storage for those global
	   variables, which may or may not have advantages */

	WAIT_SEM();
	tcc_state = s1;

	if (setjmp(s1->error_jmp_buf) == 0)
	{
		int is_asm;
		s1->error_set_jmp_enabled = 1;
		s1->nb_errors = 0;

		if (fd == -1)
		{
			int len = strlen(str);
			tcc_open_bf(s1, "<string>", len);
			memcpy(file->buffer, str, len);
		}
		else
		{
			tcc_open_bf(s1, str, 0);
			file->fd = fd;
		}

		is_asm = !!(filetype & (AFF_TYPE_ASM|AFF_TYPE_ASMPP));
		tccelf_begin_file(s1);
		preprocess_start(s1, is_asm);
		tccgen_init(s1);
		if (s1->output_type == TCC_OUTPUT_PREPROCESS)
		{
			tcc_preprocess(s1);
		}
		else if (is_asm)
		{
#ifdef CONFIG_TCC_ASM
			tcc_assemble(s1, !!(filetype & AFF_TYPE_ASMPP));
#else
			tcc_error_noabort("asm not supported");
#endif
		}
		else
		{
			tccgen_compile(s1);
		}
	}
	s1->error_set_jmp_enabled = 0;
	tccgen_finish(s1);
	preprocess_end(s1);
	tccelf_end_file(s1);

	tcc_state = NULL;
	POST_SEM();
	return s1->nb_errors != 0 ? -1 : 0;
}

LIBTCCAPI int tcc_compile_string(TCCState *s, const char *str)
{
	return tcc_compile(s, s->filetype, str, -1);
}

/* define a preprocessor symbol. A value can also be provided with the '=' operator */
LIBTCCAPI void tcc_define_symbol(TCCState *s1, const char *sym, const char *value)
{
	if (!value)
		value = "1";
	cstr_printf(&s1->cmdline_defs, "#define %s %s\n", sym, value);
}

/* undefine a preprocessor symbol */
LIBTCCAPI void tcc_undefine_symbol(TCCState *s1, const char *sym)
{
	cstr_printf(&s1->cmdline_defs, "#undef %s\n", sym);
}


LIBTCCAPI TCCState *tcc_new(void)
{
	TCCState *s;

	s = tcc_mallocz(sizeof(TCCState));
	if (!s)
		return NULL;
#ifdef MEM_DEBUG
	++nb_states;
#endif

#undef gnu_ext

	s->gnu_ext = 1;
	s->tcc_ext = 1;
	s->nocommon = 1;
	s->dollars_in_identifiers = 1; /*on by default like in gcc/clang*/
	s->cversion = 199901; /* default unless -std=c11 is supplied */
	s->warn_implicit_function_declaration = 1;
	s->ms_extensions = 1;

#ifdef CHAR_IS_UNSIGNED
	s->char_is_unsigned = 1;
#endif
#ifdef TCC_TARGET_I386
	s->seg_size = 32;
#endif
	/* enable this if you want symbols with leading underscore on windows: */
#if 0 /* def TCC_TARGET_PE */
	s->leading_underscore = 1;
#endif
	s->ppfp = stdout;
	/* might be used in error() before preprocess_start() */
	s->include_stack_ptr = s->include_stack;

	tccelf_new(s);

#ifdef _WIN32
	tcc_set_lib_path_w32(s);
#else
	tcc_set_lib_path(s, CONFIG_TCCDIR);
#endif

	{
		/* define __TINYC__ 92X  */
		char buffer[32];
		int a,b,c;
		sscanf(TCC_VERSION, "%d.%d.%d", &a, &b, &c);
		sprintf(buffer, "%d", a*10000 + b*100 + c);
		tcc_define_symbol(s, "__TINYC__", buffer);
	}

	/* standard defines */
	tcc_define_symbol(s, "__STDC__", NULL);
	tcc_define_symbol(s, "__STDC_VERSION__", "199901L");
	tcc_define_symbol(s, "__STDC_HOSTED__", NULL);

	/* target defines */
#if defined(TCC_TARGET_I386)
	tcc_define_symbol(s, "__i386__", NULL);
	tcc_define_symbol(s, "__i386", NULL);
	tcc_define_symbol(s, "i386", NULL);
#elif defined(TCC_TARGET_X86_64)
	tcc_define_symbol(s, "__x86_64__", NULL);
#elif defined(TCC_TARGET_ARM)
	tcc_define_symbol(s, "__ARM_ARCH_4__", NULL);
	tcc_define_symbol(s, "__arm_elf__", NULL);
	tcc_define_symbol(s, "__arm_elf", NULL);
	tcc_define_symbol(s, "arm_elf", NULL);
	tcc_define_symbol(s, "__arm__", NULL);
	tcc_define_symbol(s, "__arm", NULL);
	tcc_define_symbol(s, "arm", NULL);
	tcc_define_symbol(s, "__APCS_32__", NULL);
	tcc_define_symbol(s, "__ARMEL__", NULL);
#if defined(TCC_ARM_EABI)
	tcc_define_symbol(s, "__ARM_EABI__", NULL);
#endif
#if defined(TCC_ARM_HARDFLOAT)
	s->float_abi = ARM_HARD_FLOAT;
	tcc_define_symbol(s, "__ARM_PCS_VFP", NULL);
#else
	s->float_abi = ARM_SOFTFP_FLOAT;
#endif
#elif defined(TCC_TARGET_ARM64)
	tcc_define_symbol(s, "__aarch64__", NULL);
#elif defined TCC_TARGET_C67
	tcc_define_symbol(s, "__C67__", NULL);
#elif defined TCC_TARGET_RISCV64
	tcc_define_symbol(s, "__riscv", NULL);
	tcc_define_symbol(s, "__riscv_xlen", "64");
	tcc_define_symbol(s, "__riscv_flen", "64");
	tcc_define_symbol(s, "__riscv_div", NULL);
	tcc_define_symbol(s, "__riscv_mul", NULL);
	tcc_define_symbol(s, "__riscv_fdiv", NULL);
	tcc_define_symbol(s, "__riscv_fsqrt", NULL);
	tcc_define_symbol(s, "__riscv_float_abi_double", NULL);
#endif

#ifdef TCC_TARGET_PE
	tcc_define_symbol(s, "_WIN32", NULL);
	tcc_define_symbol(s, "__declspec(x)", "__attribute__((x))");
	tcc_define_symbol(s, "__cdecl", "");
# ifdef TCC_TARGET_X86_64
	tcc_define_symbol(s, "_WIN64", NULL);
# endif
#else
	tcc_define_symbol(s, "__unix__", NULL);
	tcc_define_symbol(s, "__unix", NULL);
	tcc_define_symbol(s, "unix", NULL);
# if defined(__linux__)
	tcc_define_symbol(s, "__linux__", NULL);
	tcc_define_symbol(s, "__linux", NULL);
# endif
# if defined(__FreeBSD__)
	tcc_define_symbol(s, "__FreeBSD__", "__FreeBSD__");
	/* No 'Thread Storage Local' on FreeBSD with tcc */
	tcc_define_symbol(s, "__NO_TLS", NULL);
# endif
# if defined(__FreeBSD_kernel__)
	tcc_define_symbol(s, "__FreeBSD_kernel__", NULL);
# endif
# if defined(__NetBSD__)
	tcc_define_symbol(s, "__NetBSD__", "__NetBSD__");
# endif
# if defined(__OpenBSD__)
	tcc_define_symbol(s, "__OpenBSD__", "__OpenBSD__");
# endif
#endif

	/* TinyCC & gcc defines */
#if PTR_SIZE == 4
	/* 32bit systems. */
	tcc_define_symbol(s, "__SIZE_TYPE__", "unsigned int");
	tcc_define_symbol(s, "__PTRDIFF_TYPE__", "int");
	tcc_define_symbol(s, "__ILP32__", NULL);
#elif LONG_SIZE == 4
	/* 64bit Windows. */
	tcc_define_symbol(s, "__SIZE_TYPE__", "unsigned long long");
	tcc_define_symbol(s, "__PTRDIFF_TYPE__", "long long");
	tcc_define_symbol(s, "__LLP64__", NULL);
#else
	/* Other 64bit systems. */
	tcc_define_symbol(s, "__SIZE_TYPE__", "unsigned long");
	tcc_define_symbol(s, "__PTRDIFF_TYPE__", "long");
	tcc_define_symbol(s, "__LP64__", NULL);
#endif
	tcc_define_symbol(s, "__SIZEOF_POINTER__", PTR_SIZE == 4 ? "4" : "8");

#ifdef TCC_TARGET_PE
	tcc_define_symbol(s, "__WCHAR_TYPE__", "unsigned short");
	tcc_define_symbol(s, "__WINT_TYPE__", "unsigned short");
#else
	tcc_define_symbol(s, "__WCHAR_TYPE__", "int");
	/* wint_t is unsigned int by default, but (signed) int on BSDs
	   and unsigned short on windows.  Other OSes might have still
	   other conventions, sigh.  */
# if defined(__FreeBSD__) || defined (__FreeBSD_kernel__) \
  || defined(__NetBSD__) || defined(__OpenBSD__)
	tcc_define_symbol(s, "__WINT_TYPE__", "int");
#  ifdef __FreeBSD__
	/* define __GNUC__ to have some useful stuff from sys/cdefs.h
	   that are unconditionally used in FreeBSDs other system headers :/ */
	tcc_define_symbol(s, "__GNUC__", "2");
	tcc_define_symbol(s, "__GNUC_MINOR__", "7");
	tcc_define_symbol(s, "__builtin_alloca", "alloca");
#  endif
# else
	tcc_define_symbol(s, "__WINT_TYPE__", "unsigned int");
	/* glibc defines */
	tcc_define_symbol(s, "__REDIRECT(name, proto, alias)",
	                  "name proto __asm__ (#alias)");
	tcc_define_symbol(s, "__REDIRECT_NTH(name, proto, alias)",
	                  "name proto __asm__ (#alias) __THROW");
# endif
# if defined(TCC_MUSL)
	tcc_define_symbol(s, "__DEFINED_va_list", "");
	tcc_define_symbol(s, "__DEFINED___isoc_va_list", "");
	tcc_define_symbol(s, "__isoc_va_list", "void *");
# endif /* TCC_MUSL */
	/* Some GCC builtins that are simple to express as macros.  */
	tcc_define_symbol(s, "__builtin_extract_return_addr(x)", "x");
#endif /* ndef TCC_TARGET_PE */
	return s;
}

LIBTCCAPI void tcc_delete(TCCState *s1)
{
	/* free sections */
	tccelf_delete(s1);

	/* free library paths */
	dynarray_reset(&s1->library_paths, &s1->nb_library_paths);
	dynarray_reset(&s1->crt_paths, &s1->nb_crt_paths);

	/* free include paths */
	dynarray_reset(&s1->include_paths, &s1->nb_include_paths);
	dynarray_reset(&s1->sysinclude_paths, &s1->nb_sysinclude_paths);

	tcc_free(s1->tcc_lib_path);
	tcc_free(s1->soname);
	tcc_free(s1->rpath);
	tcc_free(s1->init_symbol);
	tcc_free(s1->fini_symbol);
	tcc_free(s1->outfile);
	tcc_free(s1->deps_outfile);
	dynarray_reset(&s1->files, &s1->nb_files);
	dynarray_reset(&s1->target_deps, &s1->nb_target_deps);
	dynarray_reset(&s1->pragma_libs, &s1->nb_pragma_libs);
	dynarray_reset(&s1->argv, &s1->argc);

	cstr_free(&s1->cmdline_defs);
	cstr_free(&s1->cmdline_incl);
#ifdef TCC_IS_NATIVE
	/* free runtime memory */
	tcc_run_free(s1);
#endif

	tcc_free(s1);
#ifdef MEM_DEBUG
	if (0 == --nb_states)
		tcc_memcheck();
#endif
}

LIBTCCAPI int tcc_set_output_type(TCCState *s, int output_type)
{
	s->output_type = output_type;

	/* always elf for objects */
	if (output_type == TCC_OUTPUT_OBJ)
		s->output_format = TCC_OUTPUT_FORMAT_ELF;

	if (s->char_is_unsigned)
		tcc_define_symbol(s, "__CHAR_UNSIGNED__", NULL);

	if (!s->nostdinc)
	{
		/* default include paths */
		/* -isystem paths have already been handled */
		tcc_add_sysinclude_path(s, CONFIG_TCC_SYSINCLUDEPATHS);
	}

#ifdef CONFIG_TCC_BCHECK
	if (s->do_bounds_check)
	{
		/* if bound checking, then add corresponding sections */
		tccelf_bounds_new(s);
		/* define symbol */
		tcc_define_symbol(s, "__BOUNDS_CHECKING_ON", NULL);
	}
#endif
	if (s->do_debug)
	{
		/* add debug sections */
		tccelf_stab_new(s);
	}

	tcc_add_library_path(s, CONFIG_TCC_LIBPATHS);

#ifdef TCC_TARGET_PE
# ifdef _WIN32
	if (!s->nostdlib && output_type != TCC_OUTPUT_OBJ)
		tcc_add_systemdir(s);
# endif
#else
	/* paths for crt objects */
	tcc_split_path(s, &s->crt_paths, &s->nb_crt_paths, CONFIG_TCC_CRTPREFIX);
	/* add libc crt1/crti objects */
	if ((output_type == TCC_OUTPUT_EXE || output_type == TCC_OUTPUT_DLL) &&
	        !s->nostdlib)
	{
		if (output_type != TCC_OUTPUT_DLL)
			tcc_add_crt(s, "crt1.o");
		tcc_add_crt(s, "crti.o");
	}
#endif
	return 0;
}

LIBTCCAPI int tcc_add_include_path(TCCState *s, const char *pathname)
{
	tcc_split_path(s, &s->include_paths, &s->nb_include_paths, pathname);
	return 0;
}

LIBTCCAPI int tcc_add_sysinclude_path(TCCState *s, const char *pathname)
{
	tcc_split_path(s, &s->sysinclude_paths, &s->nb_sysinclude_paths, pathname);
	return 0;
}

ST_FUNC int tcc_add_file_internal(TCCState *s1, const char *filename, int flags)
{
	int fd, ret;

	/* open the file */
	fd = _tcc_open(s1, filename);
	if (fd < 0)
	{
		if (flags & AFF_PRINT_ERROR)
			tcc_error_noabort("file '%s' not found", filename);
		return -1;
	}

	/* update target deps */
	dynarray_add(&s1->target_deps, &s1->nb_target_deps,
	             tcc_strdup(filename));

	if (flags & AFF_TYPE_BIN)
	{
		ElfW(Ehdr) ehdr;
		int obj_type;

		obj_type = tcc_object_type(fd, &ehdr);
		lseek(fd, 0, SEEK_SET);

#ifdef TCC_TARGET_MACHO
		if (0 == obj_type && 0 == strcmp(tcc_fileextension(filename), ".dylib"))
			obj_type = AFF_BINTYPE_DYN;
#endif

		switch (obj_type)
		{
		case AFF_BINTYPE_REL:
			ret = tcc_load_object_file(s1, fd, 0);
			break;
#ifndef TCC_TARGET_PE
		case AFF_BINTYPE_DYN:
			if (s1->output_type == TCC_OUTPUT_MEMORY)
			{
				ret = 0;
#ifdef TCC_IS_NATIVE
				if (NULL == dlopen(filename, RTLD_GLOBAL | RTLD_LAZY))
					ret = -1;
#endif
			}
			else
			{
				ret = tcc_load_dll(s1, fd, filename,
				                   (flags & AFF_REFERENCED_DLL) != 0);
			}
			break;
#endif
		case AFF_BINTYPE_AR:
			ret = tcc_load_archive(s1, fd, !(flags & AFF_WHOLE_ARCHIVE));
			break;
#ifdef TCC_TARGET_COFF
		case AFF_BINTYPE_C67:
			ret = tcc_load_coff(s1, fd);
			break;
#endif
		default:
#ifdef TCC_TARGET_PE
			ret = pe_load_file(s1, filename, fd);
#else
			/* as GNU ld, consider it is an ld script if not recognized */
			ret = tcc_load_ldscript(s1, fd);
#endif
			if (ret < 0)
				tcc_error_noabort("unrecognized file type");
			break;
		}
		close(fd);
	}
	else
	{
		ret = tcc_compile(s1, flags, filename, fd);
	}
	return ret;
}

LIBTCCAPI int tcc_add_file(TCCState *s, const char *filename)
{
	int filetype = s->filetype;
	if (0 == (filetype & AFF_TYPE_MASK))
	{
		/* use a file extension to detect a filetype */
		const char *ext = tcc_fileextension(filename);
		if (ext[0])
		{
			ext++;
			if (!strcmp(ext, "S"))
				filetype = AFF_TYPE_ASMPP;
			else if (!strcmp(ext, "s"))
				filetype = AFF_TYPE_ASM;
			else if (!PATHCMP(ext, "c") || !PATHCMP(ext, "i"))
				filetype = AFF_TYPE_C;
			else
				filetype |= AFF_TYPE_BIN;
		}
		else
		{
			filetype = AFF_TYPE_C;
		}
	}
	return tcc_add_file_internal(s, filename, filetype | AFF_PRINT_ERROR);
}

LIBTCCAPI int tcc_add_library_path(TCCState *s, const char *pathname)
{
	tcc_split_path(s, &s->library_paths, &s->nb_library_paths, pathname);
	return 0;
}

static int tcc_add_library_internal(TCCState *s, const char *fmt,
                                    const char *filename, int flags, char **paths, int nb_paths)
{
	char buf[1024];
	int i;

	for(i = 0; i < nb_paths; i++)
	{
		snprintf(buf, sizeof(buf), fmt, paths[i], filename);
		if (tcc_add_file_internal(s, buf, flags | AFF_TYPE_BIN) == 0)
			return 0;
	}
	return -1;
}

/* find and load a dll. Return non zero if not found */
/* XXX: add '-rpath' option support ? */
ST_FUNC int tcc_add_dll(TCCState *s, const char *filename, int flags)
{
	return tcc_add_library_internal(s, "%s/%s", filename, flags,
	                                s->library_paths, s->nb_library_paths);
}

#ifndef TCC_TARGET_PE
ST_FUNC int tcc_add_crt(TCCState *s1, const char *filename)
{
	if (-1 == tcc_add_library_internal(s1, "%s/%s",
	                                   filename, 0, s1->crt_paths, s1->nb_crt_paths))
		tcc_error_noabort("file '%s' not found", filename);
	return 0;
}
#endif

/* the library name is the same as the argument of the '-l' option */
LIBTCCAPI int tcc_add_library(TCCState *s, const char *libraryname)
{
#if defined TCC_TARGET_PE
	const char *libs[] = { "%s/%s.def", "%s/lib%s.def", "%s/%s.dll", "%s/lib%s.dll", "%s/lib%s.a", NULL };
	const char **pp = s->static_link ? libs + 4 : libs;
#elif defined TCC_TARGET_MACHO
	const char *libs[] = { "%s/lib%s.dylib", "%s/lib%s.a", NULL };
	const char **pp = s->static_link ? libs + 1 : libs;
#else
	const char *libs[] = { "%s/lib%s.so", "%s/lib%s.a", NULL };
	const char **pp = s->static_link ? libs + 1 : libs;
#endif
	int flags = s->filetype & AFF_WHOLE_ARCHIVE;
	while (*pp)
	{
		if (0 == tcc_add_library_internal(s, *pp,
		                                  libraryname, flags, s->library_paths, s->nb_library_paths))
			return 0;
		++pp;
	}
	return -1;
}

PUB_FUNC int tcc_add_library_err(TCCState *s1, const char *libname)
{
	int ret = tcc_add_library(s1, libname);
	if (ret < 0)
		tcc_error_noabort("library '%s' not found", libname);
	return ret;
}

/* handle #pragma comment(lib,) */
ST_FUNC void tcc_add_pragma_libs(TCCState *s1)
{
	int i;
	for (i = 0; i < s1->nb_pragma_libs; i++)
		tcc_add_library_err(s1, s1->pragma_libs[i]);
}

LIBTCCAPI int tcc_add_symbol(TCCState *s1, const char *name, const void *val)
{
#ifdef TCC_TARGET_PE
	/* On x86_64 'val' might not be reachable with a 32bit offset.
	   So it is handled here as if it were in a DLL. */
	pe_putimport(s1, 0, name, (uintptr_t)val);
#else
	set_elf_sym(symtab_section, (uintptr_t)val, 0,
	            ELFW(ST_INFO)(STB_GLOBAL, STT_NOTYPE), 0,
	            SHN_ABS, name);
#endif
	return 0;
}

LIBTCCAPI void tcc_set_lib_path(TCCState *s, const char *path)
{
	tcc_free(s->tcc_lib_path);
	s->tcc_lib_path = tcc_strdup(path);
}

#define WD_ALL    0x0001 /* warning is activated when using -Wall */
#define FD_INVERT 0x0002 /* invert value before storing */

typedef struct FlagDef
{
	uint16_t offset;
	uint16_t flags;
	const char *name;
} FlagDef;

static int no_flag(const char **pp)
{
	const char *p = *pp;
	if (*p != 'n' || *++p != 'o' || *++p != '-')
		return 0;
	*pp = p + 1;
	return 1;
}

ST_FUNC int set_flag(TCCState *s, const FlagDef *flags, const char *name)
{
	int value, ret;
	const FlagDef *p;
	const char *r;

	value = 1;
	r = name;
	if (no_flag(&r))
		value = 0;

	for (ret = -1, p = flags; p->name; ++p)
	{
		if (ret)
		{
			if (strcmp(r, p->name))
				continue;
		}
		else
		{
			if (0 == (p->flags & WD_ALL))
				continue;
		}
		if (p->offset)
		{
			*((unsigned char *)s + p->offset) =
			    p->flags & FD_INVERT ? !value : value;
			if (ret)
				return 0;
		}
		else
		{
			ret = 0;
		}
	}
	return ret;
}

static int strstart(const char *val, const char **str)
{
	const char *p, *q;
	p = *str;
	q = val;
	while (*q)
	{
		if (*p != *q)
			return 0;
		p++;
		q++;
	}
	*str = p;
	return 1;
}

/* Like strstart, but automatically takes into account that ld options can
 *
 * - start with double or single dash (e.g. '--soname' or '-soname')
 * - arguments can be given as separate or after '=' (e.g. '-Wl,-soname,x.so'
 *   or '-Wl,-soname=x.so')
 *
 * you provide `val` always in 'option[=]' form (no leading -)
 */
static int link_option(const char *str, const char *val, const char **ptr)
{
	const char *p, *q;
	int ret;

	/* there should be 1 or 2 dashes */
	if (*str++ != '-')
		return 0;
	if (*str == '-')
		str++;

	/* then str & val should match (potentially up to '=') */
	p = str;
	q = val;

	ret = 1;
	if (q[0] == '?')
	{
		++q;
		if (no_flag(&p))
			ret = -1;
	}

	while (*q != '\0' && *q != '=')
	{
		if (*p != *q)
			return 0;
		p++;
		q++;
	}

	/* '=' near eos means ',' or '=' is ok */
	if (*q == '=')
	{
		if (*p == 0)
			*ptr = p;
		if (*p != ',' && *p != '=')
			return 0;
		p++;
	}
	else if (*p)
	{
		return 0;
	}
	*ptr = p;
	return ret;
}

static const char *skip_linker_arg(const char **str)
{
	const char *s1 = *str;
	const char *s2 = strchr(s1, ',');
	*str = s2 ? s2++ : (s2 = s1 + strlen(s1));
	return s2;
}

static void copy_linker_arg(char **pp, const char *s, int sep)
{
	const char *q = s;
	char *p = *pp;
	int l = 0;
	if (p && sep)
		p[l = strlen(p)] = sep, ++l;
	skip_linker_arg(&q);
	pstrncpy(l + (*pp = tcc_realloc(p, q - s + l + 1)), s, q - s);
}

/* set linker options */
static int tcc_set_linker(TCCState *s, const char *option)
{
	TCCState *s1 = s;
	while (*option)
	{

		const char *p = NULL;
		char *end = NULL;
		int ignoring = 0;
		int ret;

		if (link_option(option, "Bsymbolic", &p))
		{
			s->symbolic = 1;
		}
		else if (link_option(option, "nostdlib", &p))
		{
			s->nostdlib = 1;
		}
		else if (link_option(option, "fini=", &p))
		{
			copy_linker_arg(&s->fini_symbol, p, 0);
			ignoring = 1;
		}
		else if (link_option(option, "image-base=", &p)
		         || link_option(option, "Ttext=", &p))
		{
			s->text_addr = strtoull(p, &end, 16);
			s->has_text_addr = 1;
		}
		else if (link_option(option, "init=", &p))
		{
			copy_linker_arg(&s->init_symbol, p, 0);
			ignoring = 1;
		}
		else if (link_option(option, "oformat=", &p))
		{
#if defined(TCC_TARGET_PE)
			if (strstart("pe-", &p))
			{
#elif PTR_SIZE == 8
			if (strstart("elf64-", &p))
			{
#else
			if (strstart("elf32-", &p))
			{
#endif
				s->output_format = TCC_OUTPUT_FORMAT_ELF;
			}
			else if (!strcmp(p, "binary"))
			{
				s->output_format = TCC_OUTPUT_FORMAT_BINARY;
#ifdef TCC_TARGET_COFF
			}
			else if (!strcmp(p, "coff"))
			{
				s->output_format = TCC_OUTPUT_FORMAT_COFF;
#endif
			}
			else
				goto err;

		}
		else if (link_option(option, "as-needed", &p))
		{
			ignoring = 1;
		}
		else if (link_option(option, "O", &p))
		{
			ignoring = 1;
		}
		else if (link_option(option, "export-all-symbols", &p))
		{
			s->rdynamic = 1;
		}
		else if (link_option(option, "export-dynamic", &p))
		{
			s->rdynamic = 1;
		}
		else if (link_option(option, "rpath=", &p))
		{
			copy_linker_arg(&s->rpath, p, ':');
		}
		else if (link_option(option, "enable-new-dtags", &p))
		{
			s->enable_new_dtags = 1;
		}
		else if (link_option(option, "section-alignment=", &p))
		{
			s->section_align = strtoul(p, &end, 16);
		}
		else if (link_option(option, "soname=", &p))
		{
			copy_linker_arg(&s->soname, p, 0);
#ifdef TCC_TARGET_PE
		}
		else if (link_option(option, "large-address-aware", &p))
		{
			s->pe_characteristics |= 0x20;
		}
		else if (link_option(option, "file-alignment=", &p))
		{
			s->pe_file_align = strtoul(p, &end, 16);
		}
		else if (link_option(option, "stack=", &p))
		{
			s->pe_stack_size = strtoul(p, &end, 10);
		}
		else if (link_option(option, "subsystem=", &p))
		{
#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
			if (!strcmp(p, "native"))
			{
				s->pe_subsystem = 1;
			}
			else if (!strcmp(p, "console"))
			{
				s->pe_subsystem = 3;
			}
			else if (!strcmp(p, "gui") || !strcmp(p, "windows"))
			{
				s->pe_subsystem = 2;
			}
			else if (!strcmp(p, "posix"))
			{
				s->pe_subsystem = 7;
			}
			else if (!strcmp(p, "efiapp"))
			{
				s->pe_subsystem = 10;
			}
			else if (!strcmp(p, "efiboot"))
			{
				s->pe_subsystem = 11;
			}
			else if (!strcmp(p, "efiruntime"))
			{
				s->pe_subsystem = 12;
			}
			else if (!strcmp(p, "efirom"))
			{
				s->pe_subsystem = 13;
#elif defined(TCC_TARGET_ARM)
			if (!strcmp(p, "wince"))
			{
				s->pe_subsystem = 9;
#endif
			}
			else
				goto err;
#endif
		}
		else if (ret = link_option(option, "?whole-archive", &p), ret)
		{
			if (ret > 0)
				s->filetype |= AFF_WHOLE_ARCHIVE;
			else
				s->filetype &= ~AFF_WHOLE_ARCHIVE;
		}
		else if (p)
		{
			return 0;
		}
		else
		{
err:
			tcc_error("unsupported linker option '%s'", option);
		}

		if (ignoring && s->warn_unsupported)
			tcc_warning("unsupported linker option '%s'", option);

		option = skip_linker_arg(&p);
	}
	return 1;
}

typedef struct TCCOption
{
	const char *name;
	uint16_t index;
	uint16_t flags;
} TCCOption;

enum
{
	TCC_OPTION_HELP,
	TCC_OPTION_HELP2,
	TCC_OPTION_v,
	TCC_OPTION_I,
	TCC_OPTION_D,
	TCC_OPTION_U,
	TCC_OPTION_P,
	TCC_OPTION_L,
	TCC_OPTION_B,
	TCC_OPTION_l,
	TCC_OPTION_bench,
	TCC_OPTION_bt,
	TCC_OPTION_b,
	TCC_OPTION_ba,
	TCC_OPTION_g,
	TCC_OPTION_c,
	TCC_OPTION_dumpversion,
	TCC_OPTION_d,
	TCC_OPTION_static,
	TCC_OPTION_std,
	TCC_OPTION_shared,
	TCC_OPTION_soname,
	TCC_OPTION_o,
	TCC_OPTION_r,
	TCC_OPTION_s,
	TCC_OPTION_traditional,
	TCC_OPTION_Wl,
	TCC_OPTION_Wp,
	TCC_OPTION_W,
	TCC_OPTION_O,
	TCC_OPTION_mfloat_abi,
	TCC_OPTION_m,
	TCC_OPTION_f,
	TCC_OPTION_isystem,
	TCC_OPTION_iwithprefix,
	TCC_OPTION_include,
	TCC_OPTION_nostdinc,
	TCC_OPTION_nostdlib,
	TCC_OPTION_print_search_dirs,
	TCC_OPTION_rdynamic,
	TCC_OPTION_param,
	TCC_OPTION_pedantic,
	TCC_OPTION_pthread,
	TCC_OPTION_run,
	TCC_OPTION_w,
	TCC_OPTION_pipe,
	TCC_OPTION_E,
	TCC_OPTION_MD,
	TCC_OPTION_MF,
	TCC_OPTION_x,
	TCC_OPTION_ar,
	TCC_OPTION_impdef,
	TCC_OPTION_intelasm
};

#define TCC_OPTION_HAS_ARG 0x0001
#define TCC_OPTION_NOSEP   0x0002 /* cannot have space before option and arg */

static const TCCOption tcc_options[] =
{
	{ "h", TCC_OPTION_HELP, 0 },
	{ "-help", TCC_OPTION_HELP, 0 },
	{ "?", TCC_OPTION_HELP, 0 },
	{ "hh", TCC_OPTION_HELP2, 0 },
	{ "v", TCC_OPTION_v, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "I", TCC_OPTION_I, TCC_OPTION_HAS_ARG },
	{ "D", TCC_OPTION_D, TCC_OPTION_HAS_ARG },
	{ "U", TCC_OPTION_U, TCC_OPTION_HAS_ARG },
	{ "P", TCC_OPTION_P, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "L", TCC_OPTION_L, TCC_OPTION_HAS_ARG },
	{ "B", TCC_OPTION_B, TCC_OPTION_HAS_ARG },
	{ "l", TCC_OPTION_l, TCC_OPTION_HAS_ARG },
	{ "bench", TCC_OPTION_bench, 0 },
#ifdef CONFIG_TCC_BACKTRACE
	{ "bt", TCC_OPTION_bt, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
#endif
#ifdef CONFIG_TCC_BCHECK
	{ "b", TCC_OPTION_b, 0 },
#endif
	{ "g", TCC_OPTION_g, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "c", TCC_OPTION_c, 0 },
	{ "dumpversion", TCC_OPTION_dumpversion, 0},
	{ "d", TCC_OPTION_d, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "static", TCC_OPTION_static, 0 },
	{ "std", TCC_OPTION_std, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "shared", TCC_OPTION_shared, 0 },
	{ "soname", TCC_OPTION_soname, TCC_OPTION_HAS_ARG },
	{ "o", TCC_OPTION_o, TCC_OPTION_HAS_ARG },
	{ "-param", TCC_OPTION_param, TCC_OPTION_HAS_ARG },
	{ "pedantic", TCC_OPTION_pedantic, 0},
	{ "pthread", TCC_OPTION_pthread, 0},
	{ "run", TCC_OPTION_run, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "rdynamic", TCC_OPTION_rdynamic, 0 },
	{ "r", TCC_OPTION_r, 0 },
	{ "s", TCC_OPTION_s, 0 },
	{ "traditional", TCC_OPTION_traditional, 0 },
	{ "Wl,", TCC_OPTION_Wl, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "Wp,", TCC_OPTION_Wp, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "W", TCC_OPTION_W, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "O", TCC_OPTION_O, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
#ifdef TCC_TARGET_ARM
	{ "mfloat-abi", TCC_OPTION_mfloat_abi, TCC_OPTION_HAS_ARG },
#endif
	{ "m", TCC_OPTION_m, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "f", TCC_OPTION_f, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },
	{ "isystem", TCC_OPTION_isystem, TCC_OPTION_HAS_ARG },
	{ "include", TCC_OPTION_include, TCC_OPTION_HAS_ARG },
	{ "nostdinc", TCC_OPTION_nostdinc, 0 },
	{ "nostdlib", TCC_OPTION_nostdlib, 0 },
	{ "print-search-dirs", TCC_OPTION_print_search_dirs, 0 },
	{ "w", TCC_OPTION_w, 0 },
	{ "pipe", TCC_OPTION_pipe, 0},
	{ "E", TCC_OPTION_E, 0},
	{ "MD", TCC_OPTION_MD, 0},
	{ "MF", TCC_OPTION_MF, TCC_OPTION_HAS_ARG },
	{ "x", TCC_OPTION_x, TCC_OPTION_HAS_ARG },
	{ "ar", TCC_OPTION_ar, 0},
	{ "intelasm", TCC_OPTION_intelasm, 0},
#ifdef TCC_TARGET_PE
	{ "impdef", TCC_OPTION_impdef, 0},
#endif
	{ NULL, 0, 0 },
};

static const FlagDef options_W[] =
{
	{ 0, 0, "all" },
	{ offsetof(TCCState, warn_unsupported), 0, "unsupported" },
	{ offsetof(TCCState, warn_write_strings), 0, "write-strings" },
	{ offsetof(TCCState, warn_error), 0, "error" },
	{ offsetof(TCCState, warn_gcc_compat), 0, "gcc-compat" },
	{
		offsetof(TCCState, warn_implicit_function_declaration), WD_ALL,
		"implicit-function-declaration"
	},
	{ 0, 0, NULL }
};

static const FlagDef options_f[] =
{
	{ offsetof(TCCState, char_is_unsigned), 0, "unsigned-char" },
	{ offsetof(TCCState, char_is_unsigned), FD_INVERT, "signed-char" },
	{ offsetof(TCCState, nocommon), FD_INVERT, "common" },
	{ offsetof(TCCState, leading_underscore), 0, "leading-underscore" },
	{ offsetof(TCCState, ms_extensions), 0, "ms-extensions" },
	{ offsetof(TCCState, dollars_in_identifiers), 0, "dollars-in-identifiers" },
	{ 0, 0, NULL }
};

static const FlagDef options_m[] =
{
	{ offsetof(TCCState, ms_bitfields), 0, "ms-bitfields" },
#ifdef TCC_TARGET_X86_64
	{ offsetof(TCCState, nosse), FD_INVERT, "sse" },
#endif
	{ 0, 0, NULL }
};

static void parse_option_D(TCCState *s1, const char *optarg)
{
	char *sym = tcc_strdup(optarg);
	char *value = strchr(sym, '=');
	if (value)
		*value++ = '\0';
	tcc_define_symbol(s1, sym, value);
	tcc_free(sym);
}

static void args_parser_add_file(TCCState *s, const char* filename, int filetype)
{
	struct filespec *f = tcc_malloc(sizeof *f + strlen(filename));
	f->type = filetype;
	strcpy(f->name, filename);
	dynarray_add(&s->files, &s->nb_files, f);
}

static int args_parser_make_argv(const char *r, int *argc, char ***argv)
{
	int ret = 0, q, c;
	CString str;
	for(;;)
	{
		while (c = (unsigned char)*r, c && c <= ' ')
			++r;
		if (c == 0)
			break;
		q = 0;
		cstr_new(&str);
		while (c = (unsigned char)*r, c)
		{
			++r;
			if (c == '\\' && (*r == '"' || *r == '\\'))
			{
				c = *r++;
			}
			else if (c == '"')
			{
				q = !q;
				continue;
			}
			else if (q == 0 && c <= ' ')
			{
				break;
			}
			cstr_ccat(&str, c);
		}
		cstr_ccat(&str, 0);
		//printf("<%s>\n", str.data), fflush(stdout);
		dynarray_add(argv, argc, tcc_strdup(str.data));
		cstr_free(&str);
		++ret;
	}
	return ret;
}

/* read list file */
static void args_parser_listfile(TCCState *s,
                                 const char *filename, int optind, int *pargc, char ***pargv)
{
	TCCState *s1 = s;
	int fd, i;
	size_t len;
	char *p;
	int argc = 0;
	char **argv = NULL;

	fd = open(filename, O_RDONLY | O_BINARY);
	if (fd < 0)
		tcc_error("listfile '%s' not found", filename);

	len = lseek(fd, 0, SEEK_END);
	p = tcc_malloc(len + 1), p[len] = 0;
	lseek(fd, 0, SEEK_SET), read(fd, p, len), close(fd);

	for (i = 0; i < *pargc; ++i)
		if (i == optind)
			args_parser_make_argv(p, &argc, &argv);
		else
			dynarray_add(&argv, &argc, tcc_strdup((*pargv)[i]));

	tcc_free(p);
	dynarray_reset(&s->argv, &s->argc);
	*pargc = s->argc = argc, *pargv = s->argv = argv;
}

PUB_FUNC int tcc_parse_args(TCCState *s, int *pargc, char ***pargv, int optind)
{
	TCCState *s1 = s;
	const TCCOption *popt;
	const char *optarg, *r;
	const char *run = NULL;
	int last_o = -1;
	int x;
	CString linker_arg; /* collect -Wl options */
	int tool = 0, arg_start = 0, noaction = optind;
	char **argv = *pargv;
	int argc = *pargc;

	cstr_new(&linker_arg);

	while (optind < argc)
	{
		r = argv[optind];
		if (r[0] == '@' && r[1] != '\0')
		{
			args_parser_listfile(s, r + 1, optind, &argc, &argv);
			continue;
		}
		optind++;
		if (tool)
		{
			if (r[0] == '-' && r[1] == 'v' && r[2] == 0)
				++s->verbose;
			continue;
		}
reparse:
		if (r[0] != '-' || r[1] == '\0')
		{
			if (r[0] != '@') /* allow "tcc file(s) -run @ args ..." */
				args_parser_add_file(s, r, s->filetype);
			if (run)
			{
				tcc_set_options(s, run);
				arg_start = optind - 1;
				break;
			}
			continue;
		}

		/* find option in table */
		for(popt = tcc_options; ; ++popt)
		{
			const char *p1 = popt->name;
			const char *r1 = r + 1;
			if (p1 == NULL)
				tcc_error("invalid option -- '%s'", r);
			if (!strstart(p1, &r1))
				continue;
			optarg = r1;
			if (popt->flags & TCC_OPTION_HAS_ARG)
			{
				if (*r1 == '\0' && !(popt->flags & TCC_OPTION_NOSEP))
				{
					if (optind >= argc)
arg_err:
						tcc_error("argument to '%s' is missing", r);
					optarg = argv[optind++];
				}
			}
			else if (*r1 != '\0')
				continue;
			break;
		}

		switch(popt->index)
		{
		case TCC_OPTION_HELP:
			return OPT_HELP;
		case TCC_OPTION_HELP2:
			return OPT_HELP2;
		case TCC_OPTION_I:
			tcc_add_include_path(s, optarg);
			break;
		case TCC_OPTION_D:
			parse_option_D(s, optarg);
			break;
		case TCC_OPTION_U:
			tcc_undefine_symbol(s, optarg);
			break;
		case TCC_OPTION_L:
			tcc_add_library_path(s, optarg);
			break;
		case TCC_OPTION_B:
			/* set tcc utilities path (mainly for tcc development) */
			tcc_set_lib_path(s, optarg);
			break;
		case TCC_OPTION_l:
			args_parser_add_file(s, optarg, AFF_TYPE_LIB | (s->filetype & ~AFF_TYPE_MASK));
			s->nb_libraries++;
			break;
		case TCC_OPTION_pthread:
			parse_option_D(s, "_REENTRANT");
			s->option_pthread = 1;
			break;
		case TCC_OPTION_bench:
			s->do_bench = 1;
			break;
#ifdef CONFIG_TCC_BACKTRACE
		case TCC_OPTION_bt:
			s->rt_num_callers = atoi(optarg);
			s->do_backtrace = 1;
			s->do_debug = 1;
			break;
#endif
#ifdef CONFIG_TCC_BCHECK
		case TCC_OPTION_b:
			s->do_bounds_check = 1;
			s->do_backtrace = 1;
			s->do_debug = 1;
			break;
#endif
		case TCC_OPTION_g:
			s->do_debug = 1;
			break;
		case TCC_OPTION_c:
			x = TCC_OUTPUT_OBJ;
set_output_type:
			if (s->output_type)
				tcc_warning("-%s: overriding compiler action already specified", popt->name);
			s->output_type = x;
			break;
		case TCC_OPTION_d:
			if (*optarg == 'D')
				s->dflag = 3;
			else if (*optarg == 'M')
				s->dflag = 7;
			else if (*optarg == 't')
				s->dflag = 16;
			else if (isnum(*optarg))
				s->g_debug |= atoi(optarg);
			else
				goto unsupported_option;
			break;
		case TCC_OPTION_static:
			s->static_link = 1;
			break;
		case TCC_OPTION_std:
			if (*optarg == '=')
			{
				if (strcmp(optarg, "=c11") == 0)
				{
					tcc_undefine_symbol(s, "__STDC_VERSION__");
					tcc_define_symbol(s, "__STDC_VERSION__", "201112L");
					/*
					 * The integer constant 1, intended to indicate
					 * that the implementation does not support atomic
					 * types (including the _Atomic type qualier) and
					 * the <stdatomic.h> header.
					 */
					tcc_define_symbol(s, "__STDC_NO_ATOMICS__", "1");
					/*
					 * The integer constant 1, intended to indicate
					 * that the implementation does not support complex
					 * types or the <complex.h> header.
					 */
					tcc_define_symbol(s, "__STDC_NO_COMPLEX__", "1");
					/*
					 * The integer constant 1, intended to indicate
					 * that the implementation does not support the
					 * <threads.h> header.
					 */
					tcc_define_symbol(s, "__STDC_NO_THREADS__", "1");
					/*
					 * __STDC_NO_VLA__, tcc supports VLA.
					 * The integer constant 1, intended to indicate
					 * that the implementation does not support
					 * variable length arrays or variably modied
					 * types.
					 */
#if !defined(TCC_TARGET_PE)
					/*
					 * An integer constant of the form yyyymmL (for
					 * example, 199712L). If this symbol is dened,
					 * then every character in the Unicode required
					 * set, when stored in an object of type
					 * wchar_t, has the same value as the short
					 * identier of that character.
					 */
#if 0
					/* on Linux, this conflicts with a define introduced by
					 * /usr/include/stdc-predef.h included by glibc libs;
					 * clang doesn't define it at all so it's probably not necessary
					 */
					tcc_define_symbol(s, "__STDC_ISO_10646__", "201605L");
#endif
					/*
					 * The integer constant 1, intended to indicate
					 * that values of type char16_t are UTF16
					 * encoded. If some other encoding is used, the
					 * macro shall not be dened and the actual
					 * encoding used is implementation dened.
					 */
					tcc_define_symbol(s, "__STDC_UTF_16__", "1");
					/*
					 * The integer constant 1, intended to indicate
					 * that values of type char32_t are UTF32
					 * encoded. If some other encoding is used, the
					 * macro shall not be dened and the actual
					 * encoding used is implementationdened.
					 */
					tcc_define_symbol(s, "__STDC_UTF_32__", "1");
#endif /* !TCC_TARGET_PE */
					s->cversion = 201112;
				}
			}
			/*
			 * silently ignore other values, a current purpose:
			 * allow to use a tcc as a reference compiler for "make test"
			 */
			break;
		case TCC_OPTION_shared:
			x = TCC_OUTPUT_DLL;
			goto set_output_type;
		case TCC_OPTION_soname:
			s->soname = tcc_strdup(optarg);
			break;
		case TCC_OPTION_o:
			if (s->outfile)
			{
				tcc_warning("multiple -o option");
				tcc_free(s->outfile);
			}
			s->outfile = tcc_strdup(optarg);
			break;
		case TCC_OPTION_r:
			/* generate a .o merging several output files */
			s->option_r = 1;
			x = TCC_OUTPUT_OBJ;
			goto set_output_type;
		case TCC_OPTION_isystem:
			tcc_add_sysinclude_path(s, optarg);
			break;
		case TCC_OPTION_include:
			cstr_printf(&s->cmdline_incl, "#include \"%s\"\n", optarg);
			break;
		case TCC_OPTION_nostdinc:
			s->nostdinc = 1;
			break;
		case TCC_OPTION_nostdlib:
			s->nostdlib = 1;
			break;
		case TCC_OPTION_run:
#ifndef TCC_IS_NATIVE
			tcc_error("-run is not available in a cross compiler");
#endif
			run = optarg;
			x = TCC_OUTPUT_MEMORY;
			goto set_output_type;
		case TCC_OPTION_v:
			do ++s->verbose;
			while (*optarg++ == 'v');
			++noaction;
			break;
		case TCC_OPTION_f:
			if (set_flag(s, options_f, optarg) < 0)
				goto unsupported_option;
			break;
#ifdef TCC_TARGET_ARM
		case TCC_OPTION_mfloat_abi:
			/* tcc doesn't support soft float yet */
			if (!strcmp(optarg, "softfp"))
			{
				s->float_abi = ARM_SOFTFP_FLOAT;
				tcc_undefine_symbol(s, "__ARM_PCS_VFP");
			}
			else if (!strcmp(optarg, "hard"))
				s->float_abi = ARM_HARD_FLOAT;
			else
				tcc_error("unsupported float abi '%s'", optarg);
			break;
#endif
		case TCC_OPTION_m:
			if (set_flag(s, options_m, optarg) < 0)
			{
				if (x = atoi(optarg), x != 32 && x != 64)
					goto unsupported_option;
				if (PTR_SIZE != x/8)
					return x;
				++noaction;
			}
			break;
		case TCC_OPTION_W:
			s->warn_none = 0;
			if (optarg[0] && set_flag(s, options_W, optarg) < 0)
				goto unsupported_option;
			break;
		case TCC_OPTION_w:
			s->warn_none = 1;
			break;
		case TCC_OPTION_rdynamic:
			s->rdynamic = 1;
			break;
		case TCC_OPTION_Wl:
			if (linker_arg.size)
				--linker_arg.size, cstr_ccat(&linker_arg, ',');
			cstr_cat(&linker_arg, optarg, 0);
			if (tcc_set_linker(s, linker_arg.data))
				cstr_free(&linker_arg);
			break;
		case TCC_OPTION_Wp:
			r = optarg;
			goto reparse;
		case TCC_OPTION_E:
			x = TCC_OUTPUT_PREPROCESS;
			goto set_output_type;
		case TCC_OPTION_P:
			s->Pflag = atoi(optarg) + 1;
			break;
		case TCC_OPTION_MD:
			s->gen_deps = 1;
			break;
		case TCC_OPTION_MF:
			s->deps_outfile = tcc_strdup(optarg);
			break;
		case TCC_OPTION_dumpversion:
			printf ("%s\n", TCC_VERSION);
			exit(0);
			break;
		case TCC_OPTION_x:
			x = 0;
			if (*optarg == 'c')
				x = AFF_TYPE_C;
			else if (*optarg == 'a')
				x = AFF_TYPE_ASMPP;
			else if (*optarg == 'b')
				x = AFF_TYPE_BIN;
			else if (*optarg == 'n')
				x = AFF_TYPE_NONE;
			else
				tcc_warning("unsupported language '%s'", optarg);
			s->filetype = x | (s->filetype & ~AFF_TYPE_MASK);
			break;
		case TCC_OPTION_O:
			last_o = atoi(optarg);
			break;
		case TCC_OPTION_print_search_dirs:
			x = OPT_PRINT_DIRS;
			goto extra_action;
		case TCC_OPTION_impdef:
			x = OPT_IMPDEF;
			goto extra_action;
		case TCC_OPTION_ar:
			x = OPT_AR;
extra_action:
			arg_start = optind - 1;
			if (arg_start != noaction)
				tcc_error("cannot parse %s here", r);
			tool = x;
			break;
		case TCC_OPTION_intelasm:
			s->intelasm = 1;
			break;
		case TCC_OPTION_traditional:
		case TCC_OPTION_pedantic:
		case TCC_OPTION_pipe:
		case TCC_OPTION_s:
			/* ignored */
			break;
		default:
unsupported_option:
			if (s->warn_unsupported)
				tcc_warning("unsupported option '%s'", r);
			break;
		}
	}
	if (last_o > 0)
		tcc_define_symbol(s, "__OPTIMIZE__", NULL);
	if (linker_arg.size)
	{
		r = linker_arg.data;
		goto arg_err;
	}
	*pargc = argc - arg_start;
	*pargv = argv + arg_start;
	if (tool)
		return tool;
	if (optind != noaction)
		return 0;
	if (s->verbose == 2)
		return OPT_PRINT_DIRS;
	if (s->verbose)
		return OPT_V;
	return OPT_HELP;
}

LIBTCCAPI void tcc_set_options(TCCState *s, const char *r)
{
	char **argv = NULL;
	int argc = 0;
	args_parser_make_argv(r, &argc, &argv);
	tcc_parse_args(s, &argc, &argv, 0);
	dynarray_reset(&argv, &argc);
}

PUB_FUNC void tcc_print_stats(TCCState *s1, unsigned total_time)
{
	if (total_time < 1)
		total_time = 1;
	if (total_bytes < 1)
		total_bytes = 1;
	fprintf(stderr, "* %d idents, %d lines, %d bytes\n"
	        "* %0.3f s, %u lines/s, %0.1f MB/s\n",
	        total_idents, total_lines, total_bytes,
	        (double)total_time/1000,
	        (unsigned)total_lines*1000/total_time,
	        (double)total_bytes/1000/total_time);
#ifdef MEM_DEBUG
	fprintf(stderr, "* %d bytes memory used\n", mem_max_size);
#endif
}
//END libtcc.c

//START tcctools.c

#undef TCC_STATE_VAR
#undef TCC_SET_STATE

# define TCC_STATE_VAR(sym) s1->sym
# define TCC_SET_STATE(fn) (tcc_enter_state(s1),fn)


//#define ARMAG  "!<arch>\n"
#define ARFMAG "`\n"

typedef struct
{
	char ar_name[16];
	char ar_date[12];
	char ar_uid[6];
	char ar_gid[6];
	char ar_mode[8];
	char ar_size[10];
	char ar_fmag[2];
} ArHdr;

static unsigned long le2belong(unsigned long ul)
{
	return ((ul & 0xFF0000)>>8)+((ul & 0xFF000000)>>24) +
	       ((ul & 0xFF)<<24)+((ul & 0xFF00)<<8);
}

/* Returns 1 if s contains any of the chars of list, else 0 */
static int contains_any(const char *s, const char *list)
{
	const char *l;
	for (; *s; s++)
	{
		for (l = list; *l; l++)
		{
			if (*s == *l)
				return 1;
		}
	}
	return 0;
}

static int ar_usage(int ret)
{
	fprintf(stderr, "usage: tcc -ar [rcsv] lib file...\n");
	fprintf(stderr, "create library ([abdioptxN] not supported).\n");
	return ret;
}

ST_FUNC int tcc_tool_ar(TCCState *s1, int argc, char **argv)
{
	static ArHdr arhdr =
	{
		"/               ",
		"            ",
		"0     ",
		"0     ",
		"0       ",
		"          ",
		ARFMAG
	};

	static ArHdr arhdro =
	{
		"                ",
		"            ",
		"0     ",
		"0     ",
		"0       ",
		"          ",
		ARFMAG
	};

	FILE *fi, *fh = NULL, *fo = NULL;
	ElfW(Ehdr) *ehdr;
	ElfW(Shdr) *shdr;
	ElfW(Sym) *sym;
	int i, fsize, i_lib, i_obj;
	char *buf, *shstr, *symtab = NULL, *strtab = NULL;
	int symtabsize = 0;//, strtabsize = 0;
	char *anames = NULL;
	int *afpos = NULL;
	int istrlen, strpos = 0, fpos = 0, funccnt = 0, funcmax, hofs;
	char tfile[260], stmp[20];
	char *file, *name;
	int ret = 2;
	const char *ops_conflict = "habdioptxN";  // unsupported but destructive if ignored.
	int verbose = 0;

	i_lib = 0;
	i_obj = 0;  // will hold the index of the lib and first obj
	for (i = 1; i < argc; i++)
	{
		const char *a = argv[i];
		if (*a == '-' && strstr(a, "."))
			ret = 1; // -x.y is always invalid (same as gnu ar)
		if ((*a == '-') || (i == 1 && !strstr(a, ".")))    // options argument
		{
			if (contains_any(a, ops_conflict))
				ret = 1;
			if (strstr(a, "v"))
				verbose = 1;
		}
		else      // lib or obj files: don't abort - keep validating all args.
		{
			if (!i_lib)  // first file is the lib
				i_lib = i;
			else if (!i_obj)  // second file is the first obj
				i_obj = i;
		}
	}

	if (!i_obj)  // i_obj implies also i_lib. we require both.
		ret = 1;

	if (ret == 1)
		return ar_usage(ret);

	if ((fh = fopen(argv[i_lib], "wb")) == NULL)
	{
		fprintf(stderr, "tcc: ar: can't open file %s \n", argv[i_lib]);
		goto the_end;
	}

	sprintf(tfile, "%s.tmp", argv[i_lib]);
	if ((fo = fopen(tfile, "wb+")) == NULL)
	{
		fprintf(stderr, "tcc: ar: can't create temporary file %s\n", tfile);
		goto the_end;
	}

	funcmax = 250;
	afpos = tcc_realloc(NULL, funcmax * sizeof *afpos); // 250 func
	memcpy(&arhdro.ar_mode, "100666", 6);

	// i_obj = first input object file
	while (i_obj < argc)
	{
		if (*argv[i_obj] == '-')    // by now, all options start with '-'
		{
			i_obj++;
			continue;
		}
		if ((fi = fopen(argv[i_obj], "rb")) == NULL)
		{
			fprintf(stderr, "tcc: ar: can't open file %s \n", argv[i_obj]);
			goto the_end;
		}
		if (verbose)
			printf("a - %s\n", argv[i_obj]);

		fseek(fi, 0, SEEK_END);
		fsize = ftell(fi);
		fseek(fi, 0, SEEK_SET);
		buf = tcc_malloc(fsize + 1);
		fread(buf, fsize, 1, fi);
		fclose(fi);

		// elf header
		ehdr = (ElfW(Ehdr) *)buf;
		if (ehdr->e_ident[4] != ELFCLASSW)
		{
			fprintf(stderr, "tcc: ar: Unsupported Elf Class: %s\n", argv[i_obj]);
			goto the_end;
		}

		shdr = (ElfW(Shdr) *) (buf + ehdr->e_shoff + ehdr->e_shstrndx * ehdr->e_shentsize);
		shstr = (char *)(buf + shdr->sh_offset);
		for (i = 0; i < ehdr->e_shnum; i++)
		{
			shdr = (ElfW(Shdr) *) (buf + ehdr->e_shoff + i * ehdr->e_shentsize);
			if (!shdr->sh_offset)
				continue;
			if (shdr->sh_type == SHT_SYMTAB)
			{
				symtab = (char *)(buf + shdr->sh_offset);
				symtabsize = shdr->sh_size;
			}
			if (shdr->sh_type == SHT_STRTAB)
			{
				if (!strcmp(shstr + shdr->sh_name, ".strtab"))
				{
					strtab = (char *)(buf + shdr->sh_offset);
					//strtabsize = shdr->sh_size;
				}
			}
		}

		if (symtab && symtabsize)
		{
			int nsym = symtabsize / sizeof(ElfW(Sym));
			//printf("symtab: info size shndx name\n");
			for (i = 1; i < nsym; i++)
			{
				sym = (ElfW(Sym) *) (symtab + i * sizeof(ElfW(Sym)));
				if (sym->st_shndx &&
				        (sym->st_info == 0x10
				         || sym->st_info == 0x11
				         || sym->st_info == 0x12
				        ))
				{
					//printf("symtab: %2Xh %4Xh %2Xh %s\n", sym->st_info, sym->st_size, sym->st_shndx, strtab + sym->st_name);
					istrlen = strlen(strtab + sym->st_name)+1;
					anames = tcc_realloc(anames, strpos+istrlen);
					strcpy(anames + strpos, strtab + sym->st_name);
					strpos += istrlen;
					if (++funccnt >= funcmax)
					{
						funcmax += 250;
						afpos = tcc_realloc(afpos, funcmax * sizeof *afpos); // 250 func more
					}
					afpos[funccnt] = fpos;
				}
			}
		}

		file = argv[i_obj];
		for (name = strchr(file, 0);
		        name > file && name[-1] != '/' && name[-1] != '\\';
		        --name);
		istrlen = strlen(name);
		if (istrlen >= sizeof(arhdro.ar_name))
			istrlen = sizeof(arhdro.ar_name) - 1;
		memset(arhdro.ar_name, ' ', sizeof(arhdro.ar_name));
		memcpy(arhdro.ar_name, name, istrlen);
		arhdro.ar_name[istrlen] = '/';
		sprintf(stmp, "%-10d", fsize);
		memcpy(&arhdro.ar_size, stmp, 10);
		fwrite(&arhdro, sizeof(arhdro), 1, fo);
		fwrite(buf, fsize, 1, fo);
		tcc_free(buf);
		i_obj++;
		fpos += (fsize + sizeof(arhdro));
	}
	hofs = 8 + sizeof(arhdr) + strpos + (funccnt+1) * sizeof(int);
	fpos = 0;
	if ((hofs & 1)) // align
		hofs++, fpos = 1;
	// write header
	fwrite("!<arch>\n", 8, 1, fh);
	sprintf(stmp, "%-10d", (int)(strpos + (funccnt+1) * sizeof(int)));
	memcpy(&arhdr.ar_size, stmp, 10);
	fwrite(&arhdr, sizeof(arhdr), 1, fh);
	afpos[0] = le2belong(funccnt);
	for (i=1; i<=funccnt; i++)
		afpos[i] = le2belong(afpos[i] + hofs);
	fwrite(afpos, (funccnt+1) * sizeof(int), 1, fh);
	fwrite(anames, strpos, 1, fh);
	if (fpos)
		fwrite("", 1, 1, fh);
	// write objects
	fseek(fo, 0, SEEK_END);
	fsize = ftell(fo);
	fseek(fo, 0, SEEK_SET);
	buf = tcc_malloc(fsize + 1);
	fread(buf, fsize, 1, fo);
	fwrite(buf, fsize, 1, fh);
	tcc_free(buf);
	ret = 0;
the_end:
	if (anames)
		tcc_free(anames);
	if (afpos)
		tcc_free(afpos);
	if (fh)
		fclose(fh);
	if (fo)
		fclose(fo), remove(tfile);
	return ret;
}

/* -------------------------------------------------------------- */
/*
 * tiny_impdef creates an export definition file (.def) from a dll
 * on MS-Windows. Usage: tiny_impdef library.dll [-o outputfile]"
 *
 *  Copyright (c) 2005,2007 grischka
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifdef TCC_TARGET_PE

ST_FUNC int tcc_tool_impdef(TCCState *s1, int argc, char **argv)
{
	int ret, v, i;
	char infile[260];
	char outfile[260];

	const char *file;
	char *p, *q;
	FILE *fp, *op;

#ifdef _WIN32
	char path[260];
#endif

	infile[0] = outfile[0] = 0;
	fp = op = NULL;
	ret = 1;
	p = NULL;
	v = 0;

	for (i = 1; i < argc; ++i)
	{
		const char *a = argv[i];
		if ('-' == a[0])
		{
			if (0 == strcmp(a, "-v"))
			{
				v = 1;
			}
			else if (0 == strcmp(a, "-o"))
			{
				if (++i == argc)
					goto usage;
				strcpy(outfile, argv[i]);
			}
			else
				goto usage;
		}
		else if (0 == infile[0])
			strcpy(infile, a);
		else
			goto usage;
	}

	if (0 == infile[0])
	{
usage:
		fprintf(stderr,
		        "usage: tcc -impdef library.dll [-v] [-o outputfile]\n"
		        "create export definition file (.def) from dll\n"
		       );
		goto the_end;
	}

	if (0 == outfile[0])
	{
		strcpy(outfile, tcc_basename(infile));
		q = strrchr(outfile, '.');
		if (NULL == q)
			q = strchr(outfile, 0);
		strcpy(q, ".def");
	}

	file = infile;
#ifdef _WIN32
	if (SearchPath(NULL, file, ".dll", sizeof path, path, NULL))
		file = path;
#endif
	ret = tcc_get_dllexports(file, &p);
	if (ret || !p)
	{
		fprintf(stderr, "tcc: impdef: %s '%s'\n",
		        ret == -1 ? "can't find file" :
		        ret ==  1 ? "can't read symbols" :
		        ret ==  0 ? "no symbols found in" :
		        "unknown file type", file);
		ret = 1;
		goto the_end;
	}

	if (v)
		printf("-> %s\n", file);

	op = fopen(outfile, "wb");
	if (NULL == op)
	{
		fprintf(stderr, "tcc: impdef: could not create output file: %s\n", outfile);
		goto the_end;
	}

	fprintf(op, "LIBRARY %s\n\nEXPORTS\n", tcc_basename(file));
	for (q = p, i = 0; *q; ++i)
	{
		fprintf(op, "%s\n", q);
		q += strlen(q) + 1;
	}

	if (v)
		printf("<- %s (%d symbol%s)\n", outfile, i, &"s"[i<2]);

	ret = 0;

the_end:
	/* cannot free memory received from tcc_get_dllexports
	   if it came from a dll */
	/* if (p)
	    tcc_free(p); */
	if (fp)
		fclose(fp);
	if (op)
		fclose(op);
	return ret;
}

#endif /* TCC_TARGET_PE */

/* -------------------------------------------------------------- */
/*
 *  TCC - Tiny C Compiler
 *
 *  Copyright (c) 2001-2004 Fabrice Bellard
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/* re-execute the i386/x86_64 cross-compilers with tcc -m32/-m64: */

#if !defined TCC_TARGET_I386 && !defined TCC_TARGET_X86_64

ST_FUNC void tcc_tool_cross(TCCState *s1, char **argv, int option)
{
	tcc_error("-m%d not implemented.", option);
}

#else
#ifdef _WIN32
#include <process.h>

static char *str_replace(const char *str, const char *p, const char *r)
{
	const char *s, *s0;
	char *d, *d0;
	int sl, pl, rl;

	sl = strlen(str);
	pl = strlen(p);
	rl = strlen(r);
	for (d0 = NULL;; d0 = tcc_malloc(sl + 1))
	{
		for (d = d0, s = str; s0 = s, s = strstr(s, p), s; s += pl)
		{
			if (d)
			{
				memcpy(d, s0, sl = s - s0), d += sl;
				memcpy(d, r, rl), d += rl;
			}
			else
				sl += rl - pl;
		}
		if (d)
		{
			strcpy(d, s0);
			return d0;
		}
	}
}

static int execvp_win32(const char *prog, char **argv)
{
	int ret;
	char **p;
	/* replace all " by \" */
	for (p = argv; *p; ++p)
		if (strchr(*p, '"'))
			*p = str_replace(*p, "\"", "\\\"");
	ret = _spawnvp(P_NOWAIT, prog, (const char *const*)argv);
	if (-1 == ret)
		return ret;
	_cwait(&ret, ret, WAIT_CHILD);
	exit(ret);
}
#define execvp execvp_win32
#endif /* _WIN32 */

ST_FUNC void tcc_tool_cross(TCCState *s1, char **argv, int target)
{
	char program[4096];
	char *a0 = argv[0];
	int prefix = tcc_basename(a0) - a0;

	snprintf(program, sizeof program,
	         "%.*s%s"
#ifdef TCC_TARGET_PE
	         "-win32"
#endif
	         "-tcc"
#ifdef _WIN32
	         ".exe"
#endif
	         , prefix, a0, target == 64 ? "x86_64" : "i386");

	if (strcmp(a0, program))
		execvp(argv[0] = program, argv);
	tcc_error("could not run '%s'", program);
}

#endif /* TCC_TARGET_I386 && TCC_TARGET_X86_64 */
/* -------------------------------------------------------------- */
/* enable commandline wildcard expansion (tcc -o x.exe *.c) */

#ifdef _WIN32
int _CRT_glob = 1;
#ifndef _CRT_glob
int _dowildcard = 1;
#endif
#endif

/* -------------------------------------------------------------- */
/* generate xxx.d file */

ST_FUNC void gen_makedeps(TCCState *s1, const char *target, const char *filename)
{
	FILE *depout;
	char buf[1024];
	int i;

	if (!filename)
	{
		/* compute filename automatically: dir/file.o -> dir/file.d */
		snprintf(buf, sizeof buf, "%.*s.d",
		         (int)(tcc_fileextension(target) - target), target);
		filename = buf;
	}

	if (s1->verbose)
		printf("<- %s\n", filename);

	/* XXX return err codes instead of error() ? */
	depout = fopen(filename, "w");
	if (!depout)
		tcc_error("could not open '%s'", filename);

	fprintf(depout, "%s: \\\n", target);
	for (i=0; i<s1->nb_target_deps; ++i)
		fprintf(depout, " %s \\\n", s1->target_deps[i]);
	fprintf(depout, "\n");
	fclose(depout);
}

/* -------------------------------------------------------------- */
//END tcctools.c

//START tcc.c

static const char help[] =
    "Tiny C Compiler "TCC_VERSION" - Copyright (C) 2001-2006 Fabrice Bellard\n"
    "Usage: tcc [options...] [-o outfile] [-c] infile(s)...\n"
    "       tcc [options...] -run infile [arguments...]\n"
    "General options:\n"
    "  -c          compile only - generate an object file\n"
    "  -o outfile  set output filename\n"
    "  -run        run compiled source\n"
    "  -fflag      set or reset (with 'no-' prefix) 'flag' (see tcc -hh)\n"
    "  -std=c99    Conform to the ISO 1999 C standard (default).\n"
    "  -std=c11    Conform to the ISO 2011 C standard.\n"
    "  -Wwarning   set or reset (with 'no-' prefix) 'warning' (see tcc -hh)\n"
    "  -w          disable all warnings\n"
    "  -v -vv      show version, show search paths or loaded files\n"
    "  -h -hh      show this, show more help\n"
    "  -bench      show compilation statistics\n"
    "  -           use stdin pipe as infile\n"
    "  @listfile   read arguments from listfile\n"
    "Preprocessor options:\n"
    "  -Idir       add include path 'dir'\n"
    "  -Dsym[=val] define 'sym' with value 'val'\n"
    "  -Usym       undefine 'sym'\n"
    "  -E          preprocess only\n"
    "Linker options:\n"
    "  -Ldir       add library path 'dir'\n"
    "  -llib       link with dynamic or static library 'lib'\n"
    "  -r          generate (relocatable) object file\n"
    "  -shared     generate a shared library/dll\n"
    "  -rdynamic   export all global symbols to dynamic linker\n"
    "  -soname     set name for shared library to be used at runtime\n"
    "  -Wl,-opt[=val]  set linker option (see tcc -hh)\n"
    "Debugger options:\n"
    "  -g          generate runtime debug info\n"
#ifdef CONFIG_TCC_BCHECK
    "  -b          compile with built-in memory and bounds checker (implies -g)\n"
#endif
#ifdef CONFIG_TCC_BACKTRACE
    "  -bt[N]      link with backtrace (stack dump) support [show max N callers]\n"
#endif
    "Misc. options:\n"
    "  -x[c|a|b|n] specify type of the next infile (C,ASM,BIN,NONE)\n"
    "  -nostdinc   do not use standard system include paths\n"
    "  -nostdlib   do not link with standard crt and libraries\n"
    "  -Bdir       set tcc's private include/library dir\n"
    "  -MD         generate dependency file for make\n"
    "  -MF file    specify dependency file name\n"
    "  -m32/64     defer to i386/x86_64 cross compiler\n"
    "Tools:\n"
    "  create library  : tcc -ar [rcsv] lib.a files\n"
#ifdef TCC_TARGET_PE
    "  create def file : tcc -impdef lib.dll [-v] [-o lib.def]\n"
#endif
    ;

static const char help2[] =
    "Tiny C Compiler "TCC_VERSION" - More Options\n"
    "Special options:\n"
    "  -P -P1                        with -E: no/alternative #line output\n"
    "  -dD -dM                       with -E: output #define directives\n"
    "  -pthread                      same as -D_REENTRANT and -lpthread\n"
    "  -On                           same as -D__OPTIMIZE__ for n > 0\n"
    "  -Wp,-opt                      same as -opt\n"
    "  -include file                 include 'file' above each input file\n"
    "  -isystem dir                  add 'dir' to system include path\n"
    "  -static                       link to static libraries (not recommended)\n"
    "  -dumpversion                  print version\n"
    "  -print-search-dirs            print search paths\n"
    "  -dt                           with -run/-E: auto-define 'test_...' macros\n"
    "Ignored options:\n"
    "  --param  -pedantic  -pipe  -s  -traditional\n"
    "-W... warnings:\n"
    "  all                           turn on some (*) warnings\n"
    "  error                         stop after first warning\n"
    "  unsupported                   warn about ignored options, pragmas, etc.\n"
    "  write-strings                 strings are const\n"
    "  implicit-function-declaration warn for missing prototype (*)\n"
    "-f[no-]... flags:\n"
    "  unsigned-char                 default char is unsigned\n"
    "  signed-char                   default char is signed\n"
    "  common                        use common section instead of bss\n"
    "  leading-underscore            decorate extern symbols\n"
    "  ms-extensions                 allow anonymous struct in struct\n"
    "  dollars-in-identifiers        allow '$' in C symbols\n"
    "-m... target specific options:\n"
    "  ms-bitfields                  use MSVC bitfield layout\n"
#ifdef TCC_TARGET_ARM
    "  float-abi                     hard/softfp on arm\n"
#endif
#ifdef TCC_TARGET_X86_64
    "  no-sse                        disable floats on x86_64\n"
#endif
    "-Wl,... linker options:\n"
    "  -nostdlib                     do not link with standard crt/libs\n"
    "  -[no-]whole-archive           load lib(s) fully/only as needed\n"
    "  -export-all-symbols           same as -rdynamic\n"
    "  -export-dynamic               same as -rdynamic\n"
    "  -image-base= -Ttext=          set base address of executable\n"
    "  -section-alignment=           set section alignment in executable\n"
#ifdef TCC_TARGET_PE
    "  -file-alignment=              set PE file alignment\n"
    "  -stack=                       set PE stack reserve\n"
    "  -large-address-aware          set related PE option\n"
    "  -subsystem=[console/windows]  set PE subsystem\n"
    "  -oformat=[pe-* binary]        set executable output format\n"
    "Predefined macros:\n"
    "  tcc -E -dM - < nul\n"
#else
    "  -rpath=                       set dynamic library search path\n"
    "  -enable-new-dtags             set DT_RUNPATH instead of DT_RPATH\n"
    "  -soname=                      set DT_SONAME elf tag\n"
    "  -Bsymbolic                    set DT_SYMBOLIC elf tag\n"
    "  -oformat=[elf32/64-* binary]  set executable output format\n"
    "  -init= -fini= -as-needed -O   (ignored)\n"
    "Predefined macros:\n"
    "  tcc -E -dM - < /dev/null\n"
#endif
    "See also the manual for more details.\n"
    ;

static const char version[] =
    "tcc version "TCC_VERSION" ("
#ifdef TCC_TARGET_I386
    "i386"
#elif defined TCC_TARGET_X86_64
    "x86_64"
#elif defined TCC_TARGET_C67
    "C67"
#elif defined TCC_TARGET_ARM
    "ARM"
#elif defined TCC_TARGET_ARM64
    "AArch64"
#endif
#ifdef TCC_ARM_HARDFLOAT
    " Hard Float"
#endif
#ifdef TCC_TARGET_PE
    " Windows"
#elif defined(TCC_TARGET_MACHO)
    " Darwin"
#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
    " FreeBSD"
#else
    " Linux"
#endif
    ")\n"
    ;

static void print_dirs(const char *msg, char **paths, int nb_paths)
{
	int i;
	printf("%s:\n%s", msg, nb_paths ? "" : "  -\n");
	for(i = 0; i < nb_paths; i++)
		printf("  %s\n", paths[i]);
}

static void print_search_dirs(TCCState *s)
{
	printf("install: %s\n", s->tcc_lib_path);
	/* print_dirs("programs", NULL, 0); */
	print_dirs("include", s->sysinclude_paths, s->nb_sysinclude_paths);
	print_dirs("libraries", s->library_paths, s->nb_library_paths);
#ifdef TCC_LIBTCC1
#ifdef TCC_TARGET_PE
	printf("libtcc1:\n  %s/lib/"TCC_LIBTCC1"\n", s->tcc_lib_path);
#else
	printf("libtcc1:\n  %s/"TCC_LIBTCC1"\n", s->tcc_lib_path);
	print_dirs("crt", s->crt_paths, s->nb_crt_paths);
	printf("elfinterp:\n  %s\n",  DEFAULT_ELFINTERP(s));
#endif
#endif
}

static void set_environment(TCCState *s)
{
	char * path;

	path = getenv("C_INCLUDE_PATH");
	if(path != NULL)
	{
		tcc_add_sysinclude_path(s, path);
	}
	path = getenv("CPATH");
	if(path != NULL)
	{
		tcc_add_include_path(s, path);
	}
	path = getenv("LIBRARY_PATH");
	if(path != NULL)
	{
		tcc_add_library_path(s, path);
	}
}

static char *default_outputfile(TCCState *s, const char *first_file)
{
	char buf[1024];
	char *ext;
	const char *name = "a";

	if (first_file && strcmp(first_file, "-"))
		name = tcc_basename(first_file);
	snprintf(buf, sizeof(buf), "%s", name);
	ext = tcc_fileextension(buf);
#ifdef TCC_TARGET_PE
	if (s->output_type == TCC_OUTPUT_DLL)
		strcpy(ext, ".dll");
	else if (s->output_type == TCC_OUTPUT_EXE)
		strcpy(ext, ".exe");
	else
#endif
		if (s->output_type == TCC_OUTPUT_OBJ && !s->option_r && *ext)
			strcpy(ext, ".o");
		else
			strcpy(buf, "a.out");
	return tcc_strdup(buf);
}

static unsigned getclock_ms(void)
{
#ifdef _WIN32
	return GetTickCount();
#else
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return tv.tv_sec*1000 + (tv.tv_usec+500)/1000;
#endif
}


//END tcc.c


#endif /* _TCC_H */


//START x86_64-asm.h

#ifdef X86ASMOPCODE

DEF_ASM_OP0(clc, 0xf8) /* must be first OP0 */
DEF_ASM_OP0(cld, 0xfc)
DEF_ASM_OP0(cli, 0xfa)
DEF_ASM_OP0(clts, 0x0f06)
DEF_ASM_OP0(cmc, 0xf5)
DEF_ASM_OP0(lahf, 0x9f)
DEF_ASM_OP0(sahf, 0x9e)
DEF_ASM_OP0(pushfq, 0x9c)
DEF_ASM_OP0(popfq, 0x9d)
DEF_ASM_OP0(pushf, 0x9c)
DEF_ASM_OP0(popf, 0x9d)
DEF_ASM_OP0(stc, 0xf9)
DEF_ASM_OP0(std, 0xfd)
DEF_ASM_OP0(sti, 0xfb)
DEF_ASM_OP0(aaa, 0x37)
DEF_ASM_OP0(aas, 0x3f)
DEF_ASM_OP0(daa, 0x27)
DEF_ASM_OP0(das, 0x2f)
DEF_ASM_OP0(aad, 0xd50a)
DEF_ASM_OP0(aam, 0xd40a)
DEF_ASM_OP0(cbw, 0x6698)
DEF_ASM_OP0(cwd, 0x6699)
DEF_ASM_OP0(cwde, 0x98)
DEF_ASM_OP0(cdq, 0x99)
DEF_ASM_OP0(cbtw, 0x6698)
DEF_ASM_OP0(cwtl, 0x98)
DEF_ASM_OP0(cwtd, 0x6699)
DEF_ASM_OP0(cltd, 0x99)
DEF_ASM_OP0(cqto, 0x4899)
DEF_ASM_OP0(int3, 0xcc)
DEF_ASM_OP0(into, 0xce)
DEF_ASM_OP0(iret, 0xcf)
DEF_ASM_OP0(rsm, 0x0faa)
DEF_ASM_OP0(hlt, 0xf4)
DEF_ASM_OP0(wait, 0x9b)
DEF_ASM_OP0(nop, 0x90)
DEF_ASM_OP0(pause, 0xf390)
DEF_ASM_OP0(xlat, 0xd7)

/* strings */
ALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))
ALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))

ALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWLX))

/* bits */

ALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))

ALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

ALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

ALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

ALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

/* prefixes */
DEF_ASM_OP0(lock, 0xf0)
DEF_ASM_OP0(rep, 0xf3)
DEF_ASM_OP0(repe, 0xf3)
DEF_ASM_OP0(repz, 0xf3)
DEF_ASM_OP0(repne, 0xf2)
DEF_ASM_OP0(repnz, 0xf2)

DEF_ASM_OP0(invd, 0x0f08)
DEF_ASM_OP0(wbinvd, 0x0f09)
DEF_ASM_OP0(cpuid, 0x0fa2)
DEF_ASM_OP0(wrmsr, 0x0f30)
DEF_ASM_OP0(rdtsc, 0x0f31)
DEF_ASM_OP0(rdmsr, 0x0f32)
DEF_ASM_OP0(rdpmc, 0x0f33)

DEF_ASM_OP0(syscall, 0x0f05)
DEF_ASM_OP0(sysret, 0x0f07)
DEF_ASM_OP0L(sysretq, 0x480f07, 0, 0)
DEF_ASM_OP0(ud2, 0x0f0b)

/* NOTE: we took the same order as gas opcode definition order */
/* Right now we can't express the fact that 0xa1/0xa3 can't use $eax and a
   32 bit moffset as operands.
ALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWLX, OPT_ADDR, OPT_EAX))
ALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWLX, OPT_EAX, OPT_ADDR)) */
ALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))
/* The moves are special: the 0xb8 form supports IM64 (the only insn that
   does) with REG64.  It doesn't support IM32 with REG64, it would use
   the full movabs form (64bit immediate).  For IM32->REG64 we prefer
   the 0xc7 opcode.  So disallow all 64bit forms and code the rest by hand. */
ALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWLX, OPT_IM, OPT_REG))
ALT(DEF_ASM_OP2(mov,  0xb8, 0, OPC_REG, OPT_IM64, OPT_REG64))
ALT(DEF_ASM_OP2(movq, 0xb8, 0, OPC_REG, OPT_IM64, OPT_REG64))
ALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WLX, OPT_SEG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_SEG))

ALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WLX, OPT_CR, OPT_REG64))
ALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WLX, OPT_DB, OPT_REG64))
ALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WLX, OPT_REG64, OPT_CR))
ALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WLX, OPT_REG64, OPT_DB))

ALT(DEF_ASM_OP2(movsbw, 0x660fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG16))
ALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(movsbq, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(movswq, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG))
ALT(DEF_ASM_OP2(movslq, 0x63, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG))
ALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WLX, OPT_REG8 | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(movzwq, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG))

ALT(DEF_ASM_OP1(pushq, 0x6a, 0, 0, OPT_IM8S))
ALT(DEF_ASM_OP1(push, 0x6a, 0, 0, OPT_IM8S))
ALT(DEF_ASM_OP1(pushw, 0x666a, 0, 0, OPT_IM8S))
ALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WLX, OPT_REG64))
ALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WLX, OPT_REG16))
ALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WLX, OPT_REG64 | OPT_EA))
ALT(DEF_ASM_OP1(pushw, 0x6668, 0, 0, OPT_IM16))
ALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WLX, OPT_IM32))
ALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WLX, OPT_SEG))

ALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WLX, OPT_REG64))
ALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WLX, OPT_REG16))
ALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WLX, OPT_SEG))

ALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_REGW, OPT_EAX))
ALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_EAX, OPT_REGW))
ALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))

ALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))
ALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))
ALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))
ALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))

ALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))
ALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))
ALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))
ALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))

ALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WLX, OPT_EA, OPT_REG))

ALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))

/* arith */
ALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */
ALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))
ALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWLX, OPT_IM, OPT_EAX))
ALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))

ALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))
ALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWLX, OPT_IM, OPT_EAX))
ALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))

ALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))
ALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW))
ALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW))

ALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))
ALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))

/* shifts */
ALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_EA | OPT_REG))

ALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))

ALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))
ALT(DEF_ASM_OP1(call, 0xe8, 0, 0, OPT_DISP))
ALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))
ALT(DEF_ASM_OP1(jmp, 0xeb, 0, 0, OPT_DISP8))

ALT(DEF_ASM_OP1(lcall, 0xff, 3, OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP1(ljmp, 0xff, 5, OPC_MODRM, OPT_EA))
DEF_ASM_OP1(ljmpw, 0x66ff, 5, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(ljmpl, 0xff, 5, OPC_MODRM, OPT_EA)

ALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))
ALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))
ALT(DEF_ASM_OP1(setob, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))
DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)
DEF_ASM_OP0(leave, 0xc9)
DEF_ASM_OP0(ret, 0xc3)
DEF_ASM_OP0(retq, 0xc3)
ALT(DEF_ASM_OP1(retq, 0xc2, 0, 0, OPT_IM16))
ALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))
DEF_ASM_OP0(lret, 0xcb)
ALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))

ALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_TEST, OPT_DISP8))
DEF_ASM_OP1(loopne, 0xe0, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loopnz, 0xe0, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loope, 0xe1, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loopz, 0xe1, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loop, 0xe2, 0, 0, OPT_DISP8)
DEF_ASM_OP1(jecxz, 0x67e3, 0, 0, OPT_DISP8)

/* float */
/* specific fcomp handling */
ALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))

ALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))
ALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))
ALT(DEF_ASM_OP2(fadd, 0xdcc0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))
ALT(DEF_ASM_OP2(fmul, 0xdcc8, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))
ALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))
ALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))
ALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))
ALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))
ALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))
ALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))

DEF_ASM_OP0(fucompp, 0xdae9)
DEF_ASM_OP0(ftst, 0xd9e4)
DEF_ASM_OP0(fxam, 0xd9e5)
DEF_ASM_OP0(fld1, 0xd9e8)
DEF_ASM_OP0(fldl2t, 0xd9e9)
DEF_ASM_OP0(fldl2e, 0xd9ea)
DEF_ASM_OP0(fldpi, 0xd9eb)
DEF_ASM_OP0(fldlg2, 0xd9ec)
DEF_ASM_OP0(fldln2, 0xd9ed)
DEF_ASM_OP0(fldz, 0xd9ee)

DEF_ASM_OP0(f2xm1, 0xd9f0)
DEF_ASM_OP0(fyl2x, 0xd9f1)
DEF_ASM_OP0(fptan, 0xd9f2)
DEF_ASM_OP0(fpatan, 0xd9f3)
DEF_ASM_OP0(fxtract, 0xd9f4)
DEF_ASM_OP0(fprem1, 0xd9f5)
DEF_ASM_OP0(fdecstp, 0xd9f6)
DEF_ASM_OP0(fincstp, 0xd9f7)
DEF_ASM_OP0(fprem, 0xd9f8)
DEF_ASM_OP0(fyl2xp1, 0xd9f9)
DEF_ASM_OP0(fsqrt, 0xd9fa)
DEF_ASM_OP0(fsincos, 0xd9fb)
DEF_ASM_OP0(frndint, 0xd9fc)
DEF_ASM_OP0(fscale, 0xd9fd)
DEF_ASM_OP0(fsin, 0xd9fe)
DEF_ASM_OP0(fcos, 0xd9ff)
DEF_ASM_OP0(fchs, 0xd9e0)
DEF_ASM_OP0(fabs, 0xd9e1)
DEF_ASM_OP0(fninit, 0xdbe3)
DEF_ASM_OP0(fnclex, 0xdbe2)
DEF_ASM_OP0(fnop, 0xd9d0)
DEF_ASM_OP0(fwait, 0x9b)

/* fp load */
DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)
ALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))
DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)
DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)

/* fp store */
DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)
ALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))
DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)

DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)

/* exchange */
DEF_ASM_OP0(fxch, 0xd9c9)
ALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))

/* misc FPU */
DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )
DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )

DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)
DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )
DEF_ASM_OP0(fnstsw, 0xdfe0)
ALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))
ALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))
DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )
ALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))
ALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))
DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)
DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )
DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )
DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )
DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )
DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )
/* The *q forms of fxrstor/fxsave use a REX prefix.
   If the operand would use extended registers we would have to modify
   it instead of generating a second one.  Currently that's no
   problem with TCC, we don't use extended registers.  */
DEF_ASM_OP1(fxsaveq, 0x0fae, 0, OPC_MODRM | OPC_48, OPT_EA )
DEF_ASM_OP1(fxrstorq, 0x0fae, 1, OPC_MODRM | OPC_48, OPT_EA )

/* segments */
DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)
ALT(DEF_ASM_OP2(larw, 0x0f02, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))
DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(lgdtq, 0x0f01, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(lidtq, 0x0f01, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)
DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)
ALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_REG))
DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG16)
DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(sgdtq, 0x0f01, 0, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(sidtq, 0x0f01, 1, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)
DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)
DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG32 | OPT_EA)
ALT(DEF_ASM_OP1(str, 0x660f00, 1, OPC_MODRM, OPT_REG16))
ALT(DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM | OPC_48, OPT_REG64))
DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)
DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)
DEF_ASM_OP0L(swapgs, 0x0f01, 7, OPC_MODRM)

/* 486 */
/* bswap can't be applied to 16bit regs */
DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )
DEF_ASM_OP1(bswapl, 0x0fc8, 0, OPC_REG, OPT_REG32 )
DEF_ASM_OP1(bswapq, 0x0fc8, 0, OPC_REG | OPC_48, OPT_REG64 )

ALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))
ALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))
DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )

/* pentium */
DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )

/* AMD 64 */
DEF_ASM_OP1(cmpxchg16b, 0x0fc7, 1, OPC_MODRM | OPC_48, OPT_EA )

/* pentium pro */
ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))

DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )

DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )

/* mmx */
DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */
DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMXSSE )
/* movd shouldn't accept REG64, but AMD64 spec uses it for 32 and 64 bit
   moves, so let's be compatible. */
ALT(DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG64, OPT_MMXSSE ))
ALT(DEF_ASM_OP2(movq, 0x0f6e, 0, OPC_MODRM | OPC_48, OPT_REG64, OPT_MMXSSE ))
ALT(DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX ))
ALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG32 ))
ALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG64 ))
ALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))
ALT(DEF_ASM_OP2(movq, 0x660fd6, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_SSE ))
ALT(DEF_ASM_OP2(movq, 0xf30f7e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE ))
ALT(DEF_ASM_OP2(movq, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG64 ))

DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )

/* sse */
DEF_ASM_OP2(movups, 0x0f10, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )
ALT(DEF_ASM_OP2(movups, 0x0f11, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))
DEF_ASM_OP2(movaps, 0x0f28, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )
ALT(DEF_ASM_OP2(movaps, 0x0f29, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))
DEF_ASM_OP2(movhps, 0x0f16, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )
ALT(DEF_ASM_OP2(movhps, 0x0f17, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))
DEF_ASM_OP2(addps, 0x0f58, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(cvtpi2ps, 0x0f2a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_SSE )
DEF_ASM_OP2(cvtps2pi, 0x0f2d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )
DEF_ASM_OP2(cvttps2pi, 0x0f2c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )
DEF_ASM_OP2(divps, 0x0f5e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(maxps, 0x0f5f, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(minps, 0x0f5d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(mulps, 0x0f59, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(pavgb, 0x0fe0, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(pavgw, 0x0fe3, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(pmaxsw, 0x0fee, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmaxub, 0x0fde, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pminsw, 0x0fea, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pminub, 0x0fda, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(rcpss, 0x0f53, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(rsqrtps, 0x0f52, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(sqrtps, 0x0f51, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(subps, 0x0f5c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )

DEF_ASM_OP1(prefetchnta, 0x0f18, 0, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(prefetcht0, 0x0f18, 1, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(prefetcht1, 0x0f18, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(prefetcht2, 0x0f18, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(prefetchw, 0x0f0d, 1, OPC_MODRM, OPT_EA)
DEF_ASM_OP0L(lfence, 0x0fae, 5, OPC_MODRM)
DEF_ASM_OP0L(mfence, 0x0fae, 6, OPC_MODRM)
DEF_ASM_OP0L(sfence, 0x0fae, 7, OPC_MODRM)
DEF_ASM_OP1(clflush, 0x0fae, 7, OPC_MODRM, OPT_EA)
#undef ALT
#undef DEF_ASM_OP0
#undef DEF_ASM_OP0L
#undef DEF_ASM_OP1
#undef DEF_ASM_OP2
#undef DEF_ASM_OP3

#undef X86ASMOPCODE
#endif

//END x86_64-asm.h

//START i386-asm.h

#ifdef i386ASMOPCODE

DEF_ASM_OP0(clc, 0xf8) /* must be first OP0 */
DEF_ASM_OP0(cld, 0xfc)
DEF_ASM_OP0(cli, 0xfa)
DEF_ASM_OP0(clts, 0x0f06)
DEF_ASM_OP0(cmc, 0xf5)
DEF_ASM_OP0(lahf, 0x9f)
DEF_ASM_OP0(sahf, 0x9e)
DEF_ASM_OP0(pusha, 0x60)
DEF_ASM_OP0(popa, 0x61)
DEF_ASM_OP0(pushfl, 0x9c)
DEF_ASM_OP0(popfl, 0x9d)
DEF_ASM_OP0(pushf, 0x9c)
DEF_ASM_OP0(popf, 0x9d)
DEF_ASM_OP0(stc, 0xf9)
DEF_ASM_OP0(std, 0xfd)
DEF_ASM_OP0(sti, 0xfb)
DEF_ASM_OP0(aaa, 0x37)
DEF_ASM_OP0(aas, 0x3f)
DEF_ASM_OP0(daa, 0x27)
DEF_ASM_OP0(das, 0x2f)
DEF_ASM_OP0(aad, 0xd50a)
DEF_ASM_OP0(aam, 0xd40a)
DEF_ASM_OP0(cbw, 0x6698)
DEF_ASM_OP0(cwd, 0x6699)
DEF_ASM_OP0(cwde, 0x98)
DEF_ASM_OP0(cdq, 0x99)
DEF_ASM_OP0(cbtw, 0x6698)
DEF_ASM_OP0(cwtl, 0x98)
DEF_ASM_OP0(cwtd, 0x6699)
DEF_ASM_OP0(cltd, 0x99)
DEF_ASM_OP0(int3, 0xcc)
DEF_ASM_OP0(into, 0xce)
DEF_ASM_OP0(iret, 0xcf)
DEF_ASM_OP0(rsm, 0x0faa)
DEF_ASM_OP0(hlt, 0xf4)
DEF_ASM_OP0(nop, 0x90)
DEF_ASM_OP0(pause, 0xf390)
DEF_ASM_OP0(xlat, 0xd7)

/* strings */
ALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))
ALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))

ALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWLX))

ALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWLX))
ALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWLX))

/* bits */

ALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))

ALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

ALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

ALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

ALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW | OPT_EA))

/* prefixes */
DEF_ASM_OP0(wait, 0x9b)
DEF_ASM_OP0(fwait, 0x9b)
DEF_ASM_OP0(aword, 0x67)
DEF_ASM_OP0(addr16, 0x67)
ALT(DEF_ASM_OP0(word, 0x66))
DEF_ASM_OP0(data16, 0x66)
DEF_ASM_OP0(lock, 0xf0)
DEF_ASM_OP0(rep, 0xf3)
DEF_ASM_OP0(repe, 0xf3)
DEF_ASM_OP0(repz, 0xf3)
DEF_ASM_OP0(repne, 0xf2)
DEF_ASM_OP0(repnz, 0xf2)

DEF_ASM_OP0(invd, 0x0f08)
DEF_ASM_OP0(wbinvd, 0x0f09)
DEF_ASM_OP0(cpuid, 0x0fa2)
DEF_ASM_OP0(wrmsr, 0x0f30)
DEF_ASM_OP0(rdtsc, 0x0f31)
DEF_ASM_OP0(rdmsr, 0x0f32)
DEF_ASM_OP0(rdpmc, 0x0f33)
DEF_ASM_OP0(ud2, 0x0f0b)

/* NOTE: we took the same order as gas opcode definition order */
ALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWLX, OPT_ADDR, OPT_EAX))
ALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWLX, OPT_EAX, OPT_ADDR))
ALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))
ALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWLX, OPT_IM, OPT_REG))
ALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WLX, OPT_SEG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_SEG))

ALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WLX, OPT_CR, OPT_REG32))
ALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WLX, OPT_DB, OPT_REG32))
ALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WLX, OPT_TR, OPT_REG32))
ALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WLX, OPT_REG32, OPT_CR))
ALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WLX, OPT_REG32, OPT_DB))
ALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WLX, OPT_REG32, OPT_TR))

ALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(movsbw, 0x660fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG16))
ALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WLX, OPT_REG8 | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))

ALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WLX, OPT_REGW))
ALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WLX, OPT_IM8S))
ALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WLX, OPT_IM32))
ALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WLX, OPT_SEG))

ALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WLX, OPT_REGW))
ALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WLX, OPT_REGW | OPT_EA))
ALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WLX, OPT_SEG))

ALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_REGW, OPT_EAX))
ALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WLX, OPT_EAX, OPT_REGW))
ALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))

ALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))
ALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))
ALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))
ALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))

ALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))
ALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))
ALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))
ALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))

ALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WLX, OPT_EA, OPT_REG))

ALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))
ALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))

/* arith */
ALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */
ALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))
ALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWLX, OPT_IM, OPT_EAX))
ALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))

ALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWLX, OPT_EA | OPT_REG, OPT_REG))
ALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWLX, OPT_IM, OPT_EAX))
ALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWLX, OPT_IM, OPT_EA | OPT_REG))

ALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WLX, OPT_REGW))
ALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WLX, OPT_REGW))
ALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))

ALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))
ALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WLX, OPT_IM8S, OPT_REGW))
ALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))
ALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WLX, OPT_IMW, OPT_REGW))

ALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))
ALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA))
ALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWLX, OPT_REG | OPT_EA, OPT_EAX))

/* shifts */
ALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))
ALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWLX | OPC_SHIFT, OPT_EA | OPT_REG))

ALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WLX, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))
ALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WLX, OPT_REGW, OPT_EA | OPT_REGW))

ALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))
ALT(DEF_ASM_OP1(call, 0xe8, 0, 0, OPT_DISP))
ALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))
ALT(DEF_ASM_OP1(jmp, 0xeb, 0, 0, OPT_DISP8))

ALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))
ALT(DEF_ASM_OP1(lcall, 0xff, 3, OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))
ALT(DEF_ASM_OP1(ljmp, 0xff, 5, OPC_MODRM, OPT_EA))

ALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))
ALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))
ALT(DEF_ASM_OP1(setob, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))
DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)
DEF_ASM_OP0(leave, 0xc9)
DEF_ASM_OP0(ret, 0xc3)
DEF_ASM_OP0(retl,0xc3)
ALT(DEF_ASM_OP1(retl,0xc2, 0, 0, OPT_IM16))
ALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))
DEF_ASM_OP0(lret, 0xcb)
ALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))

ALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_TEST, OPT_DISP8))
DEF_ASM_OP1(loopne, 0xe0, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loopnz, 0xe0, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loope, 0xe1, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loopz, 0xe1, 0, 0, OPT_DISP8)
DEF_ASM_OP1(loop, 0xe2, 0, 0, OPT_DISP8)
DEF_ASM_OP1(jecxz, 0xe3, 0, 0, OPT_DISP8)

/* float */
/* specific fcomp handling */
ALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))

ALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))
ALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))
ALT(DEF_ASM_OP2(fadd, 0xdcc0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))
ALT(DEF_ASM_OP2(fmul, 0xdcc8, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))
ALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))
ALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))
ALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))
ALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))
ALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))
ALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))
ALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))

DEF_ASM_OP0(fucompp, 0xdae9)
DEF_ASM_OP0(ftst, 0xd9e4)
DEF_ASM_OP0(fxam, 0xd9e5)
DEF_ASM_OP0(fld1, 0xd9e8)
DEF_ASM_OP0(fldl2t, 0xd9e9)
DEF_ASM_OP0(fldl2e, 0xd9ea)
DEF_ASM_OP0(fldpi, 0xd9eb)
DEF_ASM_OP0(fldlg2, 0xd9ec)
DEF_ASM_OP0(fldln2, 0xd9ed)
DEF_ASM_OP0(fldz, 0xd9ee)

DEF_ASM_OP0(f2xm1, 0xd9f0)
DEF_ASM_OP0(fyl2x, 0xd9f1)
DEF_ASM_OP0(fptan, 0xd9f2)
DEF_ASM_OP0(fpatan, 0xd9f3)
DEF_ASM_OP0(fxtract, 0xd9f4)
DEF_ASM_OP0(fprem1, 0xd9f5)
DEF_ASM_OP0(fdecstp, 0xd9f6)
DEF_ASM_OP0(fincstp, 0xd9f7)
DEF_ASM_OP0(fprem, 0xd9f8)
DEF_ASM_OP0(fyl2xp1, 0xd9f9)
DEF_ASM_OP0(fsqrt, 0xd9fa)
DEF_ASM_OP0(fsincos, 0xd9fb)
DEF_ASM_OP0(frndint, 0xd9fc)
DEF_ASM_OP0(fscale, 0xd9fd)
DEF_ASM_OP0(fsin, 0xd9fe)
DEF_ASM_OP0(fcos, 0xd9ff)
DEF_ASM_OP0(fchs, 0xd9e0)
DEF_ASM_OP0(fabs, 0xd9e1)
DEF_ASM_OP0(fninit, 0xdbe3)
DEF_ASM_OP0(fnclex, 0xdbe2)
DEF_ASM_OP0(fnop, 0xd9d0)

/* fp load */
DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)
ALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))
DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)
DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)

/* fp store */
DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)
ALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))
DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)

DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)
DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)

/* exchange */
DEF_ASM_OP0(fxch, 0xd9c9)
ALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))

/* misc FPU */
DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )
DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )

DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)
DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )
DEF_ASM_OP0(fnstsw, 0xdfe0)
ALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))
ALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))
DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )
ALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))
ALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))
DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)
DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )
DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )
DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )
DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )
DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )
DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )

/* segments */
DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)
ALT(DEF_ASM_OP2(larw, 0x0f02, 0, OPC_MODRM | OPC_WLX, OPT_REG | OPT_EA, OPT_REG))
DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)
DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)
ALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WLX, OPT_EA | OPT_REG, OPT_REG))
DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)
DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)
DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)
DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)
DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)
DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)
DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)

/* 486 */
DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )
ALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))
ALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWLX, OPT_REG, OPT_REG | OPT_EA ))
DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )

DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)
DEF_ASM_OP2(boundw, 0x6662, 0, OPC_MODRM, OPT_REG16, OPT_EA)

/* pentium */
DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )

/* pentium pro */
ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST | OPC_WLX, OPT_REGW | OPT_EA, OPT_REGW))
DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )

DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )
DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )

/* mmx */
DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */
DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMXSSE )
DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )
ALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMXSSE, OPT_EA | OPT_REG32 ))
ALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))
ALT(DEF_ASM_OP2(movq, 0x660fd6, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_SSE ))
ALT(DEF_ASM_OP2(movq, 0xf30f7e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE ))

DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
ALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMXSSE ))
DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )

/* sse */
DEF_ASM_OP2(movups, 0x0f10, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )
ALT(DEF_ASM_OP2(movups, 0x0f11, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))
DEF_ASM_OP2(movaps, 0x0f28, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )
ALT(DEF_ASM_OP2(movaps, 0x0f29, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))
DEF_ASM_OP2(movhps, 0x0f16, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_SSE )
ALT(DEF_ASM_OP2(movhps, 0x0f17, 0, OPC_MODRM, OPT_SSE, OPT_EA | OPT_REG32 ))
DEF_ASM_OP2(addps, 0x0f58, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(cvtpi2ps, 0x0f2a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_SSE )
DEF_ASM_OP2(cvtps2pi, 0x0f2d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )
DEF_ASM_OP2(cvttps2pi, 0x0f2c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_MMX )
DEF_ASM_OP2(divps, 0x0f5e, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(maxps, 0x0f5f, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(minps, 0x0f5d, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(mulps, 0x0f59, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(pavgb, 0x0fe0, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(pavgw, 0x0fe3, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(pmaxsw, 0x0fee, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pmaxub, 0x0fde, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pminsw, 0x0fea, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(pminub, 0x0fda, 0, OPC_MODRM, OPT_EA | OPT_MMXSSE, OPT_MMXSSE )
DEF_ASM_OP2(rcpss, 0x0f53, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(rsqrtps, 0x0f52, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(sqrtps, 0x0f51, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )
DEF_ASM_OP2(subps, 0x0f5c, 0, OPC_MODRM, OPT_EA | OPT_SSE, OPT_SSE )

#undef ALT
#undef DEF_ASM_OP0
#undef DEF_ASM_OP0L
#undef DEF_ASM_OP1
#undef DEF_ASM_OP2
#undef DEF_ASM_OP3

#undef i386ASMOPCODE
#endif

//END i386-asm.h

